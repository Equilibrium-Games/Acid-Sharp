// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace AcidSharp
{
    /// <summary>A helper for C++ strings.</summary>
    public unsafe partial class String : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0String@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StartsWith@String@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool StartsWith(global::System.IntPtr str, global::System.IntPtr token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Contains@String@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(global::System.IntPtr str, global::System.IntPtr token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInteger@String@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsInteger(global::System.IntPtr str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindCharPos@String@acid@@SAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBD@Z")]
            internal static extern int FindCharPos(global::System.IntPtr str, sbyte c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Trim@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z")]
            internal static extern void Trim(global::System.IntPtr @return, global::System.IntPtr str, global::System.IntPtr whitespace);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Substring@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@AEBI1@Z")]
            internal static extern void Substring(global::System.IntPtr @return, global::System.IntPtr str, uint start, uint end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveAll@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@AEBD@Z")]
            internal static extern void RemoveAll(global::System.IntPtr @return, global::System.IntPtr str, sbyte token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveLast@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@AEBD@Z")]
            internal static extern void RemoveLast(global::System.IntPtr @return, global::System.IntPtr str, sbyte token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Replace@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@00@Z")]
            internal static extern void Replace(global::System.IntPtr @return, global::System.IntPtr str, global::System.IntPtr token, global::System.IntPtr to);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Lowercase@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void Lowercase(global::System.IntPtr @return, global::System.IntPtr str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Uppercase@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void Uppercase(global::System.IntPtr @return, global::System.IntPtr str);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.String> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.String>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.String __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.String(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.String __CreateInstance(global::AcidSharp.String.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.String(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.String.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.String.__Internal));
            *(global::AcidSharp.String.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private String(global::AcidSharp.String.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected String(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public String()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.String.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public String(global::AcidSharp.String _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.String.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.String.__Internal*) __Instance) = *((global::AcidSharp.String.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.String __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if a string starts with a token.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static bool StartsWith(string str, string token)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.StartsWith(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>Gets if a string contains a token.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static bool Contains(string str, string token)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.Contains(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>Gets if a string is a integer.</summary>
        /// <param name="str">The string.</param>
        public static bool IsInteger(string str)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.IsInteger(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Gets the first char index in the string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="c">The char to look for.</param>
        public static int FindCharPos(string str, char c)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = global::System.Convert.ToSByte(c);
            var __ret = __Internal.FindCharPos(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Trims the left and right side of a string of whitespace.</summary>
        /// <param name="str">The string.</param>
        /// <param name="whitespace">The whitespace type.</param>
        public static string Trim(string str, string whitespace)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(whitespace, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Trim(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Takes a substring of a string between two bounds.</summary>
        /// <param name="str">The string.</param>
        /// <param name="start">The left bound.</param>
        /// <param name="end">The right bound.</param>
        public static string Substring(string str, uint start, uint end)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Substring(new IntPtr(&__ret), __arg0, start, end);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Removes all tokens from a string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static string RemoveAll(string str, char token)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = global::System.Convert.ToSByte(token);
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.RemoveAll(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Removes the last token from a string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static string RemoveLast(string str, char token)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = global::System.Convert.ToSByte(token);
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.RemoveLast(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Replaces all tokens from a string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        /// <param name="to">The string to replace the tokens with.</param>
        public static string Replace(string str, string token, string to)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(to, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Replace(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Lowercases a string.</summary>
        /// <param name="str">The string.</param>
        public static string Lowercase(string str)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Lowercase(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>uppercased a string.</summary>
        /// <param name="str">The string.</param>
        public static string Uppercase(string str)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Uppercase(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Trims the left and right side of a string of whitespace.</summary>
        /// <param name="str">The string.</param>
        /// <param name="whitespace">The whitespace type.</param>
        public static string Trim(string str)
        {
            return Trim(str, " \t");
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr _0, int _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate global::VkPipelineBindPoint Func_VkPipelineBindPoint_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate ulong Func_ulong_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float_IntPtr_float(global::System.IntPtr _0, float _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_float(global::System.IntPtr _0, float _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool_IntPtr_AcidSharp_MouseButton(global::System.IntPtr _0, global::AcidSharp.MouseButton _1);
    }
}

namespace AcidSharp
{
    /// <summary>A class that is used to represent a tree of values, used in file-object serialization.</summary>
    public unsafe partial class Metadata : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value;

            [FieldOffset(64)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_acid_S_Metadata___N_std_S_allocator__S0_ m_children;

            [FieldOffset(88)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C_S0____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S0_ m_attributes;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Metadata@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Metadata@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ClearChildren@Metadata@acid@@QEAAXXZ")]
            internal static extern void ClearChildren(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddAttribute@Metadata@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern void AddAttribute(global::System.IntPtr instance, global::System.IntPtr attribute, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveAttribute@Metadata@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveAttribute(global::System.IntPtr instance, global::System.IntPtr attribute);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindAttribute@Metadata@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void FindAttribute(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr attribute);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Metadata@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Metadata@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@Metadata@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetValue(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@Metadata@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetString@Metadata@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetString@Metadata@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetString(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChildCount@Metadata@acid@@QEBAIXZ")]
            internal static extern uint GetChildCount(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttributeCount@Metadata@acid@@QEBAIXZ")]
            internal static extern uint GetAttributeCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Metadata> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Metadata>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Metadata __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Metadata(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Metadata __CreateInstance(global::AcidSharp.Metadata.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Metadata(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Metadata.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Metadata.__Internal));
            global::AcidSharp.Metadata.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Metadata(global::AcidSharp.Metadata.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Metadata(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Metadata(global::AcidSharp.Metadata source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Metadata.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Metadata __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void ClearChildren()
        {
            __Internal.ClearChildren((__Instance + __PointerAdjustment));
        }

        public void AddAttribute(string attribute, string value)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(attribute, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.AddAttribute((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public bool RemoveAttribute(string attribute)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(attribute, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.RemoveAttribute((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public string FindAttribute(string attribute)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(attribute, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.FindAttribute((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        protected string MName
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new global::System.IntPtr(&((global::AcidSharp.Metadata.__Internal*) __Instance)->m_name));
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                ((global::AcidSharp.Metadata.__Internal*)__Instance)->m_name = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }
        }

        protected string MValue
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new global::System.IntPtr(&((global::AcidSharp.Metadata.__Internal*) __Instance)->m_value));
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                ((global::AcidSharp.Metadata.__Internal*)__Instance)->m_value = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Value
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetValue((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetValue((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string String
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetString((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public uint ChildCount
        {
            get
            {
                var __ret = __Internal.GetChildCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint AttributeCount
        {
            get
            {
                var __ret = __Internal.GetAttributeCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Holds a 3-tuple vector.</summary>
    public unsafe partial class Vector3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Vector3._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBVVector2@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr source, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBVVector4@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBVColour@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Vector3@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector3@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector3@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Cross@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Cross(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector3@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector3@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector3@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToQuaternion@Vector3@acid@@QEBA?AVQuaternion@2@XZ")]
            internal static extern void ToQuaternion(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector3@acid@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector3@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector3@acid@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ProjectCubeToSphere@Vector3@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void ProjectCubeToSphere(global::System.IntPtr instance, global::System.IntPtr @return, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BaryCentric@Vector3@acid@@QEAAMAEBV12@00@Z")]
            internal static extern float BaryCentric(global::System.IntPtr instance, global::System.IntPtr p1, global::System.IntPtr p2, global::System.IntPtr p3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinVector@Vector3@acid@@SA?AV12@AEBV12@0@Z")]
            internal static extern void MinVector(global::System.IntPtr @return, global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxVector@Vector3@acid@@SA?AV12@AEBV12@0@Z")]
            internal static extern void MaxVector(global::System.IntPtr @return, global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomPointOnCircle@Vector3@acid@@SA?AV12@AEBV12@AEBM@Z")]
            internal static extern void RandomPointOnCircle(global::System.IntPtr @return, global::System.IntPtr normal, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomUnitVectorWithinCone@Vector3@acid@@SA?AV12@AEBV12@AEBM@Z")]
            internal static extern void RandomUnitVectorWithinCone(global::System.IntPtr @return, global::System.IntPtr coneDirection, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Vector3@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Vector3@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector3@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector3@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector3@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector3@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector3@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector3@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector3@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBV10@AEBVQuaternion@0@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr right, global::System.IntPtr left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBVVector3@0@AEBV10@@Z")]
            internal static extern void OperatorStar_2(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBVVector3@0@AEBV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AVector3@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector3@acid@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector3@acid@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector3@acid@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector3@acid@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Vector3@acid@@QEBAMXZ")]
            internal static extern float GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Vector3@acid@@QEAAXAEBM@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector3@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector3@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector3@acid@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector3@acid@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CartesianToPolar@Vector3@acid@@QEBA?AV12@XZ")]
            internal static extern void CartesianToPolar(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PolarToCartesian@Vector3@acid@@QEBA?AV12@XZ")]
            internal static extern void PolarToCartesian(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomUnitVector@Vector3@acid@@SA?AV12@XZ")]
            internal static extern void RandomUnitVector(global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::AcidSharp.Vector3._.__.__Internal __;

                [FieldOffset(0)]
                internal global::AcidSharp.Vector3._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed float m_elements[3];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Vector3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Vector3>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Vector3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Vector3(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Vector3 __CreateInstance(global::AcidSharp.Vector3.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Vector3(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Vector3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector3.__Internal));
            global::AcidSharp.Vector3.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector3(global::AcidSharp.Vector3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector3.</summary>
        public Vector3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        public Vector3(float x, float y, float z)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), x, y, z);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        /// <param name="z">Start z.</param>
        public Vector3(global::AcidSharp.Vector2 source, float z = 0.0F)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, z);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector3(global::AcidSharp.Vector3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector3(global::AcidSharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing colour.</param>
        public Vector3(global::AcidSharp.Colour source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Vector3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector3 Add(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector3 Subtract(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector3 Multiply(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector3 Divide(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the cross product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector3 Cross(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Cross((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::AcidSharp.Vector3 Scale(float scalar)
        {
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around the origin.</summary>
        /// <param name="rotation">The rotation amount.</param>
        public global::AcidSharp.Vector3 Rotate(global::AcidSharp.Vector3 rotation)
        {
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = rotation.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::AcidSharp.Vector3 Negate()
        {
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::AcidSharp.Vector3 Normalize()
        {
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Converts these euler angles to a quaternion.</summary>
        public global::AcidSharp.Quaternion ToQuaternion()
        {
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.ToQuaternion((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector3 DistanceVector(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::AcidSharp.Vector3 SmoothDamp(global::AcidSharp.Vector3 target, global::AcidSharp.Vector3 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Projects this cube coordinate onto a sphere.</summary>
        /// <param name="radius">The sphere radius.</param>
        public global::AcidSharp.Vector3 ProjectCubeToSphere(float radius)
        {
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.ProjectCubeToSphere((__Instance + __PointerAdjustment), new IntPtr(&__ret), radius);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets the height of this vector on a point off of a 3d triangle.</summary>
        /// <param name="p1">Point 1 on the triangle.</param>
        /// <param name="p2">Point 2 on the triangle.</param>
        /// <param name="p3">Point 3 on the triangle.</param>
        public float BaryCentric(global::AcidSharp.Vector3 p1, global::AcidSharp.Vector3 p2, global::AcidSharp.Vector3 p3)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            var __ret = __Internal.BaryCentric((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        public void Decode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::AcidSharp.Vector3 __op, global::AcidSharp.Vector3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Vector3;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Vector3.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Vector3 __op, global::AcidSharp.Vector3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::AcidSharp.Vector3 __op, global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::AcidSharp.Vector3 __op, global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::AcidSharp.Vector3 __op, global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::AcidSharp.Vector3 __op, global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::AcidSharp.Vector3 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::AcidSharp.Vector3 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public static global::AcidSharp.Vector3 operator -(global::AcidSharp.Vector3 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.Vector3(global::AcidSharp.Vector2 source)
        {
            return new global::AcidSharp.Vector3(source);
        }

        public static implicit operator global::AcidSharp.Vector3(global::AcidSharp.Vector4 source)
        {
            return new global::AcidSharp.Vector3(source);
        }

        public static implicit operator global::AcidSharp.Vector3(global::AcidSharp.Colour source)
        {
            return new global::AcidSharp.Vector3(source);
        }

        /// <summary>Gets the lowest vector size.</summary>
        /// <param name="a">The first vector to get values from.</param>
        /// <param name="b">The second vector to get values from.</param>
        public static global::AcidSharp.Vector3 MinVector(global::AcidSharp.Vector3 a, global::AcidSharp.Vector3 b)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.MinVector(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets the maximum vector size.</summary>
        /// <param name="a">The first vector to get values from.</param>
        /// <param name="b">The second vector to get values from.</param>
        public static global::AcidSharp.Vector3 MaxVector(global::AcidSharp.Vector3 a, global::AcidSharp.Vector3 b)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.MaxVector(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets a random point from on a circle.</summary>
        /// <param name="normal">The circles normal.</param>
        /// <param name="radius">The circles radius.</param>
        public static global::AcidSharp.Vector3 RandomPointOnCircle(global::AcidSharp.Vector3 normal, float radius)
        {
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = normal.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.RandomPointOnCircle(new IntPtr(&__ret), __arg0, radius);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Generates a random unit vector from within a cone.</summary>
        /// <param name="coneDirection">The cones direction.</param>
        /// <param name="angle">The cones major angle.</param>
        public static global::AcidSharp.Vector3 RandomUnitVectorWithinCone(global::AcidSharp.Vector3 coneDirection, float angle)
        {
            if (ReferenceEquals(coneDirection, null))
                throw new global::System.ArgumentNullException("coneDirection", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = coneDirection.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.RandomUnitVectorWithinCone(new IntPtr(&__ret), __arg0, angle);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator +(global::AcidSharp.Vector3 left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator -(global::AcidSharp.Vector3 left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator *(global::AcidSharp.Vector3 left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator /(global::AcidSharp.Vector3 left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator +(float left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator -(float left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator *(float left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator /(float left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator +(global::AcidSharp.Vector3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator -(global::AcidSharp.Vector3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator *(global::AcidSharp.Vector3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator /(global::AcidSharp.Vector3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator *(global::AcidSharp.Vector3 right, global::AcidSharp.Quaternion left)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = right.__Instance;
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = left.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator *(global::AcidSharp.Vector3 left, global::AcidSharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorStar_2(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator /(global::AcidSharp.Vector3 left, global::AcidSharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 Zero
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector3 One
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ONE@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector3 Left
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?LEFT@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector3 Right
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?RIGHT@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector3 Up
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?UP@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector3 Down
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DOWN@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector3 Front
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?FRONT@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector3 Back
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?BACK@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector3 PositiveInfinity
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector3 NegativeInfinity
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Vector3@acid@@2V12@B");
                return global::AcidSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), index);
                return *__ret;
            }

            set
            {
                *global::AcidSharp.Vector3.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), index) = value;
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetX((__Instance + __PointerAdjustment), value);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetY((__Instance + __PointerAdjustment), value);
            }
        }

        public float Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetZ((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Converts from rectangular to spherical coordinates, this vector is in cartesian (x, y, z).</summary>
        public global::AcidSharp.Vector3 CartesianToPolar
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.CartesianToPolar((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Converts from spherical to rectangular coordinates, this vector is in polar (radius, theta, phi).</summary>
        public global::AcidSharp.Vector3 PolarToCartesian
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.PolarToCartesian((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Generates a random unit vector.</summary>
        public static global::AcidSharp.Vector3 RandomUnitVector
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.RandomUnitVector(new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Holds a 4-tuple vector.</summary>
    public unsafe partial class Vector4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Vector4._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@AEBVVector3@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr source, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@AEBVColour@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Vector4@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector4@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector4@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector4@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector4@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector4@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector4@acid@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector4@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector4@acid@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Vector4@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Vector4@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector4@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector4@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector4@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector4@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector4@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector4@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector4@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector4@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBVVector4@0@AEBV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBVVector4@0@AEBV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AVector4@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector4@acid@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector4@acid@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector4@acid@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector4@acid@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Vector4@acid@@QEBAMXZ")]
            internal static extern float GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Vector4@acid@@QEAAXAEBM@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetW@Vector4@acid@@QEBAMXZ")]
            internal static extern float GetW(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetW@Vector4@acid@@QEAAXAEBM@Z")]
            internal static extern void SetW(global::System.IntPtr instance, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector4@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector4@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector4@acid@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector4@acid@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::AcidSharp.Vector4._.__.__Internal __;

                [FieldOffset(0)]
                internal global::AcidSharp.Vector4._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed float m_elements[4];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Vector4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Vector4>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Vector4 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Vector4(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Vector4 __CreateInstance(global::AcidSharp.Vector4.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Vector4(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Vector4.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector4.__Internal));
            global::AcidSharp.Vector4.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector4(global::AcidSharp.Vector4.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector4.</summary>
        public Vector4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        /// <param name="w">Start w.</param>
        public Vector4(float x, float y, float z, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), x, y, z, w);
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        /// <param name="w">Start w.</param>
        public Vector4(global::AcidSharp.Vector3 source, float w = 1.0F)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, w);
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector4(global::AcidSharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="source">Creates this vector out of a existing colour.</param>
        public Vector4(global::AcidSharp.Colour source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Vector4 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector4 Add(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector4 Subtract(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector4 Multiply(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector4 Divide(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::AcidSharp.Vector4 Scale(float scalar)
        {
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::AcidSharp.Vector4 Negate()
        {
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::AcidSharp.Vector4 Normalize()
        {
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector4 DistanceVector(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::AcidSharp.Vector4 SmoothDamp(global::AcidSharp.Vector4 target, global::AcidSharp.Vector4 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public void Decode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::AcidSharp.Vector4 __op, global::AcidSharp.Vector4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Vector4;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Vector4.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Vector4 __op, global::AcidSharp.Vector4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::AcidSharp.Vector4 __op, global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::AcidSharp.Vector4 __op, global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::AcidSharp.Vector4 __op, global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::AcidSharp.Vector4 __op, global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::AcidSharp.Vector4 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::AcidSharp.Vector4 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public static global::AcidSharp.Vector4 operator -(global::AcidSharp.Vector4 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.Vector4(global::AcidSharp.Vector3 source)
        {
            return new global::AcidSharp.Vector4(source);
        }

        public static implicit operator global::AcidSharp.Vector4(global::AcidSharp.Colour source)
        {
            return new global::AcidSharp.Vector4(source);
        }

        public static global::AcidSharp.Vector4 operator +(global::AcidSharp.Vector4 left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator -(global::AcidSharp.Vector4 left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator *(global::AcidSharp.Vector4 left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator /(global::AcidSharp.Vector4 left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator +(float left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator -(float left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator *(float left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator /(float left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator +(global::AcidSharp.Vector4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator -(global::AcidSharp.Vector4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator *(global::AcidSharp.Vector4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 operator /(global::AcidSharp.Vector4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator *(global::AcidSharp.Vector4 left, global::AcidSharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator /(global::AcidSharp.Vector4 left, global::AcidSharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector4 Zero
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Vector4@acid@@2V12@B");
                return global::AcidSharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector4 One
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ONE@Vector4@acid@@2V12@B");
                return global::AcidSharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector4 PositiveInfinity
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Vector4@acid@@2V12@B");
                return global::AcidSharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector4 NegativeInfinity
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Vector4@acid@@2V12@B");
                return global::AcidSharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), index);
                return *__ret;
            }

            set
            {
                *global::AcidSharp.Vector4.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), index) = value;
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetX((__Instance + __PointerAdjustment), value);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetY((__Instance + __PointerAdjustment), value);
            }
        }

        public float Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetZ((__Instance + __PointerAdjustment), value);
            }
        }

        public float W
        {
            get
            {
                var __ret = __Internal.GetW((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetW((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Holds a row major 4x4 matrix.</summary>
    public unsafe partial class Matrix4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Matrix4._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float diagonal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@acid@@QEAA@QEBM@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, float[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@acid@@QEAA@QEBVVector4@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::AcidSharp.Vector4.__Internal[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Matrix4@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Matrix4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Matrix4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix4@acid@@QEBA?AVVector4@2@AEBV32@@Z")]
            internal static extern void Multiply_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Matrix4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transform@Matrix4@acid@@QEBA?AVVector4@2@AEBV32@@Z")]
            internal static extern void Transform(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Translate@Matrix4@acid@@QEBA?AV12@AEBVVector2@2@@Z")]
            internal static extern void Translate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Translate@Matrix4@acid@@QEBA?AV12@AEBVVector3@2@@Z")]
            internal static extern void Translate_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix4@acid@@QEBA?AV12@AEBVVector3@2@@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix4@acid@@QEBA?AV12@AEBVVector4@2@@Z")]
            internal static extern void Scale_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Matrix4@acid@@QEBA?AV12@AEBMAEBVVector3@2@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float angle, global::System.IntPtr axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Matrix4@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSubmatrix@Matrix4@acid@@QEBA?AVMatrix3@2@AEBH0@Z")]
            internal static extern void GetSubmatrix(global::System.IntPtr instance, global::System.IntPtr @return, int row, int col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TransformationMatrix@Matrix4@acid@@SA?AV12@AEBVVector3@2@00@Z")]
            internal static extern void TransformationMatrix(global::System.IntPtr @return, global::System.IntPtr translation, global::System.IntPtr rotation, global::System.IntPtr scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TransformationMatrix@Matrix4@acid@@SA?AV12@AEBVVector3@2@AEBVQuaternion@2@0@Z")]
            internal static extern void TransformationMatrix_1(global::System.IntPtr @return, global::System.IntPtr translation, global::System.IntPtr rotation, global::System.IntPtr scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PerspectiveMatrix@Matrix4@acid@@SA?AV12@AEBM000@Z")]
            internal static extern void PerspectiveMatrix(global::System.IntPtr @return, float fov, float aspectRatio, float zNear, float zFar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?OrthographicMatrix@Matrix4@acid@@SA?AV12@AEBM00000@Z")]
            internal static extern void OrthographicMatrix(global::System.IntPtr @return, float left, float right, float bottom, float top, float near, float far);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ViewMatrix@Matrix4@acid@@SA?AV12@AEBVVector3@2@0@Z")]
            internal static extern void ViewMatrix(global::System.IntPtr @return, global::System.IntPtr position, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ViewMatrix@Matrix4@acid@@SA?AV12@AEBVVector3@2@AEBVQuaternion@2@@Z")]
            internal static extern void ViewMatrix_1(global::System.IntPtr @return, global::System.IntPtr position, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WorldToScreenSpace@Matrix4@acid@@SA?AVVector3@2@AEBV32@AEBV12@1@Z")]
            internal static extern void WorldToScreenSpace(global::System.IntPtr @return, global::System.IntPtr worldSpace, global::System.IntPtr viewMatrix, global::System.IntPtr projectionMatrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LookAt@Matrix4@acid@@SA?AV12@AEBVVector3@2@00@Z")]
            internal static extern void LookAt(global::System.IntPtr @return, global::System.IntPtr camera, global::System.IntPtr targetObject, global::System.IntPtr up);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Matrix4@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Matrix4@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Matrix4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Matrix4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GMatrix4@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Matrix4@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVMatrix4@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVMatrix4@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBV10@AEBVVector4@0@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBV10@AEBVVector4@0@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AMatrix4@acid@@QEAAAEAVVector4@1@AEBI@Z")]
            internal static extern global::System.IntPtr OperatorSubscript(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Invert@Matrix4@acid@@QEBA?AV12@XZ")]
            internal static extern void Invert(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transpose@Matrix4@acid@@QEBA?AV12@XZ")]
            internal static extern void Transpose(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Determinant@Matrix4@acid@@QEBAMXZ")]
            internal static extern float Determinant(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::AcidSharp.Matrix4._.__.__Internal __;

                [FieldOffset(0)]
                internal global::AcidSharp.Matrix4._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed byte m_rows[64];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Matrix4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Matrix4>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Matrix4 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Matrix4(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Matrix4 __CreateInstance(global::AcidSharp.Matrix4.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Matrix4(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Matrix4.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix4.__Internal));
            global::AcidSharp.Matrix4.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Matrix4(global::AcidSharp.Matrix4.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Matrix4. The matrix is initialised to the identity.</summary>
        /// <param name="diagonal">The value set to the diagonals.</param>
        public Matrix4(float diagonal = 1.0F)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), diagonal);
        }

        /// <summary>Constructor for Matrix4.</summary>
        /// <param name="source">Creates this matrix out of a existing one.</param>
        public Matrix4(global::AcidSharp.Matrix4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix4.</summary>
        /// <param name="source">Creates this matrix out of a 16 element array.</param>
        public Matrix4(float[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 16)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            __Internal.ctor_1((__Instance + __PointerAdjustment), source);
        }

        /// <summary>Constructor for Matrix4.</summary>
        /// <param name="source">Creates this matrix out of a 4 vector array.</param>
        public Matrix4(global::AcidSharp.Vector4[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 4)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            global::AcidSharp.Vector4.__Internal[] __source;
            if (ReferenceEquals(source, null))
                __source = null;
            else
            {
                __source = new global::AcidSharp.Vector4.__Internal[source.Length];
                for (int i = 0; i < __source.Length; i++)
                {
                    var __element = source[i];
                    __source[i] = ReferenceEquals(__element, null) ? new global::AcidSharp.Vector4.__Internal() : *(global::AcidSharp.Vector4.__Internal*) __element.__Instance;
                }
            }
            var __arg0 = __source;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Matrix4 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix4 Add(global::AcidSharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix4 Subtract(global::AcidSharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix4 Multiply(global::AcidSharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector4 Multiply(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.Multiply_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Divides this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix4 Divide(global::AcidSharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Transforms this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector4 Transform(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector4.__Internal();
            __Internal.Transform((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Translates this matrix by a vector.</summary>
        /// <param name="other">The vector.</param>
        public global::AcidSharp.Matrix4 Translate(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Translate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Translates this matrix by a vector.</summary>
        /// <param name="other">The vector.</param>
        public global::AcidSharp.Matrix4 Translate(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Translate_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Matrix4 Scale(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Matrix4 Scale(global::AcidSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Scale_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Rotates this matrix around the given axis the specified angle.</summary>
        /// <param name="angle">The angle, in radians.</param>
        /// <param name="axis">The vector representing the rotation axis.</param>
        public global::AcidSharp.Matrix4 Rotate(float angle, global::AcidSharp.Vector3 axis)
        {
            if (ReferenceEquals(axis, null))
                throw new global::System.ArgumentNullException("axis", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = axis.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), angle, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Inverts this matrix.</summary>
        public global::AcidSharp.Matrix4 Negate()
        {
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Gets the submatrix of this matrix.</summary>
        public global::AcidSharp.Matrix3 GetSubmatrix(int row, int col)
        {
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.GetSubmatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret), row, col);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public void Decode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::AcidSharp.Matrix4 __op, global::AcidSharp.Matrix4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Matrix4;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Matrix4.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Matrix4 __op, global::AcidSharp.Matrix4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::AcidSharp.Matrix4 operator -(global::AcidSharp.Matrix4 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.Matrix4(float diagonal)
        {
            return new global::AcidSharp.Matrix4(diagonal);
        }

        public static implicit operator global::AcidSharp.Matrix4(float[] source)
        {
            return new global::AcidSharp.Matrix4(source);
        }

        public static implicit operator global::AcidSharp.Matrix4(global::AcidSharp.Vector4[] source)
        {
            return new global::AcidSharp.Matrix4(source);
        }

        /// <summary>Creates a new transformation matrix for a object in 3d space.</summary>
        /// <param name="translation">Translation amount the XYZ.</param>
        /// <param name="rotation">Rotation amount (Pitch, Yaw, Roll).</param>
        /// <param name="scale">How much to scale the matrix.</param>
        public static global::AcidSharp.Matrix4 TransformationMatrix(global::AcidSharp.Vector3 translation, global::AcidSharp.Vector3 rotation, global::AcidSharp.Vector3 scale)
        {
            if (ReferenceEquals(translation, null))
                throw new global::System.ArgumentNullException("translation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = translation.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = scale.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.TransformationMatrix(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new transformation matrix for a object in 3d space.</summary>
        /// <param name="translation">Translation amount the XYZ.</param>
        /// <param name="rotation">Rotation amount.</param>
        /// <param name="scale">How much to scale the matrix.</param>
        public static global::AcidSharp.Matrix4 TransformationMatrix(global::AcidSharp.Vector3 translation, global::AcidSharp.Quaternion rotation, global::AcidSharp.Vector3 scale)
        {
            if (ReferenceEquals(translation, null))
                throw new global::System.ArgumentNullException("translation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = translation.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = scale.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.TransformationMatrix_1(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new perspective matrix.</summary>
        /// <param name="fov">The cameras FOV.</param>
        /// <param name="aspectRatio">The cameras aspect ratio.</param>
        /// <param name="zNear">The cameras near plane.</param>
        /// <param name="zFar">The cameras far plane.</param>
        public static global::AcidSharp.Matrix4 PerspectiveMatrix(float fov, float aspectRatio, float zNear, float zFar)
        {
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.PerspectiveMatrix(new IntPtr(&__ret), fov, aspectRatio, zNear, zFar);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new orthographic matrix.</summary>
        /// <param name="left">The left plane.</param>
        /// <param name="right">The right plane.</param>
        /// <param name="bottom">The bottom plane.</param>
        /// <param name="top">The top plane.</param>
        /// <param name="near">The near plane.</param>
        /// <param name="far">The far plane.</param>
        /// <param name="destination">The destination matrix or nullptr if a new matrix is to be created.</param>
        public static global::AcidSharp.Matrix4 OrthographicMatrix(float left, float right, float bottom, float top, float near, float far)
        {
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OrthographicMatrix(new IntPtr(&__ret), left, right, bottom, top, near, far);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new view matrix.</summary>
        /// <param name="position">The cameras position.</param>
        /// <param name="rotation">The cameras rotation.</param>
        public static global::AcidSharp.Matrix4 ViewMatrix(global::AcidSharp.Vector3 position, global::AcidSharp.Vector3 rotation)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.ViewMatrix(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new view matrix.</summary>
        /// <param name="position">The cameras position.</param>
        /// <param name="rotation">The cameras rotation.</param>
        public static global::AcidSharp.Matrix4 ViewMatrix(global::AcidSharp.Vector3 position, global::AcidSharp.Quaternion rotation)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.ViewMatrix_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Transforms a 3D world point into screen space.</summary>
        /// <param name="worldSpace">The point to get into screen space.</param>
        /// <param name="viewMatrix">The cameras view matrix.</param>
        /// <param name="projectionMatrix">The cameras projection matrix.</param>
        public static global::AcidSharp.Vector3 WorldToScreenSpace(global::AcidSharp.Vector3 worldSpace, global::AcidSharp.Matrix4 viewMatrix, global::AcidSharp.Matrix4 projectionMatrix)
        {
            if (ReferenceEquals(worldSpace, null))
                throw new global::System.ArgumentNullException("worldSpace", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = worldSpace.__Instance;
            if (ReferenceEquals(viewMatrix, null))
                throw new global::System.ArgumentNullException("viewMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = viewMatrix.__Instance;
            if (ReferenceEquals(projectionMatrix, null))
                throw new global::System.ArgumentNullException("projectionMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = projectionMatrix.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.WorldToScreenSpace(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Creates a new transformation matrix that has the camera looking at the target.</summary>
        /// <param name="camera">The source position.</param>
        /// <param name="object">The target position.</param>
        /// <param name="up">What view direction is up.</param>
        public static global::AcidSharp.Matrix4 LookAt(global::AcidSharp.Vector3 camera, global::AcidSharp.Vector3 targetObject, global::AcidSharp.Vector3 up)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = camera.__Instance;
            if (ReferenceEquals(targetObject, null))
                throw new global::System.ArgumentNullException("targetObject", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = targetObject.__Instance;
            if (ReferenceEquals(up, null))
                throw new global::System.ArgumentNullException("up", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = up.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.LookAt(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator +(global::AcidSharp.Matrix4 left, global::AcidSharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator -(global::AcidSharp.Matrix4 left, global::AcidSharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator *(global::AcidSharp.Matrix4 left, global::AcidSharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator /(global::AcidSharp.Matrix4 left, global::AcidSharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator *(global::AcidSharp.Matrix4 left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator /(global::AcidSharp.Matrix4 left, global::AcidSharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator *(float left, global::AcidSharp.Matrix4 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator /(float left, global::AcidSharp.Matrix4 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator *(global::AcidSharp.Matrix4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix4 operator /(global::AcidSharp.Matrix4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new transformation matrix that has the camera looking at the target.</summary>
        /// <param name="camera">The source position.</param>
        /// <param name="object">The target position.</param>
        /// <param name="up">What view direction is up.</param>
        public static global::AcidSharp.Matrix4 LookAt(global::AcidSharp.Vector3 camera, global::AcidSharp.Vector3 targetObject)
        {
            return LookAt(camera, targetObject, global::AcidSharp.Vector3.Up);
        }

        public static global::AcidSharp.Matrix4 Identity
        {
            get
            {
                var __ptr = (global::AcidSharp.Matrix4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?IDENTITY@Matrix4@acid@@2V12@B");
                return global::AcidSharp.Matrix4.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Matrix4 Zero
        {
            get
            {
                var __ptr = (global::AcidSharp.Matrix4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Matrix4@acid@@2V12@B");
                return global::AcidSharp.Matrix4.__CreateInstance(*__ptr);
            }
        }

        public global::AcidSharp.Vector4 this[uint index]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), index);
                return global::AcidSharp.Vector4.__CreateInstance(__ret);
            }

            set
            {
                *(global::AcidSharp.Vector4.__Internal*) global::AcidSharp.Matrix4.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), index) = ReferenceEquals(value, null) ? new global::AcidSharp.Vector4.__Internal() : *(global::AcidSharp.Vector4.__Internal*) value.__Instance;
            }
        }

        /// <summary>Negates this matrix.</summary>
        public global::AcidSharp.Matrix4 Invert
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.Invert((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Transposes this matrix.</summary>
        public global::AcidSharp.Matrix4 Transpose
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.Transpose((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Takes the determinant of this matrix.</summary>
        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A vector like object of the form w + xi + yj + zk, where w, x, y, z are real numbers and i, j, k are imaginary units.</summary>
    public unsafe partial class Quaternion : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Quaternion._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float pitch, float yaw, float roll);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBVVector3@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr source, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBVVector3@1@00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr axisX, global::System.IntPtr axisY, global::System.IntPtr axisZ);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Quaternion@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Quaternion@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Quaternion@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Quaternion@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Quaternion@acid@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void Multiply_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MultiplyInverse@Quaternion@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void MultiplyInverse(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Quaternion@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Slerp@Quaternion@acid@@QEAA?AV12@AEBV12@AEBM@Z")]
            internal static extern void Slerp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other, float progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Quaternion@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Quaternion@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Quaternion@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToMatrix@Quaternion@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void ToMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToRotationMatrix@Quaternion@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void ToRotationMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToEuler@Quaternion@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void ToEuler(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Quaternion@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Quaternion@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Quaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Quaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MQuaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NQuaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OQuaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PQuaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Quaternion@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Quaternion@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GQuaternion@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Quaternion@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVQuaternion@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVQuaternion@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVQuaternion@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBVQuaternion@0@AEBV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVQuaternion@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVQuaternion@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AQuaternion@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Quaternion@acid@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Quaternion@acid@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Quaternion@acid@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Quaternion@acid@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Quaternion@acid@@QEBAMXZ")]
            internal static extern float GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Quaternion@acid@@QEAAXAEBM@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetW@Quaternion@acid@@QEBAMXZ")]
            internal static extern float GetW(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetW@Quaternion@acid@@QEAAXAEBM@Z")]
            internal static extern void SetW(global::System.IntPtr instance, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Quaternion@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Quaternion@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Quaternion@acid@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Quaternion@acid@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::AcidSharp.Quaternion._.__.__Internal __;

                [FieldOffset(0)]
                internal global::AcidSharp.Quaternion._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal float m_x;

                    [FieldOffset(4)]
                    internal float m_y;

                    [FieldOffset(8)]
                    internal float m_z;

                    [FieldOffset(12)]
                    internal float m_w;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Quaternion> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Quaternion>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Quaternion __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Quaternion(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Quaternion __CreateInstance(global::AcidSharp.Quaternion.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Quaternion(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Quaternion.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Quaternion.__Internal));
            global::AcidSharp.Quaternion.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Quaternion(global::AcidSharp.Quaternion.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Quaternion(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Quaternion.</summary>
        public Quaternion()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        /// <param name="w">Start w.</param>
        public Quaternion(float x, float y, float z, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), x, y, z, w);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="pitch">Start pitch.</param>
        /// <param name="yaw">Start yaw.</param>
        /// <param name="roll">Start roll.</param>
        public Quaternion(float pitch, float yaw, float roll)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), pitch, yaw, roll);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="source">Creates this quaternion out of a existing vector (pitch, yaw roll).</param>
        /// <param name="w">Start w.</param>
        public Quaternion(global::AcidSharp.Vector3 source, float w = 1.0F)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, w);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Quaternion(global::AcidSharp.Quaternion source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="source">Creates this vector out of a existing matrix.</param>
        public Quaternion(global::AcidSharp.Matrix4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="axisX">The X axis.</param>
        /// <param name="axisY">The Y axis.</param>
        /// <param name="axisZ">The Z axis.</param>
        public Quaternion(global::AcidSharp.Vector3 axisX, global::AcidSharp.Vector3 axisY, global::AcidSharp.Vector3 axisZ)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(axisX, null))
                throw new global::System.ArgumentNullException("axisX", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = axisX.__Instance;
            if (ReferenceEquals(axisY, null))
                throw new global::System.ArgumentNullException("axisY", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = axisY.__Instance;
            if (ReferenceEquals(axisZ, null))
                throw new global::System.ArgumentNullException("axisZ", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = axisZ.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Quaternion __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this quaternion to another quaternion.</summary>
        /// <param name="other">The other quaternion.</param>
        public global::AcidSharp.Quaternion Add(global::AcidSharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this quaternion to another quaternion.</summary>
        /// <param name="other">The other quaternion.</param>
        public global::AcidSharp.Quaternion Subtract(global::AcidSharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this quaternion with another quaternion.</summary>
        /// <param name="other">The other quaternion.</param>
        public global::AcidSharp.Quaternion Multiply(global::AcidSharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this quaternion with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector3 Multiply(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Multiply_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this quaternion with the inverse of another quaternion. The value of both argument quaternions is persevered (this = left * right^-1).</summary>
        /// <param name="other">The other quaternion.</param>
        public global::AcidSharp.Quaternion MultiplyInverse(global::AcidSharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.MultiplyInverse((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Calculates the dot product of the this quaternion and another quaternion.</summary>
        /// <param name="other">The other quaternion.</param>
        public float Dot(global::AcidSharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the slerp between this quaternion and another quaternion, they must be normalized!</summary>
        /// <param name="other">The other quaternion.</param>
        /// <param name="progression">The progression.</param>
        public global::AcidSharp.Quaternion Slerp(global::AcidSharp.Quaternion other, float progression)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.Slerp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, progression);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Scales this quaternion by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::AcidSharp.Quaternion Scale(float scalar)
        {
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Negates this quaternion.</summary>
        public global::AcidSharp.Quaternion Negate()
        {
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this quaternion.</summary>
        public global::AcidSharp.Quaternion Normalize()
        {
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Converts this quaternion to a 4x4 matrix.</summary>
        public global::AcidSharp.Matrix4 ToMatrix()
        {
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.ToMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Converts this quaternion to a 3x3 matrix representing the exact same rotation as this quaternion.</summary>
        public global::AcidSharp.Matrix4 ToRotationMatrix()
        {
            var __ret = new global::AcidSharp.Matrix4.__Internal();
            __Internal.ToRotationMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Converts this quaternion to euler angles.</summary>
        public global::AcidSharp.Vector3 ToEuler()
        {
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.ToEuler((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public void Decode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::AcidSharp.Quaternion __op, global::AcidSharp.Quaternion other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Quaternion;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Quaternion.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Quaternion __op, global::AcidSharp.Quaternion other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::AcidSharp.Quaternion __op, global::AcidSharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::AcidSharp.Quaternion __op, global::AcidSharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::AcidSharp.Quaternion __op, global::AcidSharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::AcidSharp.Quaternion __op, global::AcidSharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::AcidSharp.Quaternion __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::AcidSharp.Quaternion __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public static global::AcidSharp.Quaternion operator -(global::AcidSharp.Quaternion __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.Quaternion(global::AcidSharp.Vector3 source)
        {
            return new global::AcidSharp.Quaternion(source);
        }

        public static implicit operator global::AcidSharp.Quaternion(global::AcidSharp.Matrix4 source)
        {
            return new global::AcidSharp.Quaternion(source);
        }

        public static global::AcidSharp.Quaternion operator +(global::AcidSharp.Quaternion left, global::AcidSharp.Quaternion right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Quaternion operator -(global::AcidSharp.Quaternion left, global::AcidSharp.Quaternion right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Quaternion operator *(global::AcidSharp.Quaternion left, global::AcidSharp.Quaternion right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector3 operator *(global::AcidSharp.Quaternion left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Quaternion operator *(float left, global::AcidSharp.Quaternion right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Quaternion operator *(global::AcidSharp.Quaternion left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Quaternion.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Quaternion Zero
        {
            get
            {
                var __ptr = (global::AcidSharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Quaternion@acid@@2V12@B");
                return global::AcidSharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Quaternion One
        {
            get
            {
                var __ptr = (global::AcidSharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ONE@Quaternion@acid@@2V12@B");
                return global::AcidSharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Quaternion WOne
        {
            get
            {
                var __ptr = (global::AcidSharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?W_ONE@Quaternion@acid@@2V12@B");
                return global::AcidSharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Quaternion PositiveInfinity
        {
            get
            {
                var __ptr = (global::AcidSharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Quaternion@acid@@2V12@B");
                return global::AcidSharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Quaternion NegativeInfinity
        {
            get
            {
                var __ptr = (global::AcidSharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Quaternion@acid@@2V12@B");
                return global::AcidSharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), index);
                return *__ret;
            }

            set
            {
                *global::AcidSharp.Quaternion.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), index) = value;
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetX((__Instance + __PointerAdjustment), value);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetY((__Instance + __PointerAdjustment), value);
            }
        }

        public float Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetZ((__Instance + __PointerAdjustment), value);
            }
        }

        public float W
        {
            get
            {
                var __ret = __Internal.GetW((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetW((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this quaternion.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this quaternion.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this quaternion.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this quaternion.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class JointTransformData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_jointNameId;

            [FieldOffset(32)]
            internal global::AcidSharp.Matrix4.__Internal m_jointLocalTransform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransformData@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr jointNameId, global::System.IntPtr jointLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransformData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JointTransformData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointNameId@JointTransformData@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetJointNameId(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointLocalTransform@JointTransformData@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetJointLocalTransform(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.JointTransformData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.JointTransformData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.JointTransformData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.JointTransformData(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.JointTransformData __CreateInstance(global::AcidSharp.JointTransformData.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.JointTransformData(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.JointTransformData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointTransformData.__Internal));
            global::AcidSharp.JointTransformData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JointTransformData(global::AcidSharp.JointTransformData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointTransformData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public JointTransformData(string jointNameId, global::AcidSharp.Matrix4 jointLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointTransformData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(jointNameId, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(jointLocalTransform, null))
                throw new global::System.ArgumentNullException("jointLocalTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = jointLocalTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public JointTransformData(global::AcidSharp.JointTransformData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointTransformData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.JointTransformData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string JointNameId
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetJointNameId((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public global::AcidSharp.Matrix4 JointLocalTransform
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.GetJointLocalTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Represents the local bone-space transform of a joint at a certain keyframe during an animation. This includes the position and rotation of the joint, relative to the parent joint (or relative to the model's origin if it's the root joint). The transform is stored as a position vector and a quaternion (rotation) so that these values can  be easily interpolated, a functionality that this class also provides.</summary>
    public unsafe partial class JointTransform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Vector3.__Internal m_position;

            [FieldOffset(12)]
            internal global::AcidSharp.Quaternion.__Internal m_rotation;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@acid@@QEAA@AEBVVector3@1@AEBVQuaternion@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@acid@@QEAA@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@acid@@QEAA@AEBVJointTransformData@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JointTransform@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@JointTransform@acid@@SA?AV12@AEBV12@0AEBM@Z")]
            internal static extern void Interpolate(global::System.IntPtr @return, global::System.IntPtr frameA, global::System.IntPtr frameB, float progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@JointTransform@acid@@SA?AVVector3@2@AEBV32@0AEBM@Z")]
            internal static extern void Interpolate_1(global::System.IntPtr @return, global::System.IntPtr start, global::System.IntPtr end, float progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@JointTransform@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@JointTransform@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRotation@JointTransform@acid@@QEBA?AVQuaternion@2@XZ")]
            internal static extern void GetRotation(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRotation@JointTransform@acid@@QEAAXAEBVQuaternion@2@@Z")]
            internal static extern void SetRotation(global::System.IntPtr instance, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalTransform@JointTransform@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetLocalTransform(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.JointTransform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.JointTransform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.JointTransform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.JointTransform(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.JointTransform __CreateInstance(global::AcidSharp.JointTransform.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.JointTransform(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.JointTransform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointTransform.__Internal));
            global::AcidSharp.JointTransform.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JointTransform(global::AcidSharp.JointTransform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointTransform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new joint transformation.</summary>
        /// <param name="position">The position of the joint relative to the parent joint (local-space) at a certain keyframe.</param>
        /// <param name="rotation">The rotation of the joint relative to te parent joint (local-space) at a certain keyframe.</param>
        public JointTransform(global::AcidSharp.Vector3 position, global::AcidSharp.Quaternion rotation)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Creates a new joint transformation.</summary>
        /// <param name="localTransform">The joint's local-transform at a certain keyframe of an animation.</param>
        public JointTransform(global::AcidSharp.Matrix4 localTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public JointTransform(global::AcidSharp.JointTransformData data)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = data.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public JointTransform(global::AcidSharp.JointTransform _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.JointTransform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::AcidSharp.JointTransform(global::AcidSharp.Matrix4 localTransform)
        {
            return new global::AcidSharp.JointTransform(localTransform);
        }

        public static implicit operator global::AcidSharp.JointTransform(global::AcidSharp.JointTransformData data)
        {
            return new global::AcidSharp.JointTransform(data);
        }

        /// <summary>Interpolates between two transforms based on the progression value. The result is a new transform which is part way between the two original transforms. The translation can simply be linearly interpolated, but the rotation interpolation is slightly more complex, using a method called &quot;SLERP&quot; to spherically-linearly interpolate between 2 quaternions (rotations). This gives a much much better result than trying to linearly interpolate between Euler rotations.</summary>
        /// <param name="frameA">The previous transform</param>
        /// <param name="frameB">The next transform</param>
        /// <param name="progression">A number between 0 and 1 indicating how far between the two transforms to interpolate. A progression value of 0 would return a transform equal to &quot;frameA&quot;, a value of 1 would return a transform equal to &quot;frameB&quot;. Everything else gives a transform somewhere in-between the two.</param>
        public static global::AcidSharp.JointTransform Interpolate(global::AcidSharp.JointTransform frameA, global::AcidSharp.JointTransform frameB, float progression)
        {
            if (ReferenceEquals(frameA, null))
                throw new global::System.ArgumentNullException("frameA", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = frameA.__Instance;
            if (ReferenceEquals(frameB, null))
                throw new global::System.ArgumentNullException("frameB", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = frameB.__Instance;
            var __ret = new global::AcidSharp.JointTransform.__Internal();
            __Internal.Interpolate(new IntPtr(&__ret), __arg0, __arg1, progression);
            return global::AcidSharp.JointTransform.__CreateInstance(__ret);
        }

        /// <summary>Linearly interpolates between two translations based on a &quot;progression&quot; value.</summary>
        /// <param name="start">The start translation.</param>
        /// <param name="end">The end translation.</param>
        /// <param name="progression">A value between 0 and 1 indicating how far to interpolate between the two translations.</param>
        public static global::AcidSharp.Vector3 Interpolate(global::AcidSharp.Vector3 start, global::AcidSharp.Vector3 end, float progression)
        {
            if (ReferenceEquals(start, null))
                throw new global::System.ArgumentNullException("start", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = start.__Instance;
            if (ReferenceEquals(end, null))
                throw new global::System.ArgumentNullException("end", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = end.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Interpolate_1(new IntPtr(&__ret), __arg0, __arg1, progression);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public global::AcidSharp.Vector3 Position
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Quaternion Rotation
        {
            get
            {
                var __ret = new global::AcidSharp.Quaternion.__Internal();
                __Internal.GetRotation((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Quaternion.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>In this method the local-space transform matrix is constructed by translating an identity matrix using the position variable and then applying the rotation. The rotation is applied by first converting the quaternion into a rotation matrix, which is then multiplied with the transform matrix.</summary>
        public global::AcidSharp.Matrix4 LocalTransform
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.GetLocalTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class KeyframeData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_time;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_JointTransformData___N_std_S_allocator__S0_ m_jointTransforms;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0KeyframeData@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0KeyframeData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1KeyframeData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddJointTransform@KeyframeData@acid@@QEAAXAEBVJointTransformData@2@@Z")]
            internal static extern void AddJointTransform(global::System.IntPtr instance, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@KeyframeData@acid@@QEBAMXZ")]
            internal static extern float GetTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.KeyframeData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.KeyframeData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.KeyframeData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.KeyframeData(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.KeyframeData __CreateInstance(global::AcidSharp.KeyframeData.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.KeyframeData(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.KeyframeData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.KeyframeData.__Internal));
            global::AcidSharp.KeyframeData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private KeyframeData(global::AcidSharp.KeyframeData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected KeyframeData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public KeyframeData(float time)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.KeyframeData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), time);
        }

        public KeyframeData(global::AcidSharp.KeyframeData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.KeyframeData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.KeyframeData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddJointTransform(global::AcidSharp.JointTransformData transform)
        {
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            __Internal.AddJointTransform((__Instance + __PointerAdjustment), __arg0);
        }

        public static implicit operator global::AcidSharp.KeyframeData(float time)
        {
            return new global::AcidSharp.KeyframeData(time);
        }

        public float Time
        {
            get
            {
                var __ret = __Internal.GetTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Represents one keyframe of an animation. This contains the timestamp of the keyframe, which is the time (in seconds) from the start of the animation when this keyframe occurs.  It also contains the desired local-space transforms of all of the joints in the animated entity at this keyframe in the animation. The joint transforms are stored in a map, indexed by the name of the joint that they should be applied to.</summary>
    public unsafe partial class Keyframe : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_timeStamp;

            [FieldOffset(8)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_acid_S_JointTransform___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_pose;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyframe@acid@@QEAA@AEBVKeyframeData@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyframe@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Keyframe@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeStamp@Keyframe@acid@@QEBAMXZ")]
            internal static extern float GetTimeStamp(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Keyframe> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Keyframe>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Keyframe __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Keyframe(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Keyframe __CreateInstance(global::AcidSharp.Keyframe.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Keyframe(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Keyframe.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Keyframe.__Internal));
            global::AcidSharp.Keyframe.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Keyframe(global::AcidSharp.Keyframe.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Keyframe(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new keyframe at a timestamp.</summary>
        /// <param name="data">The data to load the keyframe from.</param>
        public Keyframe(global::AcidSharp.KeyframeData data)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Keyframe.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = data.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Keyframe(global::AcidSharp.Keyframe _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Keyframe.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Keyframe __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::AcidSharp.Keyframe(global::AcidSharp.KeyframeData data)
        {
            return new global::AcidSharp.Keyframe(data);
        }

        /// <summary>Gets the time in seconds of the keyframe in the animation.</summary>
        public float TimeStamp
        {
            get
            {
                var __ret = __Internal.GetTimeStamp((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Represents an animation that can be carried out by an animated entity. It contains the length of the animation in seconds, and a list of s.</summary>
    public unsafe partial class Animation : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_length;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Keyframe___N_std_S_allocator__S0_ m_keyframes;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Animation@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Animation@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLength@Animation@acid@@QEBAMXZ")]
            internal static extern float GetLength(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Animation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Animation>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Animation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Animation(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Animation __CreateInstance(global::AcidSharp.Animation.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Animation(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Animation.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Animation.__Internal));
            global::AcidSharp.Animation.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Animation(global::AcidSharp.Animation.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Animation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Animation(global::AcidSharp.Animation _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Animation.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Animation __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets the length of the animation in seconds.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class AnimationLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.SharedPtr.__Internal m_libraryAnimations;

            [FieldOffset(16)]
            internal global::Std.SharedPtr.__Internal m_libraryVisualScenes;

            [FieldOffset(32)]
            internal float m_lengthSeconds;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_KeyframeData___N_std_S_allocator__S0_ m_keyframeData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AnimationLoader@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1AnimationLoader@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLengthSeconds@AnimationLoader@acid@@QEBAMXZ")]
            internal static extern float GetLengthSeconds(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.AnimationLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.AnimationLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.AnimationLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.AnimationLoader(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.AnimationLoader __CreateInstance(global::AcidSharp.AnimationLoader.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.AnimationLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.AnimationLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.AnimationLoader.__Internal));
            global::AcidSharp.AnimationLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AnimationLoader(global::AcidSharp.AnimationLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AnimationLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AnimationLoader(global::AcidSharp.AnimationLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.AnimationLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.AnimationLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float LengthSeconds
        {
            get
            {
                var __ret = __Internal.GetLengthSeconds((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Represents a joint in a &quot;skeleton&quot;. It contains the index of the joint which determines where in the vertex shader uniform array the joint matrix for this joint is loaded up to. It also contains the name of the bone, and a list of all the child joints.  The &quot;animatedTransform&quot; matrix is the joint transform. This is the transform that gets loaded up to the vertex shader and is used to transform vertices. It is a model-space transform that transforms the joint from it's bind (original position, no animation applied) position to it's current position in the current pose. Changing this transform changes the position/rotation of the joint in the animated entity.  The two other matrices are transforms that are required to calculate the &quot;animatedTransform&quot; in the  class. It also has the local bind transform which is the original (no pose/animation applied) transform of the joint relative to the parent joint (in bone-space).  The &quot;localBindTransform&quot; is the original (bind) transform of the joint relative to its parent (in bone-space). The inverseBindTransform is that bind transform in model-space, but inversed.</summary>
    public unsafe partial class Joint : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 256)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_index;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_acid_S_Joint___N_std_S_allocator__S0_ m_children;

            [FieldOffset(64)]
            internal global::AcidSharp.Matrix4.__Internal m_localBindTransform;

            [FieldOffset(128)]
            internal global::AcidSharp.Matrix4.__Internal m_animatedTransform;

            [FieldOffset(192)]
            internal global::AcidSharp.Matrix4.__Internal m_inverseBindTransform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joint@acid@@QEAA@AEBIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint index, global::System.IntPtr name, global::System.IntPtr bindLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joint@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Joint@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateInverseBindTransform@Joint@acid@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void CalculateInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr parentBindTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@Joint@acid@@QEBAIXZ")]
            internal static extern uint GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIndex@Joint@acid@@QEAAXAEBI@Z")]
            internal static extern void SetIndex(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Joint@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Joint@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalBindTransform@Joint@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetLocalBindTransform(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLocalBindTransform@Joint@acid@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetLocalBindTransform(global::System.IntPtr instance, global::System.IntPtr localBindTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAnimatedTransform@Joint@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetAnimatedTransform(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAnimatedTransform@Joint@acid@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetAnimatedTransform(global::System.IntPtr instance, global::System.IntPtr animatedTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInverseBindTransform@Joint@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInverseBindTransform@Joint@acid@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr inverseBindTransform);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Joint> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Joint>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Joint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Joint(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Joint __CreateInstance(global::AcidSharp.Joint.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Joint(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Joint.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Joint.__Internal));
            global::AcidSharp.Joint.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Joint(global::AcidSharp.Joint.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new skeleton joint.</summary>
        /// <param name="index">The joint's index (ID).</param>
        /// <param name="name">The name of the joint. This is how the joint is named in the collada file, and so is used to identify which joint a joint transform in an animation keyframe refers to.</param>
        /// <param name="bindLocalTransform">The bone-space transform of the joint in the bind position.</param>
        public Joint(uint index, string name, global::AcidSharp.Matrix4 bindLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Joint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(name, __allocator1);
            var __arg1 = __basicString1.__Instance;
            if (ReferenceEquals(bindLocalTransform, null))
                throw new global::System.ArgumentNullException("bindLocalTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = bindLocalTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), index, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public Joint(global::AcidSharp.Joint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Joint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Joint __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>This is called during set-up, after the joints hierarchy has been created. This calculates the model-space bind transform of this joint like so:</para>
        /// <para></para>
        /// <para></para>
        /// <para>{</para>
        /// </summary>
        public void CalculateInverseBindTransform(global::AcidSharp.Matrix4 parentBindTransform)
        {
            if (ReferenceEquals(parentBindTransform, null))
                throw new global::System.ArgumentNullException("parentBindTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = parentBindTransform.__Instance;
            __Internal.CalculateInverseBindTransform((__Instance + __PointerAdjustment), __arg0);
        }

        public uint Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetIndex((__Instance + __PointerAdjustment), value);
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::AcidSharp.Matrix4 LocalBindTransform
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.GetLocalBindTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLocalBindTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>The animated transform is the transform that gets loaded up to the shader and is used to deform the vertices of the &quot;skin&quot;. It represents the transformation from the joint's bind position (in model-space) to the joint's desired animation pose (also in model-space). This matrix is calculated by taking the desired model-space transform of the joint and multiplying it by the inverse of the starting model-space transform of the joint.</summary>
        public global::AcidSharp.Matrix4 AnimatedTransform
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.GetAnimatedTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAnimatedTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>This returns the inverted model-space bind transform. The bind transform is the original model-space transform of the joint (when no animation is applied). This returns the inverse of that, which is used to calculate the animated transform matrix which gets used to transform vertices in the shader.</summary>
        public global::AcidSharp.Matrix4 InverseBindTransform
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.GetInverseBindTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetInverseBindTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>This class contains all the functionality to apply an animation to an animated entity. An Animator instance is associated with just one animated entity. It also keeps track of the running time (in seconds) of the current animation, along with a reference to the currently playing animation for the corresponding entity.  An Animator instance needs to be updated every frame, in order for it to keep updating the animation pose of the associated entity. The currently playing animation can be changed at any time using the doAnimation() method. The Animator will keep looping the current animation until a new animation is chosen.  The Animator calculates the desired current animation pose by interpolating between the previous and next keyframes of the animation (based on the current animation time). The Animator then updates the transforms all of the joints each frame to match the current desired animation pose.</summary>
    public unsafe partial class Animator : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.SharedPtr.__Internal m_rootJoint;

            [FieldOffset(16)]
            internal float m_animationTime;

            [FieldOffset(24)]
            internal global::System.IntPtr m_currentAnimation;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Animator@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Animator@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Animator@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IncreaseAnimationTime@Animator@acid@@QEAAXXZ")]
            internal static extern void IncreaseAnimationTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateProgression@Animator@acid@@QEAAMAEBVKeyframe@2@0@Z")]
            internal static extern float CalculateProgression(global::System.IntPtr instance, global::System.IntPtr previousFrame, global::System.IntPtr nextFrame);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DoAnimation@Animator@acid@@QEAAXPEAVAnimation@2@@Z")]
            internal static extern void DoAnimation(global::System.IntPtr instance, global::System.IntPtr animation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentAnimation@Animator@acid@@QEBAPEAVAnimation@2@XZ")]
            internal static extern global::System.IntPtr GetCurrentAnimation(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Animator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Animator>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Animator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Animator(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Animator __CreateInstance(global::AcidSharp.Animator.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Animator(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Animator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Animator.__Internal));
            global::AcidSharp.Animator.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Animator(global::AcidSharp.Animator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Animator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Animator(global::AcidSharp.Animator _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Animator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Animator __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>This method should be called each frame to update the animation currently being played. This increases the animation time (and loops it back to zero if necessary), finds the pose that the entity should be in at that time of the animation, and then applied that pose to all the entity's joints.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        /// <summary>Increases the current animation time which allows the animation to progress. If the current animation has reached the end then the timer is reset, causing the animation to loop.</summary>
        public void IncreaseAnimationTime()
        {
            __Internal.IncreaseAnimationTime((__Instance + __PointerAdjustment));
        }

        /// <summary>Calculates how far between the previous and next keyframe the current animation time is, and returns it as a value between 0 and 1.</summary>
        /// <param name="previousFrame">The previous keyframe in the animation.</param>
        /// <param name="nextFrame">The next keyframe in the animation.</param>
        public float CalculateProgression(global::AcidSharp.Keyframe previousFrame, global::AcidSharp.Keyframe nextFrame)
        {
            if (ReferenceEquals(previousFrame, null))
                throw new global::System.ArgumentNullException("previousFrame", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = previousFrame.__Instance;
            if (ReferenceEquals(nextFrame, null))
                throw new global::System.ArgumentNullException("nextFrame", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = nextFrame.__Instance;
            var __ret = __Internal.CalculateProgression((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        /// <summary>Indicates that the entity should carry out the given animation. Resets the animation time so that the new animation starts from the beginning.</summary>
        /// <param name="animation">The new animation to carry out.</param>
        public void DoAnimation(global::AcidSharp.Animation animation)
        {
            var __arg0 = ReferenceEquals(animation, null) ? global::System.IntPtr.Zero : animation.__Instance;
            __Internal.DoAnimation((__Instance + __PointerAdjustment), __arg0);
        }

        public global::AcidSharp.Animation CurrentAnimation
        {
            get
            {
                var __ret = __Internal.GetCurrentAnimation((__Instance + __PointerAdjustment));
                global::AcidSharp.Animation __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.Animation.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.Animation) global::AcidSharp.Animation.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.Animation.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

public enum VkPipelineCacheHeaderVersion
{
    VkPipelineCacheHeaderVersionOne = 1,
    VkPipelineCacheHeaderVersionBeginRange = 1,
    VkPipelineCacheHeaderVersionEndRange = 1,
    VkPipelineCacheHeaderVersionRangeSize = 1,
    VkPipelineCacheHeaderVersionMaxEnum = 2147483647
}

public enum VkResult
{
    VkSuccess = 0,
    VkNotReady = 1,
    VkTimeout = 2,
    VkEventSet = 3,
    VkEventReset = 4,
    VkIncomplete = 5,
    VkErrorOutOfHostMemory = -1,
    VkErrorOutOfDeviceMemory = -2,
    VkErrorInitializationFailed = -3,
    VkErrorDeviceLost = -4,
    VkErrorMemoryMapFailed = -5,
    VkErrorLayerNotPresent = -6,
    VkErrorExtensionNotPresent = -7,
    VkErrorFeatureNotPresent = -8,
    VkErrorIncompatibleDriver = -9,
    VkErrorTooManyObjects = -10,
    VkErrorFormatNotSupported = -11,
    VkErrorFragmentedPool = -12,
    VkErrorOutOfPoolMemory = -1000069000,
    VkErrorInvalidExternalHandle = -1000072003,
    VkErrorSurfaceLostKhr = -1000000000,
    VkErrorNativeWindowInUseKhr = -1000000001,
    VkSuboptimalKhr = 1000001003,
    VkErrorOutOfDateKhr = -1000001004,
    VkErrorIncompatibleDisplayKhr = -1000003001,
    VkErrorValidationFailedExt = -1000011001,
    VkErrorInvalidShaderNv = -1000012000,
    VkErrorFragmentationExt = -1000161000,
    VkErrorNotPermittedExt = -1000174001,
    VkErrorOutOfPoolMemoryKhr = -1000069000,
    VkErrorInvalidExternalHandleKhr = -1000072003,
    VkResultBeginRange = -12,
    VkResultEndRange = 5,
    VkResultRangeSize = 18,
    VkResultMaxEnum = 2147483647
}

public enum VkStructureType
{
    VkStructureTypeApplicationInfo = 0,
    VkStructureTypeInstanceCreateInfo = 1,
    VkStructureTypeDeviceQueueCreateInfo = 2,
    VkStructureTypeDeviceCreateInfo = 3,
    VkStructureTypeSubmitInfo = 4,
    VkStructureTypeMemoryAllocateInfo = 5,
    VkStructureTypeMappedMemoryRange = 6,
    VkStructureTypeBindSparseInfo = 7,
    VkStructureTypeFenceCreateInfo = 8,
    VkStructureTypeSemaphoreCreateInfo = 9,
    VkStructureTypeEventCreateInfo = 10,
    VkStructureTypeQueryPoolCreateInfo = 11,
    VkStructureTypeBufferCreateInfo = 12,
    VkStructureTypeBufferViewCreateInfo = 13,
    VkStructureTypeImageCreateInfo = 14,
    VkStructureTypeImageViewCreateInfo = 15,
    VkStructureTypeShaderModuleCreateInfo = 16,
    VkStructureTypePipelineCacheCreateInfo = 17,
    VkStructureTypePipelineShaderStageCreateInfo = 18,
    VkStructureTypePipelineVertexInputStateCreateInfo = 19,
    VkStructureTypePipelineInputAssemblyStateCreateInfo = 20,
    VkStructureTypePipelineTessellationStateCreateInfo = 21,
    VkStructureTypePipelineViewportStateCreateInfo = 22,
    VkStructureTypePipelineRasterizationStateCreateInfo = 23,
    VkStructureTypePipelineMultisampleStateCreateInfo = 24,
    VkStructureTypePipelineDepthStencilStateCreateInfo = 25,
    VkStructureTypePipelineColorBlendStateCreateInfo = 26,
    VkStructureTypePipelineDynamicStateCreateInfo = 27,
    VkStructureTypeGraphicsPipelineCreateInfo = 28,
    VkStructureTypeComputePipelineCreateInfo = 29,
    VkStructureTypePipelineLayoutCreateInfo = 30,
    VkStructureTypeSamplerCreateInfo = 31,
    VkStructureTypeDescriptorSetLayoutCreateInfo = 32,
    VkStructureTypeDescriptorPoolCreateInfo = 33,
    VkStructureTypeDescriptorSetAllocateInfo = 34,
    VkStructureTypeWriteDescriptorSet = 35,
    VkStructureTypeCopyDescriptorSet = 36,
    VkStructureTypeFramebufferCreateInfo = 37,
    VkStructureTypeRenderPassCreateInfo = 38,
    VkStructureTypeCommandPoolCreateInfo = 39,
    VkStructureTypeCommandBufferAllocateInfo = 40,
    VkStructureTypeCommandBufferInheritanceInfo = 41,
    VkStructureTypeCommandBufferBeginInfo = 42,
    VkStructureTypeRenderPassBeginInfo = 43,
    VkStructureTypeBufferMemoryBarrier = 44,
    VkStructureTypeImageMemoryBarrier = 45,
    VkStructureTypeMemoryBarrier = 46,
    VkStructureTypeLoaderInstanceCreateInfo = 47,
    VkStructureTypeLoaderDeviceCreateInfo = 48,
    VkStructureTypePhysicalDeviceSubgroupProperties = 1000094000,
    VkStructureTypeBindBufferMemoryInfo = 1000157000,
    VkStructureTypeBindImageMemoryInfo = 1000157001,
    VkStructureTypePhysicalDevice16BitStorageFeatures = 1000083000,
    VkStructureTypeMemoryDedicatedRequirements = 1000127000,
    VkStructureTypeMemoryDedicatedAllocateInfo = 1000127001,
    VkStructureTypeMemoryAllocateFlagsInfo = 1000060000,
    VkStructureTypeDeviceGroupRenderPassBeginInfo = 1000060003,
    VkStructureTypeDeviceGroupCommandBufferBeginInfo = 1000060004,
    VkStructureTypeDeviceGroupSubmitInfo = 1000060005,
    VkStructureTypeDeviceGroupBindSparseInfo = 1000060006,
    VkStructureTypeBindBufferMemoryDeviceGroupInfo = 1000060013,
    VkStructureTypeBindImageMemoryDeviceGroupInfo = 1000060014,
    VkStructureTypePhysicalDeviceGroupProperties = 1000070000,
    VkStructureTypeDeviceGroupDeviceCreateInfo = 1000070001,
    VkStructureTypeBufferMemoryRequirementsInfo2 = 1000146000,
    VkStructureTypeImageMemoryRequirementsInfo2 = 1000146001,
    VkStructureTypeImageSparseMemoryRequirementsInfo2 = 1000146002,
    VkStructureTypeMemoryRequirements2 = 1000146003,
    VkStructureTypeSparseImageMemoryRequirements2 = 1000146004,
    VkStructureTypePhysicalDeviceFeatures2 = 1000059000,
    VkStructureTypePhysicalDeviceProperties2 = 1000059001,
    VkStructureTypeFormatProperties2 = 1000059002,
    VkStructureTypeImageFormatProperties2 = 1000059003,
    VkStructureTypePhysicalDeviceImageFormatInfo2 = 1000059004,
    VkStructureTypeQueueFamilyProperties2 = 1000059005,
    VkStructureTypePhysicalDeviceMemoryProperties2 = 1000059006,
    VkStructureTypeSparseImageFormatProperties2 = 1000059007,
    VkStructureTypePhysicalDeviceSparseImageFormatInfo2 = 1000059008,
    VkStructureTypePhysicalDevicePointClippingProperties = 1000117000,
    VkStructureTypeRenderPassInputAttachmentAspectCreateInfo = 1000117001,
    VkStructureTypeImageViewUsageCreateInfo = 1000117002,
    VkStructureTypePipelineTessellationDomainOriginStateCreateInfo = 1000117003,
    VkStructureTypeRenderPassMultiviewCreateInfo = 1000053000,
    VkStructureTypePhysicalDeviceMultiviewFeatures = 1000053001,
    VkStructureTypePhysicalDeviceMultiviewProperties = 1000053002,
    VkStructureTypePhysicalDeviceVariablePointerFeatures = 1000120000,
    VkStructureTypeProtectedSubmitInfo = 1000145000,
    VkStructureTypePhysicalDeviceProtectedMemoryFeatures = 1000145001,
    VkStructureTypePhysicalDeviceProtectedMemoryProperties = 1000145002,
    VkStructureTypeDeviceQueueInfo2 = 1000145003,
    VkStructureTypeSamplerYcbcrConversionCreateInfo = 1000156000,
    VkStructureTypeSamplerYcbcrConversionInfo = 1000156001,
    VkStructureTypeBindImagePlaneMemoryInfo = 1000156002,
    VkStructureTypeImagePlaneMemoryRequirementsInfo = 1000156003,
    VkStructureTypePhysicalDeviceSamplerYcbcrConversionFeatures = 1000156004,
    VkStructureTypeSamplerYcbcrConversionImageFormatProperties = 1000156005,
    VkStructureTypeDescriptorUpdateTemplateCreateInfo = 1000085000,
    VkStructureTypePhysicalDeviceExternalImageFormatInfo = 1000071000,
    VkStructureTypeExternalImageFormatProperties = 1000071001,
    VkStructureTypePhysicalDeviceExternalBufferInfo = 1000071002,
    VkStructureTypeExternalBufferProperties = 1000071003,
    VkStructureTypePhysicalDeviceIdProperties = 1000071004,
    VkStructureTypeExternalMemoryBufferCreateInfo = 1000072000,
    VkStructureTypeExternalMemoryImageCreateInfo = 1000072001,
    VkStructureTypeExportMemoryAllocateInfo = 1000072002,
    VkStructureTypePhysicalDeviceExternalFenceInfo = 1000112000,
    VkStructureTypeExternalFenceProperties = 1000112001,
    VkStructureTypeExportFenceCreateInfo = 1000113000,
    VkStructureTypeExportSemaphoreCreateInfo = 1000077000,
    VkStructureTypePhysicalDeviceExternalSemaphoreInfo = 1000076000,
    VkStructureTypeExternalSemaphoreProperties = 1000076001,
    VkStructureTypePhysicalDeviceMaintenance3Properties = 1000168000,
    VkStructureTypeDescriptorSetLayoutSupport = 1000168001,
    VkStructureTypePhysicalDeviceShaderDrawParameterFeatures = 1000063000,
    VkStructureTypeSwapchainCreateInfoKhr = 1000001000,
    VkStructureTypePresentInfoKhr = 1000001001,
    VkStructureTypeDeviceGroupPresentCapabilitiesKhr = 1000060007,
    VkStructureTypeImageSwapchainCreateInfoKhr = 1000060008,
    VkStructureTypeBindImageMemorySwapchainInfoKhr = 1000060009,
    VkStructureTypeAcquireNextImageInfoKhr = 1000060010,
    VkStructureTypeDeviceGroupPresentInfoKhr = 1000060011,
    VkStructureTypeDeviceGroupSwapchainCreateInfoKhr = 1000060012,
    VkStructureTypeDisplayModeCreateInfoKhr = 1000002000,
    VkStructureTypeDisplaySurfaceCreateInfoKhr = 1000002001,
    VkStructureTypeDisplayPresentInfoKhr = 1000003000,
    VkStructureTypeXlibSurfaceCreateInfoKhr = 1000004000,
    VkStructureTypeXcbSurfaceCreateInfoKhr = 1000005000,
    VkStructureTypeWaylandSurfaceCreateInfoKhr = 1000006000,
    VkStructureTypeMirSurfaceCreateInfoKhr = 1000007000,
    VkStructureTypeAndroidSurfaceCreateInfoKhr = 1000008000,
    VkStructureTypeWin32SurfaceCreateInfoKhr = 1000009000,
    VkStructureTypeDebugReportCallbackCreateInfoExt = 1000011000,
    VkStructureTypePipelineRasterizationStateRasterizationOrderAmd = 1000018000,
    VkStructureTypeDebugMarkerObjectNameInfoExt = 1000022000,
    VkStructureTypeDebugMarkerObjectTagInfoExt = 1000022001,
    VkStructureTypeDebugMarkerMarkerInfoExt = 1000022002,
    VkStructureTypeDedicatedAllocationImageCreateInfoNv = 1000026000,
    VkStructureTypeDedicatedAllocationBufferCreateInfoNv = 1000026001,
    VkStructureTypeDedicatedAllocationMemoryAllocateInfoNv = 1000026002,
    VkStructureTypeTextureLodGatherFormatPropertiesAmd = 1000041000,
    VkStructureTypeExternalMemoryImageCreateInfoNv = 1000056000,
    VkStructureTypeExportMemoryAllocateInfoNv = 1000056001,
    VkStructureTypeImportMemoryWin32HandleInfoNv = 1000057000,
    VkStructureTypeExportMemoryWin32HandleInfoNv = 1000057001,
    VkStructureTypeWin32KeyedMutexAcquireReleaseInfoNv = 1000058000,
    VkStructureTypeValidationFlagsExt = 1000061000,
    VkStructureTypeViSurfaceCreateInfoNn = 1000062000,
    VkStructureTypeImportMemoryWin32HandleInfoKhr = 1000073000,
    VkStructureTypeExportMemoryWin32HandleInfoKhr = 1000073001,
    VkStructureTypeMemoryWin32HandlePropertiesKhr = 1000073002,
    VkStructureTypeMemoryGetWin32HandleInfoKhr = 1000073003,
    VkStructureTypeImportMemoryFdInfoKhr = 1000074000,
    VkStructureTypeMemoryFdPropertiesKhr = 1000074001,
    VkStructureTypeMemoryGetFdInfoKhr = 1000074002,
    VkStructureTypeWin32KeyedMutexAcquireReleaseInfoKhr = 1000075000,
    VkStructureTypeImportSemaphoreWin32HandleInfoKhr = 1000078000,
    VkStructureTypeExportSemaphoreWin32HandleInfoKhr = 1000078001,
    VkStructureTypeD3d12FenceSubmitInfoKhr = 1000078002,
    VkStructureTypeSemaphoreGetWin32HandleInfoKhr = 1000078003,
    VkStructureTypeImportSemaphoreFdInfoKhr = 1000079000,
    VkStructureTypeSemaphoreGetFdInfoKhr = 1000079001,
    VkStructureTypePhysicalDevicePushDescriptorPropertiesKhr = 1000080000,
    VkStructureTypeCommandBufferInheritanceConditionalRenderingInfoExt = 1000081000,
    VkStructureTypePhysicalDeviceConditionalRenderingFeaturesExt = 1000081001,
    VkStructureTypeConditionalRenderingBeginInfoExt = 1000081002,
    VkStructureTypePresentRegionsKhr = 1000084000,
    VkStructureTypeObjectTableCreateInfoNvx = 1000086000,
    VkStructureTypeIndirectCommandsLayoutCreateInfoNvx = 1000086001,
    VkStructureTypeCmdProcessCommandsInfoNvx = 1000086002,
    VkStructureTypeCmdReserveSpaceForCommandsInfoNvx = 1000086003,
    VkStructureTypeDeviceGeneratedCommandsLimitsNvx = 1000086004,
    VkStructureTypeDeviceGeneratedCommandsFeaturesNvx = 1000086005,
    VkStructureTypePipelineViewportWScalingStateCreateInfoNv = 1000087000,
    VkStructureTypeSurfaceCapabilities2Ext = 1000090000,
    VkStructureTypeDisplayPowerInfoExt = 1000091000,
    VkStructureTypeDeviceEventInfoExt = 1000091001,
    VkStructureTypeDisplayEventInfoExt = 1000091002,
    VkStructureTypeSwapchainCounterCreateInfoExt = 1000091003,
    VkStructureTypePresentTimesInfoGoogle = 1000092000,
    VkStructureTypePhysicalDeviceMultiviewPerViewAttributesPropertiesNvx = 1000097000,
    VkStructureTypePipelineViewportSwizzleStateCreateInfoNv = 1000098000,
    VkStructureTypePhysicalDeviceDiscardRectanglePropertiesExt = 1000099000,
    VkStructureTypePipelineDiscardRectangleStateCreateInfoExt = 1000099001,
    VkStructureTypePhysicalDeviceConservativeRasterizationPropertiesExt = 1000101000,
    VkStructureTypePipelineRasterizationConservativeStateCreateInfoExt = 1000101001,
    VkStructureTypeHdrMetadataExt = 1000105000,
    VkStructureTypeAttachmentDescription2Khr = 1000109000,
    VkStructureTypeAttachmentReference2Khr = 1000109001,
    VkStructureTypeSubpassDescription2Khr = 1000109002,
    VkStructureTypeSubpassDependency2Khr = 1000109003,
    VkStructureTypeRenderPassCreateInfo2Khr = 1000109004,
    VkStructureTypeSubpassBeginInfoKhr = 1000109005,
    VkStructureTypeSubpassEndInfoKhr = 1000109006,
    VkStructureTypeSharedPresentSurfaceCapabilitiesKhr = 1000111000,
    VkStructureTypeImportFenceWin32HandleInfoKhr = 1000114000,
    VkStructureTypeExportFenceWin32HandleInfoKhr = 1000114001,
    VkStructureTypeFenceGetWin32HandleInfoKhr = 1000114002,
    VkStructureTypeImportFenceFdInfoKhr = 1000115000,
    VkStructureTypeFenceGetFdInfoKhr = 1000115001,
    VkStructureTypePhysicalDeviceSurfaceInfo2Khr = 1000119000,
    VkStructureTypeSurfaceCapabilities2Khr = 1000119001,
    VkStructureTypeSurfaceFormat2Khr = 1000119002,
    VkStructureTypeDisplayProperties2Khr = 1000121000,
    VkStructureTypeDisplayPlaneProperties2Khr = 1000121001,
    VkStructureTypeDisplayModeProperties2Khr = 1000121002,
    VkStructureTypeDisplayPlaneInfo2Khr = 1000121003,
    VkStructureTypeDisplayPlaneCapabilities2Khr = 1000121004,
    VkStructureTypeIosSurfaceCreateInfoMvk = 1000122000,
    VkStructureTypeMacosSurfaceCreateInfoMvk = 1000123000,
    VkStructureTypeDebugUtilsObjectNameInfoExt = 1000128000,
    VkStructureTypeDebugUtilsObjectTagInfoExt = 1000128001,
    VkStructureTypeDebugUtilsLabelExt = 1000128002,
    VkStructureTypeDebugUtilsMessengerCallbackDataExt = 1000128003,
    VkStructureTypeDebugUtilsMessengerCreateInfoExt = 1000128004,
    VkStructureTypeAndroidHardwareBufferUsageAndroid = 1000129000,
    VkStructureTypeAndroidHardwareBufferPropertiesAndroid = 1000129001,
    VkStructureTypeAndroidHardwareBufferFormatPropertiesAndroid = 1000129002,
    VkStructureTypeImportAndroidHardwareBufferInfoAndroid = 1000129003,
    VkStructureTypeMemoryGetAndroidHardwareBufferInfoAndroid = 1000129004,
    VkStructureTypeExternalFormatAndroid = 1000129005,
    VkStructureTypePhysicalDeviceSamplerFilterMinmaxPropertiesExt = 1000130000,
    VkStructureTypeSamplerReductionModeCreateInfoExt = 1000130001,
    VkStructureTypeSampleLocationsInfoExt = 1000143000,
    VkStructureTypeRenderPassSampleLocationsBeginInfoExt = 1000143001,
    VkStructureTypePipelineSampleLocationsStateCreateInfoExt = 1000143002,
    VkStructureTypePhysicalDeviceSampleLocationsPropertiesExt = 1000143003,
    VkStructureTypeMultisamplePropertiesExt = 1000143004,
    VkStructureTypeImageFormatListCreateInfoKhr = 1000147000,
    VkStructureTypePhysicalDeviceBlendOperationAdvancedFeaturesExt = 1000148000,
    VkStructureTypePhysicalDeviceBlendOperationAdvancedPropertiesExt = 1000148001,
    VkStructureTypePipelineColorBlendAdvancedStateCreateInfoExt = 1000148002,
    VkStructureTypePipelineCoverageToColorStateCreateInfoNv = 1000149000,
    VkStructureTypePipelineCoverageModulationStateCreateInfoNv = 1000152000,
    VkStructureTypeValidationCacheCreateInfoExt = 1000160000,
    VkStructureTypeShaderModuleValidationCacheCreateInfoExt = 1000160001,
    VkStructureTypeDescriptorSetLayoutBindingFlagsCreateInfoExt = 1000161000,
    VkStructureTypePhysicalDeviceDescriptorIndexingFeaturesExt = 1000161001,
    VkStructureTypePhysicalDeviceDescriptorIndexingPropertiesExt = 1000161002,
    VkStructureTypeDescriptorSetVariableDescriptorCountAllocateInfoExt = 1000161003,
    VkStructureTypeDescriptorSetVariableDescriptorCountLayoutSupportExt = 1000161004,
    VkStructureTypeDeviceQueueGlobalPriorityCreateInfoExt = 1000174000,
    VkStructureTypePhysicalDevice8BitStorageFeaturesKhr = 1000177000,
    VkStructureTypeImportMemoryHostPointerInfoExt = 1000178000,
    VkStructureTypeMemoryHostPointerPropertiesExt = 1000178001,
    VkStructureTypePhysicalDeviceExternalMemoryHostPropertiesExt = 1000178002,
    VkStructureTypePhysicalDeviceShaderCorePropertiesAmd = 1000185000,
    VkStructureTypePhysicalDeviceVertexAttributeDivisorPropertiesExt = 1000190000,
    VkStructureTypePipelineVertexInputDivisorStateCreateInfoExt = 1000190001,
    VkStructureTypeCheckpointDataNv = 1000206000,
    VkStructureTypeQueueFamilyCheckpointPropertiesNv = 1000206001,
    VkStructureTypeRenderPassMultiviewCreateInfoKhr = 1000053000,
    VkStructureTypePhysicalDeviceMultiviewFeaturesKhr = 1000053001,
    VkStructureTypePhysicalDeviceMultiviewPropertiesKhr = 1000053002,
    VkStructureTypePhysicalDeviceFeatures2Khr = 1000059000,
    VkStructureTypePhysicalDeviceProperties2Khr = 1000059001,
    VkStructureTypeFormatProperties2Khr = 1000059002,
    VkStructureTypeImageFormatProperties2Khr = 1000059003,
    VkStructureTypePhysicalDeviceImageFormatInfo2Khr = 1000059004,
    VkStructureTypeQueueFamilyProperties2Khr = 1000059005,
    VkStructureTypePhysicalDeviceMemoryProperties2Khr = 1000059006,
    VkStructureTypeSparseImageFormatProperties2Khr = 1000059007,
    VkStructureTypePhysicalDeviceSparseImageFormatInfo2Khr = 1000059008,
    VkStructureTypeMemoryAllocateFlagsInfoKhr = 1000060000,
    VkStructureTypeDeviceGroupRenderPassBeginInfoKhr = 1000060003,
    VkStructureTypeDeviceGroupCommandBufferBeginInfoKhr = 1000060004,
    VkStructureTypeDeviceGroupSubmitInfoKhr = 1000060005,
    VkStructureTypeDeviceGroupBindSparseInfoKhr = 1000060006,
    VkStructureTypeBindBufferMemoryDeviceGroupInfoKhr = 1000060013,
    VkStructureTypeBindImageMemoryDeviceGroupInfoKhr = 1000060014,
    VkStructureTypePhysicalDeviceGroupPropertiesKhr = 1000070000,
    VkStructureTypeDeviceGroupDeviceCreateInfoKhr = 1000070001,
    VkStructureTypePhysicalDeviceExternalImageFormatInfoKhr = 1000071000,
    VkStructureTypeExternalImageFormatPropertiesKhr = 1000071001,
    VkStructureTypePhysicalDeviceExternalBufferInfoKhr = 1000071002,
    VkStructureTypeExternalBufferPropertiesKhr = 1000071003,
    VkStructureTypePhysicalDeviceIdPropertiesKhr = 1000071004,
    VkStructureTypeExternalMemoryBufferCreateInfoKhr = 1000072000,
    VkStructureTypeExternalMemoryImageCreateInfoKhr = 1000072001,
    VkStructureTypeExportMemoryAllocateInfoKhr = 1000072002,
    VkStructureTypePhysicalDeviceExternalSemaphoreInfoKhr = 1000076000,
    VkStructureTypeExternalSemaphorePropertiesKhr = 1000076001,
    VkStructureTypeExportSemaphoreCreateInfoKhr = 1000077000,
    VkStructureTypePhysicalDevice16BitStorageFeaturesKhr = 1000083000,
    VkStructureTypeDescriptorUpdateTemplateCreateInfoKhr = 1000085000,
    VkStructureTypePhysicalDeviceExternalFenceInfoKhr = 1000112000,
    VkStructureTypeExternalFencePropertiesKhr = 1000112001,
    VkStructureTypeExportFenceCreateInfoKhr = 1000113000,
    VkStructureTypePhysicalDevicePointClippingPropertiesKhr = 1000117000,
    VkStructureTypeRenderPassInputAttachmentAspectCreateInfoKhr = 1000117001,
    VkStructureTypeImageViewUsageCreateInfoKhr = 1000117002,
    VkStructureTypePipelineTessellationDomainOriginStateCreateInfoKhr = 1000117003,
    VkStructureTypePhysicalDeviceVariablePointerFeaturesKhr = 1000120000,
    VkStructureTypeMemoryDedicatedRequirementsKhr = 1000127000,
    VkStructureTypeMemoryDedicatedAllocateInfoKhr = 1000127001,
    VkStructureTypeBufferMemoryRequirementsInfo2Khr = 1000146000,
    VkStructureTypeImageMemoryRequirementsInfo2Khr = 1000146001,
    VkStructureTypeImageSparseMemoryRequirementsInfo2Khr = 1000146002,
    VkStructureTypeMemoryRequirements2Khr = 1000146003,
    VkStructureTypeSparseImageMemoryRequirements2Khr = 1000146004,
    VkStructureTypeSamplerYcbcrConversionCreateInfoKhr = 1000156000,
    VkStructureTypeSamplerYcbcrConversionInfoKhr = 1000156001,
    VkStructureTypeBindImagePlaneMemoryInfoKhr = 1000156002,
    VkStructureTypeImagePlaneMemoryRequirementsInfoKhr = 1000156003,
    VkStructureTypePhysicalDeviceSamplerYcbcrConversionFeaturesKhr = 1000156004,
    VkStructureTypeSamplerYcbcrConversionImageFormatPropertiesKhr = 1000156005,
    VkStructureTypeBindBufferMemoryInfoKhr = 1000157000,
    VkStructureTypeBindImageMemoryInfoKhr = 1000157001,
    VkStructureTypePhysicalDeviceMaintenance3PropertiesKhr = 1000168000,
    VkStructureTypeDescriptorSetLayoutSupportKhr = 1000168001,
    VkStructureTypeBeginRange = 0,
    VkStructureTypeEndRange = 48,
    VkStructureTypeRangeSize = 49,
    VkStructureTypeMaxEnum = 2147483647
}

public enum VkSystemAllocationScope
{
    VkSystemAllocationScopeCommand = 0,
    VkSystemAllocationScopeObject = 1,
    VkSystemAllocationScopeCache = 2,
    VkSystemAllocationScopeDevice = 3,
    VkSystemAllocationScopeInstance = 4,
    VkSystemAllocationScopeBeginRange = 0,
    VkSystemAllocationScopeEndRange = 4,
    VkSystemAllocationScopeRangeSize = 5,
    VkSystemAllocationScopeMaxEnum = 2147483647
}

public enum VkInternalAllocationType
{
    VkInternalAllocationTypeExecutable = 0,
    VkInternalAllocationTypeBeginRange = 0,
    VkInternalAllocationTypeEndRange = 0,
    VkInternalAllocationTypeRangeSize = 1,
    VkInternalAllocationTypeMaxEnum = 2147483647
}

public enum VkFormat
{
    VkFormatUndefined = 0,
    VkFormatR4g4UnormPack8 = 1,
    VkFormatR4g4b4a4UnormPack16 = 2,
    VkFormatB4g4r4a4UnormPack16 = 3,
    VkFormatR5g6b5UnormPack16 = 4,
    VkFormatB5g6r5UnormPack16 = 5,
    VkFormatR5g5b5a1UnormPack16 = 6,
    VkFormatB5g5r5a1UnormPack16 = 7,
    VkFormatA1r5g5b5UnormPack16 = 8,
    VkFormatR8Unorm = 9,
    VkFormatR8Snorm = 10,
    VkFormatR8Uscaled = 11,
    VkFormatR8Sscaled = 12,
    VkFormatR8Uint = 13,
    VkFormatR8Sint = 14,
    VkFormatR8Srgb = 15,
    VkFormatR8g8Unorm = 16,
    VkFormatR8g8Snorm = 17,
    VkFormatR8g8Uscaled = 18,
    VkFormatR8g8Sscaled = 19,
    VkFormatR8g8Uint = 20,
    VkFormatR8g8Sint = 21,
    VkFormatR8g8Srgb = 22,
    VkFormatR8g8b8Unorm = 23,
    VkFormatR8g8b8Snorm = 24,
    VkFormatR8g8b8Uscaled = 25,
    VkFormatR8g8b8Sscaled = 26,
    VkFormatR8g8b8Uint = 27,
    VkFormatR8g8b8Sint = 28,
    VkFormatR8g8b8Srgb = 29,
    VkFormatB8g8r8Unorm = 30,
    VkFormatB8g8r8Snorm = 31,
    VkFormatB8g8r8Uscaled = 32,
    VkFormatB8g8r8Sscaled = 33,
    VkFormatB8g8r8Uint = 34,
    VkFormatB8g8r8Sint = 35,
    VkFormatB8g8r8Srgb = 36,
    VkFormatR8g8b8a8Unorm = 37,
    VkFormatR8g8b8a8Snorm = 38,
    VkFormatR8g8b8a8Uscaled = 39,
    VkFormatR8g8b8a8Sscaled = 40,
    VkFormatR8g8b8a8Uint = 41,
    VkFormatR8g8b8a8Sint = 42,
    VkFormatR8g8b8a8Srgb = 43,
    VkFormatB8g8r8a8Unorm = 44,
    VkFormatB8g8r8a8Snorm = 45,
    VkFormatB8g8r8a8Uscaled = 46,
    VkFormatB8g8r8a8Sscaled = 47,
    VkFormatB8g8r8a8Uint = 48,
    VkFormatB8g8r8a8Sint = 49,
    VkFormatB8g8r8a8Srgb = 50,
    VkFormatA8b8g8r8UnormPack32 = 51,
    VkFormatA8b8g8r8SnormPack32 = 52,
    VkFormatA8b8g8r8UscaledPack32 = 53,
    VkFormatA8b8g8r8SscaledPack32 = 54,
    VkFormatA8b8g8r8UintPack32 = 55,
    VkFormatA8b8g8r8SintPack32 = 56,
    VkFormatA8b8g8r8SrgbPack32 = 57,
    VkFormatA2r10g10b10UnormPack32 = 58,
    VkFormatA2r10g10b10SnormPack32 = 59,
    VkFormatA2r10g10b10UscaledPack32 = 60,
    VkFormatA2r10g10b10SscaledPack32 = 61,
    VkFormatA2r10g10b10UintPack32 = 62,
    VkFormatA2r10g10b10SintPack32 = 63,
    VkFormatA2b10g10r10UnormPack32 = 64,
    VkFormatA2b10g10r10SnormPack32 = 65,
    VkFormatA2b10g10r10UscaledPack32 = 66,
    VkFormatA2b10g10r10SscaledPack32 = 67,
    VkFormatA2b10g10r10UintPack32 = 68,
    VkFormatA2b10g10r10SintPack32 = 69,
    VkFormatR16Unorm = 70,
    VkFormatR16Snorm = 71,
    VkFormatR16Uscaled = 72,
    VkFormatR16Sscaled = 73,
    VkFormatR16Uint = 74,
    VkFormatR16Sint = 75,
    VkFormatR16Sfloat = 76,
    VkFormatR16g16Unorm = 77,
    VkFormatR16g16Snorm = 78,
    VkFormatR16g16Uscaled = 79,
    VkFormatR16g16Sscaled = 80,
    VkFormatR16g16Uint = 81,
    VkFormatR16g16Sint = 82,
    VkFormatR16g16Sfloat = 83,
    VkFormatR16g16b16Unorm = 84,
    VkFormatR16g16b16Snorm = 85,
    VkFormatR16g16b16Uscaled = 86,
    VkFormatR16g16b16Sscaled = 87,
    VkFormatR16g16b16Uint = 88,
    VkFormatR16g16b16Sint = 89,
    VkFormatR16g16b16Sfloat = 90,
    VkFormatR16g16b16a16Unorm = 91,
    VkFormatR16g16b16a16Snorm = 92,
    VkFormatR16g16b16a16Uscaled = 93,
    VkFormatR16g16b16a16Sscaled = 94,
    VkFormatR16g16b16a16Uint = 95,
    VkFormatR16g16b16a16Sint = 96,
    VkFormatR16g16b16a16Sfloat = 97,
    VkFormatR32Uint = 98,
    VkFormatR32Sint = 99,
    VkFormatR32Sfloat = 100,
    VkFormatR32g32Uint = 101,
    VkFormatR32g32Sint = 102,
    VkFormatR32g32Sfloat = 103,
    VkFormatR32g32b32Uint = 104,
    VkFormatR32g32b32Sint = 105,
    VkFormatR32g32b32Sfloat = 106,
    VkFormatR32g32b32a32Uint = 107,
    VkFormatR32g32b32a32Sint = 108,
    VkFormatR32g32b32a32Sfloat = 109,
    VkFormatR64Uint = 110,
    VkFormatR64Sint = 111,
    VkFormatR64Sfloat = 112,
    VkFormatR64g64Uint = 113,
    VkFormatR64g64Sint = 114,
    VkFormatR64g64Sfloat = 115,
    VkFormatR64g64b64Uint = 116,
    VkFormatR64g64b64Sint = 117,
    VkFormatR64g64b64Sfloat = 118,
    VkFormatR64g64b64a64Uint = 119,
    VkFormatR64g64b64a64Sint = 120,
    VkFormatR64g64b64a64Sfloat = 121,
    VkFormatB10g11r11UfloatPack32 = 122,
    VkFormatE5b9g9r9UfloatPack32 = 123,
    VkFormatD16Unorm = 124,
    VkFormatX8D24UnormPack32 = 125,
    VkFormatD32Sfloat = 126,
    VkFormatS8Uint = 127,
    VkFormatD16UnormS8Uint = 128,
    VkFormatD24UnormS8Uint = 129,
    VkFormatD32SfloatS8Uint = 130,
    VkFormatBc1RgbUnormBlock = 131,
    VkFormatBc1RgbSrgbBlock = 132,
    VkFormatBc1RgbaUnormBlock = 133,
    VkFormatBc1RgbaSrgbBlock = 134,
    VkFormatBc2UnormBlock = 135,
    VkFormatBc2SrgbBlock = 136,
    VkFormatBc3UnormBlock = 137,
    VkFormatBc3SrgbBlock = 138,
    VkFormatBc4UnormBlock = 139,
    VkFormatBc4SnormBlock = 140,
    VkFormatBc5UnormBlock = 141,
    VkFormatBc5SnormBlock = 142,
    VkFormatBc6hUfloatBlock = 143,
    VkFormatBc6hSfloatBlock = 144,
    VkFormatBc7UnormBlock = 145,
    VkFormatBc7SrgbBlock = 146,
    VkFormatEtc2R8g8b8UnormBlock = 147,
    VkFormatEtc2R8g8b8SrgbBlock = 148,
    VkFormatEtc2R8g8b8a1UnormBlock = 149,
    VkFormatEtc2R8g8b8a1SrgbBlock = 150,
    VkFormatEtc2R8g8b8a8UnormBlock = 151,
    VkFormatEtc2R8g8b8a8SrgbBlock = 152,
    VkFormatEacR11UnormBlock = 153,
    VkFormatEacR11SnormBlock = 154,
    VkFormatEacR11g11UnormBlock = 155,
    VkFormatEacR11g11SnormBlock = 156,
    VkFormatAstc4X4UnormBlock = 157,
    VkFormatAstc4X4SrgbBlock = 158,
    VkFormatAstc5X4UnormBlock = 159,
    VkFormatAstc5X4SrgbBlock = 160,
    VkFormatAstc5X5UnormBlock = 161,
    VkFormatAstc5X5SrgbBlock = 162,
    VkFormatAstc6X5UnormBlock = 163,
    VkFormatAstc6X5SrgbBlock = 164,
    VkFormatAstc6X6UnormBlock = 165,
    VkFormatAstc6X6SrgbBlock = 166,
    VkFormatAstc8X5UnormBlock = 167,
    VkFormatAstc8X5SrgbBlock = 168,
    VkFormatAstc8X6UnormBlock = 169,
    VkFormatAstc8X6SrgbBlock = 170,
    VkFormatAstc8X8UnormBlock = 171,
    VkFormatAstc8X8SrgbBlock = 172,
    VkFormatAstc10X5UnormBlock = 173,
    VkFormatAstc10X5SrgbBlock = 174,
    VkFormatAstc10X6UnormBlock = 175,
    VkFormatAstc10X6SrgbBlock = 176,
    VkFormatAstc10X8UnormBlock = 177,
    VkFormatAstc10X8SrgbBlock = 178,
    VkFormatAstc10X10UnormBlock = 179,
    VkFormatAstc10X10SrgbBlock = 180,
    VkFormatAstc12X10UnormBlock = 181,
    VkFormatAstc12X10SrgbBlock = 182,
    VkFormatAstc12X12UnormBlock = 183,
    VkFormatAstc12X12SrgbBlock = 184,
    VkFormatG8b8g8r8422Unorm = 1000156000,
    VkFormatB8g8r8g8422Unorm = 1000156001,
    VkFormatG8B8R83Plane420Unorm = 1000156002,
    VkFormatG8B8r82Plane420Unorm = 1000156003,
    VkFormatG8B8R83Plane422Unorm = 1000156004,
    VkFormatG8B8r82Plane422Unorm = 1000156005,
    VkFormatG8B8R83Plane444Unorm = 1000156006,
    VkFormatR10x6UnormPack16 = 1000156007,
    VkFormatR10x6g10x6Unorm2Pack16 = 1000156008,
    VkFormatR10x6g10x6b10x6a10x6Unorm4Pack16 = 1000156009,
    VkFormatG10x6b10x6g10x6r10x6422Unorm4Pack16 = 1000156010,
    VkFormatB10x6g10x6r10x6g10x6422Unorm4Pack16 = 1000156011,
    VkFormatG10x6B10x6R10x63Plane420Unorm3Pack16 = 1000156012,
    VkFormatG10x6B10x6r10x62Plane420Unorm3Pack16 = 1000156013,
    VkFormatG10x6B10x6R10x63Plane422Unorm3Pack16 = 1000156014,
    VkFormatG10x6B10x6r10x62Plane422Unorm3Pack16 = 1000156015,
    VkFormatG10x6B10x6R10x63Plane444Unorm3Pack16 = 1000156016,
    VkFormatR12x4UnormPack16 = 1000156017,
    VkFormatR12x4g12x4Unorm2Pack16 = 1000156018,
    VkFormatR12x4g12x4b12x4a12x4Unorm4Pack16 = 1000156019,
    VkFormatG12x4b12x4g12x4r12x4422Unorm4Pack16 = 1000156020,
    VkFormatB12x4g12x4r12x4g12x4422Unorm4Pack16 = 1000156021,
    VkFormatG12x4B12x4R12x43Plane420Unorm3Pack16 = 1000156022,
    VkFormatG12x4B12x4r12x42Plane420Unorm3Pack16 = 1000156023,
    VkFormatG12x4B12x4R12x43Plane422Unorm3Pack16 = 1000156024,
    VkFormatG12x4B12x4r12x42Plane422Unorm3Pack16 = 1000156025,
    VkFormatG12x4B12x4R12x43Plane444Unorm3Pack16 = 1000156026,
    VkFormatG16b16g16r16422Unorm = 1000156027,
    VkFormatB16g16r16g16422Unorm = 1000156028,
    VkFormatG16B16R163Plane420Unorm = 1000156029,
    VkFormatG16B16r162Plane420Unorm = 1000156030,
    VkFormatG16B16R163Plane422Unorm = 1000156031,
    VkFormatG16B16r162Plane422Unorm = 1000156032,
    VkFormatG16B16R163Plane444Unorm = 1000156033,
    VkFormatPvrtc12BppUnormBlockImg = 1000054000,
    VkFormatPvrtc14BppUnormBlockImg = 1000054001,
    VkFormatPvrtc22BppUnormBlockImg = 1000054002,
    VkFormatPvrtc24BppUnormBlockImg = 1000054003,
    VkFormatPvrtc12BppSrgbBlockImg = 1000054004,
    VkFormatPvrtc14BppSrgbBlockImg = 1000054005,
    VkFormatPvrtc22BppSrgbBlockImg = 1000054006,
    VkFormatPvrtc24BppSrgbBlockImg = 1000054007,
    VkFormatG8b8g8r8422UnormKhr = 1000156000,
    VkFormatB8g8r8g8422UnormKhr = 1000156001,
    VkFormatG8B8R83Plane420UnormKhr = 1000156002,
    VkFormatG8B8r82Plane420UnormKhr = 1000156003,
    VkFormatG8B8R83Plane422UnormKhr = 1000156004,
    VkFormatG8B8r82Plane422UnormKhr = 1000156005,
    VkFormatG8B8R83Plane444UnormKhr = 1000156006,
    VkFormatR10x6UnormPack16Khr = 1000156007,
    VkFormatR10x6g10x6Unorm2Pack16Khr = 1000156008,
    VkFormatR10x6g10x6b10x6a10x6Unorm4Pack16Khr = 1000156009,
    VkFormatG10x6b10x6g10x6r10x6422Unorm4Pack16Khr = 1000156010,
    VkFormatB10x6g10x6r10x6g10x6422Unorm4Pack16Khr = 1000156011,
    VkFormatG10x6B10x6R10x63Plane420Unorm3Pack16Khr = 1000156012,
    VkFormatG10x6B10x6r10x62Plane420Unorm3Pack16Khr = 1000156013,
    VkFormatG10x6B10x6R10x63Plane422Unorm3Pack16Khr = 1000156014,
    VkFormatG10x6B10x6r10x62Plane422Unorm3Pack16Khr = 1000156015,
    VkFormatG10x6B10x6R10x63Plane444Unorm3Pack16Khr = 1000156016,
    VkFormatR12x4UnormPack16Khr = 1000156017,
    VkFormatR12x4g12x4Unorm2Pack16Khr = 1000156018,
    VkFormatR12x4g12x4b12x4a12x4Unorm4Pack16Khr = 1000156019,
    VkFormatG12x4b12x4g12x4r12x4422Unorm4Pack16Khr = 1000156020,
    VkFormatB12x4g12x4r12x4g12x4422Unorm4Pack16Khr = 1000156021,
    VkFormatG12x4B12x4R12x43Plane420Unorm3Pack16Khr = 1000156022,
    VkFormatG12x4B12x4r12x42Plane420Unorm3Pack16Khr = 1000156023,
    VkFormatG12x4B12x4R12x43Plane422Unorm3Pack16Khr = 1000156024,
    VkFormatG12x4B12x4r12x42Plane422Unorm3Pack16Khr = 1000156025,
    VkFormatG12x4B12x4R12x43Plane444Unorm3Pack16Khr = 1000156026,
    VkFormatG16b16g16r16422UnormKhr = 1000156027,
    VkFormatB16g16r16g16422UnormKhr = 1000156028,
    VkFormatG16B16R163Plane420UnormKhr = 1000156029,
    VkFormatG16B16r162Plane420UnormKhr = 1000156030,
    VkFormatG16B16R163Plane422UnormKhr = 1000156031,
    VkFormatG16B16r162Plane422UnormKhr = 1000156032,
    VkFormatG16B16R163Plane444UnormKhr = 1000156033,
    VkFormatBeginRange = 0,
    VkFormatEndRange = 184,
    VkFormatRangeSize = 185,
    VkFormatMaxEnum = 2147483647
}

public enum VkImageType
{
    VkImageType1D = 0,
    VkImageType2D = 1,
    VkImageType3D = 2,
    VkImageTypeBeginRange = 0,
    VkImageTypeEndRange = 2,
    VkImageTypeRangeSize = 3,
    VkImageTypeMaxEnum = 2147483647
}

public enum VkImageTiling
{
    VkImageTilingOptimal = 0,
    VkImageTilingLinear = 1,
    VkImageTilingBeginRange = 0,
    VkImageTilingEndRange = 1,
    VkImageTilingRangeSize = 2,
    VkImageTilingMaxEnum = 2147483647
}

public enum VkPhysicalDeviceType
{
    VkPhysicalDeviceTypeOther = 0,
    VkPhysicalDeviceTypeIntegratedGpu = 1,
    VkPhysicalDeviceTypeDiscreteGpu = 2,
    VkPhysicalDeviceTypeVirtualGpu = 3,
    VkPhysicalDeviceTypeCpu = 4,
    VkPhysicalDeviceTypeBeginRange = 0,
    VkPhysicalDeviceTypeEndRange = 4,
    VkPhysicalDeviceTypeRangeSize = 5,
    VkPhysicalDeviceTypeMaxEnum = 2147483647
}

public enum VkQueryType
{
    VkQueryTypeOcclusion = 0,
    VkQueryTypePipelineStatistics = 1,
    VkQueryTypeTimestamp = 2,
    VkQueryTypeBeginRange = 0,
    VkQueryTypeEndRange = 2,
    VkQueryTypeRangeSize = 3,
    VkQueryTypeMaxEnum = 2147483647
}

public enum VkSharingMode
{
    VkSharingModeExclusive = 0,
    VkSharingModeConcurrent = 1,
    VkSharingModeBeginRange = 0,
    VkSharingModeEndRange = 1,
    VkSharingModeRangeSize = 2,
    VkSharingModeMaxEnum = 2147483647
}

public enum VkImageLayout
{
    VkImageLayoutUndefined = 0,
    VkImageLayoutGeneral = 1,
    VkImageLayoutColorAttachmentOptimal = 2,
    VkImageLayoutDepthStencilAttachmentOptimal = 3,
    VkImageLayoutDepthStencilReadOnlyOptimal = 4,
    VkImageLayoutShaderReadOnlyOptimal = 5,
    VkImageLayoutTransferSrcOptimal = 6,
    VkImageLayoutTransferDstOptimal = 7,
    VkImageLayoutPreinitialized = 8,
    VkImageLayoutDepthReadOnlyStencilAttachmentOptimal = 1000117000,
    VkImageLayoutDepthAttachmentStencilReadOnlyOptimal = 1000117001,
    VkImageLayoutPresentSrcKhr = 1000001002,
    VkImageLayoutSharedPresentKhr = 1000111000,
    VkImageLayoutDepthReadOnlyStencilAttachmentOptimalKhr = 1000117000,
    VkImageLayoutDepthAttachmentStencilReadOnlyOptimalKhr = 1000117001,
    VkImageLayoutBeginRange = 0,
    VkImageLayoutEndRange = 8,
    VkImageLayoutRangeSize = 9,
    VkImageLayoutMaxEnum = 2147483647
}

public enum VkImageViewType
{
    VkImageViewType1D = 0,
    VkImageViewType2D = 1,
    VkImageViewType3D = 2,
    VkImageViewTypeCube = 3,
    VkImageViewType1DArray = 4,
    VkImageViewType2DArray = 5,
    VkImageViewTypeCubeArray = 6,
    VkImageViewTypeBeginRange = 0,
    VkImageViewTypeEndRange = 6,
    VkImageViewTypeRangeSize = 7,
    VkImageViewTypeMaxEnum = 2147483647
}

public enum VkComponentSwizzle
{
    VkComponentSwizzleIdentity = 0,
    VkComponentSwizzleZero = 1,
    VkComponentSwizzleOne = 2,
    VkComponentSwizzleR = 3,
    VkComponentSwizzleG = 4,
    VkComponentSwizzleB = 5,
    VkComponentSwizzleA = 6,
    VkComponentSwizzleBeginRange = 0,
    VkComponentSwizzleEndRange = 6,
    VkComponentSwizzleRangeSize = 7,
    VkComponentSwizzleMaxEnum = 2147483647
}

public enum VkVertexInputRate
{
    VkVertexInputRateVertex = 0,
    VkVertexInputRateInstance = 1,
    VkVertexInputRateBeginRange = 0,
    VkVertexInputRateEndRange = 1,
    VkVertexInputRateRangeSize = 2,
    VkVertexInputRateMaxEnum = 2147483647
}

public enum VkPrimitiveTopology
{
    VkPrimitiveTopologyPointList = 0,
    VkPrimitiveTopologyLineList = 1,
    VkPrimitiveTopologyLineStrip = 2,
    VkPrimitiveTopologyTriangleList = 3,
    VkPrimitiveTopologyTriangleStrip = 4,
    VkPrimitiveTopologyTriangleFan = 5,
    VkPrimitiveTopologyLineListWithAdjacency = 6,
    VkPrimitiveTopologyLineStripWithAdjacency = 7,
    VkPrimitiveTopologyTriangleListWithAdjacency = 8,
    VkPrimitiveTopologyTriangleStripWithAdjacency = 9,
    VkPrimitiveTopologyPatchList = 10,
    VkPrimitiveTopologyBeginRange = 0,
    VkPrimitiveTopologyEndRange = 10,
    VkPrimitiveTopologyRangeSize = 11,
    VkPrimitiveTopologyMaxEnum = 2147483647
}

public enum VkPolygonMode
{
    VkPolygonModeFill = 0,
    VkPolygonModeLine = 1,
    VkPolygonModePoint = 2,
    VkPolygonModeFillRectangleNv = 1000153000,
    VkPolygonModeBeginRange = 0,
    VkPolygonModeEndRange = 2,
    VkPolygonModeRangeSize = 3,
    VkPolygonModeMaxEnum = 2147483647
}

public enum VkFrontFace
{
    VkFrontFaceCounterClockwise = 0,
    VkFrontFaceClockwise = 1,
    VkFrontFaceBeginRange = 0,
    VkFrontFaceEndRange = 1,
    VkFrontFaceRangeSize = 2,
    VkFrontFaceMaxEnum = 2147483647
}

public enum VkCompareOp
{
    VkCompareOpNever = 0,
    VkCompareOpLess = 1,
    VkCompareOpEqual = 2,
    VkCompareOpLessOrEqual = 3,
    VkCompareOpGreater = 4,
    VkCompareOpNotEqual = 5,
    VkCompareOpGreaterOrEqual = 6,
    VkCompareOpAlways = 7,
    VkCompareOpBeginRange = 0,
    VkCompareOpEndRange = 7,
    VkCompareOpRangeSize = 8,
    VkCompareOpMaxEnum = 2147483647
}

public enum VkStencilOp
{
    VkStencilOpKeep = 0,
    VkStencilOpZero = 1,
    VkStencilOpReplace = 2,
    VkStencilOpIncrementAndClamp = 3,
    VkStencilOpDecrementAndClamp = 4,
    VkStencilOpInvert = 5,
    VkStencilOpIncrementAndWrap = 6,
    VkStencilOpDecrementAndWrap = 7,
    VkStencilOpBeginRange = 0,
    VkStencilOpEndRange = 7,
    VkStencilOpRangeSize = 8,
    VkStencilOpMaxEnum = 2147483647
}

public enum VkLogicOp
{
    VkLogicOpClear = 0,
    VkLogicOpAnd = 1,
    VkLogicOpAndReverse = 2,
    VkLogicOpCopy = 3,
    VkLogicOpAndInverted = 4,
    VkLogicOpNoOp = 5,
    VkLogicOpXor = 6,
    VkLogicOpOr = 7,
    VkLogicOpNor = 8,
    VkLogicOpEquivalent = 9,
    VkLogicOpInvert = 10,
    VkLogicOpOrReverse = 11,
    VkLogicOpCopyInverted = 12,
    VkLogicOpOrInverted = 13,
    VkLogicOpNand = 14,
    VkLogicOpSet = 15,
    VkLogicOpBeginRange = 0,
    VkLogicOpEndRange = 15,
    VkLogicOpRangeSize = 16,
    VkLogicOpMaxEnum = 2147483647
}

public enum VkBlendFactor
{
    VkBlendFactorZero = 0,
    VkBlendFactorOne = 1,
    VkBlendFactorSrcColor = 2,
    VkBlendFactorOneMinusSrcColor = 3,
    VkBlendFactorDstColor = 4,
    VkBlendFactorOneMinusDstColor = 5,
    VkBlendFactorSrcAlpha = 6,
    VkBlendFactorOneMinusSrcAlpha = 7,
    VkBlendFactorDstAlpha = 8,
    VkBlendFactorOneMinusDstAlpha = 9,
    VkBlendFactorConstantColor = 10,
    VkBlendFactorOneMinusConstantColor = 11,
    VkBlendFactorConstantAlpha = 12,
    VkBlendFactorOneMinusConstantAlpha = 13,
    VkBlendFactorSrcAlphaSaturate = 14,
    VkBlendFactorSrc1Color = 15,
    VkBlendFactorOneMinusSrc1Color = 16,
    VkBlendFactorSrc1Alpha = 17,
    VkBlendFactorOneMinusSrc1Alpha = 18,
    VkBlendFactorBeginRange = 0,
    VkBlendFactorEndRange = 18,
    VkBlendFactorRangeSize = 19,
    VkBlendFactorMaxEnum = 2147483647
}

public enum VkBlendOp
{
    VkBlendOpAdd = 0,
    VkBlendOpSubtract = 1,
    VkBlendOpReverseSubtract = 2,
    VkBlendOpMin = 3,
    VkBlendOpMax = 4,
    VkBlendOpZeroExt = 1000148000,
    VkBlendOpSrcExt = 1000148001,
    VkBlendOpDstExt = 1000148002,
    VkBlendOpSrcOverExt = 1000148003,
    VkBlendOpDstOverExt = 1000148004,
    VkBlendOpSrcInExt = 1000148005,
    VkBlendOpDstInExt = 1000148006,
    VkBlendOpSrcOutExt = 1000148007,
    VkBlendOpDstOutExt = 1000148008,
    VkBlendOpSrcAtopExt = 1000148009,
    VkBlendOpDstAtopExt = 1000148010,
    VkBlendOpXorExt = 1000148011,
    VkBlendOpMultiplyExt = 1000148012,
    VkBlendOpScreenExt = 1000148013,
    VkBlendOpOverlayExt = 1000148014,
    VkBlendOpDarkenExt = 1000148015,
    VkBlendOpLightenExt = 1000148016,
    VkBlendOpColordodgeExt = 1000148017,
    VkBlendOpColorburnExt = 1000148018,
    VkBlendOpHardlightExt = 1000148019,
    VkBlendOpSoftlightExt = 1000148020,
    VkBlendOpDifferenceExt = 1000148021,
    VkBlendOpExclusionExt = 1000148022,
    VkBlendOpInvertExt = 1000148023,
    VkBlendOpInvertRgbExt = 1000148024,
    VkBlendOpLineardodgeExt = 1000148025,
    VkBlendOpLinearburnExt = 1000148026,
    VkBlendOpVividlightExt = 1000148027,
    VkBlendOpLinearlightExt = 1000148028,
    VkBlendOpPinlightExt = 1000148029,
    VkBlendOpHardmixExt = 1000148030,
    VkBlendOpHslHueExt = 1000148031,
    VkBlendOpHslSaturationExt = 1000148032,
    VkBlendOpHslColorExt = 1000148033,
    VkBlendOpHslLuminosityExt = 1000148034,
    VkBlendOpPlusExt = 1000148035,
    VkBlendOpPlusClampedExt = 1000148036,
    VkBlendOpPlusClampedAlphaExt = 1000148037,
    VkBlendOpPlusDarkerExt = 1000148038,
    VkBlendOpMinusExt = 1000148039,
    VkBlendOpMinusClampedExt = 1000148040,
    VkBlendOpContrastExt = 1000148041,
    VkBlendOpInvertOvgExt = 1000148042,
    VkBlendOpRedExt = 1000148043,
    VkBlendOpGreenExt = 1000148044,
    VkBlendOpBlueExt = 1000148045,
    VkBlendOpBeginRange = 0,
    VkBlendOpEndRange = 4,
    VkBlendOpRangeSize = 5,
    VkBlendOpMaxEnum = 2147483647
}

public enum VkDynamicState
{
    VkDynamicStateViewport = 0,
    VkDynamicStateScissor = 1,
    VkDynamicStateLineWidth = 2,
    VkDynamicStateDepthBias = 3,
    VkDynamicStateBlendConstants = 4,
    VkDynamicStateDepthBounds = 5,
    VkDynamicStateStencilCompareMask = 6,
    VkDynamicStateStencilWriteMask = 7,
    VkDynamicStateStencilReference = 8,
    VkDynamicStateViewportWScalingNv = 1000087000,
    VkDynamicStateDiscardRectangleExt = 1000099000,
    VkDynamicStateSampleLocationsExt = 1000143000,
    VkDynamicStateBeginRange = 0,
    VkDynamicStateEndRange = 8,
    VkDynamicStateRangeSize = 9,
    VkDynamicStateMaxEnum = 2147483647
}

public enum VkFilter
{
    VkFilterNearest = 0,
    VkFilterLinear = 1,
    VkFilterCubicImg = 1000015000,
    VkFilterBeginRange = 0,
    VkFilterEndRange = 1,
    VkFilterRangeSize = 2,
    VkFilterMaxEnum = 2147483647
}

public enum VkSamplerMipmapMode
{
    VkSamplerMipmapModeNearest = 0,
    VkSamplerMipmapModeLinear = 1,
    VkSamplerMipmapModeBeginRange = 0,
    VkSamplerMipmapModeEndRange = 1,
    VkSamplerMipmapModeRangeSize = 2,
    VkSamplerMipmapModeMaxEnum = 2147483647
}

public enum VkSamplerAddressMode
{
    VkSamplerAddressModeRepeat = 0,
    VkSamplerAddressModeMirroredRepeat = 1,
    VkSamplerAddressModeClampToEdge = 2,
    VkSamplerAddressModeClampToBorder = 3,
    VkSamplerAddressModeMirrorClampToEdge = 4,
    VkSamplerAddressModeBeginRange = 0,
    VkSamplerAddressModeEndRange = 3,
    VkSamplerAddressModeRangeSize = 4,
    VkSamplerAddressModeMaxEnum = 2147483647
}

public enum VkBorderColor
{
    VkBorderColorFloatTransparentBlack = 0,
    VkBorderColorIntTransparentBlack = 1,
    VkBorderColorFloatOpaqueBlack = 2,
    VkBorderColorIntOpaqueBlack = 3,
    VkBorderColorFloatOpaqueWhite = 4,
    VkBorderColorIntOpaqueWhite = 5,
    VkBorderColorBeginRange = 0,
    VkBorderColorEndRange = 5,
    VkBorderColorRangeSize = 6,
    VkBorderColorMaxEnum = 2147483647
}

public enum VkDescriptorType
{
    VkDescriptorTypeSampler = 0,
    VkDescriptorTypeCombinedImageSampler = 1,
    VkDescriptorTypeSampledImage = 2,
    VkDescriptorTypeStorageImage = 3,
    VkDescriptorTypeUniformTexelBuffer = 4,
    VkDescriptorTypeStorageTexelBuffer = 5,
    VkDescriptorTypeUniformBuffer = 6,
    VkDescriptorTypeStorageBuffer = 7,
    VkDescriptorTypeUniformBufferDynamic = 8,
    VkDescriptorTypeStorageBufferDynamic = 9,
    VkDescriptorTypeInputAttachment = 10,
    VkDescriptorTypeBeginRange = 0,
    VkDescriptorTypeEndRange = 10,
    VkDescriptorTypeRangeSize = 11,
    VkDescriptorTypeMaxEnum = 2147483647
}

public enum VkAttachmentLoadOp
{
    VkAttachmentLoadOpLoad = 0,
    VkAttachmentLoadOpClear = 1,
    VkAttachmentLoadOpDontCare = 2,
    VkAttachmentLoadOpBeginRange = 0,
    VkAttachmentLoadOpEndRange = 2,
    VkAttachmentLoadOpRangeSize = 3,
    VkAttachmentLoadOpMaxEnum = 2147483647
}

public enum VkAttachmentStoreOp
{
    VkAttachmentStoreOpStore = 0,
    VkAttachmentStoreOpDontCare = 1,
    VkAttachmentStoreOpBeginRange = 0,
    VkAttachmentStoreOpEndRange = 1,
    VkAttachmentStoreOpRangeSize = 2,
    VkAttachmentStoreOpMaxEnum = 2147483647
}

public enum VkPipelineBindPoint
{
    VkPipelineBindPointGraphics = 0,
    VkPipelineBindPointCompute = 1,
    VkPipelineBindPointBeginRange = 0,
    VkPipelineBindPointEndRange = 1,
    VkPipelineBindPointRangeSize = 2,
    VkPipelineBindPointMaxEnum = 2147483647
}

public enum VkCommandBufferLevel
{
    VkCommandBufferLevelPrimary = 0,
    VkCommandBufferLevelSecondary = 1,
    VkCommandBufferLevelBeginRange = 0,
    VkCommandBufferLevelEndRange = 1,
    VkCommandBufferLevelRangeSize = 2,
    VkCommandBufferLevelMaxEnum = 2147483647
}

public enum VkIndexType
{
    VkIndexTypeUint16 = 0,
    VkIndexTypeUint32 = 1,
    VkIndexTypeBeginRange = 0,
    VkIndexTypeEndRange = 1,
    VkIndexTypeRangeSize = 2,
    VkIndexTypeMaxEnum = 2147483647
}

public enum VkSubpassContents
{
    VkSubpassContentsInline = 0,
    VkSubpassContentsSecondaryCommandBuffers = 1,
    VkSubpassContentsBeginRange = 0,
    VkSubpassContentsEndRange = 1,
    VkSubpassContentsRangeSize = 2,
    VkSubpassContentsMaxEnum = 2147483647
}

public enum VkObjectType
{
    VkObjectTypeUnknown = 0,
    VkObjectTypeInstance = 1,
    VkObjectTypePhysicalDevice = 2,
    VkObjectTypeDevice = 3,
    VkObjectTypeQueue = 4,
    VkObjectTypeSemaphore = 5,
    VkObjectTypeCommandBuffer = 6,
    VkObjectTypeFence = 7,
    VkObjectTypeDeviceMemory = 8,
    VkObjectTypeBuffer = 9,
    VkObjectTypeImage = 10,
    VkObjectTypeEvent = 11,
    VkObjectTypeQueryPool = 12,
    VkObjectTypeBufferView = 13,
    VkObjectTypeImageView = 14,
    VkObjectTypeShaderModule = 15,
    VkObjectTypePipelineCache = 16,
    VkObjectTypePipelineLayout = 17,
    VkObjectTypeRenderPass = 18,
    VkObjectTypePipeline = 19,
    VkObjectTypeDescriptorSetLayout = 20,
    VkObjectTypeSampler = 21,
    VkObjectTypeDescriptorPool = 22,
    VkObjectTypeDescriptorSet = 23,
    VkObjectTypeFramebuffer = 24,
    VkObjectTypeCommandPool = 25,
    VkObjectTypeSamplerYcbcrConversion = 1000156000,
    VkObjectTypeDescriptorUpdateTemplate = 1000085000,
    VkObjectTypeSurfaceKhr = 1000000000,
    VkObjectTypeSwapchainKhr = 1000001000,
    VkObjectTypeDisplayKhr = 1000002000,
    VkObjectTypeDisplayModeKhr = 1000002001,
    VkObjectTypeDebugReportCallbackExt = 1000011000,
    VkObjectTypeObjectTableNvx = 1000086000,
    VkObjectTypeIndirectCommandsLayoutNvx = 1000086001,
    VkObjectTypeDebugUtilsMessengerExt = 1000128000,
    VkObjectTypeValidationCacheExt = 1000160000,
    VkObjectTypeDescriptorUpdateTemplateKhr = 1000085000,
    VkObjectTypeSamplerYcbcrConversionKhr = 1000156000,
    VkObjectTypeBeginRange = 0,
    VkObjectTypeEndRange = 25,
    VkObjectTypeRangeSize = 26,
    VkObjectTypeMaxEnum = 2147483647
}

public enum VkVendorId
{
    VkVendorIdViv = 65537,
    VkVendorIdVsi = 65538,
    VkVendorIdKazan = 65539,
    VkVendorIdBeginRange = 65537,
    VkVendorIdEndRange = 65539,
    VkVendorIdRangeSize = 3,
    VkVendorIdMaxEnum = 2147483647
}

public enum VkFormatFeatureFlagBits
{
    VkFormatFeatureSampledImageBit = 1,
    VkFormatFeatureStorageImageBit = 2,
    VkFormatFeatureStorageImageAtomicBit = 4,
    VkFormatFeatureUniformTexelBufferBit = 8,
    VkFormatFeatureStorageTexelBufferBit = 16,
    VkFormatFeatureStorageTexelBufferAtomicBit = 32,
    VkFormatFeatureVertexBufferBit = 64,
    VkFormatFeatureColorAttachmentBit = 128,
    VkFormatFeatureColorAttachmentBlendBit = 256,
    VkFormatFeatureDepthStencilAttachmentBit = 512,
    VkFormatFeatureBlitSrcBit = 1024,
    VkFormatFeatureBlitDstBit = 2048,
    VkFormatFeatureSampledImageFilterLinearBit = 4096,
    VkFormatFeatureTransferSrcBit = 16384,
    VkFormatFeatureTransferDstBit = 32768,
    VkFormatFeatureMidpointChromaSamplesBit = 131072,
    VkFormatFeatureSampledImageYcbcrConversionLinearFilterBit = 262144,
    VkFormatFeatureSampledImageYcbcrConversionSeparateReconstructionFilterBit = 524288,
    VkFormatFeatureSampledImageYcbcrConversionChromaReconstructionExplicitBit = 1048576,
    VkFormatFeatureSampledImageYcbcrConversionChromaReconstructionExplicitForceableBit = 2097152,
    VkFormatFeatureDisjointBit = 4194304,
    VkFormatFeatureCositedChromaSamplesBit = 8388608,
    VkFormatFeatureSampledImageFilterCubicBitImg = 8192,
    VkFormatFeatureSampledImageFilterMinmaxBitExt = 65536,
    VkFormatFeatureTransferSrcBitKhr = 16384,
    VkFormatFeatureTransferDstBitKhr = 32768,
    VkFormatFeatureMidpointChromaSamplesBitKhr = 131072,
    VkFormatFeatureSampledImageYcbcrConversionLinearFilterBitKhr = 262144,
    VkFormatFeatureSampledImageYcbcrConversionSeparateReconstructionFilterBitKhr = 524288,
    VkFormatFeatureSampledImageYcbcrConversionChromaReconstructionExplicitBitKhr = 1048576,
    VkFormatFeatureSampledImageYcbcrConversionChromaReconstructionExplicitForceableBitKhr = 2097152,
    VkFormatFeatureDisjointBitKhr = 4194304,
    VkFormatFeatureCositedChromaSamplesBitKhr = 8388608,
    VkFormatFeatureFlagBitsMaxEnum = 2147483647
}

public enum VkImageUsageFlagBits
{
    VkImageUsageTransferSrcBit = 1,
    VkImageUsageTransferDstBit = 2,
    VkImageUsageSampledBit = 4,
    VkImageUsageStorageBit = 8,
    VkImageUsageColorAttachmentBit = 16,
    VkImageUsageDepthStencilAttachmentBit = 32,
    VkImageUsageTransientAttachmentBit = 64,
    VkImageUsageInputAttachmentBit = 128,
    VkImageUsageFlagBitsMaxEnum = 2147483647
}

public enum VkImageCreateFlagBits
{
    VkImageCreateSparseBindingBit = 1,
    VkImageCreateSparseResidencyBit = 2,
    VkImageCreateSparseAliasedBit = 4,
    VkImageCreateMutableFormatBit = 8,
    VkImageCreateCubeCompatibleBit = 16,
    VkImageCreateAliasBit = 1024,
    VkImageCreateSplitInstanceBindRegionsBit = 64,
    VkImageCreate2DArrayCompatibleBit = 32,
    VkImageCreateBlockTexelViewCompatibleBit = 128,
    VkImageCreateExtendedUsageBit = 256,
    VkImageCreateProtectedBit = 2048,
    VkImageCreateDisjointBit = 512,
    VkImageCreateSampleLocationsCompatibleDepthBitExt = 4096,
    VkImageCreateSplitInstanceBindRegionsBitKhr = 64,
    VkImageCreate2DArrayCompatibleBitKhr = 32,
    VkImageCreateBlockTexelViewCompatibleBitKhr = 128,
    VkImageCreateExtendedUsageBitKhr = 256,
    VkImageCreateDisjointBitKhr = 512,
    VkImageCreateAliasBitKhr = 1024,
    VkImageCreateFlagBitsMaxEnum = 2147483647
}

public enum VkSampleCountFlagBits
{
    VkSampleCount1Bit = 1,
    VkSampleCount2Bit = 2,
    VkSampleCount4Bit = 4,
    VkSampleCount8Bit = 8,
    VkSampleCount16Bit = 16,
    VkSampleCount32Bit = 32,
    VkSampleCount64Bit = 64,
    VkSampleCountFlagBitsMaxEnum = 2147483647
}

public enum VkQueueFlagBits
{
    VkQueueGraphicsBit = 1,
    VkQueueComputeBit = 2,
    VkQueueTransferBit = 4,
    VkQueueSparseBindingBit = 8,
    VkQueueProtectedBit = 16,
    VkQueueFlagBitsMaxEnum = 2147483647
}

public enum VkMemoryPropertyFlagBits
{
    VkMemoryPropertyDeviceLocalBit = 1,
    VkMemoryPropertyHostVisibleBit = 2,
    VkMemoryPropertyHostCoherentBit = 4,
    VkMemoryPropertyHostCachedBit = 8,
    VkMemoryPropertyLazilyAllocatedBit = 16,
    VkMemoryPropertyProtectedBit = 32,
    VkMemoryPropertyFlagBitsMaxEnum = 2147483647
}

public enum VkMemoryHeapFlagBits
{
    VkMemoryHeapDeviceLocalBit = 1,
    VkMemoryHeapMultiInstanceBit = 2,
    VkMemoryHeapMultiInstanceBitKhr = 2,
    VkMemoryHeapFlagBitsMaxEnum = 2147483647
}

public enum VkDeviceQueueCreateFlagBits
{
    VkDeviceQueueCreateProtectedBit = 1,
    VkDeviceQueueCreateFlagBitsMaxEnum = 2147483647
}

public enum VkPipelineStageFlagBits
{
    VkPipelineStageTopOfPipeBit = 1,
    VkPipelineStageDrawIndirectBit = 2,
    VkPipelineStageVertexInputBit = 4,
    VkPipelineStageVertexShaderBit = 8,
    VkPipelineStageTessellationControlShaderBit = 16,
    VkPipelineStageTessellationEvaluationShaderBit = 32,
    VkPipelineStageGeometryShaderBit = 64,
    VkPipelineStageFragmentShaderBit = 128,
    VkPipelineStageEarlyFragmentTestsBit = 256,
    VkPipelineStageLateFragmentTestsBit = 512,
    VkPipelineStageColorAttachmentOutputBit = 1024,
    VkPipelineStageComputeShaderBit = 2048,
    VkPipelineStageTransferBit = 4096,
    VkPipelineStageBottomOfPipeBit = 8192,
    VkPipelineStageHostBit = 16384,
    VkPipelineStageAllGraphicsBit = 32768,
    VkPipelineStageAllCommandsBit = 65536,
    VkPipelineStageConditionalRenderingBitExt = 262144,
    VkPipelineStageCommandProcessBitNvx = 131072,
    VkPipelineStageFlagBitsMaxEnum = 2147483647
}

public enum VkImageAspectFlagBits
{
    VkImageAspectColorBit = 1,
    VkImageAspectDepthBit = 2,
    VkImageAspectStencilBit = 4,
    VkImageAspectMetadataBit = 8,
    VkImageAspectPlane0Bit = 16,
    VkImageAspectPlane1Bit = 32,
    VkImageAspectPlane2Bit = 64,
    VkImageAspectPlane0BitKhr = 16,
    VkImageAspectPlane1BitKhr = 32,
    VkImageAspectPlane2BitKhr = 64,
    VkImageAspectFlagBitsMaxEnum = 2147483647
}

public enum VkSparseImageFormatFlagBits
{
    VkSparseImageFormatSingleMiptailBit = 1,
    VkSparseImageFormatAlignedMipSizeBit = 2,
    VkSparseImageFormatNonstandardBlockSizeBit = 4,
    VkSparseImageFormatFlagBitsMaxEnum = 2147483647
}

public enum VkSparseMemoryBindFlagBits
{
    VkSparseMemoryBindMetadataBit = 1,
    VkSparseMemoryBindFlagBitsMaxEnum = 2147483647
}

public enum VkFenceCreateFlagBits
{
    VkFenceCreateSignaledBit = 1,
    VkFenceCreateFlagBitsMaxEnum = 2147483647
}

public enum VkQueryPipelineStatisticFlagBits
{
    VkQueryPipelineStatisticInputAssemblyVerticesBit = 1,
    VkQueryPipelineStatisticInputAssemblyPrimitivesBit = 2,
    VkQueryPipelineStatisticVertexShaderInvocationsBit = 4,
    VkQueryPipelineStatisticGeometryShaderInvocationsBit = 8,
    VkQueryPipelineStatisticGeometryShaderPrimitivesBit = 16,
    VkQueryPipelineStatisticClippingInvocationsBit = 32,
    VkQueryPipelineStatisticClippingPrimitivesBit = 64,
    VkQueryPipelineStatisticFragmentShaderInvocationsBit = 128,
    VkQueryPipelineStatisticTessellationControlShaderPatchesBit = 256,
    VkQueryPipelineStatisticTessellationEvaluationShaderInvocationsBit = 512,
    VkQueryPipelineStatisticComputeShaderInvocationsBit = 1024,
    VkQueryPipelineStatisticFlagBitsMaxEnum = 2147483647
}

public enum VkQueryResultFlagBits
{
    VkQueryResult64Bit = 1,
    VkQueryResultWaitBit = 2,
    VkQueryResultWithAvailabilityBit = 4,
    VkQueryResultPartialBit = 8,
    VkQueryResultFlagBitsMaxEnum = 2147483647
}

public enum VkBufferCreateFlagBits
{
    VkBufferCreateSparseBindingBit = 1,
    VkBufferCreateSparseResidencyBit = 2,
    VkBufferCreateSparseAliasedBit = 4,
    VkBufferCreateProtectedBit = 8,
    VkBufferCreateFlagBitsMaxEnum = 2147483647
}

public enum VkBufferUsageFlagBits
{
    VkBufferUsageTransferSrcBit = 1,
    VkBufferUsageTransferDstBit = 2,
    VkBufferUsageUniformTexelBufferBit = 4,
    VkBufferUsageStorageTexelBufferBit = 8,
    VkBufferUsageUniformBufferBit = 16,
    VkBufferUsageStorageBufferBit = 32,
    VkBufferUsageIndexBufferBit = 64,
    VkBufferUsageVertexBufferBit = 128,
    VkBufferUsageIndirectBufferBit = 256,
    VkBufferUsageConditionalRenderingBitExt = 512,
    VkBufferUsageFlagBitsMaxEnum = 2147483647
}

public enum VkPipelineCreateFlagBits
{
    VkPipelineCreateDisableOptimizationBit = 1,
    VkPipelineCreateAllowDerivativesBit = 2,
    VkPipelineCreateDerivativeBit = 4,
    VkPipelineCreateViewIndexFromDeviceIndexBit = 8,
    VkPipelineCreateDispatchBase = 16,
    VkPipelineCreateViewIndexFromDeviceIndexBitKhr = 8,
    VkPipelineCreateDispatchBaseKhr = 16,
    VkPipelineCreateFlagBitsMaxEnum = 2147483647
}

public enum VkShaderStageFlagBits
{
    VkShaderStageVertexBit = 1,
    VkShaderStageTessellationControlBit = 2,
    VkShaderStageTessellationEvaluationBit = 4,
    VkShaderStageGeometryBit = 8,
    VkShaderStageFragmentBit = 16,
    VkShaderStageComputeBit = 32,
    VkShaderStageAllGraphics = 31,
    VkShaderStageAll = 2147483647,
    VkShaderStageFlagBitsMaxEnum = 2147483647
}

public enum VkCullModeFlagBits
{
    VkCullModeNone = 0,
    VkCullModeFrontBit = 1,
    VkCullModeBackBit = 2,
    VkCullModeFrontAndBack = 3,
    VkCullModeFlagBitsMaxEnum = 2147483647
}

public enum VkColorComponentFlagBits
{
    VkColorComponentRBit = 1,
    VkColorComponentGBit = 2,
    VkColorComponentBBit = 4,
    VkColorComponentABit = 8,
    VkColorComponentFlagBitsMaxEnum = 2147483647
}

public enum VkDescriptorSetLayoutCreateFlagBits
{
    VkDescriptorSetLayoutCreatePushDescriptorBitKhr = 1,
    VkDescriptorSetLayoutCreateUpdateAfterBindPoolBitExt = 2,
    VkDescriptorSetLayoutCreateFlagBitsMaxEnum = 2147483647
}

public enum VkDescriptorPoolCreateFlagBits
{
    VkDescriptorPoolCreateFreeDescriptorSetBit = 1,
    VkDescriptorPoolCreateUpdateAfterBindBitExt = 2,
    VkDescriptorPoolCreateFlagBitsMaxEnum = 2147483647
}

public enum VkAttachmentDescriptionFlagBits
{
    VkAttachmentDescriptionMayAliasBit = 1,
    VkAttachmentDescriptionFlagBitsMaxEnum = 2147483647
}

public enum VkSubpassDescriptionFlagBits
{
    VkSubpassDescriptionPerViewAttributesBitNvx = 1,
    VkSubpassDescriptionPerViewPositionXOnlyBitNvx = 2,
    VkSubpassDescriptionFlagBitsMaxEnum = 2147483647
}

public enum VkAccessFlagBits
{
    VkAccessIndirectCommandReadBit = 1,
    VkAccessIndexReadBit = 2,
    VkAccessVertexAttributeReadBit = 4,
    VkAccessUniformReadBit = 8,
    VkAccessInputAttachmentReadBit = 16,
    VkAccessShaderReadBit = 32,
    VkAccessShaderWriteBit = 64,
    VkAccessColorAttachmentReadBit = 128,
    VkAccessColorAttachmentWriteBit = 256,
    VkAccessDepthStencilAttachmentReadBit = 512,
    VkAccessDepthStencilAttachmentWriteBit = 1024,
    VkAccessTransferReadBit = 2048,
    VkAccessTransferWriteBit = 4096,
    VkAccessHostReadBit = 8192,
    VkAccessHostWriteBit = 16384,
    VkAccessMemoryReadBit = 32768,
    VkAccessMemoryWriteBit = 65536,
    VkAccessConditionalRenderingReadBitExt = 1048576,
    VkAccessCommandProcessReadBitNvx = 131072,
    VkAccessCommandProcessWriteBitNvx = 262144,
    VkAccessColorAttachmentReadNoncoherentBitExt = 524288,
    VkAccessFlagBitsMaxEnum = 2147483647
}

public enum VkDependencyFlagBits
{
    VkDependencyByRegionBit = 1,
    VkDependencyDeviceGroupBit = 4,
    VkDependencyViewLocalBit = 2,
    VkDependencyViewLocalBitKhr = 2,
    VkDependencyDeviceGroupBitKhr = 4,
    VkDependencyFlagBitsMaxEnum = 2147483647
}

public enum VkCommandPoolCreateFlagBits
{
    VkCommandPoolCreateTransientBit = 1,
    VkCommandPoolCreateResetCommandBufferBit = 2,
    VkCommandPoolCreateProtectedBit = 4,
    VkCommandPoolCreateFlagBitsMaxEnum = 2147483647
}

public enum VkCommandPoolResetFlagBits
{
    VkCommandPoolResetReleaseResourcesBit = 1,
    VkCommandPoolResetFlagBitsMaxEnum = 2147483647
}

public enum VkCommandBufferUsageFlagBits
{
    VkCommandBufferUsageOneTimeSubmitBit = 1,
    VkCommandBufferUsageRenderPassContinueBit = 2,
    VkCommandBufferUsageSimultaneousUseBit = 4,
    VkCommandBufferUsageFlagBitsMaxEnum = 2147483647
}

public enum VkQueryControlFlagBits
{
    VkQueryControlPreciseBit = 1,
    VkQueryControlFlagBitsMaxEnum = 2147483647
}

public enum VkCommandBufferResetFlagBits
{
    VkCommandBufferResetReleaseResourcesBit = 1,
    VkCommandBufferResetFlagBitsMaxEnum = 2147483647
}

public enum VkStencilFaceFlagBits
{
    VkStencilFaceFrontBit = 1,
    VkStencilFaceBackBit = 2,
    VkStencilFrontAndBack = 3,
    VkStencilFaceFlagBitsMaxEnum = 2147483647
}

public enum VkPointClippingBehavior
{
    VkPointClippingBehaviorAllClipPlanes = 0,
    VkPointClippingBehaviorUserClipPlanesOnly = 1,
    VkPointClippingBehaviorAllClipPlanesKhr = 0,
    VkPointClippingBehaviorUserClipPlanesOnlyKhr = 1,
    VkPointClippingBehaviorBeginRange = 0,
    VkPointClippingBehaviorEndRange = 1,
    VkPointClippingBehaviorRangeSize = 2,
    VkPointClippingBehaviorMaxEnum = 2147483647
}

public enum VkTessellationDomainOrigin
{
    VkTessellationDomainOriginUpperLeft = 0,
    VkTessellationDomainOriginLowerLeft = 1,
    VkTessellationDomainOriginUpperLeftKhr = 0,
    VkTessellationDomainOriginLowerLeftKhr = 1,
    VkTessellationDomainOriginBeginRange = 0,
    VkTessellationDomainOriginEndRange = 1,
    VkTessellationDomainOriginRangeSize = 2,
    VkTessellationDomainOriginMaxEnum = 2147483647
}

public enum VkSamplerYcbcrModelConversion
{
    VkSamplerYcbcrModelConversionRgbIdentity = 0,
    VkSamplerYcbcrModelConversionYcbcrIdentity = 1,
    VkSamplerYcbcrModelConversionYcbcr709 = 2,
    VkSamplerYcbcrModelConversionYcbcr601 = 3,
    VkSamplerYcbcrModelConversionYcbcr2020 = 4,
    VkSamplerYcbcrModelConversionRgbIdentityKhr = 0,
    VkSamplerYcbcrModelConversionYcbcrIdentityKhr = 1,
    VkSamplerYcbcrModelConversionYcbcr709Khr = 2,
    VkSamplerYcbcrModelConversionYcbcr601Khr = 3,
    VkSamplerYcbcrModelConversionYcbcr2020Khr = 4,
    VkSamplerYcbcrModelConversionBeginRange = 0,
    VkSamplerYcbcrModelConversionEndRange = 4,
    VkSamplerYcbcrModelConversionRangeSize = 5,
    VkSamplerYcbcrModelConversionMaxEnum = 2147483647
}

public enum VkSamplerYcbcrRange
{
    VkSamplerYcbcrRangeItuFull = 0,
    VkSamplerYcbcrRangeItuNarrow = 1,
    VkSamplerYcbcrRangeItuFullKhr = 0,
    VkSamplerYcbcrRangeItuNarrowKhr = 1,
    VkSamplerYcbcrRangeBeginRange = 0,
    VkSamplerYcbcrRangeEndRange = 1,
    VkSamplerYcbcrRangeRangeSize = 2,
    VkSamplerYcbcrRangeMaxEnum = 2147483647
}

public enum VkChromaLocation
{
    VkChromaLocationCositedEven = 0,
    VkChromaLocationMidpoint = 1,
    VkChromaLocationCositedEvenKhr = 0,
    VkChromaLocationMidpointKhr = 1,
    VkChromaLocationBeginRange = 0,
    VkChromaLocationEndRange = 1,
    VkChromaLocationRangeSize = 2,
    VkChromaLocationMaxEnum = 2147483647
}

public enum VkDescriptorUpdateTemplateType
{
    VkDescriptorUpdateTemplateTypeDescriptorSet = 0,
    VkDescriptorUpdateTemplateTypePushDescriptorsKhr = 1,
    VkDescriptorUpdateTemplateTypeDescriptorSetKhr = 0,
    VkDescriptorUpdateTemplateTypeBeginRange = 0,
    VkDescriptorUpdateTemplateTypeEndRange = 0,
    VkDescriptorUpdateTemplateTypeRangeSize = 1,
    VkDescriptorUpdateTemplateTypeMaxEnum = 2147483647
}

public enum VkSubgroupFeatureFlagBits
{
    VkSubgroupFeatureBasicBit = 1,
    VkSubgroupFeatureVoteBit = 2,
    VkSubgroupFeatureArithmeticBit = 4,
    VkSubgroupFeatureBallotBit = 8,
    VkSubgroupFeatureShuffleBit = 16,
    VkSubgroupFeatureShuffleRelativeBit = 32,
    VkSubgroupFeatureClusteredBit = 64,
    VkSubgroupFeatureQuadBit = 128,
    VkSubgroupFeaturePartitionedBitNv = 256,
    VkSubgroupFeatureFlagBitsMaxEnum = 2147483647
}

public enum VkPeerMemoryFeatureFlagBits
{
    VkPeerMemoryFeatureCopySrcBit = 1,
    VkPeerMemoryFeatureCopyDstBit = 2,
    VkPeerMemoryFeatureGenericSrcBit = 4,
    VkPeerMemoryFeatureGenericDstBit = 8,
    VkPeerMemoryFeatureCopySrcBitKhr = 1,
    VkPeerMemoryFeatureCopyDstBitKhr = 2,
    VkPeerMemoryFeatureGenericSrcBitKhr = 4,
    VkPeerMemoryFeatureGenericDstBitKhr = 8,
    VkPeerMemoryFeatureFlagBitsMaxEnum = 2147483647
}

public enum VkMemoryAllocateFlagBits
{
    VkMemoryAllocateDeviceMaskBit = 1,
    VkMemoryAllocateDeviceMaskBitKhr = 1,
    VkMemoryAllocateFlagBitsMaxEnum = 2147483647
}

public enum VkExternalMemoryHandleTypeFlagBits
{
    VkExternalMemoryHandleTypeOpaqueFdBit = 1,
    VkExternalMemoryHandleTypeOpaqueWin32Bit = 2,
    VkExternalMemoryHandleTypeOpaqueWin32KmtBit = 4,
    VkExternalMemoryHandleTypeD3d11TextureBit = 8,
    VkExternalMemoryHandleTypeD3d11TextureKmtBit = 16,
    VkExternalMemoryHandleTypeD3d12HeapBit = 32,
    VkExternalMemoryHandleTypeD3d12ResourceBit = 64,
    VkExternalMemoryHandleTypeDmaBufBitExt = 512,
    VkExternalMemoryHandleTypeAndroidHardwareBufferBitAndroid = 1024,
    VkExternalMemoryHandleTypeHostAllocationBitExt = 128,
    VkExternalMemoryHandleTypeHostMappedForeignMemoryBitExt = 256,
    VkExternalMemoryHandleTypeOpaqueFdBitKhr = 1,
    VkExternalMemoryHandleTypeOpaqueWin32BitKhr = 2,
    VkExternalMemoryHandleTypeOpaqueWin32KmtBitKhr = 4,
    VkExternalMemoryHandleTypeD3d11TextureBitKhr = 8,
    VkExternalMemoryHandleTypeD3d11TextureKmtBitKhr = 16,
    VkExternalMemoryHandleTypeD3d12HeapBitKhr = 32,
    VkExternalMemoryHandleTypeD3d12ResourceBitKhr = 64,
    VkExternalMemoryHandleTypeFlagBitsMaxEnum = 2147483647
}

public enum VkExternalMemoryFeatureFlagBits
{
    VkExternalMemoryFeatureDedicatedOnlyBit = 1,
    VkExternalMemoryFeatureExportableBit = 2,
    VkExternalMemoryFeatureImportableBit = 4,
    VkExternalMemoryFeatureDedicatedOnlyBitKhr = 1,
    VkExternalMemoryFeatureExportableBitKhr = 2,
    VkExternalMemoryFeatureImportableBitKhr = 4,
    VkExternalMemoryFeatureFlagBitsMaxEnum = 2147483647
}

public enum VkExternalFenceHandleTypeFlagBits
{
    VkExternalFenceHandleTypeOpaqueFdBit = 1,
    VkExternalFenceHandleTypeOpaqueWin32Bit = 2,
    VkExternalFenceHandleTypeOpaqueWin32KmtBit = 4,
    VkExternalFenceHandleTypeSyncFdBit = 8,
    VkExternalFenceHandleTypeOpaqueFdBitKhr = 1,
    VkExternalFenceHandleTypeOpaqueWin32BitKhr = 2,
    VkExternalFenceHandleTypeOpaqueWin32KmtBitKhr = 4,
    VkExternalFenceHandleTypeSyncFdBitKhr = 8,
    VkExternalFenceHandleTypeFlagBitsMaxEnum = 2147483647
}

public enum VkExternalFenceFeatureFlagBits
{
    VkExternalFenceFeatureExportableBit = 1,
    VkExternalFenceFeatureImportableBit = 2,
    VkExternalFenceFeatureExportableBitKhr = 1,
    VkExternalFenceFeatureImportableBitKhr = 2,
    VkExternalFenceFeatureFlagBitsMaxEnum = 2147483647
}

public enum VkFenceImportFlagBits
{
    VkFenceImportTemporaryBit = 1,
    VkFenceImportTemporaryBitKhr = 1,
    VkFenceImportFlagBitsMaxEnum = 2147483647
}

public enum VkSemaphoreImportFlagBits
{
    VkSemaphoreImportTemporaryBit = 1,
    VkSemaphoreImportTemporaryBitKhr = 1,
    VkSemaphoreImportFlagBitsMaxEnum = 2147483647
}

public enum VkExternalSemaphoreHandleTypeFlagBits
{
    VkExternalSemaphoreHandleTypeOpaqueFdBit = 1,
    VkExternalSemaphoreHandleTypeOpaqueWin32Bit = 2,
    VkExternalSemaphoreHandleTypeOpaqueWin32KmtBit = 4,
    VkExternalSemaphoreHandleTypeD3d12FenceBit = 8,
    VkExternalSemaphoreHandleTypeSyncFdBit = 16,
    VkExternalSemaphoreHandleTypeOpaqueFdBitKhr = 1,
    VkExternalSemaphoreHandleTypeOpaqueWin32BitKhr = 2,
    VkExternalSemaphoreHandleTypeOpaqueWin32KmtBitKhr = 4,
    VkExternalSemaphoreHandleTypeD3d12FenceBitKhr = 8,
    VkExternalSemaphoreHandleTypeSyncFdBitKhr = 16,
    VkExternalSemaphoreHandleTypeFlagBitsMaxEnum = 2147483647
}

public enum VkExternalSemaphoreFeatureFlagBits
{
    VkExternalSemaphoreFeatureExportableBit = 1,
    VkExternalSemaphoreFeatureImportableBit = 2,
    VkExternalSemaphoreFeatureExportableBitKhr = 1,
    VkExternalSemaphoreFeatureImportableBitKhr = 2,
    VkExternalSemaphoreFeatureFlagBitsMaxEnum = 2147483647
}

public enum VkColorSpaceKHR
{
    VkColorSpaceSrgbNonlinearKhr = 0,
    VkColorSpaceDisplayP3NonlinearExt = 1000104001,
    VkColorSpaceExtendedSrgbLinearExt = 1000104002,
    VkColorSpaceDciP3LinearExt = 1000104003,
    VkColorSpaceDciP3NonlinearExt = 1000104004,
    VkColorSpaceBt709LinearExt = 1000104005,
    VkColorSpaceBt709NonlinearExt = 1000104006,
    VkColorSpaceBt2020LinearExt = 1000104007,
    VkColorSpaceHdr10St2084Ext = 1000104008,
    VkColorSpaceDolbyvisionExt = 1000104009,
    VkColorSpaceHdr10HlgExt = 1000104010,
    VkColorSpaceAdobergbLinearExt = 1000104011,
    VkColorSpaceAdobergbNonlinearExt = 1000104012,
    VkColorSpacePassThroughExt = 1000104013,
    VkColorSpaceExtendedSrgbNonlinearExt = 1000104014,
    VkColorSpaceBeginRangeKhr = 0,
    VkColorSpaceEndRangeKhr = 0,
    VkColorSpaceRangeSizeKhr = 1,
    VkColorSpaceMaxEnumKhr = 2147483647
}

public enum VkPresentModeKHR
{
    VkPresentModeImmediateKhr = 0,
    VkPresentModeMailboxKhr = 1,
    VkPresentModeFifoKhr = 2,
    VkPresentModeFifoRelaxedKhr = 3,
    VkPresentModeSharedDemandRefreshKhr = 1000111000,
    VkPresentModeSharedContinuousRefreshKhr = 1000111001,
    VkPresentModeBeginRangeKhr = 0,
    VkPresentModeEndRangeKhr = 3,
    VkPresentModeRangeSizeKhr = 4,
    VkPresentModeMaxEnumKhr = 2147483647
}

public enum VkSurfaceTransformFlagBitsKHR
{
    VkSurfaceTransformIdentityBitKhr = 1,
    VkSurfaceTransformRotate90BitKhr = 2,
    VkSurfaceTransformRotate180BitKhr = 4,
    VkSurfaceTransformRotate270BitKhr = 8,
    VkSurfaceTransformHorizontalMirrorBitKhr = 16,
    VkSurfaceTransformHorizontalMirrorRotate90BitKhr = 32,
    VkSurfaceTransformHorizontalMirrorRotate180BitKhr = 64,
    VkSurfaceTransformHorizontalMirrorRotate270BitKhr = 128,
    VkSurfaceTransformInheritBitKhr = 256,
    VkSurfaceTransformFlagBitsMaxEnumKhr = 2147483647
}

public enum VkCompositeAlphaFlagBitsKHR
{
    VkCompositeAlphaOpaqueBitKhr = 1,
    VkCompositeAlphaPreMultipliedBitKhr = 2,
    VkCompositeAlphaPostMultipliedBitKhr = 4,
    VkCompositeAlphaInheritBitKhr = 8,
    VkCompositeAlphaFlagBitsMaxEnumKhr = 2147483647
}

public enum VkSwapchainCreateFlagBitsKHR
{
    VkSwapchainCreateSplitInstanceBindRegionsBitKhr = 1,
    VkSwapchainCreateProtectedBitKhr = 2,
    VkSwapchainCreateFlagBitsMaxEnumKhr = 2147483647
}

public enum VkDeviceGroupPresentModeFlagBitsKHR
{
    VkDeviceGroupPresentModeLocalBitKhr = 1,
    VkDeviceGroupPresentModeRemoteBitKhr = 2,
    VkDeviceGroupPresentModeSumBitKhr = 4,
    VkDeviceGroupPresentModeLocalMultiDeviceBitKhr = 8,
    VkDeviceGroupPresentModeFlagBitsMaxEnumKhr = 2147483647
}

public enum VkDisplayPlaneAlphaFlagBitsKHR
{
    VkDisplayPlaneAlphaOpaqueBitKhr = 1,
    VkDisplayPlaneAlphaGlobalBitKhr = 2,
    VkDisplayPlaneAlphaPerPixelBitKhr = 4,
    VkDisplayPlaneAlphaPerPixelPremultipliedBitKhr = 8,
    VkDisplayPlaneAlphaFlagBitsMaxEnumKhr = 2147483647
}

public enum VkDebugReportObjectTypeEXT
{
    VkDebugReportObjectTypeUnknownExt = 0,
    VkDebugReportObjectTypeInstanceExt = 1,
    VkDebugReportObjectTypePhysicalDeviceExt = 2,
    VkDebugReportObjectTypeDeviceExt = 3,
    VkDebugReportObjectTypeQueueExt = 4,
    VkDebugReportObjectTypeSemaphoreExt = 5,
    VkDebugReportObjectTypeCommandBufferExt = 6,
    VkDebugReportObjectTypeFenceExt = 7,
    VkDebugReportObjectTypeDeviceMemoryExt = 8,
    VkDebugReportObjectTypeBufferExt = 9,
    VkDebugReportObjectTypeImageExt = 10,
    VkDebugReportObjectTypeEventExt = 11,
    VkDebugReportObjectTypeQueryPoolExt = 12,
    VkDebugReportObjectTypeBufferViewExt = 13,
    VkDebugReportObjectTypeImageViewExt = 14,
    VkDebugReportObjectTypeShaderModuleExt = 15,
    VkDebugReportObjectTypePipelineCacheExt = 16,
    VkDebugReportObjectTypePipelineLayoutExt = 17,
    VkDebugReportObjectTypeRenderPassExt = 18,
    VkDebugReportObjectTypePipelineExt = 19,
    VkDebugReportObjectTypeDescriptorSetLayoutExt = 20,
    VkDebugReportObjectTypeSamplerExt = 21,
    VkDebugReportObjectTypeDescriptorPoolExt = 22,
    VkDebugReportObjectTypeDescriptorSetExt = 23,
    VkDebugReportObjectTypeFramebufferExt = 24,
    VkDebugReportObjectTypeCommandPoolExt = 25,
    VkDebugReportObjectTypeSurfaceKhrExt = 26,
    VkDebugReportObjectTypeSwapchainKhrExt = 27,
    VkDebugReportObjectTypeDebugReportCallbackExtExt = 28,
    VkDebugReportObjectTypeDisplayKhrExt = 29,
    VkDebugReportObjectTypeDisplayModeKhrExt = 30,
    VkDebugReportObjectTypeObjectTableNvxExt = 31,
    VkDebugReportObjectTypeIndirectCommandsLayoutNvxExt = 32,
    VkDebugReportObjectTypeValidationCacheExtExt = 33,
    VkDebugReportObjectTypeSamplerYcbcrConversionExt = 1000156000,
    VkDebugReportObjectTypeDescriptorUpdateTemplateExt = 1000085000,
    VkDebugReportObjectTypeDescriptorUpdateTemplateKhrExt = 1000085000,
    VkDebugReportObjectTypeSamplerYcbcrConversionKhrExt = 1000156000,
    VkDebugReportObjectTypeBeginRangeExt = 0,
    VkDebugReportObjectTypeEndRangeExt = 33,
    VkDebugReportObjectTypeRangeSizeExt = 34,
    VkDebugReportObjectTypeMaxEnumExt = 2147483647
}

public enum VkDebugReportFlagBitsEXT
{
    VkDebugReportInformationBitExt = 1,
    VkDebugReportWarningBitExt = 2,
    VkDebugReportPerformanceWarningBitExt = 4,
    VkDebugReportErrorBitExt = 8,
    VkDebugReportDebugBitExt = 16,
    VkDebugReportFlagBitsMaxEnumExt = 2147483647
}

public enum VkRasterizationOrderAMD
{
    VkRasterizationOrderStrictAmd = 0,
    VkRasterizationOrderRelaxedAmd = 1,
    VkRasterizationOrderBeginRangeAmd = 0,
    VkRasterizationOrderEndRangeAmd = 1,
    VkRasterizationOrderRangeSizeAmd = 2,
    VkRasterizationOrderMaxEnumAmd = 2147483647
}

public enum VkShaderInfoTypeAMD
{
    VkShaderInfoTypeStatisticsAmd = 0,
    VkShaderInfoTypeBinaryAmd = 1,
    VkShaderInfoTypeDisassemblyAmd = 2,
    VkShaderInfoTypeBeginRangeAmd = 0,
    VkShaderInfoTypeEndRangeAmd = 2,
    VkShaderInfoTypeRangeSizeAmd = 3,
    VkShaderInfoTypeMaxEnumAmd = 2147483647
}

public enum VkExternalMemoryHandleTypeFlagBitsNV
{
    VkExternalMemoryHandleTypeOpaqueWin32BitNv = 1,
    VkExternalMemoryHandleTypeOpaqueWin32KmtBitNv = 2,
    VkExternalMemoryHandleTypeD3d11ImageBitNv = 4,
    VkExternalMemoryHandleTypeD3d11ImageKmtBitNv = 8,
    VkExternalMemoryHandleTypeFlagBitsMaxEnumNv = 2147483647
}

public enum VkExternalMemoryFeatureFlagBitsNV
{
    VkExternalMemoryFeatureDedicatedOnlyBitNv = 1,
    VkExternalMemoryFeatureExportableBitNv = 2,
    VkExternalMemoryFeatureImportableBitNv = 4,
    VkExternalMemoryFeatureFlagBitsMaxEnumNv = 2147483647
}

public enum VkValidationCheckEXT
{
    VkValidationCheckAllExt = 0,
    VkValidationCheckShadersExt = 1,
    VkValidationCheckBeginRangeExt = 0,
    VkValidationCheckEndRangeExt = 1,
    VkValidationCheckRangeSizeExt = 2,
    VkValidationCheckMaxEnumExt = 2147483647
}

public enum VkConditionalRenderingFlagBitsEXT
{
    VkConditionalRenderingInvertedBitExt = 1,
    VkConditionalRenderingFlagBitsMaxEnumExt = 2147483647
}

public enum VkIndirectCommandsTokenTypeNVX
{
    VkIndirectCommandsTokenTypePipelineNvx = 0,
    VkIndirectCommandsTokenTypeDescriptorSetNvx = 1,
    VkIndirectCommandsTokenTypeIndexBufferNvx = 2,
    VkIndirectCommandsTokenTypeVertexBufferNvx = 3,
    VkIndirectCommandsTokenTypePushConstantNvx = 4,
    VkIndirectCommandsTokenTypeDrawIndexedNvx = 5,
    VkIndirectCommandsTokenTypeDrawNvx = 6,
    VkIndirectCommandsTokenTypeDispatchNvx = 7,
    VkIndirectCommandsTokenTypeBeginRangeNvx = 0,
    VkIndirectCommandsTokenTypeEndRangeNvx = 7,
    VkIndirectCommandsTokenTypeRangeSizeNvx = 8,
    VkIndirectCommandsTokenTypeMaxEnumNvx = 2147483647
}

public enum VkObjectEntryTypeNVX
{
    VkObjectEntryTypeDescriptorSetNvx = 0,
    VkObjectEntryTypePipelineNvx = 1,
    VkObjectEntryTypeIndexBufferNvx = 2,
    VkObjectEntryTypeVertexBufferNvx = 3,
    VkObjectEntryTypePushConstantNvx = 4,
    VkObjectEntryTypeBeginRangeNvx = 0,
    VkObjectEntryTypeEndRangeNvx = 4,
    VkObjectEntryTypeRangeSizeNvx = 5,
    VkObjectEntryTypeMaxEnumNvx = 2147483647
}

public enum VkIndirectCommandsLayoutUsageFlagBitsNVX
{
    VkIndirectCommandsLayoutUsageUnorderedSequencesBitNvx = 1,
    VkIndirectCommandsLayoutUsageSparseSequencesBitNvx = 2,
    VkIndirectCommandsLayoutUsageEmptyExecutionsBitNvx = 4,
    VkIndirectCommandsLayoutUsageIndexedSequencesBitNvx = 8,
    VkIndirectCommandsLayoutUsageFlagBitsMaxEnumNvx = 2147483647
}

public enum VkObjectEntryUsageFlagBitsNVX
{
    VkObjectEntryUsageGraphicsBitNvx = 1,
    VkObjectEntryUsageComputeBitNvx = 2,
    VkObjectEntryUsageFlagBitsMaxEnumNvx = 2147483647
}

public enum VkSurfaceCounterFlagBitsEXT
{
    VkSurfaceCounterVblankExt = 1,
    VkSurfaceCounterFlagBitsMaxEnumExt = 2147483647
}

public enum VkDisplayPowerStateEXT
{
    VkDisplayPowerStateOffExt = 0,
    VkDisplayPowerStateSuspendExt = 1,
    VkDisplayPowerStateOnExt = 2,
    VkDisplayPowerStateBeginRangeExt = 0,
    VkDisplayPowerStateEndRangeExt = 2,
    VkDisplayPowerStateRangeSizeExt = 3,
    VkDisplayPowerStateMaxEnumExt = 2147483647
}

public enum VkDeviceEventTypeEXT
{
    VkDeviceEventTypeDisplayHotplugExt = 0,
    VkDeviceEventTypeBeginRangeExt = 0,
    VkDeviceEventTypeEndRangeExt = 0,
    VkDeviceEventTypeRangeSizeExt = 1,
    VkDeviceEventTypeMaxEnumExt = 2147483647
}

public enum VkDisplayEventTypeEXT
{
    VkDisplayEventTypeFirstPixelOutExt = 0,
    VkDisplayEventTypeBeginRangeExt = 0,
    VkDisplayEventTypeEndRangeExt = 0,
    VkDisplayEventTypeRangeSizeExt = 1,
    VkDisplayEventTypeMaxEnumExt = 2147483647
}

public enum VkViewportCoordinateSwizzleNV
{
    VkViewportCoordinateSwizzlePositiveXNv = 0,
    VkViewportCoordinateSwizzleNegativeXNv = 1,
    VkViewportCoordinateSwizzlePositiveYNv = 2,
    VkViewportCoordinateSwizzleNegativeYNv = 3,
    VkViewportCoordinateSwizzlePositiveZNv = 4,
    VkViewportCoordinateSwizzleNegativeZNv = 5,
    VkViewportCoordinateSwizzlePositiveWNv = 6,
    VkViewportCoordinateSwizzleNegativeWNv = 7,
    VkViewportCoordinateSwizzleBeginRangeNv = 0,
    VkViewportCoordinateSwizzleEndRangeNv = 7,
    VkViewportCoordinateSwizzleRangeSizeNv = 8,
    VkViewportCoordinateSwizzleMaxEnumNv = 2147483647
}

public enum VkDiscardRectangleModeEXT
{
    VkDiscardRectangleModeInclusiveExt = 0,
    VkDiscardRectangleModeExclusiveExt = 1,
    VkDiscardRectangleModeBeginRangeExt = 0,
    VkDiscardRectangleModeEndRangeExt = 1,
    VkDiscardRectangleModeRangeSizeExt = 2,
    VkDiscardRectangleModeMaxEnumExt = 2147483647
}

public enum VkConservativeRasterizationModeEXT
{
    VkConservativeRasterizationModeDisabledExt = 0,
    VkConservativeRasterizationModeOverestimateExt = 1,
    VkConservativeRasterizationModeUnderestimateExt = 2,
    VkConservativeRasterizationModeBeginRangeExt = 0,
    VkConservativeRasterizationModeEndRangeExt = 2,
    VkConservativeRasterizationModeRangeSizeExt = 3,
    VkConservativeRasterizationModeMaxEnumExt = 2147483647
}

public enum VkDebugUtilsMessageSeverityFlagBitsEXT
{
    VkDebugUtilsMessageSeverityVerboseBitExt = 1,
    VkDebugUtilsMessageSeverityInfoBitExt = 16,
    VkDebugUtilsMessageSeverityWarningBitExt = 256,
    VkDebugUtilsMessageSeverityErrorBitExt = 4096,
    VkDebugUtilsMessageSeverityFlagBitsMaxEnumExt = 2147483647
}

public enum VkDebugUtilsMessageTypeFlagBitsEXT
{
    VkDebugUtilsMessageTypeGeneralBitExt = 1,
    VkDebugUtilsMessageTypeValidationBitExt = 2,
    VkDebugUtilsMessageTypePerformanceBitExt = 4,
    VkDebugUtilsMessageTypeFlagBitsMaxEnumExt = 2147483647
}

public enum VkSamplerReductionModeEXT
{
    VkSamplerReductionModeWeightedAverageExt = 0,
    VkSamplerReductionModeMinExt = 1,
    VkSamplerReductionModeMaxExt = 2,
    VkSamplerReductionModeBeginRangeExt = 0,
    VkSamplerReductionModeEndRangeExt = 2,
    VkSamplerReductionModeRangeSizeExt = 3,
    VkSamplerReductionModeMaxEnumExt = 2147483647
}

public enum VkBlendOverlapEXT
{
    VkBlendOverlapUncorrelatedExt = 0,
    VkBlendOverlapDisjointExt = 1,
    VkBlendOverlapConjointExt = 2,
    VkBlendOverlapBeginRangeExt = 0,
    VkBlendOverlapEndRangeExt = 2,
    VkBlendOverlapRangeSizeExt = 3,
    VkBlendOverlapMaxEnumExt = 2147483647
}

public enum VkCoverageModulationModeNV
{
    VkCoverageModulationModeNoneNv = 0,
    VkCoverageModulationModeRgbNv = 1,
    VkCoverageModulationModeAlphaNv = 2,
    VkCoverageModulationModeRgbaNv = 3,
    VkCoverageModulationModeBeginRangeNv = 0,
    VkCoverageModulationModeEndRangeNv = 3,
    VkCoverageModulationModeRangeSizeNv = 4,
    VkCoverageModulationModeMaxEnumNv = 2147483647
}

public enum VkValidationCacheHeaderVersionEXT
{
    VkValidationCacheHeaderVersionOneExt = 1,
    VkValidationCacheHeaderVersionBeginRangeExt = 1,
    VkValidationCacheHeaderVersionEndRangeExt = 1,
    VkValidationCacheHeaderVersionRangeSizeExt = 1,
    VkValidationCacheHeaderVersionMaxEnumExt = 2147483647
}

public enum VkDescriptorBindingFlagBitsEXT
{
    VkDescriptorBindingUpdateAfterBindBitExt = 1,
    VkDescriptorBindingUpdateUnusedWhilePendingBitExt = 2,
    VkDescriptorBindingPartiallyBoundBitExt = 4,
    VkDescriptorBindingVariableDescriptorCountBitExt = 8,
    VkDescriptorBindingFlagBitsMaxEnumExt = 2147483647
}

public enum VkQueueGlobalPriorityEXT
{
    VkQueueGlobalPriorityLowExt = 128,
    VkQueueGlobalPriorityMediumExt = 256,
    VkQueueGlobalPriorityHighExt = 512,
    VkQueueGlobalPriorityRealtimeExt = 1024,
    VkQueueGlobalPriorityBeginRangeExt = 128,
    VkQueueGlobalPriorityEndRangeExt = 1024,
    VkQueueGlobalPriorityRangeSizeExt = 897,
    VkQueueGlobalPriorityMaxEnumExt = 2147483647
}

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::System.IntPtr PFN_vkAllocationFunction(global::System.IntPtr pUserData, ulong size, ulong alignment, global::VkSystemAllocationScope allocationScope);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::System.IntPtr PFN_vkReallocationFunction(global::System.IntPtr pUserData, global::System.IntPtr pOriginal, ulong size, ulong alignment, global::VkSystemAllocationScope allocationScope);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkFreeFunction(global::System.IntPtr pUserData, global::System.IntPtr pMemory);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkInternalAllocationNotification(global::System.IntPtr pUserData, ulong size, global::VkInternalAllocationType allocationType, global::VkSystemAllocationScope allocationScope);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkInternalFreeNotification(global::System.IntPtr pUserData, ulong size, global::VkInternalAllocationType allocationType, global::VkSystemAllocationScope allocationScope);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkVoidFunction();

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateInstance(global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pInstance);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyInstance(global::System.IntPtr instance, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkEnumeratePhysicalDevices(global::System.IntPtr instance, uint* pPhysicalDeviceCount, global::System.IntPtr pPhysicalDevices);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceFeatures(global::System.IntPtr physicalDevice, global::System.IntPtr pFeatures);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceFormatProperties(global::System.IntPtr physicalDevice, global::VkFormat format, global::System.IntPtr pFormatProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceImageFormatProperties(global::System.IntPtr physicalDevice, global::VkFormat format, global::VkImageType type, global::VkImageTiling tiling, uint usage, uint flags, global::System.IntPtr pImageFormatProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceQueueFamilyProperties(global::System.IntPtr physicalDevice, uint* pQueueFamilyPropertyCount, global::System.IntPtr pQueueFamilyProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceMemoryProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pMemoryProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::System.IntPtr PFN_vkGetInstanceProcAddr(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string pName);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::System.IntPtr PFN_vkGetDeviceProcAddr(global::System.IntPtr device, [MarshalAs(UnmanagedType.LPStr)] string pName);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateDevice(global::System.IntPtr physicalDevice, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pDevice);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyDevice(global::System.IntPtr device, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkEnumerateInstanceExtensionProperties([MarshalAs(UnmanagedType.LPStr)] string pLayerName, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkEnumerateDeviceExtensionProperties(global::System.IntPtr physicalDevice, [MarshalAs(UnmanagedType.LPStr)] string pLayerName, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkEnumerateInstanceLayerProperties(uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkEnumerateDeviceLayerProperties(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetDeviceQueue(global::System.IntPtr device, uint queueFamilyIndex, uint queueIndex, global::System.IntPtr pQueue);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkQueueSubmit(global::System.IntPtr queue, uint submitCount, global::System.IntPtr pSubmits, global::System.IntPtr fence);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkQueueWaitIdle(global::System.IntPtr queue);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkDeviceWaitIdle(global::System.IntPtr device);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkAllocateMemory(global::System.IntPtr device, global::System.IntPtr pAllocateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pMemory);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkFreeMemory(global::System.IntPtr device, global::System.IntPtr memory, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkMapMemory(global::System.IntPtr device, global::System.IntPtr memory, ulong offset, ulong size, uint flags, void** ppData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkUnmapMemory(global::System.IntPtr device, global::System.IntPtr memory);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkFlushMappedMemoryRanges(global::System.IntPtr device, uint memoryRangeCount, global::System.IntPtr pMemoryRanges);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkInvalidateMappedMemoryRanges(global::System.IntPtr device, uint memoryRangeCount, global::System.IntPtr pMemoryRanges);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetDeviceMemoryCommitment(global::System.IntPtr device, global::System.IntPtr memory, ulong* pCommittedMemoryInBytes);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkBindBufferMemory(global::System.IntPtr device, global::System.IntPtr buffer, global::System.IntPtr memory, ulong memoryOffset);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkBindImageMemory(global::System.IntPtr device, global::System.IntPtr image, global::System.IntPtr memory, ulong memoryOffset);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetBufferMemoryRequirements(global::System.IntPtr device, global::System.IntPtr buffer, global::System.IntPtr pMemoryRequirements);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetImageMemoryRequirements(global::System.IntPtr device, global::System.IntPtr image, global::System.IntPtr pMemoryRequirements);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetImageSparseMemoryRequirements(global::System.IntPtr device, global::System.IntPtr image, uint* pSparseMemoryRequirementCount, global::System.IntPtr pSparseMemoryRequirements);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceSparseImageFormatProperties(global::System.IntPtr physicalDevice, global::VkFormat format, global::VkImageType type, global::VkSampleCountFlagBits samples, uint usage, global::VkImageTiling tiling, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkQueueBindSparse(global::System.IntPtr queue, uint bindInfoCount, global::System.IntPtr pBindInfo, global::System.IntPtr fence);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateFence(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pFence);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyFence(global::System.IntPtr device, global::System.IntPtr fence, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkResetFences(global::System.IntPtr device, uint fenceCount, global::System.IntPtr pFences);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetFenceStatus(global::System.IntPtr device, global::System.IntPtr fence);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkWaitForFences(global::System.IntPtr device, uint fenceCount, global::System.IntPtr pFences, uint waitAll, ulong timeout);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateSemaphore(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSemaphore);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroySemaphore(global::System.IntPtr device, global::System.IntPtr semaphore, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateEvent(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pEvent);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyEvent(global::System.IntPtr device, global::System.IntPtr @event, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetEventStatus(global::System.IntPtr device, global::System.IntPtr @event);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkSetEvent(global::System.IntPtr device, global::System.IntPtr @event);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkResetEvent(global::System.IntPtr device, global::System.IntPtr @event);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateQueryPool(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pQueryPool);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyQueryPool(global::System.IntPtr device, global::System.IntPtr queryPool, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetQueryPoolResults(global::System.IntPtr device, global::System.IntPtr queryPool, uint firstQuery, uint queryCount, ulong dataSize, global::System.IntPtr pData, ulong stride, uint flags);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateBuffer(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pBuffer);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyBuffer(global::System.IntPtr device, global::System.IntPtr buffer, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateBufferView(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pView);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyBufferView(global::System.IntPtr device, global::System.IntPtr bufferView, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateImage(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pImage);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyImage(global::System.IntPtr device, global::System.IntPtr image, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetImageSubresourceLayout(global::System.IntPtr device, global::System.IntPtr image, global::System.IntPtr pSubresource, global::System.IntPtr pLayout);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateImageView(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pView);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyImageView(global::System.IntPtr device, global::System.IntPtr imageView, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateShaderModule(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pShaderModule);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyShaderModule(global::System.IntPtr device, global::System.IntPtr shaderModule, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreatePipelineCache(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pPipelineCache);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyPipelineCache(global::System.IntPtr device, global::System.IntPtr pipelineCache, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPipelineCacheData(global::System.IntPtr device, global::System.IntPtr pipelineCache, ulong* pDataSize, global::System.IntPtr pData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkMergePipelineCaches(global::System.IntPtr device, global::System.IntPtr dstCache, uint srcCacheCount, global::System.IntPtr pSrcCaches);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateGraphicsPipelines(global::System.IntPtr device, global::System.IntPtr pipelineCache, uint createInfoCount, global::System.IntPtr pCreateInfos, global::System.IntPtr pAllocator, global::System.IntPtr pPipelines);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateComputePipelines(global::System.IntPtr device, global::System.IntPtr pipelineCache, uint createInfoCount, global::System.IntPtr pCreateInfos, global::System.IntPtr pAllocator, global::System.IntPtr pPipelines);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyPipeline(global::System.IntPtr device, global::System.IntPtr pipeline, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreatePipelineLayout(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pPipelineLayout);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyPipelineLayout(global::System.IntPtr device, global::System.IntPtr pipelineLayout, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateSampler(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSampler);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroySampler(global::System.IntPtr device, global::System.IntPtr sampler, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateDescriptorSetLayout(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSetLayout);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyDescriptorSetLayout(global::System.IntPtr device, global::System.IntPtr descriptorSetLayout, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateDescriptorPool(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pDescriptorPool);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyDescriptorPool(global::System.IntPtr device, global::System.IntPtr descriptorPool, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkResetDescriptorPool(global::System.IntPtr device, global::System.IntPtr descriptorPool, uint flags);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkAllocateDescriptorSets(global::System.IntPtr device, global::System.IntPtr pAllocateInfo, global::System.IntPtr pDescriptorSets);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkFreeDescriptorSets(global::System.IntPtr device, global::System.IntPtr descriptorPool, uint descriptorSetCount, global::System.IntPtr pDescriptorSets);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkUpdateDescriptorSets(global::System.IntPtr device, uint descriptorWriteCount, global::System.IntPtr pDescriptorWrites, uint descriptorCopyCount, global::System.IntPtr pDescriptorCopies);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateFramebuffer(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pFramebuffer);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyFramebuffer(global::System.IntPtr device, global::System.IntPtr framebuffer, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateRenderPass(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pRenderPass);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyRenderPass(global::System.IntPtr device, global::System.IntPtr renderPass, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetRenderAreaGranularity(global::System.IntPtr device, global::System.IntPtr renderPass, global::System.IntPtr pGranularity);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateCommandPool(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pCommandPool);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyCommandPool(global::System.IntPtr device, global::System.IntPtr commandPool, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkResetCommandPool(global::System.IntPtr device, global::System.IntPtr commandPool, uint flags);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkAllocateCommandBuffers(global::System.IntPtr device, global::System.IntPtr pAllocateInfo, global::System.IntPtr pCommandBuffers);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkFreeCommandBuffers(global::System.IntPtr device, global::System.IntPtr commandPool, uint commandBufferCount, global::System.IntPtr pCommandBuffers);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkBeginCommandBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr pBeginInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkEndCommandBuffer(global::System.IntPtr commandBuffer);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkResetCommandBuffer(global::System.IntPtr commandBuffer, uint flags);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBindPipeline(global::System.IntPtr commandBuffer, global::VkPipelineBindPoint pipelineBindPoint, global::System.IntPtr pipeline);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetViewport(global::System.IntPtr commandBuffer, uint firstViewport, uint viewportCount, global::System.IntPtr pViewports);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetScissor(global::System.IntPtr commandBuffer, uint firstScissor, uint scissorCount, global::System.IntPtr pScissors);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetLineWidth(global::System.IntPtr commandBuffer, float lineWidth);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetDepthBias(global::System.IntPtr commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetBlendConstants(global::System.IntPtr commandBuffer, float[] blendConstants);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetDepthBounds(global::System.IntPtr commandBuffer, float minDepthBounds, float maxDepthBounds);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetStencilCompareMask(global::System.IntPtr commandBuffer, uint faceMask, uint compareMask);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetStencilWriteMask(global::System.IntPtr commandBuffer, uint faceMask, uint writeMask);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetStencilReference(global::System.IntPtr commandBuffer, uint faceMask, uint reference);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBindDescriptorSets(global::System.IntPtr commandBuffer, global::VkPipelineBindPoint pipelineBindPoint, global::System.IntPtr layout, uint firstSet, uint descriptorSetCount, global::System.IntPtr pDescriptorSets, uint dynamicOffsetCount, uint* pDynamicOffsets);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBindIndexBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::VkIndexType indexType);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBindVertexBuffers(global::System.IntPtr commandBuffer, uint firstBinding, uint bindingCount, global::System.IntPtr pBuffers, ulong* pOffsets);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDraw(global::System.IntPtr commandBuffer, uint vertexCount, uint instanceCount, uint firstVertex, uint firstInstance);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDrawIndexed(global::System.IntPtr commandBuffer, uint indexCount, uint instanceCount, uint firstIndex, int vertexOffset, uint firstInstance);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDrawIndirect(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, uint drawCount, uint stride);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDrawIndexedIndirect(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, uint drawCount, uint stride);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDispatch(global::System.IntPtr commandBuffer, uint groupCountX, uint groupCountY, uint groupCountZ);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDispatchIndirect(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdCopyBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr srcBuffer, global::System.IntPtr dstBuffer, uint regionCount, global::System.IntPtr pRegions);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdCopyImage(global::System.IntPtr commandBuffer, global::System.IntPtr srcImage, global::VkImageLayout srcImageLayout, global::System.IntPtr dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::System.IntPtr pRegions);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBlitImage(global::System.IntPtr commandBuffer, global::System.IntPtr srcImage, global::VkImageLayout srcImageLayout, global::System.IntPtr dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::System.IntPtr pRegions, global::VkFilter filter);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdCopyBufferToImage(global::System.IntPtr commandBuffer, global::System.IntPtr srcBuffer, global::System.IntPtr dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::System.IntPtr pRegions);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdCopyImageToBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr srcImage, global::VkImageLayout srcImageLayout, global::System.IntPtr dstBuffer, uint regionCount, global::System.IntPtr pRegions);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdUpdateBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr dstBuffer, ulong dstOffset, ulong dataSize, global::System.IntPtr pData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdFillBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr dstBuffer, ulong dstOffset, ulong size, uint data);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdClearColorImage(global::System.IntPtr commandBuffer, global::System.IntPtr image, global::VkImageLayout imageLayout, global::System.IntPtr pColor, uint rangeCount, global::System.IntPtr pRanges);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdClearDepthStencilImage(global::System.IntPtr commandBuffer, global::System.IntPtr image, global::VkImageLayout imageLayout, global::System.IntPtr pDepthStencil, uint rangeCount, global::System.IntPtr pRanges);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdClearAttachments(global::System.IntPtr commandBuffer, uint attachmentCount, global::System.IntPtr pAttachments, uint rectCount, global::System.IntPtr pRects);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdResolveImage(global::System.IntPtr commandBuffer, global::System.IntPtr srcImage, global::VkImageLayout srcImageLayout, global::System.IntPtr dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::System.IntPtr pRegions);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetEvent(global::System.IntPtr commandBuffer, global::System.IntPtr @event, uint stageMask);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdResetEvent(global::System.IntPtr commandBuffer, global::System.IntPtr @event, uint stageMask);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdWaitEvents(global::System.IntPtr commandBuffer, uint eventCount, global::System.IntPtr pEvents, uint srcStageMask, uint dstStageMask, uint memoryBarrierCount, global::System.IntPtr pMemoryBarriers, uint bufferMemoryBarrierCount, global::System.IntPtr pBufferMemoryBarriers, uint imageMemoryBarrierCount, global::System.IntPtr pImageMemoryBarriers);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdPipelineBarrier(global::System.IntPtr commandBuffer, uint srcStageMask, uint dstStageMask, uint dependencyFlags, uint memoryBarrierCount, global::System.IntPtr pMemoryBarriers, uint bufferMemoryBarrierCount, global::System.IntPtr pBufferMemoryBarriers, uint imageMemoryBarrierCount, global::System.IntPtr pImageMemoryBarriers);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBeginQuery(global::System.IntPtr commandBuffer, global::System.IntPtr queryPool, uint query, uint flags);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdEndQuery(global::System.IntPtr commandBuffer, global::System.IntPtr queryPool, uint query);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdResetQueryPool(global::System.IntPtr commandBuffer, global::System.IntPtr queryPool, uint firstQuery, uint queryCount);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdWriteTimestamp(global::System.IntPtr commandBuffer, global::VkPipelineStageFlagBits pipelineStage, global::System.IntPtr queryPool, uint query);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdCopyQueryPoolResults(global::System.IntPtr commandBuffer, global::System.IntPtr queryPool, uint firstQuery, uint queryCount, global::System.IntPtr dstBuffer, ulong dstOffset, ulong stride, uint flags);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdPushConstants(global::System.IntPtr commandBuffer, global::System.IntPtr layout, uint stageFlags, uint offset, uint size, global::System.IntPtr pValues);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBeginRenderPass(global::System.IntPtr commandBuffer, global::System.IntPtr pRenderPassBegin, global::VkSubpassContents contents);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdNextSubpass(global::System.IntPtr commandBuffer, global::VkSubpassContents contents);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdEndRenderPass(global::System.IntPtr commandBuffer);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdExecuteCommands(global::System.IntPtr commandBuffer, uint commandBufferCount, global::System.IntPtr pCommandBuffers);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkEnumerateInstanceVersion(uint* pApiVersion);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkBindBufferMemory2(global::System.IntPtr device, uint bindInfoCount, global::System.IntPtr pBindInfos);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkBindImageMemory2(global::System.IntPtr device, uint bindInfoCount, global::System.IntPtr pBindInfos);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetDeviceGroupPeerMemoryFeatures(global::System.IntPtr device, uint heapIndex, uint localDeviceIndex, uint remoteDeviceIndex, uint* pPeerMemoryFeatures);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetDeviceMask(global::System.IntPtr commandBuffer, uint deviceMask);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDispatchBase(global::System.IntPtr commandBuffer, uint baseGroupX, uint baseGroupY, uint baseGroupZ, uint groupCountX, uint groupCountY, uint groupCountZ);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkEnumeratePhysicalDeviceGroups(global::System.IntPtr instance, uint* pPhysicalDeviceGroupCount, global::System.IntPtr pPhysicalDeviceGroupProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetImageMemoryRequirements2(global::System.IntPtr device, global::System.IntPtr pInfo, global::System.IntPtr pMemoryRequirements);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetBufferMemoryRequirements2(global::System.IntPtr device, global::System.IntPtr pInfo, global::System.IntPtr pMemoryRequirements);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetImageSparseMemoryRequirements2(global::System.IntPtr device, global::System.IntPtr pInfo, uint* pSparseMemoryRequirementCount, global::System.IntPtr pSparseMemoryRequirements);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceFeatures2(global::System.IntPtr physicalDevice, global::System.IntPtr pFeatures);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceProperties2(global::System.IntPtr physicalDevice, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceFormatProperties2(global::System.IntPtr physicalDevice, global::VkFormat format, global::System.IntPtr pFormatProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceImageFormatProperties2(global::System.IntPtr physicalDevice, global::System.IntPtr pImageFormatInfo, global::System.IntPtr pImageFormatProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceQueueFamilyProperties2(global::System.IntPtr physicalDevice, uint* pQueueFamilyPropertyCount, global::System.IntPtr pQueueFamilyProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceMemoryProperties2(global::System.IntPtr physicalDevice, global::System.IntPtr pMemoryProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceSparseImageFormatProperties2(global::System.IntPtr physicalDevice, global::System.IntPtr pFormatInfo, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkTrimCommandPool(global::System.IntPtr device, global::System.IntPtr commandPool, uint flags);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetDeviceQueue2(global::System.IntPtr device, global::System.IntPtr pQueueInfo, global::System.IntPtr pQueue);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateSamplerYcbcrConversion(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pYcbcrConversion);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroySamplerYcbcrConversion(global::System.IntPtr device, global::System.IntPtr ycbcrConversion, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateDescriptorUpdateTemplate(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pDescriptorUpdateTemplate);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyDescriptorUpdateTemplate(global::System.IntPtr device, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkUpdateDescriptorSetWithTemplate(global::System.IntPtr device, global::System.IntPtr descriptorSet, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr pData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceExternalBufferProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalBufferInfo, global::System.IntPtr pExternalBufferProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceExternalFenceProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalFenceInfo, global::System.IntPtr pExternalFenceProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceExternalSemaphoreProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalSemaphoreInfo, global::System.IntPtr pExternalSemaphoreProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetDescriptorSetLayoutSupport(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pSupport);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroySurfaceKHR(global::System.IntPtr instance, global::System.IntPtr surface, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceSurfaceSupportKHR(global::System.IntPtr physicalDevice, uint queueFamilyIndex, global::System.IntPtr surface, uint* pSupported);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr surface, global::System.IntPtr pSurfaceCapabilities);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceSurfaceFormatsKHR(global::System.IntPtr physicalDevice, global::System.IntPtr surface, uint* pSurfaceFormatCount, global::System.IntPtr pSurfaceFormats);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceSurfacePresentModesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr surface, uint* pPresentModeCount, global::VkPresentModeKHR* pPresentModes);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateSwapchainKHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSwapchain);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroySwapchainKHR(global::System.IntPtr device, global::System.IntPtr swapchain, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetSwapchainImagesKHR(global::System.IntPtr device, global::System.IntPtr swapchain, uint* pSwapchainImageCount, global::System.IntPtr pSwapchainImages);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkAcquireNextImageKHR(global::System.IntPtr device, global::System.IntPtr swapchain, ulong timeout, global::System.IntPtr semaphore, global::System.IntPtr fence, uint* pImageIndex);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkQueuePresentKHR(global::System.IntPtr queue, global::System.IntPtr pPresentInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetDeviceGroupPresentCapabilitiesKHR(global::System.IntPtr device, global::System.IntPtr pDeviceGroupPresentCapabilities);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetDeviceGroupSurfacePresentModesKHR(global::System.IntPtr device, global::System.IntPtr surface, uint* pModes);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDevicePresentRectanglesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr surface, uint* pRectCount, global::System.IntPtr pRects);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkAcquireNextImage2KHR(global::System.IntPtr device, global::System.IntPtr pAcquireInfo, uint* pImageIndex);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceDisplayPropertiesKHR(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetDisplayPlaneSupportedDisplaysKHR(global::System.IntPtr physicalDevice, uint planeIndex, uint* pDisplayCount, global::System.IntPtr pDisplays);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetDisplayModePropertiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr display, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateDisplayModeKHR(global::System.IntPtr physicalDevice, global::System.IntPtr display, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pMode);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetDisplayPlaneCapabilitiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr mode, uint planeIndex, global::System.IntPtr pCapabilities);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateDisplayPlaneSurfaceKHR(global::System.IntPtr instance, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSurface);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateSharedSwapchainsKHR(global::System.IntPtr device, uint swapchainCount, global::System.IntPtr pCreateInfos, global::System.IntPtr pAllocator, global::System.IntPtr pSwapchains);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceFeatures2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pFeatures);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceFormatProperties2KHR(global::System.IntPtr physicalDevice, global::VkFormat format, global::System.IntPtr pFormatProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceImageFormatProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pImageFormatInfo, global::System.IntPtr pImageFormatProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR(global::System.IntPtr physicalDevice, uint* pQueueFamilyPropertyCount, global::System.IntPtr pQueueFamilyProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceMemoryProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pMemoryProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pFormatInfo, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR(global::System.IntPtr device, uint heapIndex, uint localDeviceIndex, uint remoteDeviceIndex, uint* pPeerMemoryFeatures);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetDeviceMaskKHR(global::System.IntPtr commandBuffer, uint deviceMask);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDispatchBaseKHR(global::System.IntPtr commandBuffer, uint baseGroupX, uint baseGroupY, uint baseGroupZ, uint groupCountX, uint groupCountY, uint groupCountZ);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkTrimCommandPoolKHR(global::System.IntPtr device, global::System.IntPtr commandPool, uint flags);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkEnumeratePhysicalDeviceGroupsKHR(global::System.IntPtr instance, uint* pPhysicalDeviceGroupCount, global::System.IntPtr pPhysicalDeviceGroupProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalBufferInfo, global::System.IntPtr pExternalBufferProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetMemoryFdKHR(global::System.IntPtr device, global::System.IntPtr pGetFdInfo, int* pFd);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetMemoryFdPropertiesKHR(global::System.IntPtr device, global::VkExternalMemoryHandleTypeFlagBits handleType, int fd, global::System.IntPtr pMemoryFdProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalSemaphoreInfo, global::System.IntPtr pExternalSemaphoreProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkImportSemaphoreFdKHR(global::System.IntPtr device, global::System.IntPtr pImportSemaphoreFdInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetSemaphoreFdKHR(global::System.IntPtr device, global::System.IntPtr pGetFdInfo, int* pFd);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdPushDescriptorSetKHR(global::System.IntPtr commandBuffer, global::VkPipelineBindPoint pipelineBindPoint, global::System.IntPtr layout, uint set, uint descriptorWriteCount, global::System.IntPtr pDescriptorWrites);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdPushDescriptorSetWithTemplateKHR(global::System.IntPtr commandBuffer, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr layout, uint set, global::System.IntPtr pData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateDescriptorUpdateTemplateKHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pDescriptorUpdateTemplate);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyDescriptorUpdateTemplateKHR(global::System.IntPtr device, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkUpdateDescriptorSetWithTemplateKHR(global::System.IntPtr device, global::System.IntPtr descriptorSet, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr pData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateRenderPass2KHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pRenderPass);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBeginRenderPass2KHR(global::System.IntPtr commandBuffer, global::System.IntPtr pRenderPassBegin, global::System.IntPtr pSubpassBeginInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdNextSubpass2KHR(global::System.IntPtr commandBuffer, global::System.IntPtr pSubpassBeginInfo, global::System.IntPtr pSubpassEndInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdEndRenderPass2KHR(global::System.IntPtr commandBuffer, global::System.IntPtr pSubpassEndInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetSwapchainStatusKHR(global::System.IntPtr device, global::System.IntPtr swapchain);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalFenceInfo, global::System.IntPtr pExternalFenceProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkImportFenceFdKHR(global::System.IntPtr device, global::System.IntPtr pImportFenceFdInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetFenceFdKHR(global::System.IntPtr device, global::System.IntPtr pGetFdInfo, int* pFd);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pSurfaceInfo, global::System.IntPtr pSurfaceCapabilities);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceSurfaceFormats2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pSurfaceInfo, uint* pSurfaceFormatCount, global::System.IntPtr pSurfaceFormats);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceDisplayProperties2KHR(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetDisplayModeProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr display, uint* pPropertyCount, global::System.IntPtr pProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetDisplayPlaneCapabilities2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pDisplayPlaneInfo, global::System.IntPtr pCapabilities);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetImageMemoryRequirements2KHR(global::System.IntPtr device, global::System.IntPtr pInfo, global::System.IntPtr pMemoryRequirements);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetBufferMemoryRequirements2KHR(global::System.IntPtr device, global::System.IntPtr pInfo, global::System.IntPtr pMemoryRequirements);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetImageSparseMemoryRequirements2KHR(global::System.IntPtr device, global::System.IntPtr pInfo, uint* pSparseMemoryRequirementCount, global::System.IntPtr pSparseMemoryRequirements);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateSamplerYcbcrConversionKHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pYcbcrConversion);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroySamplerYcbcrConversionKHR(global::System.IntPtr device, global::System.IntPtr ycbcrConversion, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkBindBufferMemory2KHR(global::System.IntPtr device, uint bindInfoCount, global::System.IntPtr pBindInfos);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkBindImageMemory2KHR(global::System.IntPtr device, uint bindInfoCount, global::System.IntPtr pBindInfos);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetDescriptorSetLayoutSupportKHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pSupport);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDrawIndirectCountKHR(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::System.IntPtr countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDrawIndexedIndirectCountKHR(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::System.IntPtr countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate uint PFN_vkDebugReportCallbackEXT(uint flags, global::VkDebugReportObjectTypeEXT objectType, ulong targetObject, ulong location, int messageCode, [MarshalAs(UnmanagedType.LPStr)] string pLayerPrefix, [MarshalAs(UnmanagedType.LPStr)] string pMessage, global::System.IntPtr pUserData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateDebugReportCallbackEXT(global::System.IntPtr instance, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pCallback);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyDebugReportCallbackEXT(global::System.IntPtr instance, global::System.IntPtr callback, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDebugReportMessageEXT(global::System.IntPtr instance, uint flags, global::VkDebugReportObjectTypeEXT objectType, ulong targetObject, ulong location, int messageCode, [MarshalAs(UnmanagedType.LPStr)] string pLayerPrefix, [MarshalAs(UnmanagedType.LPStr)] string pMessage);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkDebugMarkerSetObjectTagEXT(global::System.IntPtr device, global::System.IntPtr pTagInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkDebugMarkerSetObjectNameEXT(global::System.IntPtr device, global::System.IntPtr pNameInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDebugMarkerBeginEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pMarkerInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDebugMarkerEndEXT(global::System.IntPtr commandBuffer);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDebugMarkerInsertEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pMarkerInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDrawIndirectCountAMD(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::System.IntPtr countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdDrawIndexedIndirectCountAMD(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::System.IntPtr countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetShaderInfoAMD(global::System.IntPtr device, global::System.IntPtr pipeline, global::VkShaderStageFlagBits shaderStage, global::VkShaderInfoTypeAMD infoType, ulong* pInfoSize, global::System.IntPtr pInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(global::System.IntPtr physicalDevice, global::VkFormat format, global::VkImageType type, global::VkImageTiling tiling, uint usage, uint flags, uint externalHandleType, global::System.IntPtr pExternalImageFormatProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBeginConditionalRenderingEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pConditionalRenderingBegin);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdEndConditionalRenderingEXT(global::System.IntPtr commandBuffer);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdProcessCommandsNVX(global::System.IntPtr commandBuffer, global::System.IntPtr pProcessCommandsInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdReserveSpaceForCommandsNVX(global::System.IntPtr commandBuffer, global::System.IntPtr pReserveSpaceInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateIndirectCommandsLayoutNVX(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pIndirectCommandsLayout);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyIndirectCommandsLayoutNVX(global::System.IntPtr device, global::System.IntPtr indirectCommandsLayout, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateObjectTableNVX(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pObjectTable);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyObjectTableNVX(global::System.IntPtr device, global::System.IntPtr objectTable, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkRegisterObjectsNVX(global::System.IntPtr device, global::System.IntPtr objectTable, uint objectCount, global::System.IntPtr ppObjectTableEntries, uint* pObjectIndices);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkUnregisterObjectsNVX(global::System.IntPtr device, global::System.IntPtr objectTable, uint objectCount, global::VkObjectEntryTypeNVX* pObjectEntryTypes, uint* pObjectIndices);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(global::System.IntPtr physicalDevice, global::System.IntPtr pFeatures, global::System.IntPtr pLimits);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetViewportWScalingNV(global::System.IntPtr commandBuffer, uint firstViewport, uint viewportCount, global::System.IntPtr pViewportWScalings);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkReleaseDisplayEXT(global::System.IntPtr physicalDevice, global::System.IntPtr display);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT(global::System.IntPtr physicalDevice, global::System.IntPtr surface, global::System.IntPtr pSurfaceCapabilities);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkDisplayPowerControlEXT(global::System.IntPtr device, global::System.IntPtr display, global::System.IntPtr pDisplayPowerInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkRegisterDeviceEventEXT(global::System.IntPtr device, global::System.IntPtr pDeviceEventInfo, global::System.IntPtr pAllocator, global::System.IntPtr pFence);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkRegisterDisplayEventEXT(global::System.IntPtr device, global::System.IntPtr display, global::System.IntPtr pDisplayEventInfo, global::System.IntPtr pAllocator, global::System.IntPtr pFence);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetSwapchainCounterEXT(global::System.IntPtr device, global::System.IntPtr swapchain, global::VkSurfaceCounterFlagBitsEXT counter, ulong* pCounterValue);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetRefreshCycleDurationGOOGLE(global::System.IntPtr device, global::System.IntPtr swapchain, global::System.IntPtr pDisplayTimingProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetPastPresentationTimingGOOGLE(global::System.IntPtr device, global::System.IntPtr swapchain, uint* pPresentationTimingCount, global::System.IntPtr pPresentationTimings);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetDiscardRectangleEXT(global::System.IntPtr commandBuffer, uint firstDiscardRectangle, uint discardRectangleCount, global::System.IntPtr pDiscardRectangles);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkSetHdrMetadataEXT(global::System.IntPtr device, uint swapchainCount, global::System.IntPtr pSwapchains, global::System.IntPtr pMetadata);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate uint PFN_vkDebugUtilsMessengerCallbackEXT(global::VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, uint messageType, global::System.IntPtr pCallbackData, global::System.IntPtr pUserData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkSetDebugUtilsObjectNameEXT(global::System.IntPtr device, global::System.IntPtr pNameInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkSetDebugUtilsObjectTagEXT(global::System.IntPtr device, global::System.IntPtr pTagInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkQueueBeginDebugUtilsLabelEXT(global::System.IntPtr queue, global::System.IntPtr pLabelInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkQueueEndDebugUtilsLabelEXT(global::System.IntPtr queue);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkQueueInsertDebugUtilsLabelEXT(global::System.IntPtr queue, global::System.IntPtr pLabelInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdBeginDebugUtilsLabelEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pLabelInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdEndDebugUtilsLabelEXT(global::System.IntPtr commandBuffer);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdInsertDebugUtilsLabelEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pLabelInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateDebugUtilsMessengerEXT(global::System.IntPtr instance, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pMessenger);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyDebugUtilsMessengerEXT(global::System.IntPtr instance, global::System.IntPtr messenger, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkSubmitDebugUtilsMessageEXT(global::System.IntPtr instance, global::VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, uint messageTypes, global::System.IntPtr pCallbackData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetSampleLocationsEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pSampleLocationsInfo);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT(global::System.IntPtr physicalDevice, global::VkSampleCountFlagBits samples, global::System.IntPtr pMultisampleProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkCreateValidationCacheEXT(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pValidationCache);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkDestroyValidationCacheEXT(global::System.IntPtr device, global::System.IntPtr validationCache, global::System.IntPtr pAllocator);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkMergeValidationCachesEXT(global::System.IntPtr device, global::System.IntPtr dstCache, uint srcCacheCount, global::System.IntPtr pSrcCaches);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetValidationCacheDataEXT(global::System.IntPtr device, global::System.IntPtr validationCache, ulong* pDataSize, global::System.IntPtr pData);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate global::VkResult PFN_vkGetMemoryHostPointerPropertiesEXT(global::System.IntPtr device, global::VkExternalMemoryHandleTypeFlagBits handleType, global::System.IntPtr pHostPointer, global::System.IntPtr pMemoryHostPointerProperties);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdWriteBufferMarkerAMD(global::System.IntPtr commandBuffer, global::VkPipelineStageFlagBits pipelineStage, global::System.IntPtr dstBuffer, ulong dstOffset, uint marker);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkCmdSetCheckpointNV(global::System.IntPtr commandBuffer, global::System.IntPtr pCheckpointMarker);

[SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
public unsafe delegate void PFN_vkGetQueueCheckpointDataNV(global::System.IntPtr queue, uint* pCheckpointDataCount, global::System.IntPtr pCheckpointData);

public unsafe partial class VkInstanceT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkInstanceT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkInstanceT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkInstanceT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkInstanceT(native.ToPointer(), skipVTables);
    }

    internal static global::VkInstanceT __CreateInstance(global::VkInstanceT.__Internal native, bool skipVTables = false)
    {
        return new global::VkInstanceT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkInstanceT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkInstanceT.__Internal));
        *(global::VkInstanceT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkInstanceT(global::VkInstanceT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkInstanceT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkPhysicalDeviceT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceT __CreateInstance(global::VkPhysicalDeviceT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceT.__Internal));
        *(global::VkPhysicalDeviceT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceT(global::VkPhysicalDeviceT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDeviceT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceT __CreateInstance(global::VkDeviceT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceT.__Internal));
        *(global::VkDeviceT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceT(global::VkDeviceT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkQueueT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueueT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueueT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkQueueT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkQueueT(native.ToPointer(), skipVTables);
    }

    internal static global::VkQueueT __CreateInstance(global::VkQueueT.__Internal native, bool skipVTables = false)
    {
        return new global::VkQueueT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkQueueT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkQueueT.__Internal));
        *(global::VkQueueT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkQueueT(global::VkQueueT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkQueueT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkSemaphoreT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSemaphoreT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSemaphoreT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSemaphoreT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSemaphoreT(native.ToPointer(), skipVTables);
    }

    internal static global::VkSemaphoreT __CreateInstance(global::VkSemaphoreT.__Internal native, bool skipVTables = false)
    {
        return new global::VkSemaphoreT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSemaphoreT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSemaphoreT.__Internal));
        *(global::VkSemaphoreT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSemaphoreT(global::VkSemaphoreT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSemaphoreT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkCommandBufferT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCommandBufferT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCommandBufferT(native.ToPointer(), skipVTables);
    }

    internal static global::VkCommandBufferT __CreateInstance(global::VkCommandBufferT.__Internal native, bool skipVTables = false)
    {
        return new global::VkCommandBufferT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCommandBufferT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferT.__Internal));
        *(global::VkCommandBufferT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCommandBufferT(global::VkCommandBufferT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCommandBufferT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkFenceT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFenceT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFenceT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkFenceT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkFenceT(native.ToPointer(), skipVTables);
    }

    internal static global::VkFenceT __CreateInstance(global::VkFenceT.__Internal native, bool skipVTables = false)
    {
        return new global::VkFenceT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkFenceT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkFenceT.__Internal));
        *(global::VkFenceT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkFenceT(global::VkFenceT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkFenceT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDeviceMemoryT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceMemoryT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceMemoryT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceMemoryT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceMemoryT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceMemoryT __CreateInstance(global::VkDeviceMemoryT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceMemoryT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceMemoryT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceMemoryT.__Internal));
        *(global::VkDeviceMemoryT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceMemoryT(global::VkDeviceMemoryT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceMemoryT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkBufferT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBufferT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBufferT(native.ToPointer(), skipVTables);
    }

    internal static global::VkBufferT __CreateInstance(global::VkBufferT.__Internal native, bool skipVTables = false)
    {
        return new global::VkBufferT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBufferT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBufferT.__Internal));
        *(global::VkBufferT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBufferT(global::VkBufferT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBufferT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkImageT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageT(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageT __CreateInstance(global::VkImageT.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageT.__Internal));
        *(global::VkImageT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageT(global::VkImageT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkEventT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkEventT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkEventT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkEventT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkEventT(native.ToPointer(), skipVTables);
    }

    internal static global::VkEventT __CreateInstance(global::VkEventT.__Internal native, bool skipVTables = false)
    {
        return new global::VkEventT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkEventT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkEventT.__Internal));
        *(global::VkEventT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkEventT(global::VkEventT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkEventT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkQueryPoolT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueryPoolT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueryPoolT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkQueryPoolT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkQueryPoolT(native.ToPointer(), skipVTables);
    }

    internal static global::VkQueryPoolT __CreateInstance(global::VkQueryPoolT.__Internal native, bool skipVTables = false)
    {
        return new global::VkQueryPoolT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkQueryPoolT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkQueryPoolT.__Internal));
        *(global::VkQueryPoolT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkQueryPoolT(global::VkQueryPoolT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkQueryPoolT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkBufferViewT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferViewT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferViewT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBufferViewT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBufferViewT(native.ToPointer(), skipVTables);
    }

    internal static global::VkBufferViewT __CreateInstance(global::VkBufferViewT.__Internal native, bool skipVTables = false)
    {
        return new global::VkBufferViewT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBufferViewT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBufferViewT.__Internal));
        *(global::VkBufferViewT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBufferViewT(global::VkBufferViewT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBufferViewT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkImageViewT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageViewT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageViewT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageViewT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageViewT(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageViewT __CreateInstance(global::VkImageViewT.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageViewT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageViewT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageViewT.__Internal));
        *(global::VkImageViewT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageViewT(global::VkImageViewT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageViewT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkShaderModuleT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderModuleT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderModuleT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkShaderModuleT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkShaderModuleT(native.ToPointer(), skipVTables);
    }

    internal static global::VkShaderModuleT __CreateInstance(global::VkShaderModuleT.__Internal native, bool skipVTables = false)
    {
        return new global::VkShaderModuleT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkShaderModuleT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkShaderModuleT.__Internal));
        *(global::VkShaderModuleT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkShaderModuleT(global::VkShaderModuleT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkShaderModuleT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkPipelineCacheT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineCacheT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineCacheT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineCacheT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineCacheT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineCacheT __CreateInstance(global::VkPipelineCacheT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineCacheT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineCacheT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineCacheT.__Internal));
        *(global::VkPipelineCacheT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineCacheT(global::VkPipelineCacheT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineCacheT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkPipelineLayoutT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineLayoutT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineLayoutT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineLayoutT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineLayoutT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineLayoutT __CreateInstance(global::VkPipelineLayoutT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineLayoutT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineLayoutT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineLayoutT.__Internal));
        *(global::VkPipelineLayoutT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineLayoutT(global::VkPipelineLayoutT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineLayoutT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkRenderPassT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRenderPassT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRenderPassT(native.ToPointer(), skipVTables);
    }

    internal static global::VkRenderPassT __CreateInstance(global::VkRenderPassT.__Internal native, bool skipVTables = false)
    {
        return new global::VkRenderPassT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRenderPassT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRenderPassT.__Internal));
        *(global::VkRenderPassT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRenderPassT(global::VkRenderPassT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRenderPassT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkPipelineT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineT __CreateInstance(global::VkPipelineT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineT.__Internal));
        *(global::VkPipelineT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineT(global::VkPipelineT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDescriptorSetLayoutT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorSetLayoutT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorSetLayoutT __CreateInstance(global::VkDescriptorSetLayoutT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorSetLayoutT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutT.__Internal));
        *(global::VkDescriptorSetLayoutT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorSetLayoutT(global::VkDescriptorSetLayoutT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorSetLayoutT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkSamplerT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSamplerT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSamplerT(native.ToPointer(), skipVTables);
    }

    internal static global::VkSamplerT __CreateInstance(global::VkSamplerT.__Internal native, bool skipVTables = false)
    {
        return new global::VkSamplerT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSamplerT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSamplerT.__Internal));
        *(global::VkSamplerT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSamplerT(global::VkSamplerT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSamplerT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDescriptorPoolT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorPoolT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorPoolT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorPoolT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorPoolT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorPoolT __CreateInstance(global::VkDescriptorPoolT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorPoolT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorPoolT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorPoolT.__Internal));
        *(global::VkDescriptorPoolT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorPoolT(global::VkDescriptorPoolT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorPoolT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDescriptorSetT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorSetT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorSetT __CreateInstance(global::VkDescriptorSetT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorSetT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetT.__Internal));
        *(global::VkDescriptorSetT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorSetT(global::VkDescriptorSetT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorSetT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkFramebufferT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFramebufferT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFramebufferT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkFramebufferT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkFramebufferT(native.ToPointer(), skipVTables);
    }

    internal static global::VkFramebufferT __CreateInstance(global::VkFramebufferT.__Internal native, bool skipVTables = false)
    {
        return new global::VkFramebufferT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkFramebufferT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkFramebufferT.__Internal));
        *(global::VkFramebufferT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkFramebufferT(global::VkFramebufferT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkFramebufferT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkCommandPoolT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandPoolT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandPoolT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCommandPoolT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCommandPoolT(native.ToPointer(), skipVTables);
    }

    internal static global::VkCommandPoolT __CreateInstance(global::VkCommandPoolT.__Internal native, bool skipVTables = false)
    {
        return new global::VkCommandPoolT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCommandPoolT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCommandPoolT.__Internal));
        *(global::VkCommandPoolT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCommandPoolT(global::VkCommandPoolT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCommandPoolT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkApplicationInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr pApplicationName;

        [FieldOffset(24)]
        internal uint applicationVersion;

        [FieldOffset(32)]
        internal global::System.IntPtr pEngineName;

        [FieldOffset(40)]
        internal uint engineVersion;

        [FieldOffset(44)]
        internal uint apiVersion;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkApplicationInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkApplicationInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkApplicationInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkApplicationInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkApplicationInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkApplicationInfo __CreateInstance(global::VkApplicationInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkApplicationInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkApplicationInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkApplicationInfo.__Internal));
        *(global::VkApplicationInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkApplicationInfo(global::VkApplicationInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkApplicationInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkApplicationInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkApplicationInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkApplicationInfo(global::VkApplicationInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkApplicationInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkApplicationInfo.__Internal*) __Instance) = *((global::VkApplicationInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkApplicationInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkApplicationInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkApplicationInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkApplicationInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkApplicationInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public string PApplicationName
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkApplicationInfo.__Internal*) __Instance)->pApplicationName);
        }

        set
        {
            ((global::VkApplicationInfo.__Internal*)__Instance)->pApplicationName = Marshal.StringToHGlobalAnsi(value);
        }
    }

    public uint ApplicationVersion
    {
        get
        {
            return ((global::VkApplicationInfo.__Internal*) __Instance)->applicationVersion;
        }

        set
        {
            ((global::VkApplicationInfo.__Internal*)__Instance)->applicationVersion = value;
        }
    }

    public string PEngineName
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkApplicationInfo.__Internal*) __Instance)->pEngineName);
        }

        set
        {
            ((global::VkApplicationInfo.__Internal*)__Instance)->pEngineName = Marshal.StringToHGlobalAnsi(value);
        }
    }

    public uint EngineVersion
    {
        get
        {
            return ((global::VkApplicationInfo.__Internal*) __Instance)->engineVersion;
        }

        set
        {
            ((global::VkApplicationInfo.__Internal*)__Instance)->engineVersion = value;
        }
    }

    public uint ApiVersion
    {
        get
        {
            return ((global::VkApplicationInfo.__Internal*) __Instance)->apiVersion;
        }

        set
        {
            ((global::VkApplicationInfo.__Internal*)__Instance)->apiVersion = value;
        }
    }
}

public unsafe partial class VkInstanceCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::System.IntPtr pApplicationInfo;

        [FieldOffset(32)]
        internal uint enabledLayerCount;

        [FieldOffset(40)]
        internal global::System.IntPtr ppEnabledLayerNames;

        [FieldOffset(48)]
        internal uint enabledExtensionCount;

        [FieldOffset(56)]
        internal global::System.IntPtr ppEnabledExtensionNames;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkInstanceCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkInstanceCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkInstanceCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkInstanceCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkInstanceCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkInstanceCreateInfo __CreateInstance(global::VkInstanceCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkInstanceCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkInstanceCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkInstanceCreateInfo.__Internal));
        *(global::VkInstanceCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkInstanceCreateInfo(global::VkInstanceCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkInstanceCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkInstanceCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkInstanceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkInstanceCreateInfo(global::VkInstanceCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkInstanceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkInstanceCreateInfo.__Internal*) __Instance) = *((global::VkInstanceCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkInstanceCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkInstanceCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkInstanceCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkInstanceCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkInstanceCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkInstanceCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkInstanceCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkApplicationInfo PApplicationInfo
    {
        get
        {
            global::VkApplicationInfo __result0;
            if (((global::VkInstanceCreateInfo.__Internal*) __Instance)->pApplicationInfo == IntPtr.Zero) __result0 = null;
            else if (global::VkApplicationInfo.NativeToManagedMap.ContainsKey(((global::VkInstanceCreateInfo.__Internal*) __Instance)->pApplicationInfo))
                __result0 = (global::VkApplicationInfo) global::VkApplicationInfo.NativeToManagedMap[((global::VkInstanceCreateInfo.__Internal*) __Instance)->pApplicationInfo];
            else __result0 = global::VkApplicationInfo.__CreateInstance(((global::VkInstanceCreateInfo.__Internal*) __Instance)->pApplicationInfo);
            return __result0;
        }

        set
        {
            ((global::VkInstanceCreateInfo.__Internal*)__Instance)->pApplicationInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint EnabledLayerCount
    {
        get
        {
            return ((global::VkInstanceCreateInfo.__Internal*) __Instance)->enabledLayerCount;
        }

        set
        {
            ((global::VkInstanceCreateInfo.__Internal*)__Instance)->enabledLayerCount = value;
        }
    }

    public char** PpEnabledLayerNames
    {
        get
        {
            return (char**) ((global::VkInstanceCreateInfo.__Internal*) __Instance)->ppEnabledLayerNames;
        }

        set
        {
            ((global::VkInstanceCreateInfo.__Internal*)__Instance)->ppEnabledLayerNames = (global::System.IntPtr) (sbyte**) value;
        }
    }

    public uint EnabledExtensionCount
    {
        get
        {
            return ((global::VkInstanceCreateInfo.__Internal*) __Instance)->enabledExtensionCount;
        }

        set
        {
            ((global::VkInstanceCreateInfo.__Internal*)__Instance)->enabledExtensionCount = value;
        }
    }

    public char** PpEnabledExtensionNames
    {
        get
        {
            return (char**) ((global::VkInstanceCreateInfo.__Internal*) __Instance)->ppEnabledExtensionNames;
        }

        set
        {
            ((global::VkInstanceCreateInfo.__Internal*)__Instance)->ppEnabledExtensionNames = (global::System.IntPtr) (sbyte**) value;
        }
    }
}

public unsafe partial class VkAllocationCallbacks : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr pUserData;

        [FieldOffset(8)]
        internal global::System.IntPtr pfnAllocation;

        [FieldOffset(16)]
        internal global::System.IntPtr pfnReallocation;

        [FieldOffset(24)]
        internal global::System.IntPtr pfnFree;

        [FieldOffset(32)]
        internal global::System.IntPtr pfnInternalAllocation;

        [FieldOffset(40)]
        internal global::System.IntPtr pfnInternalFree;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkAllocationCallbacks@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAllocationCallbacks> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAllocationCallbacks>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkAllocationCallbacks __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkAllocationCallbacks(native.ToPointer(), skipVTables);
    }

    internal static global::VkAllocationCallbacks __CreateInstance(global::VkAllocationCallbacks.__Internal native, bool skipVTables = false)
    {
        return new global::VkAllocationCallbacks(native, skipVTables);
    }

    private static void* __CopyValue(global::VkAllocationCallbacks.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkAllocationCallbacks.__Internal));
        *(global::VkAllocationCallbacks.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkAllocationCallbacks(global::VkAllocationCallbacks.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkAllocationCallbacks(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkAllocationCallbacks()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAllocationCallbacks.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkAllocationCallbacks(global::VkAllocationCallbacks _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAllocationCallbacks.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkAllocationCallbacks.__Internal*) __Instance) = *((global::VkAllocationCallbacks.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkAllocationCallbacks __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::System.IntPtr PUserData
    {
        get
        {
            return ((global::VkAllocationCallbacks.__Internal*) __Instance)->pUserData;
        }

        set
        {
            ((global::VkAllocationCallbacks.__Internal*)__Instance)->pUserData = (global::System.IntPtr) value;
        }
    }

    public global::PFN_vkAllocationFunction PfnAllocation
    {
        get
        {
            var __ptr0 = ((global::VkAllocationCallbacks.__Internal*) __Instance)->pfnAllocation;
            return __ptr0 == IntPtr.Zero? null : (global::PFN_vkAllocationFunction) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PFN_vkAllocationFunction));
        }

        set
        {
            ((global::VkAllocationCallbacks.__Internal*)__Instance)->pfnAllocation = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
        }
    }

    public global::PFN_vkReallocationFunction PfnReallocation
    {
        get
        {
            var __ptr0 = ((global::VkAllocationCallbacks.__Internal*) __Instance)->pfnReallocation;
            return __ptr0 == IntPtr.Zero? null : (global::PFN_vkReallocationFunction) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PFN_vkReallocationFunction));
        }

        set
        {
            ((global::VkAllocationCallbacks.__Internal*)__Instance)->pfnReallocation = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
        }
    }

    public global::PFN_vkFreeFunction PfnFree
    {
        get
        {
            var __ptr0 = ((global::VkAllocationCallbacks.__Internal*) __Instance)->pfnFree;
            return __ptr0 == IntPtr.Zero? null : (global::PFN_vkFreeFunction) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PFN_vkFreeFunction));
        }

        set
        {
            ((global::VkAllocationCallbacks.__Internal*)__Instance)->pfnFree = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
        }
    }

    public global::PFN_vkInternalAllocationNotification PfnInternalAllocation
    {
        get
        {
            var __ptr0 = ((global::VkAllocationCallbacks.__Internal*) __Instance)->pfnInternalAllocation;
            return __ptr0 == IntPtr.Zero? null : (global::PFN_vkInternalAllocationNotification) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PFN_vkInternalAllocationNotification));
        }

        set
        {
            ((global::VkAllocationCallbacks.__Internal*)__Instance)->pfnInternalAllocation = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
        }
    }

    public global::PFN_vkInternalFreeNotification PfnInternalFree
    {
        get
        {
            var __ptr0 = ((global::VkAllocationCallbacks.__Internal*) __Instance)->pfnInternalFree;
            return __ptr0 == IntPtr.Zero? null : (global::PFN_vkInternalFreeNotification) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PFN_vkInternalFreeNotification));
        }

        set
        {
            ((global::VkAllocationCallbacks.__Internal*)__Instance)->pfnInternalFree = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
        }
    }
}

public unsafe partial class VkPhysicalDeviceFeatures : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 220)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint robustBufferAccess;

        [FieldOffset(4)]
        internal uint fullDrawIndexUint32;

        [FieldOffset(8)]
        internal uint imageCubeArray;

        [FieldOffset(12)]
        internal uint independentBlend;

        [FieldOffset(16)]
        internal uint geometryShader;

        [FieldOffset(20)]
        internal uint tessellationShader;

        [FieldOffset(24)]
        internal uint sampleRateShading;

        [FieldOffset(28)]
        internal uint dualSrcBlend;

        [FieldOffset(32)]
        internal uint logicOp;

        [FieldOffset(36)]
        internal uint multiDrawIndirect;

        [FieldOffset(40)]
        internal uint drawIndirectFirstInstance;

        [FieldOffset(44)]
        internal uint depthClamp;

        [FieldOffset(48)]
        internal uint depthBiasClamp;

        [FieldOffset(52)]
        internal uint fillModeNonSolid;

        [FieldOffset(56)]
        internal uint depthBounds;

        [FieldOffset(60)]
        internal uint wideLines;

        [FieldOffset(64)]
        internal uint largePoints;

        [FieldOffset(68)]
        internal uint alphaToOne;

        [FieldOffset(72)]
        internal uint multiViewport;

        [FieldOffset(76)]
        internal uint samplerAnisotropy;

        [FieldOffset(80)]
        internal uint textureCompressionETC2;

        [FieldOffset(84)]
        internal uint textureCompressionASTC_LDR;

        [FieldOffset(88)]
        internal uint textureCompressionBC;

        [FieldOffset(92)]
        internal uint occlusionQueryPrecise;

        [FieldOffset(96)]
        internal uint pipelineStatisticsQuery;

        [FieldOffset(100)]
        internal uint vertexPipelineStoresAndAtomics;

        [FieldOffset(104)]
        internal uint fragmentStoresAndAtomics;

        [FieldOffset(108)]
        internal uint shaderTessellationAndGeometryPointSize;

        [FieldOffset(112)]
        internal uint shaderImageGatherExtended;

        [FieldOffset(116)]
        internal uint shaderStorageImageExtendedFormats;

        [FieldOffset(120)]
        internal uint shaderStorageImageMultisample;

        [FieldOffset(124)]
        internal uint shaderStorageImageReadWithoutFormat;

        [FieldOffset(128)]
        internal uint shaderStorageImageWriteWithoutFormat;

        [FieldOffset(132)]
        internal uint shaderUniformBufferArrayDynamicIndexing;

        [FieldOffset(136)]
        internal uint shaderSampledImageArrayDynamicIndexing;

        [FieldOffset(140)]
        internal uint shaderStorageBufferArrayDynamicIndexing;

        [FieldOffset(144)]
        internal uint shaderStorageImageArrayDynamicIndexing;

        [FieldOffset(148)]
        internal uint shaderClipDistance;

        [FieldOffset(152)]
        internal uint shaderCullDistance;

        [FieldOffset(156)]
        internal uint shaderFloat64;

        [FieldOffset(160)]
        internal uint shaderInt64;

        [FieldOffset(164)]
        internal uint shaderInt16;

        [FieldOffset(168)]
        internal uint shaderResourceResidency;

        [FieldOffset(172)]
        internal uint shaderResourceMinLod;

        [FieldOffset(176)]
        internal uint sparseBinding;

        [FieldOffset(180)]
        internal uint sparseResidencyBuffer;

        [FieldOffset(184)]
        internal uint sparseResidencyImage2D;

        [FieldOffset(188)]
        internal uint sparseResidencyImage3D;

        [FieldOffset(192)]
        internal uint sparseResidency2Samples;

        [FieldOffset(196)]
        internal uint sparseResidency4Samples;

        [FieldOffset(200)]
        internal uint sparseResidency8Samples;

        [FieldOffset(204)]
        internal uint sparseResidency16Samples;

        [FieldOffset(208)]
        internal uint sparseResidencyAliased;

        [FieldOffset(212)]
        internal uint variableMultisampleRate;

        [FieldOffset(216)]
        internal uint inheritedQueries;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceFeatures@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceFeatures> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceFeatures>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceFeatures __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceFeatures(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceFeatures __CreateInstance(global::VkPhysicalDeviceFeatures.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceFeatures(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceFeatures.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceFeatures.__Internal));
        *(global::VkPhysicalDeviceFeatures.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceFeatures(global::VkPhysicalDeviceFeatures.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceFeatures(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceFeatures(global::VkPhysicalDeviceFeatures _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceFeatures.__Internal*) __Instance) = *((global::VkPhysicalDeviceFeatures.__Internal*) _0.__Instance);
    }

    public VkPhysicalDeviceFeatures()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceFeatures __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint RobustBufferAccess
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->robustBufferAccess;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->robustBufferAccess = value;
        }
    }

    public uint FullDrawIndexUint32
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->fullDrawIndexUint32;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->fullDrawIndexUint32 = value;
        }
    }

    public uint ImageCubeArray
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->imageCubeArray;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->imageCubeArray = value;
        }
    }

    public uint IndependentBlend
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->independentBlend;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->independentBlend = value;
        }
    }

    public uint GeometryShader
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->geometryShader;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->geometryShader = value;
        }
    }

    public uint TessellationShader
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->tessellationShader;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->tessellationShader = value;
        }
    }

    public uint SampleRateShading
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sampleRateShading;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sampleRateShading = value;
        }
    }

    public uint DualSrcBlend
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->dualSrcBlend;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->dualSrcBlend = value;
        }
    }

    public uint LogicOp
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->logicOp;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->logicOp = value;
        }
    }

    public uint MultiDrawIndirect
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->multiDrawIndirect;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->multiDrawIndirect = value;
        }
    }

    public uint DrawIndirectFirstInstance
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->drawIndirectFirstInstance;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->drawIndirectFirstInstance = value;
        }
    }

    public uint DepthClamp
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->depthClamp;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->depthClamp = value;
        }
    }

    public uint DepthBiasClamp
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->depthBiasClamp;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->depthBiasClamp = value;
        }
    }

    public uint FillModeNonSolid
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->fillModeNonSolid;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->fillModeNonSolid = value;
        }
    }

    public uint DepthBounds
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->depthBounds;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->depthBounds = value;
        }
    }

    public uint WideLines
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->wideLines;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->wideLines = value;
        }
    }

    public uint LargePoints
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->largePoints;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->largePoints = value;
        }
    }

    public uint AlphaToOne
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->alphaToOne;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->alphaToOne = value;
        }
    }

    public uint MultiViewport
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->multiViewport;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->multiViewport = value;
        }
    }

    public uint SamplerAnisotropy
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->samplerAnisotropy;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->samplerAnisotropy = value;
        }
    }

    public uint TextureCompressionETC2
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->textureCompressionETC2;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->textureCompressionETC2 = value;
        }
    }

    public uint TextureCompressionASTC_LDR
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->textureCompressionASTC_LDR;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->textureCompressionASTC_LDR = value;
        }
    }

    public uint TextureCompressionBC
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->textureCompressionBC;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->textureCompressionBC = value;
        }
    }

    public uint OcclusionQueryPrecise
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->occlusionQueryPrecise;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->occlusionQueryPrecise = value;
        }
    }

    public uint PipelineStatisticsQuery
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->pipelineStatisticsQuery;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->pipelineStatisticsQuery = value;
        }
    }

    public uint VertexPipelineStoresAndAtomics
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->vertexPipelineStoresAndAtomics;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->vertexPipelineStoresAndAtomics = value;
        }
    }

    public uint FragmentStoresAndAtomics
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->fragmentStoresAndAtomics;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->fragmentStoresAndAtomics = value;
        }
    }

    public uint ShaderTessellationAndGeometryPointSize
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderTessellationAndGeometryPointSize;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderTessellationAndGeometryPointSize = value;
        }
    }

    public uint ShaderImageGatherExtended
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderImageGatherExtended;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderImageGatherExtended = value;
        }
    }

    public uint ShaderStorageImageExtendedFormats
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderStorageImageExtendedFormats;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderStorageImageExtendedFormats = value;
        }
    }

    public uint ShaderStorageImageMultisample
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderStorageImageMultisample;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderStorageImageMultisample = value;
        }
    }

    public uint ShaderStorageImageReadWithoutFormat
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderStorageImageReadWithoutFormat;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderStorageImageReadWithoutFormat = value;
        }
    }

    public uint ShaderStorageImageWriteWithoutFormat
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderStorageImageWriteWithoutFormat;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderStorageImageWriteWithoutFormat = value;
        }
    }

    public uint ShaderUniformBufferArrayDynamicIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderUniformBufferArrayDynamicIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderUniformBufferArrayDynamicIndexing = value;
        }
    }

    public uint ShaderSampledImageArrayDynamicIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderSampledImageArrayDynamicIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderSampledImageArrayDynamicIndexing = value;
        }
    }

    public uint ShaderStorageBufferArrayDynamicIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderStorageBufferArrayDynamicIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderStorageBufferArrayDynamicIndexing = value;
        }
    }

    public uint ShaderStorageImageArrayDynamicIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderStorageImageArrayDynamicIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderStorageImageArrayDynamicIndexing = value;
        }
    }

    public uint ShaderClipDistance
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderClipDistance;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderClipDistance = value;
        }
    }

    public uint ShaderCullDistance
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderCullDistance;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderCullDistance = value;
        }
    }

    public uint ShaderFloat64
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderFloat64;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderFloat64 = value;
        }
    }

    public uint ShaderInt64
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderInt64;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderInt64 = value;
        }
    }

    public uint ShaderInt16
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderInt16;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderInt16 = value;
        }
    }

    public uint ShaderResourceResidency
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderResourceResidency;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderResourceResidency = value;
        }
    }

    public uint ShaderResourceMinLod
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->shaderResourceMinLod;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->shaderResourceMinLod = value;
        }
    }

    public uint SparseBinding
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sparseBinding;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sparseBinding = value;
        }
    }

    public uint SparseResidencyBuffer
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sparseResidencyBuffer;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sparseResidencyBuffer = value;
        }
    }

    public uint SparseResidencyImage2D
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sparseResidencyImage2D;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sparseResidencyImage2D = value;
        }
    }

    public uint SparseResidencyImage3D
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sparseResidencyImage3D;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sparseResidencyImage3D = value;
        }
    }

    public uint SparseResidency2Samples
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sparseResidency2Samples;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sparseResidency2Samples = value;
        }
    }

    public uint SparseResidency4Samples
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sparseResidency4Samples;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sparseResidency4Samples = value;
        }
    }

    public uint SparseResidency8Samples
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sparseResidency8Samples;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sparseResidency8Samples = value;
        }
    }

    public uint SparseResidency16Samples
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sparseResidency16Samples;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sparseResidency16Samples = value;
        }
    }

    public uint SparseResidencyAliased
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->sparseResidencyAliased;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->sparseResidencyAliased = value;
        }
    }

    public uint VariableMultisampleRate
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->variableMultisampleRate;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->variableMultisampleRate = value;
        }
    }

    public uint InheritedQueries
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures.__Internal*) __Instance)->inheritedQueries;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures.__Internal*)__Instance)->inheritedQueries = value;
        }
    }
}

public unsafe partial class VkFormatProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint linearTilingFeatures;

        [FieldOffset(4)]
        internal uint optimalTilingFeatures;

        [FieldOffset(8)]
        internal uint bufferFeatures;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkFormatProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFormatProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFormatProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkFormatProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkFormatProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkFormatProperties __CreateInstance(global::VkFormatProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkFormatProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkFormatProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkFormatProperties.__Internal));
        *(global::VkFormatProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkFormatProperties(global::VkFormatProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkFormatProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkFormatProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkFormatProperties(global::VkFormatProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkFormatProperties.__Internal*) __Instance) = *((global::VkFormatProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkFormatProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint LinearTilingFeatures
    {
        get
        {
            return ((global::VkFormatProperties.__Internal*) __Instance)->linearTilingFeatures;
        }

        set
        {
            ((global::VkFormatProperties.__Internal*)__Instance)->linearTilingFeatures = value;
        }
    }

    public uint OptimalTilingFeatures
    {
        get
        {
            return ((global::VkFormatProperties.__Internal*) __Instance)->optimalTilingFeatures;
        }

        set
        {
            ((global::VkFormatProperties.__Internal*)__Instance)->optimalTilingFeatures = value;
        }
    }

    public uint BufferFeatures
    {
        get
        {
            return ((global::VkFormatProperties.__Internal*) __Instance)->bufferFeatures;
        }

        set
        {
            ((global::VkFormatProperties.__Internal*)__Instance)->bufferFeatures = value;
        }
    }
}

public unsafe partial class VkExtent3D : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint width;

        [FieldOffset(4)]
        internal uint height;

        [FieldOffset(8)]
        internal uint depth;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExtent3D@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExtent3D> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExtent3D>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExtent3D __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExtent3D(native.ToPointer(), skipVTables);
    }

    internal static global::VkExtent3D __CreateInstance(global::VkExtent3D.__Internal native, bool skipVTables = false)
    {
        return new global::VkExtent3D(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExtent3D.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExtent3D.__Internal));
        *(global::VkExtent3D.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExtent3D(global::VkExtent3D.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExtent3D(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExtent3D()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExtent3D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExtent3D(global::VkExtent3D _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExtent3D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExtent3D.__Internal*) __Instance) = *((global::VkExtent3D.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExtent3D __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Width
    {
        get
        {
            return ((global::VkExtent3D.__Internal*) __Instance)->width;
        }

        set
        {
            ((global::VkExtent3D.__Internal*)__Instance)->width = value;
        }
    }

    public uint Height
    {
        get
        {
            return ((global::VkExtent3D.__Internal*) __Instance)->height;
        }

        set
        {
            ((global::VkExtent3D.__Internal*)__Instance)->height = value;
        }
    }

    public uint Depth
    {
        get
        {
            return ((global::VkExtent3D.__Internal*) __Instance)->depth;
        }

        set
        {
            ((global::VkExtent3D.__Internal*)__Instance)->depth = value;
        }
    }
}

public unsafe partial class VkImageFormatProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkExtent3D.__Internal maxExtent;

        [FieldOffset(12)]
        internal uint maxMipLevels;

        [FieldOffset(16)]
        internal uint maxArrayLayers;

        [FieldOffset(20)]
        internal uint sampleCounts;

        [FieldOffset(24)]
        internal ulong maxResourceSize;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageFormatProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageFormatProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageFormatProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageFormatProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageFormatProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageFormatProperties __CreateInstance(global::VkImageFormatProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageFormatProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageFormatProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageFormatProperties.__Internal));
        *(global::VkImageFormatProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageFormatProperties(global::VkImageFormatProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageFormatProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageFormatProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageFormatProperties(global::VkImageFormatProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageFormatProperties.__Internal*) __Instance) = *((global::VkImageFormatProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageFormatProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkExtent3D MaxExtent
    {
        get
        {
            return global::VkExtent3D.__CreateInstance(new global::System.IntPtr(&((global::VkImageFormatProperties.__Internal*) __Instance)->maxExtent));
        }

        set
        {
            ((global::VkImageFormatProperties.__Internal*)__Instance)->maxExtent = ReferenceEquals(value, null) ? new global::VkExtent3D.__Internal() : *(global::VkExtent3D.__Internal*) value.__Instance;
        }
    }

    public uint MaxMipLevels
    {
        get
        {
            return ((global::VkImageFormatProperties.__Internal*) __Instance)->maxMipLevels;
        }

        set
        {
            ((global::VkImageFormatProperties.__Internal*)__Instance)->maxMipLevels = value;
        }
    }

    public uint MaxArrayLayers
    {
        get
        {
            return ((global::VkImageFormatProperties.__Internal*) __Instance)->maxArrayLayers;
        }

        set
        {
            ((global::VkImageFormatProperties.__Internal*)__Instance)->maxArrayLayers = value;
        }
    }

    public uint SampleCounts
    {
        get
        {
            return ((global::VkImageFormatProperties.__Internal*) __Instance)->sampleCounts;
        }

        set
        {
            ((global::VkImageFormatProperties.__Internal*)__Instance)->sampleCounts = value;
        }
    }

    public ulong MaxResourceSize
    {
        get
        {
            return ((global::VkImageFormatProperties.__Internal*) __Instance)->maxResourceSize;
        }

        set
        {
            ((global::VkImageFormatProperties.__Internal*)__Instance)->maxResourceSize = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceLimits : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 504)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint maxImageDimension1D;

        [FieldOffset(4)]
        internal uint maxImageDimension2D;

        [FieldOffset(8)]
        internal uint maxImageDimension3D;

        [FieldOffset(12)]
        internal uint maxImageDimensionCube;

        [FieldOffset(16)]
        internal uint maxImageArrayLayers;

        [FieldOffset(20)]
        internal uint maxTexelBufferElements;

        [FieldOffset(24)]
        internal uint maxUniformBufferRange;

        [FieldOffset(28)]
        internal uint maxStorageBufferRange;

        [FieldOffset(32)]
        internal uint maxPushConstantsSize;

        [FieldOffset(36)]
        internal uint maxMemoryAllocationCount;

        [FieldOffset(40)]
        internal uint maxSamplerAllocationCount;

        [FieldOffset(48)]
        internal ulong bufferImageGranularity;

        [FieldOffset(56)]
        internal ulong sparseAddressSpaceSize;

        [FieldOffset(64)]
        internal uint maxBoundDescriptorSets;

        [FieldOffset(68)]
        internal uint maxPerStageDescriptorSamplers;

        [FieldOffset(72)]
        internal uint maxPerStageDescriptorUniformBuffers;

        [FieldOffset(76)]
        internal uint maxPerStageDescriptorStorageBuffers;

        [FieldOffset(80)]
        internal uint maxPerStageDescriptorSampledImages;

        [FieldOffset(84)]
        internal uint maxPerStageDescriptorStorageImages;

        [FieldOffset(88)]
        internal uint maxPerStageDescriptorInputAttachments;

        [FieldOffset(92)]
        internal uint maxPerStageResources;

        [FieldOffset(96)]
        internal uint maxDescriptorSetSamplers;

        [FieldOffset(100)]
        internal uint maxDescriptorSetUniformBuffers;

        [FieldOffset(104)]
        internal uint maxDescriptorSetUniformBuffersDynamic;

        [FieldOffset(108)]
        internal uint maxDescriptorSetStorageBuffers;

        [FieldOffset(112)]
        internal uint maxDescriptorSetStorageBuffersDynamic;

        [FieldOffset(116)]
        internal uint maxDescriptorSetSampledImages;

        [FieldOffset(120)]
        internal uint maxDescriptorSetStorageImages;

        [FieldOffset(124)]
        internal uint maxDescriptorSetInputAttachments;

        [FieldOffset(128)]
        internal uint maxVertexInputAttributes;

        [FieldOffset(132)]
        internal uint maxVertexInputBindings;

        [FieldOffset(136)]
        internal uint maxVertexInputAttributeOffset;

        [FieldOffset(140)]
        internal uint maxVertexInputBindingStride;

        [FieldOffset(144)]
        internal uint maxVertexOutputComponents;

        [FieldOffset(148)]
        internal uint maxTessellationGenerationLevel;

        [FieldOffset(152)]
        internal uint maxTessellationPatchSize;

        [FieldOffset(156)]
        internal uint maxTessellationControlPerVertexInputComponents;

        [FieldOffset(160)]
        internal uint maxTessellationControlPerVertexOutputComponents;

        [FieldOffset(164)]
        internal uint maxTessellationControlPerPatchOutputComponents;

        [FieldOffset(168)]
        internal uint maxTessellationControlTotalOutputComponents;

        [FieldOffset(172)]
        internal uint maxTessellationEvaluationInputComponents;

        [FieldOffset(176)]
        internal uint maxTessellationEvaluationOutputComponents;

        [FieldOffset(180)]
        internal uint maxGeometryShaderInvocations;

        [FieldOffset(184)]
        internal uint maxGeometryInputComponents;

        [FieldOffset(188)]
        internal uint maxGeometryOutputComponents;

        [FieldOffset(192)]
        internal uint maxGeometryOutputVertices;

        [FieldOffset(196)]
        internal uint maxGeometryTotalOutputComponents;

        [FieldOffset(200)]
        internal uint maxFragmentInputComponents;

        [FieldOffset(204)]
        internal uint maxFragmentOutputAttachments;

        [FieldOffset(208)]
        internal uint maxFragmentDualSrcAttachments;

        [FieldOffset(212)]
        internal uint maxFragmentCombinedOutputResources;

        [FieldOffset(216)]
        internal uint maxComputeSharedMemorySize;

        [FieldOffset(220)]
        internal fixed uint maxComputeWorkGroupCount[3];

        [FieldOffset(232)]
        internal uint maxComputeWorkGroupInvocations;

        [FieldOffset(236)]
        internal fixed uint maxComputeWorkGroupSize[3];

        [FieldOffset(248)]
        internal uint subPixelPrecisionBits;

        [FieldOffset(252)]
        internal uint subTexelPrecisionBits;

        [FieldOffset(256)]
        internal uint mipmapPrecisionBits;

        [FieldOffset(260)]
        internal uint maxDrawIndexedIndexValue;

        [FieldOffset(264)]
        internal uint maxDrawIndirectCount;

        [FieldOffset(268)]
        internal float maxSamplerLodBias;

        [FieldOffset(272)]
        internal float maxSamplerAnisotropy;

        [FieldOffset(276)]
        internal uint maxViewports;

        [FieldOffset(280)]
        internal fixed uint maxViewportDimensions[2];

        [FieldOffset(288)]
        internal fixed float viewportBoundsRange[2];

        [FieldOffset(296)]
        internal uint viewportSubPixelBits;

        [FieldOffset(304)]
        internal ulong minMemoryMapAlignment;

        [FieldOffset(312)]
        internal ulong minTexelBufferOffsetAlignment;

        [FieldOffset(320)]
        internal ulong minUniformBufferOffsetAlignment;

        [FieldOffset(328)]
        internal ulong minStorageBufferOffsetAlignment;

        [FieldOffset(336)]
        internal int minTexelOffset;

        [FieldOffset(340)]
        internal uint maxTexelOffset;

        [FieldOffset(344)]
        internal int minTexelGatherOffset;

        [FieldOffset(348)]
        internal uint maxTexelGatherOffset;

        [FieldOffset(352)]
        internal float minInterpolationOffset;

        [FieldOffset(356)]
        internal float maxInterpolationOffset;

        [FieldOffset(360)]
        internal uint subPixelInterpolationOffsetBits;

        [FieldOffset(364)]
        internal uint maxFramebufferWidth;

        [FieldOffset(368)]
        internal uint maxFramebufferHeight;

        [FieldOffset(372)]
        internal uint maxFramebufferLayers;

        [FieldOffset(376)]
        internal uint framebufferColorSampleCounts;

        [FieldOffset(380)]
        internal uint framebufferDepthSampleCounts;

        [FieldOffset(384)]
        internal uint framebufferStencilSampleCounts;

        [FieldOffset(388)]
        internal uint framebufferNoAttachmentsSampleCounts;

        [FieldOffset(392)]
        internal uint maxColorAttachments;

        [FieldOffset(396)]
        internal uint sampledImageColorSampleCounts;

        [FieldOffset(400)]
        internal uint sampledImageIntegerSampleCounts;

        [FieldOffset(404)]
        internal uint sampledImageDepthSampleCounts;

        [FieldOffset(408)]
        internal uint sampledImageStencilSampleCounts;

        [FieldOffset(412)]
        internal uint storageImageSampleCounts;

        [FieldOffset(416)]
        internal uint maxSampleMaskWords;

        [FieldOffset(420)]
        internal uint timestampComputeAndGraphics;

        [FieldOffset(424)]
        internal float timestampPeriod;

        [FieldOffset(428)]
        internal uint maxClipDistances;

        [FieldOffset(432)]
        internal uint maxCullDistances;

        [FieldOffset(436)]
        internal uint maxCombinedClipAndCullDistances;

        [FieldOffset(440)]
        internal uint discreteQueuePriorities;

        [FieldOffset(444)]
        internal fixed float pointSizeRange[2];

        [FieldOffset(452)]
        internal fixed float lineWidthRange[2];

        [FieldOffset(460)]
        internal float pointSizeGranularity;

        [FieldOffset(464)]
        internal float lineWidthGranularity;

        [FieldOffset(468)]
        internal uint strictLines;

        [FieldOffset(472)]
        internal uint standardSampleLocations;

        [FieldOffset(480)]
        internal ulong optimalBufferCopyOffsetAlignment;

        [FieldOffset(488)]
        internal ulong optimalBufferCopyRowPitchAlignment;

        [FieldOffset(496)]
        internal ulong nonCoherentAtomSize;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceLimits@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceLimits> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceLimits>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceLimits __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceLimits(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceLimits __CreateInstance(global::VkPhysicalDeviceLimits.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceLimits(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceLimits.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceLimits.__Internal));
        *(global::VkPhysicalDeviceLimits.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceLimits(global::VkPhysicalDeviceLimits.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceLimits(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceLimits(global::VkPhysicalDeviceLimits _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceLimits.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceLimits.__Internal*) __Instance) = *((global::VkPhysicalDeviceLimits.__Internal*) _0.__Instance);
    }

    public VkPhysicalDeviceLimits()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceLimits.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceLimits __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint MaxImageDimension1D
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxImageDimension1D;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxImageDimension1D = value;
        }
    }

    public uint MaxImageDimension2D
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxImageDimension2D;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxImageDimension2D = value;
        }
    }

    public uint MaxImageDimension3D
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxImageDimension3D;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxImageDimension3D = value;
        }
    }

    public uint MaxImageDimensionCube
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxImageDimensionCube;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxImageDimensionCube = value;
        }
    }

    public uint MaxImageArrayLayers
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxImageArrayLayers;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxImageArrayLayers = value;
        }
    }

    public uint MaxTexelBufferElements
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTexelBufferElements;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTexelBufferElements = value;
        }
    }

    public uint MaxUniformBufferRange
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxUniformBufferRange;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxUniformBufferRange = value;
        }
    }

    public uint MaxStorageBufferRange
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxStorageBufferRange;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxStorageBufferRange = value;
        }
    }

    public uint MaxPushConstantsSize
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxPushConstantsSize;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxPushConstantsSize = value;
        }
    }

    public uint MaxMemoryAllocationCount
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxMemoryAllocationCount;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxMemoryAllocationCount = value;
        }
    }

    public uint MaxSamplerAllocationCount
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxSamplerAllocationCount;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxSamplerAllocationCount = value;
        }
    }

    public ulong BufferImageGranularity
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->bufferImageGranularity;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->bufferImageGranularity = value;
        }
    }

    public ulong SparseAddressSpaceSize
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->sparseAddressSpaceSize;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->sparseAddressSpaceSize = value;
        }
    }

    public uint MaxBoundDescriptorSets
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxBoundDescriptorSets;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxBoundDescriptorSets = value;
        }
    }

    public uint MaxPerStageDescriptorSamplers
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxPerStageDescriptorSamplers;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxPerStageDescriptorSamplers = value;
        }
    }

    public uint MaxPerStageDescriptorUniformBuffers
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxPerStageDescriptorUniformBuffers;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxPerStageDescriptorUniformBuffers = value;
        }
    }

    public uint MaxPerStageDescriptorStorageBuffers
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxPerStageDescriptorStorageBuffers;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxPerStageDescriptorStorageBuffers = value;
        }
    }

    public uint MaxPerStageDescriptorSampledImages
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxPerStageDescriptorSampledImages;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxPerStageDescriptorSampledImages = value;
        }
    }

    public uint MaxPerStageDescriptorStorageImages
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxPerStageDescriptorStorageImages;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxPerStageDescriptorStorageImages = value;
        }
    }

    public uint MaxPerStageDescriptorInputAttachments
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxPerStageDescriptorInputAttachments;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxPerStageDescriptorInputAttachments = value;
        }
    }

    public uint MaxPerStageResources
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxPerStageResources;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxPerStageResources = value;
        }
    }

    public uint MaxDescriptorSetSamplers
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDescriptorSetSamplers;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDescriptorSetSamplers = value;
        }
    }

    public uint MaxDescriptorSetUniformBuffers
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDescriptorSetUniformBuffers;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDescriptorSetUniformBuffers = value;
        }
    }

    public uint MaxDescriptorSetUniformBuffersDynamic
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDescriptorSetUniformBuffersDynamic;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDescriptorSetUniformBuffersDynamic = value;
        }
    }

    public uint MaxDescriptorSetStorageBuffers
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDescriptorSetStorageBuffers;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDescriptorSetStorageBuffers = value;
        }
    }

    public uint MaxDescriptorSetStorageBuffersDynamic
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDescriptorSetStorageBuffersDynamic;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDescriptorSetStorageBuffersDynamic = value;
        }
    }

    public uint MaxDescriptorSetSampledImages
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDescriptorSetSampledImages;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDescriptorSetSampledImages = value;
        }
    }

    public uint MaxDescriptorSetStorageImages
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDescriptorSetStorageImages;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDescriptorSetStorageImages = value;
        }
    }

    public uint MaxDescriptorSetInputAttachments
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDescriptorSetInputAttachments;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDescriptorSetInputAttachments = value;
        }
    }

    public uint MaxVertexInputAttributes
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxVertexInputAttributes;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxVertexInputAttributes = value;
        }
    }

    public uint MaxVertexInputBindings
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxVertexInputBindings;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxVertexInputBindings = value;
        }
    }

    public uint MaxVertexInputAttributeOffset
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxVertexInputAttributeOffset;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxVertexInputAttributeOffset = value;
        }
    }

    public uint MaxVertexInputBindingStride
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxVertexInputBindingStride;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxVertexInputBindingStride = value;
        }
    }

    public uint MaxVertexOutputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxVertexOutputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxVertexOutputComponents = value;
        }
    }

    public uint MaxTessellationGenerationLevel
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTessellationGenerationLevel;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTessellationGenerationLevel = value;
        }
    }

    public uint MaxTessellationPatchSize
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTessellationPatchSize;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTessellationPatchSize = value;
        }
    }

    public uint MaxTessellationControlPerVertexInputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTessellationControlPerVertexInputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTessellationControlPerVertexInputComponents = value;
        }
    }

    public uint MaxTessellationControlPerVertexOutputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTessellationControlPerVertexOutputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTessellationControlPerVertexOutputComponents = value;
        }
    }

    public uint MaxTessellationControlPerPatchOutputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTessellationControlPerPatchOutputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTessellationControlPerPatchOutputComponents = value;
        }
    }

    public uint MaxTessellationControlTotalOutputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTessellationControlTotalOutputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTessellationControlTotalOutputComponents = value;
        }
    }

    public uint MaxTessellationEvaluationInputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTessellationEvaluationInputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTessellationEvaluationInputComponents = value;
        }
    }

    public uint MaxTessellationEvaluationOutputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTessellationEvaluationOutputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTessellationEvaluationOutputComponents = value;
        }
    }

    public uint MaxGeometryShaderInvocations
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxGeometryShaderInvocations;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxGeometryShaderInvocations = value;
        }
    }

    public uint MaxGeometryInputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxGeometryInputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxGeometryInputComponents = value;
        }
    }

    public uint MaxGeometryOutputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxGeometryOutputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxGeometryOutputComponents = value;
        }
    }

    public uint MaxGeometryOutputVertices
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxGeometryOutputVertices;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxGeometryOutputVertices = value;
        }
    }

    public uint MaxGeometryTotalOutputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxGeometryTotalOutputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxGeometryTotalOutputComponents = value;
        }
    }

    public uint MaxFragmentInputComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxFragmentInputComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxFragmentInputComponents = value;
        }
    }

    public uint MaxFragmentOutputAttachments
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxFragmentOutputAttachments;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxFragmentOutputAttachments = value;
        }
    }

    public uint MaxFragmentDualSrcAttachments
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxFragmentDualSrcAttachments;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxFragmentDualSrcAttachments = value;
        }
    }

    public uint MaxFragmentCombinedOutputResources
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxFragmentCombinedOutputResources;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxFragmentCombinedOutputResources = value;
        }
    }

    public uint MaxComputeSharedMemorySize
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxComputeSharedMemorySize;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxComputeSharedMemorySize = value;
        }
    }

    public uint[] MaxComputeWorkGroupCount
    {
        get
        {
            uint[] __value = null;
            if (((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxComputeWorkGroupCount != null)
            {
                __value = new uint[3];
                for (int i = 0; i < 3; i++)
                    __value[i] = ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxComputeWorkGroupCount[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 3; i++)
                    ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxComputeWorkGroupCount[i] = value[i];
            }
        }
    }

    public uint MaxComputeWorkGroupInvocations
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxComputeWorkGroupInvocations;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxComputeWorkGroupInvocations = value;
        }
    }

    public uint[] MaxComputeWorkGroupSize
    {
        get
        {
            uint[] __value = null;
            if (((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxComputeWorkGroupSize != null)
            {
                __value = new uint[3];
                for (int i = 0; i < 3; i++)
                    __value[i] = ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxComputeWorkGroupSize[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 3; i++)
                    ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxComputeWorkGroupSize[i] = value[i];
            }
        }
    }

    public uint SubPixelPrecisionBits
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->subPixelPrecisionBits;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->subPixelPrecisionBits = value;
        }
    }

    public uint SubTexelPrecisionBits
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->subTexelPrecisionBits;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->subTexelPrecisionBits = value;
        }
    }

    public uint MipmapPrecisionBits
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->mipmapPrecisionBits;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->mipmapPrecisionBits = value;
        }
    }

    public uint MaxDrawIndexedIndexValue
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDrawIndexedIndexValue;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDrawIndexedIndexValue = value;
        }
    }

    public uint MaxDrawIndirectCount
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxDrawIndirectCount;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxDrawIndirectCount = value;
        }
    }

    public float MaxSamplerLodBias
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxSamplerLodBias;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxSamplerLodBias = value;
        }
    }

    public float MaxSamplerAnisotropy
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxSamplerAnisotropy;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxSamplerAnisotropy = value;
        }
    }

    public uint MaxViewports
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxViewports;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxViewports = value;
        }
    }

    public uint[] MaxViewportDimensions
    {
        get
        {
            uint[] __value = null;
            if (((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxViewportDimensions != null)
            {
                __value = new uint[2];
                for (int i = 0; i < 2; i++)
                    __value[i] = ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxViewportDimensions[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 2; i++)
                    ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxViewportDimensions[i] = value[i];
            }
        }
    }

    public float[] ViewportBoundsRange
    {
        get
        {
            float[] __value = null;
            if (((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->viewportBoundsRange != null)
            {
                __value = new float[2];
                for (int i = 0; i < 2; i++)
                    __value[i] = ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->viewportBoundsRange[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 2; i++)
                    ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->viewportBoundsRange[i] = value[i];
            }
        }
    }

    public uint ViewportSubPixelBits
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->viewportSubPixelBits;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->viewportSubPixelBits = value;
        }
    }

    public ulong MinMemoryMapAlignment
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->minMemoryMapAlignment;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->minMemoryMapAlignment = value;
        }
    }

    public ulong MinTexelBufferOffsetAlignment
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->minTexelBufferOffsetAlignment;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->minTexelBufferOffsetAlignment = value;
        }
    }

    public ulong MinUniformBufferOffsetAlignment
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->minUniformBufferOffsetAlignment;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->minUniformBufferOffsetAlignment = value;
        }
    }

    public ulong MinStorageBufferOffsetAlignment
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->minStorageBufferOffsetAlignment;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->minStorageBufferOffsetAlignment = value;
        }
    }

    public int MinTexelOffset
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->minTexelOffset;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->minTexelOffset = value;
        }
    }

    public uint MaxTexelOffset
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTexelOffset;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTexelOffset = value;
        }
    }

    public int MinTexelGatherOffset
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->minTexelGatherOffset;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->minTexelGatherOffset = value;
        }
    }

    public uint MaxTexelGatherOffset
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxTexelGatherOffset;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxTexelGatherOffset = value;
        }
    }

    public float MinInterpolationOffset
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->minInterpolationOffset;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->minInterpolationOffset = value;
        }
    }

    public float MaxInterpolationOffset
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxInterpolationOffset;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxInterpolationOffset = value;
        }
    }

    public uint SubPixelInterpolationOffsetBits
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->subPixelInterpolationOffsetBits;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->subPixelInterpolationOffsetBits = value;
        }
    }

    public uint MaxFramebufferWidth
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxFramebufferWidth;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxFramebufferWidth = value;
        }
    }

    public uint MaxFramebufferHeight
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxFramebufferHeight;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxFramebufferHeight = value;
        }
    }

    public uint MaxFramebufferLayers
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxFramebufferLayers;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxFramebufferLayers = value;
        }
    }

    public uint FramebufferColorSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->framebufferColorSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->framebufferColorSampleCounts = value;
        }
    }

    public uint FramebufferDepthSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->framebufferDepthSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->framebufferDepthSampleCounts = value;
        }
    }

    public uint FramebufferStencilSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->framebufferStencilSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->framebufferStencilSampleCounts = value;
        }
    }

    public uint FramebufferNoAttachmentsSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->framebufferNoAttachmentsSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->framebufferNoAttachmentsSampleCounts = value;
        }
    }

    public uint MaxColorAttachments
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxColorAttachments;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxColorAttachments = value;
        }
    }

    public uint SampledImageColorSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->sampledImageColorSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->sampledImageColorSampleCounts = value;
        }
    }

    public uint SampledImageIntegerSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->sampledImageIntegerSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->sampledImageIntegerSampleCounts = value;
        }
    }

    public uint SampledImageDepthSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->sampledImageDepthSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->sampledImageDepthSampleCounts = value;
        }
    }

    public uint SampledImageStencilSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->sampledImageStencilSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->sampledImageStencilSampleCounts = value;
        }
    }

    public uint StorageImageSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->storageImageSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->storageImageSampleCounts = value;
        }
    }

    public uint MaxSampleMaskWords
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxSampleMaskWords;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxSampleMaskWords = value;
        }
    }

    public uint TimestampComputeAndGraphics
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->timestampComputeAndGraphics;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->timestampComputeAndGraphics = value;
        }
    }

    public float TimestampPeriod
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->timestampPeriod;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->timestampPeriod = value;
        }
    }

    public uint MaxClipDistances
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxClipDistances;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxClipDistances = value;
        }
    }

    public uint MaxCullDistances
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxCullDistances;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxCullDistances = value;
        }
    }

    public uint MaxCombinedClipAndCullDistances
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->maxCombinedClipAndCullDistances;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->maxCombinedClipAndCullDistances = value;
        }
    }

    public uint DiscreteQueuePriorities
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->discreteQueuePriorities;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->discreteQueuePriorities = value;
        }
    }

    public float[] PointSizeRange
    {
        get
        {
            float[] __value = null;
            if (((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->pointSizeRange != null)
            {
                __value = new float[2];
                for (int i = 0; i < 2; i++)
                    __value[i] = ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->pointSizeRange[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 2; i++)
                    ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->pointSizeRange[i] = value[i];
            }
        }
    }

    public float[] LineWidthRange
    {
        get
        {
            float[] __value = null;
            if (((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->lineWidthRange != null)
            {
                __value = new float[2];
                for (int i = 0; i < 2; i++)
                    __value[i] = ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->lineWidthRange[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 2; i++)
                    ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->lineWidthRange[i] = value[i];
            }
        }
    }

    public float PointSizeGranularity
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->pointSizeGranularity;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->pointSizeGranularity = value;
        }
    }

    public float LineWidthGranularity
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->lineWidthGranularity;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->lineWidthGranularity = value;
        }
    }

    public uint StrictLines
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->strictLines;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->strictLines = value;
        }
    }

    public uint StandardSampleLocations
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->standardSampleLocations;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->standardSampleLocations = value;
        }
    }

    public ulong OptimalBufferCopyOffsetAlignment
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->optimalBufferCopyOffsetAlignment;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->optimalBufferCopyOffsetAlignment = value;
        }
    }

    public ulong OptimalBufferCopyRowPitchAlignment
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->optimalBufferCopyRowPitchAlignment;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->optimalBufferCopyRowPitchAlignment = value;
        }
    }

    public ulong NonCoherentAtomSize
    {
        get
        {
            return ((global::VkPhysicalDeviceLimits.__Internal*) __Instance)->nonCoherentAtomSize;
        }

        set
        {
            ((global::VkPhysicalDeviceLimits.__Internal*)__Instance)->nonCoherentAtomSize = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceSparseProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint residencyStandard2DBlockShape;

        [FieldOffset(4)]
        internal uint residencyStandard2DMultisampleBlockShape;

        [FieldOffset(8)]
        internal uint residencyStandard3DBlockShape;

        [FieldOffset(12)]
        internal uint residencyAlignedMipSize;

        [FieldOffset(16)]
        internal uint residencyNonResidentStrict;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceSparseProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSparseProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSparseProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceSparseProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSparseProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceSparseProperties __CreateInstance(global::VkPhysicalDeviceSparseProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSparseProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceSparseProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSparseProperties.__Internal));
        *(global::VkPhysicalDeviceSparseProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceSparseProperties(global::VkPhysicalDeviceSparseProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceSparseProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceSparseProperties(global::VkPhysicalDeviceSparseProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSparseProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceSparseProperties.__Internal*) __Instance) = *((global::VkPhysicalDeviceSparseProperties.__Internal*) _0.__Instance);
    }

    public VkPhysicalDeviceSparseProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSparseProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceSparseProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint ResidencyStandard2DBlockShape
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseProperties.__Internal*) __Instance)->residencyStandard2DBlockShape;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseProperties.__Internal*)__Instance)->residencyStandard2DBlockShape = value;
        }
    }

    public uint ResidencyStandard2DMultisampleBlockShape
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseProperties.__Internal*) __Instance)->residencyStandard2DMultisampleBlockShape;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseProperties.__Internal*)__Instance)->residencyStandard2DMultisampleBlockShape = value;
        }
    }

    public uint ResidencyStandard3DBlockShape
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseProperties.__Internal*) __Instance)->residencyStandard3DBlockShape;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseProperties.__Internal*)__Instance)->residencyStandard3DBlockShape = value;
        }
    }

    public uint ResidencyAlignedMipSize
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseProperties.__Internal*) __Instance)->residencyAlignedMipSize;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseProperties.__Internal*)__Instance)->residencyAlignedMipSize = value;
        }
    }

    public uint ResidencyNonResidentStrict
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseProperties.__Internal*) __Instance)->residencyNonResidentStrict;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseProperties.__Internal*)__Instance)->residencyNonResidentStrict = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 824)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint apiVersion;

        [FieldOffset(4)]
        internal uint driverVersion;

        [FieldOffset(8)]
        internal uint vendorID;

        [FieldOffset(12)]
        internal uint deviceID;

        [FieldOffset(16)]
        internal global::VkPhysicalDeviceType deviceType;

        [FieldOffset(20)]
        internal fixed sbyte deviceName[256];

        [FieldOffset(276)]
        internal fixed byte pipelineCacheUUID[16];

        [FieldOffset(296)]
        internal global::VkPhysicalDeviceLimits.__Internal limits;

        [FieldOffset(800)]
        internal global::VkPhysicalDeviceSparseProperties.__Internal sparseProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceProperties __CreateInstance(global::VkPhysicalDeviceProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProperties.__Internal));
        *(global::VkPhysicalDeviceProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceProperties(global::VkPhysicalDeviceProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceProperties(global::VkPhysicalDeviceProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceProperties.__Internal*) __Instance) = *((global::VkPhysicalDeviceProperties.__Internal*) _0.__Instance);
    }

    public VkPhysicalDeviceProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint ApiVersion
    {
        get
        {
            return ((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->apiVersion;
        }

        set
        {
            ((global::VkPhysicalDeviceProperties.__Internal*)__Instance)->apiVersion = value;
        }
    }

    public uint DriverVersion
    {
        get
        {
            return ((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->driverVersion;
        }

        set
        {
            ((global::VkPhysicalDeviceProperties.__Internal*)__Instance)->driverVersion = value;
        }
    }

    public uint VendorID
    {
        get
        {
            return ((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->vendorID;
        }

        set
        {
            ((global::VkPhysicalDeviceProperties.__Internal*)__Instance)->vendorID = value;
        }
    }

    public uint DeviceID
    {
        get
        {
            return ((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->deviceID;
        }

        set
        {
            ((global::VkPhysicalDeviceProperties.__Internal*)__Instance)->deviceID = value;
        }
    }

    public global::VkPhysicalDeviceType DeviceType
    {
        get
        {
            return ((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->deviceType;
        }

        set
        {
            ((global::VkPhysicalDeviceProperties.__Internal*)__Instance)->deviceType = value;
        }
    }

    public char[] DeviceName
    {
        get
        {
            char[] __value = null;
            if (((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->deviceName != null)
            {
                __value = new char[256];
                for (int i = 0; i < 256; i++)
                    __value[i] = global::System.Convert.ToChar(((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->deviceName[i]);
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 256; i++)
                    ((global::VkPhysicalDeviceProperties.__Internal*)__Instance)->deviceName[i] = global::System.Convert.ToSByte(value[i]);
            }
        }
    }

    public byte[] PipelineCacheUUID
    {
        get
        {
            byte[] __value = null;
            if (((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->pipelineCacheUUID != null)
            {
                __value = new byte[16];
                for (int i = 0; i < 16; i++)
                    __value[i] = ((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->pipelineCacheUUID[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 16; i++)
                    ((global::VkPhysicalDeviceProperties.__Internal*)__Instance)->pipelineCacheUUID[i] = value[i];
            }
        }
    }

    public global::VkPhysicalDeviceLimits Limits
    {
        get
        {
            return global::VkPhysicalDeviceLimits.__CreateInstance(new global::System.IntPtr(&((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->limits));
        }

        set
        {
            ((global::VkPhysicalDeviceProperties.__Internal*)__Instance)->limits = ReferenceEquals(value, null) ? new global::VkPhysicalDeviceLimits.__Internal() : *(global::VkPhysicalDeviceLimits.__Internal*) value.__Instance;
        }
    }

    public global::VkPhysicalDeviceSparseProperties SparseProperties
    {
        get
        {
            return global::VkPhysicalDeviceSparseProperties.__CreateInstance(new global::System.IntPtr(&((global::VkPhysicalDeviceProperties.__Internal*) __Instance)->sparseProperties));
        }

        set
        {
            ((global::VkPhysicalDeviceProperties.__Internal*)__Instance)->sparseProperties = ReferenceEquals(value, null) ? new global::VkPhysicalDeviceSparseProperties.__Internal() : *(global::VkPhysicalDeviceSparseProperties.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkQueueFamilyProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint queueFlags;

        [FieldOffset(4)]
        internal uint queueCount;

        [FieldOffset(8)]
        internal uint timestampValidBits;

        [FieldOffset(12)]
        internal global::VkExtent3D.__Internal minImageTransferGranularity;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkQueueFamilyProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueueFamilyProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueueFamilyProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkQueueFamilyProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkQueueFamilyProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkQueueFamilyProperties __CreateInstance(global::VkQueueFamilyProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkQueueFamilyProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkQueueFamilyProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkQueueFamilyProperties.__Internal));
        *(global::VkQueueFamilyProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkQueueFamilyProperties(global::VkQueueFamilyProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkQueueFamilyProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkQueueFamilyProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkQueueFamilyProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkQueueFamilyProperties(global::VkQueueFamilyProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkQueueFamilyProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkQueueFamilyProperties.__Internal*) __Instance) = *((global::VkQueueFamilyProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkQueueFamilyProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint QueueFlags
    {
        get
        {
            return ((global::VkQueueFamilyProperties.__Internal*) __Instance)->queueFlags;
        }

        set
        {
            ((global::VkQueueFamilyProperties.__Internal*)__Instance)->queueFlags = value;
        }
    }

    public uint QueueCount
    {
        get
        {
            return ((global::VkQueueFamilyProperties.__Internal*) __Instance)->queueCount;
        }

        set
        {
            ((global::VkQueueFamilyProperties.__Internal*)__Instance)->queueCount = value;
        }
    }

    public uint TimestampValidBits
    {
        get
        {
            return ((global::VkQueueFamilyProperties.__Internal*) __Instance)->timestampValidBits;
        }

        set
        {
            ((global::VkQueueFamilyProperties.__Internal*)__Instance)->timestampValidBits = value;
        }
    }

    public global::VkExtent3D MinImageTransferGranularity
    {
        get
        {
            return global::VkExtent3D.__CreateInstance(new global::System.IntPtr(&((global::VkQueueFamilyProperties.__Internal*) __Instance)->minImageTransferGranularity));
        }

        set
        {
            ((global::VkQueueFamilyProperties.__Internal*)__Instance)->minImageTransferGranularity = ReferenceEquals(value, null) ? new global::VkExtent3D.__Internal() : *(global::VkExtent3D.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkMemoryType : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint propertyFlags;

        [FieldOffset(4)]
        internal uint heapIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryType@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryType>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryType(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryType __CreateInstance(global::VkMemoryType.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryType(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryType.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryType.__Internal));
        *(global::VkMemoryType.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryType(global::VkMemoryType.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryType(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryType(global::VkMemoryType _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryType.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryType.__Internal*) __Instance) = *((global::VkMemoryType.__Internal*) _0.__Instance);
    }

    public VkMemoryType()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryType.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryType __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint PropertyFlags
    {
        get
        {
            return ((global::VkMemoryType.__Internal*) __Instance)->propertyFlags;
        }

        set
        {
            ((global::VkMemoryType.__Internal*)__Instance)->propertyFlags = value;
        }
    }

    public uint HeapIndex
    {
        get
        {
            return ((global::VkMemoryType.__Internal*) __Instance)->heapIndex;
        }

        set
        {
            ((global::VkMemoryType.__Internal*)__Instance)->heapIndex = value;
        }
    }
}

public unsafe partial class VkMemoryHeap : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal ulong size;

        [FieldOffset(8)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryHeap@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryHeap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryHeap>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryHeap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryHeap(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryHeap __CreateInstance(global::VkMemoryHeap.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryHeap(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryHeap.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryHeap.__Internal));
        *(global::VkMemoryHeap.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryHeap(global::VkMemoryHeap.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryHeap(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryHeap(global::VkMemoryHeap _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryHeap.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryHeap.__Internal*) __Instance) = *((global::VkMemoryHeap.__Internal*) _0.__Instance);
    }

    public VkMemoryHeap()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryHeap.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryHeap __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public ulong Size
    {
        get
        {
            return ((global::VkMemoryHeap.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkMemoryHeap.__Internal*)__Instance)->size = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkMemoryHeap.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkMemoryHeap.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceMemoryProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 520)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint memoryTypeCount;

        [FieldOffset(4)]
        internal fixed byte memoryTypes[256];

        [FieldOffset(260)]
        internal uint memoryHeapCount;

        [FieldOffset(264)]
        internal fixed byte memoryHeaps[256];

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceMemoryProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMemoryProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMemoryProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceMemoryProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMemoryProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceMemoryProperties __CreateInstance(global::VkPhysicalDeviceMemoryProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMemoryProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceMemoryProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMemoryProperties.__Internal));
        *(global::VkPhysicalDeviceMemoryProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceMemoryProperties(global::VkPhysicalDeviceMemoryProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceMemoryProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceMemoryProperties(global::VkPhysicalDeviceMemoryProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMemoryProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceMemoryProperties.__Internal*) __Instance) = *((global::VkPhysicalDeviceMemoryProperties.__Internal*) _0.__Instance);
    }

    public VkPhysicalDeviceMemoryProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMemoryProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceMemoryProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint MemoryTypeCount
    {
        get
        {
            return ((global::VkPhysicalDeviceMemoryProperties.__Internal*) __Instance)->memoryTypeCount;
        }

        set
        {
            ((global::VkPhysicalDeviceMemoryProperties.__Internal*)__Instance)->memoryTypeCount = value;
        }
    }

    public global::VkMemoryType[] MemoryTypes
    {
        get
        {
            global::VkMemoryType[] __value = null;
            if (((global::VkPhysicalDeviceMemoryProperties.__Internal*) __Instance)->memoryTypes != null)
            {
                __value = new global::VkMemoryType[32];
                for (int i = 0; i < 32; i++)
                    __value[i] = global::VkMemoryType.__CreateInstance(*((global::VkMemoryType.__Internal*)&(((global::VkPhysicalDeviceMemoryProperties.__Internal*) __Instance)->memoryTypes[i * sizeof(global::VkMemoryType.__Internal)])));
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                if (value.Length != 32)
                    throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                for (int i = 0; i < 32; i++)
                    *(global::VkMemoryType.__Internal*) &((global::VkPhysicalDeviceMemoryProperties.__Internal*)__Instance)->memoryTypes[i * sizeof(global::VkMemoryType.__Internal)] = *(global::VkMemoryType.__Internal*)value[i].__Instance;
            }
        }
    }

    public uint MemoryHeapCount
    {
        get
        {
            return ((global::VkPhysicalDeviceMemoryProperties.__Internal*) __Instance)->memoryHeapCount;
        }

        set
        {
            ((global::VkPhysicalDeviceMemoryProperties.__Internal*)__Instance)->memoryHeapCount = value;
        }
    }

    public global::VkMemoryHeap[] MemoryHeaps
    {
        get
        {
            global::VkMemoryHeap[] __value = null;
            if (((global::VkPhysicalDeviceMemoryProperties.__Internal*) __Instance)->memoryHeaps != null)
            {
                __value = new global::VkMemoryHeap[16];
                for (int i = 0; i < 16; i++)
                    __value[i] = global::VkMemoryHeap.__CreateInstance(*((global::VkMemoryHeap.__Internal*)&(((global::VkPhysicalDeviceMemoryProperties.__Internal*) __Instance)->memoryHeaps[i * sizeof(global::VkMemoryHeap.__Internal)])));
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                if (value.Length != 16)
                    throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                for (int i = 0; i < 16; i++)
                    *(global::VkMemoryHeap.__Internal*) &((global::VkPhysicalDeviceMemoryProperties.__Internal*)__Instance)->memoryHeaps[i * sizeof(global::VkMemoryHeap.__Internal)] = *(global::VkMemoryHeap.__Internal*)value[i].__Instance;
            }
        }
    }
}

public unsafe partial class VkDeviceQueueCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint queueFamilyIndex;

        [FieldOffset(24)]
        internal uint queueCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pQueuePriorities;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceQueueCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceQueueCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceQueueCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceQueueCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceQueueCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceQueueCreateInfo __CreateInstance(global::VkDeviceQueueCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceQueueCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceQueueCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceQueueCreateInfo.__Internal));
        *(global::VkDeviceQueueCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceQueueCreateInfo(global::VkDeviceQueueCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceQueueCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceQueueCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceQueueCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceQueueCreateInfo(global::VkDeviceQueueCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceQueueCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceQueueCreateInfo.__Internal*) __Instance) = *((global::VkDeviceQueueCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceQueueCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceQueueCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceQueueCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceQueueCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceQueueCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDeviceQueueCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDeviceQueueCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint QueueFamilyIndex
    {
        get
        {
            return ((global::VkDeviceQueueCreateInfo.__Internal*) __Instance)->queueFamilyIndex;
        }

        set
        {
            ((global::VkDeviceQueueCreateInfo.__Internal*)__Instance)->queueFamilyIndex = value;
        }
    }

    public uint QueueCount
    {
        get
        {
            return ((global::VkDeviceQueueCreateInfo.__Internal*) __Instance)->queueCount;
        }

        set
        {
            ((global::VkDeviceQueueCreateInfo.__Internal*)__Instance)->queueCount = value;
        }
    }

    public float* PQueuePriorities
    {
        get
        {
            return (float*) ((global::VkDeviceQueueCreateInfo.__Internal*) __Instance)->pQueuePriorities;
        }

        set
        {
            ((global::VkDeviceQueueCreateInfo.__Internal*)__Instance)->pQueuePriorities = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkDeviceCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint queueCreateInfoCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pQueueCreateInfos;

        [FieldOffset(32)]
        internal uint enabledLayerCount;

        [FieldOffset(40)]
        internal global::System.IntPtr ppEnabledLayerNames;

        [FieldOffset(48)]
        internal uint enabledExtensionCount;

        [FieldOffset(56)]
        internal global::System.IntPtr ppEnabledExtensionNames;

        [FieldOffset(64)]
        internal global::System.IntPtr pEnabledFeatures;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceCreateInfo __CreateInstance(global::VkDeviceCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceCreateInfo.__Internal));
        *(global::VkDeviceCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceCreateInfo(global::VkDeviceCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceCreateInfo(global::VkDeviceCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceCreateInfo.__Internal*) __Instance) = *((global::VkDeviceCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDeviceCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint QueueCreateInfoCount
    {
        get
        {
            return ((global::VkDeviceCreateInfo.__Internal*) __Instance)->queueCreateInfoCount;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->queueCreateInfoCount = value;
        }
    }

    public global::VkDeviceQueueCreateInfo PQueueCreateInfos
    {
        get
        {
            global::VkDeviceQueueCreateInfo __result0;
            if (((global::VkDeviceCreateInfo.__Internal*) __Instance)->pQueueCreateInfos == IntPtr.Zero) __result0 = null;
            else if (global::VkDeviceQueueCreateInfo.NativeToManagedMap.ContainsKey(((global::VkDeviceCreateInfo.__Internal*) __Instance)->pQueueCreateInfos))
                __result0 = (global::VkDeviceQueueCreateInfo) global::VkDeviceQueueCreateInfo.NativeToManagedMap[((global::VkDeviceCreateInfo.__Internal*) __Instance)->pQueueCreateInfos];
            else __result0 = global::VkDeviceQueueCreateInfo.__CreateInstance(((global::VkDeviceCreateInfo.__Internal*) __Instance)->pQueueCreateInfos);
            return __result0;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->pQueueCreateInfos = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint EnabledLayerCount
    {
        get
        {
            return ((global::VkDeviceCreateInfo.__Internal*) __Instance)->enabledLayerCount;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->enabledLayerCount = value;
        }
    }

    public char** PpEnabledLayerNames
    {
        get
        {
            return (char**) ((global::VkDeviceCreateInfo.__Internal*) __Instance)->ppEnabledLayerNames;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->ppEnabledLayerNames = (global::System.IntPtr) (sbyte**) value;
        }
    }

    public uint EnabledExtensionCount
    {
        get
        {
            return ((global::VkDeviceCreateInfo.__Internal*) __Instance)->enabledExtensionCount;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->enabledExtensionCount = value;
        }
    }

    public char** PpEnabledExtensionNames
    {
        get
        {
            return (char**) ((global::VkDeviceCreateInfo.__Internal*) __Instance)->ppEnabledExtensionNames;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->ppEnabledExtensionNames = (global::System.IntPtr) (sbyte**) value;
        }
    }

    public global::VkPhysicalDeviceFeatures PEnabledFeatures
    {
        get
        {
            global::VkPhysicalDeviceFeatures __result0;
            if (((global::VkDeviceCreateInfo.__Internal*) __Instance)->pEnabledFeatures == IntPtr.Zero) __result0 = null;
            else if (global::VkPhysicalDeviceFeatures.NativeToManagedMap.ContainsKey(((global::VkDeviceCreateInfo.__Internal*) __Instance)->pEnabledFeatures))
                __result0 = (global::VkPhysicalDeviceFeatures) global::VkPhysicalDeviceFeatures.NativeToManagedMap[((global::VkDeviceCreateInfo.__Internal*) __Instance)->pEnabledFeatures];
            else __result0 = global::VkPhysicalDeviceFeatures.__CreateInstance(((global::VkDeviceCreateInfo.__Internal*) __Instance)->pEnabledFeatures);
            return __result0;
        }

        set
        {
            ((global::VkDeviceCreateInfo.__Internal*)__Instance)->pEnabledFeatures = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkExtensionProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 260)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal fixed sbyte extensionName[256];

        [FieldOffset(256)]
        internal uint specVersion;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExtensionProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExtensionProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExtensionProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExtensionProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExtensionProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkExtensionProperties __CreateInstance(global::VkExtensionProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkExtensionProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExtensionProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExtensionProperties.__Internal));
        *(global::VkExtensionProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExtensionProperties(global::VkExtensionProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExtensionProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExtensionProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExtensionProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExtensionProperties(global::VkExtensionProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExtensionProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExtensionProperties.__Internal*) __Instance) = *((global::VkExtensionProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExtensionProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public char[] ExtensionName
    {
        get
        {
            char[] __value = null;
            if (((global::VkExtensionProperties.__Internal*) __Instance)->extensionName != null)
            {
                __value = new char[256];
                for (int i = 0; i < 256; i++)
                    __value[i] = global::System.Convert.ToChar(((global::VkExtensionProperties.__Internal*) __Instance)->extensionName[i]);
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 256; i++)
                    ((global::VkExtensionProperties.__Internal*)__Instance)->extensionName[i] = global::System.Convert.ToSByte(value[i]);
            }
        }
    }

    public uint SpecVersion
    {
        get
        {
            return ((global::VkExtensionProperties.__Internal*) __Instance)->specVersion;
        }

        set
        {
            ((global::VkExtensionProperties.__Internal*)__Instance)->specVersion = value;
        }
    }
}

public unsafe partial class VkLayerProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 520)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal fixed sbyte layerName[256];

        [FieldOffset(256)]
        internal uint specVersion;

        [FieldOffset(260)]
        internal uint implementationVersion;

        [FieldOffset(264)]
        internal fixed sbyte description[256];

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkLayerProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkLayerProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkLayerProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkLayerProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkLayerProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkLayerProperties __CreateInstance(global::VkLayerProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkLayerProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkLayerProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkLayerProperties.__Internal));
        *(global::VkLayerProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkLayerProperties(global::VkLayerProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkLayerProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkLayerProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkLayerProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkLayerProperties(global::VkLayerProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkLayerProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkLayerProperties.__Internal*) __Instance) = *((global::VkLayerProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkLayerProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public char[] LayerName
    {
        get
        {
            char[] __value = null;
            if (((global::VkLayerProperties.__Internal*) __Instance)->layerName != null)
            {
                __value = new char[256];
                for (int i = 0; i < 256; i++)
                    __value[i] = global::System.Convert.ToChar(((global::VkLayerProperties.__Internal*) __Instance)->layerName[i]);
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 256; i++)
                    ((global::VkLayerProperties.__Internal*)__Instance)->layerName[i] = global::System.Convert.ToSByte(value[i]);
            }
        }
    }

    public uint SpecVersion
    {
        get
        {
            return ((global::VkLayerProperties.__Internal*) __Instance)->specVersion;
        }

        set
        {
            ((global::VkLayerProperties.__Internal*)__Instance)->specVersion = value;
        }
    }

    public uint ImplementationVersion
    {
        get
        {
            return ((global::VkLayerProperties.__Internal*) __Instance)->implementationVersion;
        }

        set
        {
            ((global::VkLayerProperties.__Internal*)__Instance)->implementationVersion = value;
        }
    }

    public char[] Description
    {
        get
        {
            char[] __value = null;
            if (((global::VkLayerProperties.__Internal*) __Instance)->description != null)
            {
                __value = new char[256];
                for (int i = 0; i < 256; i++)
                    __value[i] = global::System.Convert.ToChar(((global::VkLayerProperties.__Internal*) __Instance)->description[i]);
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 256; i++)
                    ((global::VkLayerProperties.__Internal*)__Instance)->description[i] = global::System.Convert.ToSByte(value[i]);
            }
        }
    }
}

public unsafe partial class VkSubmitInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint waitSemaphoreCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pWaitSemaphores;

        [FieldOffset(32)]
        internal global::System.IntPtr pWaitDstStageMask;

        [FieldOffset(40)]
        internal uint commandBufferCount;

        [FieldOffset(48)]
        internal global::System.IntPtr pCommandBuffers;

        [FieldOffset(56)]
        internal uint signalSemaphoreCount;

        [FieldOffset(64)]
        internal global::System.IntPtr pSignalSemaphores;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSubmitInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubmitInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubmitInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSubmitInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSubmitInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkSubmitInfo __CreateInstance(global::VkSubmitInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkSubmitInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSubmitInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSubmitInfo.__Internal));
        *(global::VkSubmitInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSubmitInfo(global::VkSubmitInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSubmitInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSubmitInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubmitInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSubmitInfo(global::VkSubmitInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubmitInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSubmitInfo.__Internal*) __Instance) = *((global::VkSubmitInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSubmitInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSubmitInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSubmitInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSubmitInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSubmitInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint WaitSemaphoreCount
    {
        get
        {
            return ((global::VkSubmitInfo.__Internal*) __Instance)->waitSemaphoreCount;
        }

        set
        {
            ((global::VkSubmitInfo.__Internal*)__Instance)->waitSemaphoreCount = value;
        }
    }

    public global::VkSemaphoreT PWaitSemaphores
    {
        get
        {
            global::VkSemaphoreT __result0;
            if (((global::VkSubmitInfo.__Internal*) __Instance)->pWaitSemaphores == IntPtr.Zero) __result0 = null;
            else if (global::VkSemaphoreT.NativeToManagedMap.ContainsKey(((global::VkSubmitInfo.__Internal*) __Instance)->pWaitSemaphores))
                __result0 = (global::VkSemaphoreT) global::VkSemaphoreT.NativeToManagedMap[((global::VkSubmitInfo.__Internal*) __Instance)->pWaitSemaphores];
            else __result0 = global::VkSemaphoreT.__CreateInstance(((global::VkSubmitInfo.__Internal*) __Instance)->pWaitSemaphores);
            return __result0;
        }

        set
        {
            ((global::VkSubmitInfo.__Internal*)__Instance)->pWaitSemaphores = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint* PWaitDstStageMask
    {
        get
        {
            return (uint*) ((global::VkSubmitInfo.__Internal*) __Instance)->pWaitDstStageMask;
        }

        set
        {
            ((global::VkSubmitInfo.__Internal*)__Instance)->pWaitDstStageMask = (global::System.IntPtr) value;
        }
    }

    public uint CommandBufferCount
    {
        get
        {
            return ((global::VkSubmitInfo.__Internal*) __Instance)->commandBufferCount;
        }

        set
        {
            ((global::VkSubmitInfo.__Internal*)__Instance)->commandBufferCount = value;
        }
    }

    public global::VkCommandBufferT PCommandBuffers
    {
        get
        {
            global::VkCommandBufferT __result0;
            if (((global::VkSubmitInfo.__Internal*) __Instance)->pCommandBuffers == IntPtr.Zero) __result0 = null;
            else if (global::VkCommandBufferT.NativeToManagedMap.ContainsKey(((global::VkSubmitInfo.__Internal*) __Instance)->pCommandBuffers))
                __result0 = (global::VkCommandBufferT) global::VkCommandBufferT.NativeToManagedMap[((global::VkSubmitInfo.__Internal*) __Instance)->pCommandBuffers];
            else __result0 = global::VkCommandBufferT.__CreateInstance(((global::VkSubmitInfo.__Internal*) __Instance)->pCommandBuffers);
            return __result0;
        }

        set
        {
            ((global::VkSubmitInfo.__Internal*)__Instance)->pCommandBuffers = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint SignalSemaphoreCount
    {
        get
        {
            return ((global::VkSubmitInfo.__Internal*) __Instance)->signalSemaphoreCount;
        }

        set
        {
            ((global::VkSubmitInfo.__Internal*)__Instance)->signalSemaphoreCount = value;
        }
    }

    public global::VkSemaphoreT PSignalSemaphores
    {
        get
        {
            global::VkSemaphoreT __result0;
            if (((global::VkSubmitInfo.__Internal*) __Instance)->pSignalSemaphores == IntPtr.Zero) __result0 = null;
            else if (global::VkSemaphoreT.NativeToManagedMap.ContainsKey(((global::VkSubmitInfo.__Internal*) __Instance)->pSignalSemaphores))
                __result0 = (global::VkSemaphoreT) global::VkSemaphoreT.NativeToManagedMap[((global::VkSubmitInfo.__Internal*) __Instance)->pSignalSemaphores];
            else __result0 = global::VkSemaphoreT.__CreateInstance(((global::VkSubmitInfo.__Internal*) __Instance)->pSignalSemaphores);
            return __result0;
        }

        set
        {
            ((global::VkSubmitInfo.__Internal*)__Instance)->pSignalSemaphores = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkMemoryAllocateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal ulong allocationSize;

        [FieldOffset(24)]
        internal uint memoryTypeIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryAllocateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryAllocateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryAllocateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryAllocateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryAllocateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryAllocateInfo __CreateInstance(global::VkMemoryAllocateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryAllocateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryAllocateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryAllocateInfo.__Internal));
        *(global::VkMemoryAllocateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryAllocateInfo(global::VkMemoryAllocateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryAllocateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryAllocateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryAllocateInfo(global::VkMemoryAllocateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryAllocateInfo.__Internal*) __Instance) = *((global::VkMemoryAllocateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryAllocateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMemoryAllocateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMemoryAllocateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMemoryAllocateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMemoryAllocateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public ulong AllocationSize
    {
        get
        {
            return ((global::VkMemoryAllocateInfo.__Internal*) __Instance)->allocationSize;
        }

        set
        {
            ((global::VkMemoryAllocateInfo.__Internal*)__Instance)->allocationSize = value;
        }
    }

    public uint MemoryTypeIndex
    {
        get
        {
            return ((global::VkMemoryAllocateInfo.__Internal*) __Instance)->memoryTypeIndex;
        }

        set
        {
            ((global::VkMemoryAllocateInfo.__Internal*)__Instance)->memoryTypeIndex = value;
        }
    }
}

public unsafe partial class VkMappedMemoryRange : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr memory;

        [FieldOffset(24)]
        internal ulong offset;

        [FieldOffset(32)]
        internal ulong size;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMappedMemoryRange@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMappedMemoryRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMappedMemoryRange>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMappedMemoryRange __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMappedMemoryRange(native.ToPointer(), skipVTables);
    }

    internal static global::VkMappedMemoryRange __CreateInstance(global::VkMappedMemoryRange.__Internal native, bool skipVTables = false)
    {
        return new global::VkMappedMemoryRange(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMappedMemoryRange.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMappedMemoryRange.__Internal));
        *(global::VkMappedMemoryRange.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMappedMemoryRange(global::VkMappedMemoryRange.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMappedMemoryRange(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMappedMemoryRange()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMappedMemoryRange.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMappedMemoryRange(global::VkMappedMemoryRange _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMappedMemoryRange.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMappedMemoryRange.__Internal*) __Instance) = *((global::VkMappedMemoryRange.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMappedMemoryRange __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMappedMemoryRange.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMappedMemoryRange.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMappedMemoryRange.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMappedMemoryRange.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDeviceMemoryT Memory
    {
        get
        {
            global::VkDeviceMemoryT __result0;
            if (((global::VkMappedMemoryRange.__Internal*) __Instance)->memory == IntPtr.Zero) __result0 = null;
            else if (global::VkDeviceMemoryT.NativeToManagedMap.ContainsKey(((global::VkMappedMemoryRange.__Internal*) __Instance)->memory))
                __result0 = (global::VkDeviceMemoryT) global::VkDeviceMemoryT.NativeToManagedMap[((global::VkMappedMemoryRange.__Internal*) __Instance)->memory];
            else __result0 = global::VkDeviceMemoryT.__CreateInstance(((global::VkMappedMemoryRange.__Internal*) __Instance)->memory);
            return __result0;
        }

        set
        {
            ((global::VkMappedMemoryRange.__Internal*)__Instance)->memory = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong Offset
    {
        get
        {
            return ((global::VkMappedMemoryRange.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkMappedMemoryRange.__Internal*)__Instance)->offset = value;
        }
    }

    public ulong Size
    {
        get
        {
            return ((global::VkMappedMemoryRange.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkMappedMemoryRange.__Internal*)__Instance)->size = value;
        }
    }
}

public unsafe partial class VkMemoryRequirements : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal ulong size;

        [FieldOffset(8)]
        internal ulong alignment;

        [FieldOffset(16)]
        internal uint memoryTypeBits;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryRequirements@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryRequirements> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryRequirements>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryRequirements __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryRequirements(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryRequirements __CreateInstance(global::VkMemoryRequirements.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryRequirements(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryRequirements.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryRequirements.__Internal));
        *(global::VkMemoryRequirements.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryRequirements(global::VkMemoryRequirements.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryRequirements(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryRequirements()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryRequirements.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryRequirements(global::VkMemoryRequirements _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryRequirements.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryRequirements.__Internal*) __Instance) = *((global::VkMemoryRequirements.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryRequirements __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public ulong Size
    {
        get
        {
            return ((global::VkMemoryRequirements.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkMemoryRequirements.__Internal*)__Instance)->size = value;
        }
    }

    public ulong Alignment
    {
        get
        {
            return ((global::VkMemoryRequirements.__Internal*) __Instance)->alignment;
        }

        set
        {
            ((global::VkMemoryRequirements.__Internal*)__Instance)->alignment = value;
        }
    }

    public uint MemoryTypeBits
    {
        get
        {
            return ((global::VkMemoryRequirements.__Internal*) __Instance)->memoryTypeBits;
        }

        set
        {
            ((global::VkMemoryRequirements.__Internal*)__Instance)->memoryTypeBits = value;
        }
    }
}

public unsafe partial class VkSparseImageFormatProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint aspectMask;

        [FieldOffset(4)]
        internal global::VkExtent3D.__Internal imageGranularity;

        [FieldOffset(16)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSparseImageFormatProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageFormatProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageFormatProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSparseImageFormatProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSparseImageFormatProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkSparseImageFormatProperties __CreateInstance(global::VkSparseImageFormatProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkSparseImageFormatProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSparseImageFormatProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSparseImageFormatProperties.__Internal));
        *(global::VkSparseImageFormatProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSparseImageFormatProperties(global::VkSparseImageFormatProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSparseImageFormatProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSparseImageFormatProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSparseImageFormatProperties(global::VkSparseImageFormatProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSparseImageFormatProperties.__Internal*) __Instance) = *((global::VkSparseImageFormatProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSparseImageFormatProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint AspectMask
    {
        get
        {
            return ((global::VkSparseImageFormatProperties.__Internal*) __Instance)->aspectMask;
        }

        set
        {
            ((global::VkSparseImageFormatProperties.__Internal*)__Instance)->aspectMask = value;
        }
    }

    public global::VkExtent3D ImageGranularity
    {
        get
        {
            return global::VkExtent3D.__CreateInstance(new global::System.IntPtr(&((global::VkSparseImageFormatProperties.__Internal*) __Instance)->imageGranularity));
        }

        set
        {
            ((global::VkSparseImageFormatProperties.__Internal*)__Instance)->imageGranularity = ReferenceEquals(value, null) ? new global::VkExtent3D.__Internal() : *(global::VkExtent3D.__Internal*) value.__Instance;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkSparseImageFormatProperties.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkSparseImageFormatProperties.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkSparseImageMemoryRequirements : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkSparseImageFormatProperties.__Internal formatProperties;

        [FieldOffset(20)]
        internal uint imageMipTailFirstLod;

        [FieldOffset(24)]
        internal ulong imageMipTailSize;

        [FieldOffset(32)]
        internal ulong imageMipTailOffset;

        [FieldOffset(40)]
        internal ulong imageMipTailStride;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSparseImageMemoryRequirements@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageMemoryRequirements> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageMemoryRequirements>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSparseImageMemoryRequirements __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSparseImageMemoryRequirements(native.ToPointer(), skipVTables);
    }

    internal static global::VkSparseImageMemoryRequirements __CreateInstance(global::VkSparseImageMemoryRequirements.__Internal native, bool skipVTables = false)
    {
        return new global::VkSparseImageMemoryRequirements(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSparseImageMemoryRequirements.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryRequirements.__Internal));
        *(global::VkSparseImageMemoryRequirements.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSparseImageMemoryRequirements(global::VkSparseImageMemoryRequirements.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSparseImageMemoryRequirements(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSparseImageMemoryRequirements()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryRequirements.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSparseImageMemoryRequirements(global::VkSparseImageMemoryRequirements _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryRequirements.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSparseImageMemoryRequirements.__Internal*) __Instance) = *((global::VkSparseImageMemoryRequirements.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSparseImageMemoryRequirements __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkSparseImageFormatProperties FormatProperties
    {
        get
        {
            return global::VkSparseImageFormatProperties.__CreateInstance(new global::System.IntPtr(&((global::VkSparseImageMemoryRequirements.__Internal*) __Instance)->formatProperties));
        }

        set
        {
            ((global::VkSparseImageMemoryRequirements.__Internal*)__Instance)->formatProperties = ReferenceEquals(value, null) ? new global::VkSparseImageFormatProperties.__Internal() : *(global::VkSparseImageFormatProperties.__Internal*) value.__Instance;
        }
    }

    public uint ImageMipTailFirstLod
    {
        get
        {
            return ((global::VkSparseImageMemoryRequirements.__Internal*) __Instance)->imageMipTailFirstLod;
        }

        set
        {
            ((global::VkSparseImageMemoryRequirements.__Internal*)__Instance)->imageMipTailFirstLod = value;
        }
    }

    public ulong ImageMipTailSize
    {
        get
        {
            return ((global::VkSparseImageMemoryRequirements.__Internal*) __Instance)->imageMipTailSize;
        }

        set
        {
            ((global::VkSparseImageMemoryRequirements.__Internal*)__Instance)->imageMipTailSize = value;
        }
    }

    public ulong ImageMipTailOffset
    {
        get
        {
            return ((global::VkSparseImageMemoryRequirements.__Internal*) __Instance)->imageMipTailOffset;
        }

        set
        {
            ((global::VkSparseImageMemoryRequirements.__Internal*)__Instance)->imageMipTailOffset = value;
        }
    }

    public ulong ImageMipTailStride
    {
        get
        {
            return ((global::VkSparseImageMemoryRequirements.__Internal*) __Instance)->imageMipTailStride;
        }

        set
        {
            ((global::VkSparseImageMemoryRequirements.__Internal*)__Instance)->imageMipTailStride = value;
        }
    }
}

public unsafe partial class VkSparseMemoryBind : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal ulong resourceOffset;

        [FieldOffset(8)]
        internal ulong size;

        [FieldOffset(16)]
        internal global::System.IntPtr memory;

        [FieldOffset(24)]
        internal ulong memoryOffset;

        [FieldOffset(32)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSparseMemoryBind@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseMemoryBind> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseMemoryBind>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSparseMemoryBind __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSparseMemoryBind(native.ToPointer(), skipVTables);
    }

    internal static global::VkSparseMemoryBind __CreateInstance(global::VkSparseMemoryBind.__Internal native, bool skipVTables = false)
    {
        return new global::VkSparseMemoryBind(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSparseMemoryBind.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSparseMemoryBind.__Internal));
        *(global::VkSparseMemoryBind.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSparseMemoryBind(global::VkSparseMemoryBind.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSparseMemoryBind(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSparseMemoryBind()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseMemoryBind.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSparseMemoryBind(global::VkSparseMemoryBind _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseMemoryBind.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSparseMemoryBind.__Internal*) __Instance) = *((global::VkSparseMemoryBind.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSparseMemoryBind __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public ulong ResourceOffset
    {
        get
        {
            return ((global::VkSparseMemoryBind.__Internal*) __Instance)->resourceOffset;
        }

        set
        {
            ((global::VkSparseMemoryBind.__Internal*)__Instance)->resourceOffset = value;
        }
    }

    public ulong Size
    {
        get
        {
            return ((global::VkSparseMemoryBind.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkSparseMemoryBind.__Internal*)__Instance)->size = value;
        }
    }

    public global::VkDeviceMemoryT Memory
    {
        get
        {
            global::VkDeviceMemoryT __result0;
            if (((global::VkSparseMemoryBind.__Internal*) __Instance)->memory == IntPtr.Zero) __result0 = null;
            else if (global::VkDeviceMemoryT.NativeToManagedMap.ContainsKey(((global::VkSparseMemoryBind.__Internal*) __Instance)->memory))
                __result0 = (global::VkDeviceMemoryT) global::VkDeviceMemoryT.NativeToManagedMap[((global::VkSparseMemoryBind.__Internal*) __Instance)->memory];
            else __result0 = global::VkDeviceMemoryT.__CreateInstance(((global::VkSparseMemoryBind.__Internal*) __Instance)->memory);
            return __result0;
        }

        set
        {
            ((global::VkSparseMemoryBind.__Internal*)__Instance)->memory = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong MemoryOffset
    {
        get
        {
            return ((global::VkSparseMemoryBind.__Internal*) __Instance)->memoryOffset;
        }

        set
        {
            ((global::VkSparseMemoryBind.__Internal*)__Instance)->memoryOffset = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkSparseMemoryBind.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkSparseMemoryBind.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkSparseBufferMemoryBindInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr buffer;

        [FieldOffset(8)]
        internal uint bindCount;

        [FieldOffset(16)]
        internal global::System.IntPtr pBinds;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSparseBufferMemoryBindInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseBufferMemoryBindInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseBufferMemoryBindInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSparseBufferMemoryBindInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSparseBufferMemoryBindInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkSparseBufferMemoryBindInfo __CreateInstance(global::VkSparseBufferMemoryBindInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkSparseBufferMemoryBindInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSparseBufferMemoryBindInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSparseBufferMemoryBindInfo.__Internal));
        *(global::VkSparseBufferMemoryBindInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSparseBufferMemoryBindInfo(global::VkSparseBufferMemoryBindInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSparseBufferMemoryBindInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSparseBufferMemoryBindInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseBufferMemoryBindInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSparseBufferMemoryBindInfo(global::VkSparseBufferMemoryBindInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseBufferMemoryBindInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance) = *((global::VkSparseBufferMemoryBindInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSparseBufferMemoryBindInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkSparseBufferMemoryBindInfo.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint BindCount
    {
        get
        {
            return ((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance)->bindCount;
        }

        set
        {
            ((global::VkSparseBufferMemoryBindInfo.__Internal*)__Instance)->bindCount = value;
        }
    }

    public global::VkSparseMemoryBind PBinds
    {
        get
        {
            global::VkSparseMemoryBind __result0;
            if (((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance)->pBinds == IntPtr.Zero) __result0 = null;
            else if (global::VkSparseMemoryBind.NativeToManagedMap.ContainsKey(((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance)->pBinds))
                __result0 = (global::VkSparseMemoryBind) global::VkSparseMemoryBind.NativeToManagedMap[((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance)->pBinds];
            else __result0 = global::VkSparseMemoryBind.__CreateInstance(((global::VkSparseBufferMemoryBindInfo.__Internal*) __Instance)->pBinds);
            return __result0;
        }

        set
        {
            ((global::VkSparseBufferMemoryBindInfo.__Internal*)__Instance)->pBinds = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkSparseImageOpaqueMemoryBindInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr image;

        [FieldOffset(8)]
        internal uint bindCount;

        [FieldOffset(16)]
        internal global::System.IntPtr pBinds;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSparseImageOpaqueMemoryBindInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageOpaqueMemoryBindInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageOpaqueMemoryBindInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSparseImageOpaqueMemoryBindInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSparseImageOpaqueMemoryBindInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkSparseImageOpaqueMemoryBindInfo __CreateInstance(global::VkSparseImageOpaqueMemoryBindInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkSparseImageOpaqueMemoryBindInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSparseImageOpaqueMemoryBindInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSparseImageOpaqueMemoryBindInfo.__Internal));
        *(global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSparseImageOpaqueMemoryBindInfo(global::VkSparseImageOpaqueMemoryBindInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSparseImageOpaqueMemoryBindInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSparseImageOpaqueMemoryBindInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageOpaqueMemoryBindInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSparseImageOpaqueMemoryBindInfo(global::VkSparseImageOpaqueMemoryBindInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageOpaqueMemoryBindInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance) = *((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSparseImageOpaqueMemoryBindInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkImageT Image
    {
        get
        {
            global::VkImageT __result0;
            if (((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance)->image == IntPtr.Zero) __result0 = null;
            else if (global::VkImageT.NativeToManagedMap.ContainsKey(((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance)->image))
                __result0 = (global::VkImageT) global::VkImageT.NativeToManagedMap[((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance)->image];
            else __result0 = global::VkImageT.__CreateInstance(((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance)->image);
            return __result0;
        }

        set
        {
            ((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*)__Instance)->image = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint BindCount
    {
        get
        {
            return ((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance)->bindCount;
        }

        set
        {
            ((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*)__Instance)->bindCount = value;
        }
    }

    public global::VkSparseMemoryBind PBinds
    {
        get
        {
            global::VkSparseMemoryBind __result0;
            if (((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance)->pBinds == IntPtr.Zero) __result0 = null;
            else if (global::VkSparseMemoryBind.NativeToManagedMap.ContainsKey(((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance)->pBinds))
                __result0 = (global::VkSparseMemoryBind) global::VkSparseMemoryBind.NativeToManagedMap[((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance)->pBinds];
            else __result0 = global::VkSparseMemoryBind.__CreateInstance(((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*) __Instance)->pBinds);
            return __result0;
        }

        set
        {
            ((global::VkSparseImageOpaqueMemoryBindInfo.__Internal*)__Instance)->pBinds = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkImageSubresource : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint aspectMask;

        [FieldOffset(4)]
        internal uint mipLevel;

        [FieldOffset(8)]
        internal uint arrayLayer;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageSubresource@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSubresource> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSubresource>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageSubresource __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageSubresource(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageSubresource __CreateInstance(global::VkImageSubresource.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageSubresource(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageSubresource.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageSubresource.__Internal));
        *(global::VkImageSubresource.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageSubresource(global::VkImageSubresource.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageSubresource(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageSubresource()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSubresource.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageSubresource(global::VkImageSubresource _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSubresource.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageSubresource.__Internal*) __Instance) = *((global::VkImageSubresource.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageSubresource __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint AspectMask
    {
        get
        {
            return ((global::VkImageSubresource.__Internal*) __Instance)->aspectMask;
        }

        set
        {
            ((global::VkImageSubresource.__Internal*)__Instance)->aspectMask = value;
        }
    }

    public uint MipLevel
    {
        get
        {
            return ((global::VkImageSubresource.__Internal*) __Instance)->mipLevel;
        }

        set
        {
            ((global::VkImageSubresource.__Internal*)__Instance)->mipLevel = value;
        }
    }

    public uint ArrayLayer
    {
        get
        {
            return ((global::VkImageSubresource.__Internal*) __Instance)->arrayLayer;
        }

        set
        {
            ((global::VkImageSubresource.__Internal*)__Instance)->arrayLayer = value;
        }
    }
}

public unsafe partial class VkOffset3D : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal int x;

        [FieldOffset(4)]
        internal int y;

        [FieldOffset(8)]
        internal int z;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkOffset3D@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkOffset3D> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkOffset3D>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkOffset3D __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkOffset3D(native.ToPointer(), skipVTables);
    }

    internal static global::VkOffset3D __CreateInstance(global::VkOffset3D.__Internal native, bool skipVTables = false)
    {
        return new global::VkOffset3D(native, skipVTables);
    }

    private static void* __CopyValue(global::VkOffset3D.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkOffset3D.__Internal));
        *(global::VkOffset3D.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkOffset3D(global::VkOffset3D.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkOffset3D(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkOffset3D()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkOffset3D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkOffset3D(global::VkOffset3D _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkOffset3D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkOffset3D.__Internal*) __Instance) = *((global::VkOffset3D.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkOffset3D __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public int X
    {
        get
        {
            return ((global::VkOffset3D.__Internal*) __Instance)->x;
        }

        set
        {
            ((global::VkOffset3D.__Internal*)__Instance)->x = value;
        }
    }

    public int Y
    {
        get
        {
            return ((global::VkOffset3D.__Internal*) __Instance)->y;
        }

        set
        {
            ((global::VkOffset3D.__Internal*)__Instance)->y = value;
        }
    }

    public int Z
    {
        get
        {
            return ((global::VkOffset3D.__Internal*) __Instance)->z;
        }

        set
        {
            ((global::VkOffset3D.__Internal*)__Instance)->z = value;
        }
    }
}

public unsafe partial class VkSparseImageMemoryBind : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkImageSubresource.__Internal subresource;

        [FieldOffset(12)]
        internal global::VkOffset3D.__Internal offset;

        [FieldOffset(24)]
        internal global::VkExtent3D.__Internal extent;

        [FieldOffset(40)]
        internal global::System.IntPtr memory;

        [FieldOffset(48)]
        internal ulong memoryOffset;

        [FieldOffset(56)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSparseImageMemoryBind@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageMemoryBind> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageMemoryBind>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSparseImageMemoryBind __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSparseImageMemoryBind(native.ToPointer(), skipVTables);
    }

    internal static global::VkSparseImageMemoryBind __CreateInstance(global::VkSparseImageMemoryBind.__Internal native, bool skipVTables = false)
    {
        return new global::VkSparseImageMemoryBind(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSparseImageMemoryBind.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryBind.__Internal));
        *(global::VkSparseImageMemoryBind.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSparseImageMemoryBind(global::VkSparseImageMemoryBind.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSparseImageMemoryBind(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSparseImageMemoryBind()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryBind.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSparseImageMemoryBind(global::VkSparseImageMemoryBind _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryBind.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSparseImageMemoryBind.__Internal*) __Instance) = *((global::VkSparseImageMemoryBind.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSparseImageMemoryBind __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkImageSubresource Subresource
    {
        get
        {
            return global::VkImageSubresource.__CreateInstance(new global::System.IntPtr(&((global::VkSparseImageMemoryBind.__Internal*) __Instance)->subresource));
        }

        set
        {
            ((global::VkSparseImageMemoryBind.__Internal*)__Instance)->subresource = ReferenceEquals(value, null) ? new global::VkImageSubresource.__Internal() : *(global::VkImageSubresource.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset3D Offset
    {
        get
        {
            return global::VkOffset3D.__CreateInstance(new global::System.IntPtr(&((global::VkSparseImageMemoryBind.__Internal*) __Instance)->offset));
        }

        set
        {
            ((global::VkSparseImageMemoryBind.__Internal*)__Instance)->offset = ReferenceEquals(value, null) ? new global::VkOffset3D.__Internal() : *(global::VkOffset3D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent3D Extent
    {
        get
        {
            return global::VkExtent3D.__CreateInstance(new global::System.IntPtr(&((global::VkSparseImageMemoryBind.__Internal*) __Instance)->extent));
        }

        set
        {
            ((global::VkSparseImageMemoryBind.__Internal*)__Instance)->extent = ReferenceEquals(value, null) ? new global::VkExtent3D.__Internal() : *(global::VkExtent3D.__Internal*) value.__Instance;
        }
    }

    public global::VkDeviceMemoryT Memory
    {
        get
        {
            global::VkDeviceMemoryT __result0;
            if (((global::VkSparseImageMemoryBind.__Internal*) __Instance)->memory == IntPtr.Zero) __result0 = null;
            else if (global::VkDeviceMemoryT.NativeToManagedMap.ContainsKey(((global::VkSparseImageMemoryBind.__Internal*) __Instance)->memory))
                __result0 = (global::VkDeviceMemoryT) global::VkDeviceMemoryT.NativeToManagedMap[((global::VkSparseImageMemoryBind.__Internal*) __Instance)->memory];
            else __result0 = global::VkDeviceMemoryT.__CreateInstance(((global::VkSparseImageMemoryBind.__Internal*) __Instance)->memory);
            return __result0;
        }

        set
        {
            ((global::VkSparseImageMemoryBind.__Internal*)__Instance)->memory = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong MemoryOffset
    {
        get
        {
            return ((global::VkSparseImageMemoryBind.__Internal*) __Instance)->memoryOffset;
        }

        set
        {
            ((global::VkSparseImageMemoryBind.__Internal*)__Instance)->memoryOffset = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkSparseImageMemoryBind.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkSparseImageMemoryBind.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkSparseImageMemoryBindInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr image;

        [FieldOffset(8)]
        internal uint bindCount;

        [FieldOffset(16)]
        internal global::System.IntPtr pBinds;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSparseImageMemoryBindInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageMemoryBindInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageMemoryBindInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSparseImageMemoryBindInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSparseImageMemoryBindInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkSparseImageMemoryBindInfo __CreateInstance(global::VkSparseImageMemoryBindInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkSparseImageMemoryBindInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSparseImageMemoryBindInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryBindInfo.__Internal));
        *(global::VkSparseImageMemoryBindInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSparseImageMemoryBindInfo(global::VkSparseImageMemoryBindInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSparseImageMemoryBindInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSparseImageMemoryBindInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryBindInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSparseImageMemoryBindInfo(global::VkSparseImageMemoryBindInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryBindInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance) = *((global::VkSparseImageMemoryBindInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSparseImageMemoryBindInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkImageT Image
    {
        get
        {
            global::VkImageT __result0;
            if (((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance)->image == IntPtr.Zero) __result0 = null;
            else if (global::VkImageT.NativeToManagedMap.ContainsKey(((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance)->image))
                __result0 = (global::VkImageT) global::VkImageT.NativeToManagedMap[((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance)->image];
            else __result0 = global::VkImageT.__CreateInstance(((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance)->image);
            return __result0;
        }

        set
        {
            ((global::VkSparseImageMemoryBindInfo.__Internal*)__Instance)->image = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint BindCount
    {
        get
        {
            return ((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance)->bindCount;
        }

        set
        {
            ((global::VkSparseImageMemoryBindInfo.__Internal*)__Instance)->bindCount = value;
        }
    }

    public global::VkSparseImageMemoryBind PBinds
    {
        get
        {
            global::VkSparseImageMemoryBind __result0;
            if (((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance)->pBinds == IntPtr.Zero) __result0 = null;
            else if (global::VkSparseImageMemoryBind.NativeToManagedMap.ContainsKey(((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance)->pBinds))
                __result0 = (global::VkSparseImageMemoryBind) global::VkSparseImageMemoryBind.NativeToManagedMap[((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance)->pBinds];
            else __result0 = global::VkSparseImageMemoryBind.__CreateInstance(((global::VkSparseImageMemoryBindInfo.__Internal*) __Instance)->pBinds);
            return __result0;
        }

        set
        {
            ((global::VkSparseImageMemoryBindInfo.__Internal*)__Instance)->pBinds = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkBindSparseInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 96)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint waitSemaphoreCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pWaitSemaphores;

        [FieldOffset(32)]
        internal uint bufferBindCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pBufferBinds;

        [FieldOffset(48)]
        internal uint imageOpaqueBindCount;

        [FieldOffset(56)]
        internal global::System.IntPtr pImageOpaqueBinds;

        [FieldOffset(64)]
        internal uint imageBindCount;

        [FieldOffset(72)]
        internal global::System.IntPtr pImageBinds;

        [FieldOffset(80)]
        internal uint signalSemaphoreCount;

        [FieldOffset(88)]
        internal global::System.IntPtr pSignalSemaphores;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBindSparseInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindSparseInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindSparseInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBindSparseInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBindSparseInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkBindSparseInfo __CreateInstance(global::VkBindSparseInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkBindSparseInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBindSparseInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBindSparseInfo.__Internal));
        *(global::VkBindSparseInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBindSparseInfo(global::VkBindSparseInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBindSparseInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBindSparseInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindSparseInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBindSparseInfo(global::VkBindSparseInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindSparseInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBindSparseInfo.__Internal*) __Instance) = *((global::VkBindSparseInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBindSparseInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBindSparseInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBindSparseInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint WaitSemaphoreCount
    {
        get
        {
            return ((global::VkBindSparseInfo.__Internal*) __Instance)->waitSemaphoreCount;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->waitSemaphoreCount = value;
        }
    }

    public global::VkSemaphoreT PWaitSemaphores
    {
        get
        {
            global::VkSemaphoreT __result0;
            if (((global::VkBindSparseInfo.__Internal*) __Instance)->pWaitSemaphores == IntPtr.Zero) __result0 = null;
            else if (global::VkSemaphoreT.NativeToManagedMap.ContainsKey(((global::VkBindSparseInfo.__Internal*) __Instance)->pWaitSemaphores))
                __result0 = (global::VkSemaphoreT) global::VkSemaphoreT.NativeToManagedMap[((global::VkBindSparseInfo.__Internal*) __Instance)->pWaitSemaphores];
            else __result0 = global::VkSemaphoreT.__CreateInstance(((global::VkBindSparseInfo.__Internal*) __Instance)->pWaitSemaphores);
            return __result0;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->pWaitSemaphores = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint BufferBindCount
    {
        get
        {
            return ((global::VkBindSparseInfo.__Internal*) __Instance)->bufferBindCount;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->bufferBindCount = value;
        }
    }

    public global::VkSparseBufferMemoryBindInfo PBufferBinds
    {
        get
        {
            global::VkSparseBufferMemoryBindInfo __result0;
            if (((global::VkBindSparseInfo.__Internal*) __Instance)->pBufferBinds == IntPtr.Zero) __result0 = null;
            else if (global::VkSparseBufferMemoryBindInfo.NativeToManagedMap.ContainsKey(((global::VkBindSparseInfo.__Internal*) __Instance)->pBufferBinds))
                __result0 = (global::VkSparseBufferMemoryBindInfo) global::VkSparseBufferMemoryBindInfo.NativeToManagedMap[((global::VkBindSparseInfo.__Internal*) __Instance)->pBufferBinds];
            else __result0 = global::VkSparseBufferMemoryBindInfo.__CreateInstance(((global::VkBindSparseInfo.__Internal*) __Instance)->pBufferBinds);
            return __result0;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->pBufferBinds = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint ImageOpaqueBindCount
    {
        get
        {
            return ((global::VkBindSparseInfo.__Internal*) __Instance)->imageOpaqueBindCount;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->imageOpaqueBindCount = value;
        }
    }

    public global::VkSparseImageOpaqueMemoryBindInfo PImageOpaqueBinds
    {
        get
        {
            global::VkSparseImageOpaqueMemoryBindInfo __result0;
            if (((global::VkBindSparseInfo.__Internal*) __Instance)->pImageOpaqueBinds == IntPtr.Zero) __result0 = null;
            else if (global::VkSparseImageOpaqueMemoryBindInfo.NativeToManagedMap.ContainsKey(((global::VkBindSparseInfo.__Internal*) __Instance)->pImageOpaqueBinds))
                __result0 = (global::VkSparseImageOpaqueMemoryBindInfo) global::VkSparseImageOpaqueMemoryBindInfo.NativeToManagedMap[((global::VkBindSparseInfo.__Internal*) __Instance)->pImageOpaqueBinds];
            else __result0 = global::VkSparseImageOpaqueMemoryBindInfo.__CreateInstance(((global::VkBindSparseInfo.__Internal*) __Instance)->pImageOpaqueBinds);
            return __result0;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->pImageOpaqueBinds = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint ImageBindCount
    {
        get
        {
            return ((global::VkBindSparseInfo.__Internal*) __Instance)->imageBindCount;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->imageBindCount = value;
        }
    }

    public global::VkSparseImageMemoryBindInfo PImageBinds
    {
        get
        {
            global::VkSparseImageMemoryBindInfo __result0;
            if (((global::VkBindSparseInfo.__Internal*) __Instance)->pImageBinds == IntPtr.Zero) __result0 = null;
            else if (global::VkSparseImageMemoryBindInfo.NativeToManagedMap.ContainsKey(((global::VkBindSparseInfo.__Internal*) __Instance)->pImageBinds))
                __result0 = (global::VkSparseImageMemoryBindInfo) global::VkSparseImageMemoryBindInfo.NativeToManagedMap[((global::VkBindSparseInfo.__Internal*) __Instance)->pImageBinds];
            else __result0 = global::VkSparseImageMemoryBindInfo.__CreateInstance(((global::VkBindSparseInfo.__Internal*) __Instance)->pImageBinds);
            return __result0;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->pImageBinds = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint SignalSemaphoreCount
    {
        get
        {
            return ((global::VkBindSparseInfo.__Internal*) __Instance)->signalSemaphoreCount;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->signalSemaphoreCount = value;
        }
    }

    public global::VkSemaphoreT PSignalSemaphores
    {
        get
        {
            global::VkSemaphoreT __result0;
            if (((global::VkBindSparseInfo.__Internal*) __Instance)->pSignalSemaphores == IntPtr.Zero) __result0 = null;
            else if (global::VkSemaphoreT.NativeToManagedMap.ContainsKey(((global::VkBindSparseInfo.__Internal*) __Instance)->pSignalSemaphores))
                __result0 = (global::VkSemaphoreT) global::VkSemaphoreT.NativeToManagedMap[((global::VkBindSparseInfo.__Internal*) __Instance)->pSignalSemaphores];
            else __result0 = global::VkSemaphoreT.__CreateInstance(((global::VkBindSparseInfo.__Internal*) __Instance)->pSignalSemaphores);
            return __result0;
        }

        set
        {
            ((global::VkBindSparseInfo.__Internal*)__Instance)->pSignalSemaphores = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkFenceCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkFenceCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFenceCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFenceCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkFenceCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkFenceCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkFenceCreateInfo __CreateInstance(global::VkFenceCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkFenceCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkFenceCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkFenceCreateInfo.__Internal));
        *(global::VkFenceCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkFenceCreateInfo(global::VkFenceCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkFenceCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkFenceCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFenceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkFenceCreateInfo(global::VkFenceCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFenceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkFenceCreateInfo.__Internal*) __Instance) = *((global::VkFenceCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkFenceCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkFenceCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkFenceCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkFenceCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkFenceCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkFenceCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkFenceCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkSemaphoreCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSemaphoreCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSemaphoreCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSemaphoreCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSemaphoreCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSemaphoreCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkSemaphoreCreateInfo __CreateInstance(global::VkSemaphoreCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkSemaphoreCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSemaphoreCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSemaphoreCreateInfo.__Internal));
        *(global::VkSemaphoreCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSemaphoreCreateInfo(global::VkSemaphoreCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSemaphoreCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSemaphoreCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSemaphoreCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSemaphoreCreateInfo(global::VkSemaphoreCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSemaphoreCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSemaphoreCreateInfo.__Internal*) __Instance) = *((global::VkSemaphoreCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSemaphoreCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSemaphoreCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSemaphoreCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSemaphoreCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSemaphoreCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkSemaphoreCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkSemaphoreCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkEventCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkEventCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkEventCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkEventCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkEventCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkEventCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkEventCreateInfo __CreateInstance(global::VkEventCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkEventCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkEventCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkEventCreateInfo.__Internal));
        *(global::VkEventCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkEventCreateInfo(global::VkEventCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkEventCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkEventCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkEventCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkEventCreateInfo(global::VkEventCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkEventCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkEventCreateInfo.__Internal*) __Instance) = *((global::VkEventCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkEventCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkEventCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkEventCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkEventCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkEventCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkEventCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkEventCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkQueryPoolCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkQueryType queryType;

        [FieldOffset(24)]
        internal uint queryCount;

        [FieldOffset(28)]
        internal uint pipelineStatistics;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkQueryPoolCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueryPoolCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueryPoolCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkQueryPoolCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkQueryPoolCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkQueryPoolCreateInfo __CreateInstance(global::VkQueryPoolCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkQueryPoolCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkQueryPoolCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkQueryPoolCreateInfo.__Internal));
        *(global::VkQueryPoolCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkQueryPoolCreateInfo(global::VkQueryPoolCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkQueryPoolCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkQueryPoolCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkQueryPoolCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkQueryPoolCreateInfo(global::VkQueryPoolCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkQueryPoolCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkQueryPoolCreateInfo.__Internal*) __Instance) = *((global::VkQueryPoolCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkQueryPoolCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkQueryPoolCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkQueryPoolCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkQueryPoolCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkQueryPoolCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkQueryPoolCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkQueryPoolCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkQueryType QueryType
    {
        get
        {
            return ((global::VkQueryPoolCreateInfo.__Internal*) __Instance)->queryType;
        }

        set
        {
            ((global::VkQueryPoolCreateInfo.__Internal*)__Instance)->queryType = value;
        }
    }

    public uint QueryCount
    {
        get
        {
            return ((global::VkQueryPoolCreateInfo.__Internal*) __Instance)->queryCount;
        }

        set
        {
            ((global::VkQueryPoolCreateInfo.__Internal*)__Instance)->queryCount = value;
        }
    }

    public uint PipelineStatistics
    {
        get
        {
            return ((global::VkQueryPoolCreateInfo.__Internal*) __Instance)->pipelineStatistics;
        }

        set
        {
            ((global::VkQueryPoolCreateInfo.__Internal*)__Instance)->pipelineStatistics = value;
        }
    }
}

public unsafe partial class VkBufferCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal ulong size;

        [FieldOffset(32)]
        internal uint usage;

        [FieldOffset(36)]
        internal global::VkSharingMode sharingMode;

        [FieldOffset(40)]
        internal uint queueFamilyIndexCount;

        [FieldOffset(48)]
        internal global::System.IntPtr pQueueFamilyIndices;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBufferCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBufferCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBufferCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkBufferCreateInfo __CreateInstance(global::VkBufferCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkBufferCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBufferCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBufferCreateInfo.__Internal));
        *(global::VkBufferCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBufferCreateInfo(global::VkBufferCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBufferCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBufferCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBufferCreateInfo(global::VkBufferCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBufferCreateInfo.__Internal*) __Instance) = *((global::VkBufferCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBufferCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBufferCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBufferCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBufferCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBufferCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkBufferCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkBufferCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public ulong Size
    {
        get
        {
            return ((global::VkBufferCreateInfo.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkBufferCreateInfo.__Internal*)__Instance)->size = value;
        }
    }

    public uint Usage
    {
        get
        {
            return ((global::VkBufferCreateInfo.__Internal*) __Instance)->usage;
        }

        set
        {
            ((global::VkBufferCreateInfo.__Internal*)__Instance)->usage = value;
        }
    }

    public global::VkSharingMode SharingMode
    {
        get
        {
            return ((global::VkBufferCreateInfo.__Internal*) __Instance)->sharingMode;
        }

        set
        {
            ((global::VkBufferCreateInfo.__Internal*)__Instance)->sharingMode = value;
        }
    }

    public uint QueueFamilyIndexCount
    {
        get
        {
            return ((global::VkBufferCreateInfo.__Internal*) __Instance)->queueFamilyIndexCount;
        }

        set
        {
            ((global::VkBufferCreateInfo.__Internal*)__Instance)->queueFamilyIndexCount = value;
        }
    }

    public uint* PQueueFamilyIndices
    {
        get
        {
            return (uint*) ((global::VkBufferCreateInfo.__Internal*) __Instance)->pQueueFamilyIndices;
        }

        set
        {
            ((global::VkBufferCreateInfo.__Internal*)__Instance)->pQueueFamilyIndices = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkBufferViewCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::System.IntPtr buffer;

        [FieldOffset(32)]
        internal global::VkFormat format;

        [FieldOffset(40)]
        internal ulong offset;

        [FieldOffset(48)]
        internal ulong range;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBufferViewCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferViewCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferViewCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBufferViewCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBufferViewCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkBufferViewCreateInfo __CreateInstance(global::VkBufferViewCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkBufferViewCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBufferViewCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBufferViewCreateInfo.__Internal));
        *(global::VkBufferViewCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBufferViewCreateInfo(global::VkBufferViewCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBufferViewCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBufferViewCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferViewCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBufferViewCreateInfo(global::VkBufferViewCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferViewCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBufferViewCreateInfo.__Internal*) __Instance) = *((global::VkBufferViewCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBufferViewCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBufferViewCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBufferViewCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBufferViewCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBufferViewCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkBufferViewCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkBufferViewCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkBufferViewCreateInfo.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkBufferViewCreateInfo.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkBufferViewCreateInfo.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkBufferViewCreateInfo.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkBufferViewCreateInfo.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkBufferViewCreateInfo.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkBufferViewCreateInfo.__Internal*)__Instance)->format = value;
        }
    }

    public ulong Offset
    {
        get
        {
            return ((global::VkBufferViewCreateInfo.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkBufferViewCreateInfo.__Internal*)__Instance)->offset = value;
        }
    }

    public ulong Range
    {
        get
        {
            return ((global::VkBufferViewCreateInfo.__Internal*) __Instance)->range;
        }

        set
        {
            ((global::VkBufferViewCreateInfo.__Internal*)__Instance)->range = value;
        }
    }
}

public unsafe partial class VkImageCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 88)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkImageType imageType;

        [FieldOffset(24)]
        internal global::VkFormat format;

        [FieldOffset(28)]
        internal global::VkExtent3D.__Internal extent;

        [FieldOffset(40)]
        internal uint mipLevels;

        [FieldOffset(44)]
        internal uint arrayLayers;

        [FieldOffset(48)]
        internal global::VkSampleCountFlagBits samples;

        [FieldOffset(52)]
        internal global::VkImageTiling tiling;

        [FieldOffset(56)]
        internal uint usage;

        [FieldOffset(60)]
        internal global::VkSharingMode sharingMode;

        [FieldOffset(64)]
        internal uint queueFamilyIndexCount;

        [FieldOffset(72)]
        internal global::System.IntPtr pQueueFamilyIndices;

        [FieldOffset(80)]
        internal global::VkImageLayout initialLayout;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageCreateInfo __CreateInstance(global::VkImageCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageCreateInfo.__Internal));
        *(global::VkImageCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageCreateInfo(global::VkImageCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageCreateInfo(global::VkImageCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageCreateInfo.__Internal*) __Instance) = *((global::VkImageCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkImageType ImageType
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->imageType;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->imageType = value;
        }
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->format = value;
        }
    }

    public global::VkExtent3D Extent
    {
        get
        {
            return global::VkExtent3D.__CreateInstance(new global::System.IntPtr(&((global::VkImageCreateInfo.__Internal*) __Instance)->extent));
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->extent = ReferenceEquals(value, null) ? new global::VkExtent3D.__Internal() : *(global::VkExtent3D.__Internal*) value.__Instance;
        }
    }

    public uint MipLevels
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->mipLevels;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->mipLevels = value;
        }
    }

    public uint ArrayLayers
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->arrayLayers;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->arrayLayers = value;
        }
    }

    public global::VkSampleCountFlagBits Samples
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->samples;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->samples = value;
        }
    }

    public global::VkImageTiling Tiling
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->tiling;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->tiling = value;
        }
    }

    public uint Usage
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->usage;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->usage = value;
        }
    }

    public global::VkSharingMode SharingMode
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->sharingMode;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->sharingMode = value;
        }
    }

    public uint QueueFamilyIndexCount
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->queueFamilyIndexCount;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->queueFamilyIndexCount = value;
        }
    }

    public uint* PQueueFamilyIndices
    {
        get
        {
            return (uint*) ((global::VkImageCreateInfo.__Internal*) __Instance)->pQueueFamilyIndices;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->pQueueFamilyIndices = (global::System.IntPtr) value;
        }
    }

    public global::VkImageLayout InitialLayout
    {
        get
        {
            return ((global::VkImageCreateInfo.__Internal*) __Instance)->initialLayout;
        }

        set
        {
            ((global::VkImageCreateInfo.__Internal*)__Instance)->initialLayout = value;
        }
    }
}

public unsafe partial class VkSubresourceLayout : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal ulong offset;

        [FieldOffset(8)]
        internal ulong size;

        [FieldOffset(16)]
        internal ulong rowPitch;

        [FieldOffset(24)]
        internal ulong arrayPitch;

        [FieldOffset(32)]
        internal ulong depthPitch;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSubresourceLayout@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubresourceLayout> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubresourceLayout>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSubresourceLayout __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSubresourceLayout(native.ToPointer(), skipVTables);
    }

    internal static global::VkSubresourceLayout __CreateInstance(global::VkSubresourceLayout.__Internal native, bool skipVTables = false)
    {
        return new global::VkSubresourceLayout(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSubresourceLayout.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSubresourceLayout.__Internal));
        *(global::VkSubresourceLayout.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSubresourceLayout(global::VkSubresourceLayout.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSubresourceLayout(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSubresourceLayout()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubresourceLayout.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSubresourceLayout(global::VkSubresourceLayout _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubresourceLayout.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSubresourceLayout.__Internal*) __Instance) = *((global::VkSubresourceLayout.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSubresourceLayout __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public ulong Offset
    {
        get
        {
            return ((global::VkSubresourceLayout.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkSubresourceLayout.__Internal*)__Instance)->offset = value;
        }
    }

    public ulong Size
    {
        get
        {
            return ((global::VkSubresourceLayout.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkSubresourceLayout.__Internal*)__Instance)->size = value;
        }
    }

    public ulong RowPitch
    {
        get
        {
            return ((global::VkSubresourceLayout.__Internal*) __Instance)->rowPitch;
        }

        set
        {
            ((global::VkSubresourceLayout.__Internal*)__Instance)->rowPitch = value;
        }
    }

    public ulong ArrayPitch
    {
        get
        {
            return ((global::VkSubresourceLayout.__Internal*) __Instance)->arrayPitch;
        }

        set
        {
            ((global::VkSubresourceLayout.__Internal*)__Instance)->arrayPitch = value;
        }
    }

    public ulong DepthPitch
    {
        get
        {
            return ((global::VkSubresourceLayout.__Internal*) __Instance)->depthPitch;
        }

        set
        {
            ((global::VkSubresourceLayout.__Internal*)__Instance)->depthPitch = value;
        }
    }
}

public unsafe partial class VkComponentMapping : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkComponentSwizzle r;

        [FieldOffset(4)]
        internal global::VkComponentSwizzle g;

        [FieldOffset(8)]
        internal global::VkComponentSwizzle b;

        [FieldOffset(12)]
        internal global::VkComponentSwizzle a;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkComponentMapping@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkComponentMapping> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkComponentMapping>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkComponentMapping __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkComponentMapping(native.ToPointer(), skipVTables);
    }

    internal static global::VkComponentMapping __CreateInstance(global::VkComponentMapping.__Internal native, bool skipVTables = false)
    {
        return new global::VkComponentMapping(native, skipVTables);
    }

    private static void* __CopyValue(global::VkComponentMapping.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkComponentMapping.__Internal));
        *(global::VkComponentMapping.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkComponentMapping(global::VkComponentMapping.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkComponentMapping(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkComponentMapping()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkComponentMapping.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkComponentMapping(global::VkComponentMapping _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkComponentMapping.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkComponentMapping.__Internal*) __Instance) = *((global::VkComponentMapping.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkComponentMapping __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkComponentSwizzle R
    {
        get
        {
            return ((global::VkComponentMapping.__Internal*) __Instance)->r;
        }

        set
        {
            ((global::VkComponentMapping.__Internal*)__Instance)->r = value;
        }
    }

    public global::VkComponentSwizzle G
    {
        get
        {
            return ((global::VkComponentMapping.__Internal*) __Instance)->g;
        }

        set
        {
            ((global::VkComponentMapping.__Internal*)__Instance)->g = value;
        }
    }

    public global::VkComponentSwizzle B
    {
        get
        {
            return ((global::VkComponentMapping.__Internal*) __Instance)->b;
        }

        set
        {
            ((global::VkComponentMapping.__Internal*)__Instance)->b = value;
        }
    }

    public global::VkComponentSwizzle A
    {
        get
        {
            return ((global::VkComponentMapping.__Internal*) __Instance)->a;
        }

        set
        {
            ((global::VkComponentMapping.__Internal*)__Instance)->a = value;
        }
    }
}

public unsafe partial class VkImageSubresourceRange : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint aspectMask;

        [FieldOffset(4)]
        internal uint baseMipLevel;

        [FieldOffset(8)]
        internal uint levelCount;

        [FieldOffset(12)]
        internal uint baseArrayLayer;

        [FieldOffset(16)]
        internal uint layerCount;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageSubresourceRange@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSubresourceRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSubresourceRange>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageSubresourceRange __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageSubresourceRange(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageSubresourceRange __CreateInstance(global::VkImageSubresourceRange.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageSubresourceRange(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageSubresourceRange.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageSubresourceRange.__Internal));
        *(global::VkImageSubresourceRange.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageSubresourceRange(global::VkImageSubresourceRange.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageSubresourceRange(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageSubresourceRange()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSubresourceRange.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageSubresourceRange(global::VkImageSubresourceRange _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSubresourceRange.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageSubresourceRange.__Internal*) __Instance) = *((global::VkImageSubresourceRange.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageSubresourceRange __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint AspectMask
    {
        get
        {
            return ((global::VkImageSubresourceRange.__Internal*) __Instance)->aspectMask;
        }

        set
        {
            ((global::VkImageSubresourceRange.__Internal*)__Instance)->aspectMask = value;
        }
    }

    public uint BaseMipLevel
    {
        get
        {
            return ((global::VkImageSubresourceRange.__Internal*) __Instance)->baseMipLevel;
        }

        set
        {
            ((global::VkImageSubresourceRange.__Internal*)__Instance)->baseMipLevel = value;
        }
    }

    public uint LevelCount
    {
        get
        {
            return ((global::VkImageSubresourceRange.__Internal*) __Instance)->levelCount;
        }

        set
        {
            ((global::VkImageSubresourceRange.__Internal*)__Instance)->levelCount = value;
        }
    }

    public uint BaseArrayLayer
    {
        get
        {
            return ((global::VkImageSubresourceRange.__Internal*) __Instance)->baseArrayLayer;
        }

        set
        {
            ((global::VkImageSubresourceRange.__Internal*)__Instance)->baseArrayLayer = value;
        }
    }

    public uint LayerCount
    {
        get
        {
            return ((global::VkImageSubresourceRange.__Internal*) __Instance)->layerCount;
        }

        set
        {
            ((global::VkImageSubresourceRange.__Internal*)__Instance)->layerCount = value;
        }
    }
}

public unsafe partial class VkImageViewCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::System.IntPtr image;

        [FieldOffset(32)]
        internal global::VkImageViewType viewType;

        [FieldOffset(36)]
        internal global::VkFormat format;

        [FieldOffset(40)]
        internal global::VkComponentMapping.__Internal components;

        [FieldOffset(56)]
        internal global::VkImageSubresourceRange.__Internal subresourceRange;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageViewCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageViewCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageViewCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageViewCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageViewCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageViewCreateInfo __CreateInstance(global::VkImageViewCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageViewCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageViewCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageViewCreateInfo.__Internal));
        *(global::VkImageViewCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageViewCreateInfo(global::VkImageViewCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageViewCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageViewCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageViewCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageViewCreateInfo(global::VkImageViewCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageViewCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageViewCreateInfo.__Internal*) __Instance) = *((global::VkImageViewCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageViewCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImageViewCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImageViewCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImageViewCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImageViewCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkImageViewCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkImageViewCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkImageT Image
    {
        get
        {
            global::VkImageT __result0;
            if (((global::VkImageViewCreateInfo.__Internal*) __Instance)->image == IntPtr.Zero) __result0 = null;
            else if (global::VkImageT.NativeToManagedMap.ContainsKey(((global::VkImageViewCreateInfo.__Internal*) __Instance)->image))
                __result0 = (global::VkImageT) global::VkImageT.NativeToManagedMap[((global::VkImageViewCreateInfo.__Internal*) __Instance)->image];
            else __result0 = global::VkImageT.__CreateInstance(((global::VkImageViewCreateInfo.__Internal*) __Instance)->image);
            return __result0;
        }

        set
        {
            ((global::VkImageViewCreateInfo.__Internal*)__Instance)->image = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkImageViewType ViewType
    {
        get
        {
            return ((global::VkImageViewCreateInfo.__Internal*) __Instance)->viewType;
        }

        set
        {
            ((global::VkImageViewCreateInfo.__Internal*)__Instance)->viewType = value;
        }
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkImageViewCreateInfo.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkImageViewCreateInfo.__Internal*)__Instance)->format = value;
        }
    }

    public global::VkComponentMapping Components
    {
        get
        {
            return global::VkComponentMapping.__CreateInstance(new global::System.IntPtr(&((global::VkImageViewCreateInfo.__Internal*) __Instance)->components));
        }

        set
        {
            ((global::VkImageViewCreateInfo.__Internal*)__Instance)->components = ReferenceEquals(value, null) ? new global::VkComponentMapping.__Internal() : *(global::VkComponentMapping.__Internal*) value.__Instance;
        }
    }

    public global::VkImageSubresourceRange SubresourceRange
    {
        get
        {
            return global::VkImageSubresourceRange.__CreateInstance(new global::System.IntPtr(&((global::VkImageViewCreateInfo.__Internal*) __Instance)->subresourceRange));
        }

        set
        {
            ((global::VkImageViewCreateInfo.__Internal*)__Instance)->subresourceRange = ReferenceEquals(value, null) ? new global::VkImageSubresourceRange.__Internal() : *(global::VkImageSubresourceRange.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkShaderModuleCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal ulong codeSize;

        [FieldOffset(32)]
        internal global::System.IntPtr pCode;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkShaderModuleCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderModuleCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderModuleCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkShaderModuleCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkShaderModuleCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkShaderModuleCreateInfo __CreateInstance(global::VkShaderModuleCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkShaderModuleCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkShaderModuleCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkShaderModuleCreateInfo.__Internal));
        *(global::VkShaderModuleCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkShaderModuleCreateInfo(global::VkShaderModuleCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkShaderModuleCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkShaderModuleCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkShaderModuleCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkShaderModuleCreateInfo(global::VkShaderModuleCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkShaderModuleCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkShaderModuleCreateInfo.__Internal*) __Instance) = *((global::VkShaderModuleCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkShaderModuleCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkShaderModuleCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkShaderModuleCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkShaderModuleCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkShaderModuleCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkShaderModuleCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkShaderModuleCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public ulong CodeSize
    {
        get
        {
            return ((global::VkShaderModuleCreateInfo.__Internal*) __Instance)->codeSize;
        }

        set
        {
            ((global::VkShaderModuleCreateInfo.__Internal*)__Instance)->codeSize = value;
        }
    }

    public uint* PCode
    {
        get
        {
            return (uint*) ((global::VkShaderModuleCreateInfo.__Internal*) __Instance)->pCode;
        }

        set
        {
            ((global::VkShaderModuleCreateInfo.__Internal*)__Instance)->pCode = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkPipelineCacheCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal ulong initialDataSize;

        [FieldOffset(32)]
        internal global::System.IntPtr pInitialData;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineCacheCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineCacheCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineCacheCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineCacheCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineCacheCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineCacheCreateInfo __CreateInstance(global::VkPipelineCacheCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineCacheCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineCacheCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineCacheCreateInfo.__Internal));
        *(global::VkPipelineCacheCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineCacheCreateInfo(global::VkPipelineCacheCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineCacheCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineCacheCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineCacheCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineCacheCreateInfo(global::VkPipelineCacheCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineCacheCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineCacheCreateInfo.__Internal*) __Instance) = *((global::VkPipelineCacheCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineCacheCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineCacheCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineCacheCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineCacheCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineCacheCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineCacheCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineCacheCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public ulong InitialDataSize
    {
        get
        {
            return ((global::VkPipelineCacheCreateInfo.__Internal*) __Instance)->initialDataSize;
        }

        set
        {
            ((global::VkPipelineCacheCreateInfo.__Internal*)__Instance)->initialDataSize = value;
        }
    }

    public global::System.IntPtr PInitialData
    {
        get
        {
            return ((global::VkPipelineCacheCreateInfo.__Internal*) __Instance)->pInitialData;
        }

        set
        {
            ((global::VkPipelineCacheCreateInfo.__Internal*)__Instance)->pInitialData = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkSpecializationMapEntry : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint constantID;

        [FieldOffset(4)]
        internal uint offset;

        [FieldOffset(8)]
        internal ulong size;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSpecializationMapEntry@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSpecializationMapEntry> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSpecializationMapEntry>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSpecializationMapEntry __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSpecializationMapEntry(native.ToPointer(), skipVTables);
    }

    internal static global::VkSpecializationMapEntry __CreateInstance(global::VkSpecializationMapEntry.__Internal native, bool skipVTables = false)
    {
        return new global::VkSpecializationMapEntry(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSpecializationMapEntry.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSpecializationMapEntry.__Internal));
        *(global::VkSpecializationMapEntry.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSpecializationMapEntry(global::VkSpecializationMapEntry.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSpecializationMapEntry(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSpecializationMapEntry()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSpecializationMapEntry.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSpecializationMapEntry(global::VkSpecializationMapEntry _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSpecializationMapEntry.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSpecializationMapEntry.__Internal*) __Instance) = *((global::VkSpecializationMapEntry.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSpecializationMapEntry __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint ConstantID
    {
        get
        {
            return ((global::VkSpecializationMapEntry.__Internal*) __Instance)->constantID;
        }

        set
        {
            ((global::VkSpecializationMapEntry.__Internal*)__Instance)->constantID = value;
        }
    }

    public uint Offset
    {
        get
        {
            return ((global::VkSpecializationMapEntry.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkSpecializationMapEntry.__Internal*)__Instance)->offset = value;
        }
    }

    public ulong Size
    {
        get
        {
            return ((global::VkSpecializationMapEntry.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkSpecializationMapEntry.__Internal*)__Instance)->size = value;
        }
    }
}

public unsafe partial class VkSpecializationInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint mapEntryCount;

        [FieldOffset(8)]
        internal global::System.IntPtr pMapEntries;

        [FieldOffset(16)]
        internal ulong dataSize;

        [FieldOffset(24)]
        internal global::System.IntPtr pData;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSpecializationInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSpecializationInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSpecializationInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSpecializationInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSpecializationInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkSpecializationInfo __CreateInstance(global::VkSpecializationInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkSpecializationInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSpecializationInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSpecializationInfo.__Internal));
        *(global::VkSpecializationInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSpecializationInfo(global::VkSpecializationInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSpecializationInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSpecializationInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSpecializationInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSpecializationInfo(global::VkSpecializationInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSpecializationInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSpecializationInfo.__Internal*) __Instance) = *((global::VkSpecializationInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSpecializationInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint MapEntryCount
    {
        get
        {
            return ((global::VkSpecializationInfo.__Internal*) __Instance)->mapEntryCount;
        }

        set
        {
            ((global::VkSpecializationInfo.__Internal*)__Instance)->mapEntryCount = value;
        }
    }

    public global::VkSpecializationMapEntry PMapEntries
    {
        get
        {
            global::VkSpecializationMapEntry __result0;
            if (((global::VkSpecializationInfo.__Internal*) __Instance)->pMapEntries == IntPtr.Zero) __result0 = null;
            else if (global::VkSpecializationMapEntry.NativeToManagedMap.ContainsKey(((global::VkSpecializationInfo.__Internal*) __Instance)->pMapEntries))
                __result0 = (global::VkSpecializationMapEntry) global::VkSpecializationMapEntry.NativeToManagedMap[((global::VkSpecializationInfo.__Internal*) __Instance)->pMapEntries];
            else __result0 = global::VkSpecializationMapEntry.__CreateInstance(((global::VkSpecializationInfo.__Internal*) __Instance)->pMapEntries);
            return __result0;
        }

        set
        {
            ((global::VkSpecializationInfo.__Internal*)__Instance)->pMapEntries = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong DataSize
    {
        get
        {
            return ((global::VkSpecializationInfo.__Internal*) __Instance)->dataSize;
        }

        set
        {
            ((global::VkSpecializationInfo.__Internal*)__Instance)->dataSize = value;
        }
    }

    public global::System.IntPtr PData
    {
        get
        {
            return ((global::VkSpecializationInfo.__Internal*) __Instance)->pData;
        }

        set
        {
            ((global::VkSpecializationInfo.__Internal*)__Instance)->pData = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkPipelineShaderStageCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkShaderStageFlagBits stage;

        [FieldOffset(24)]
        internal global::System.IntPtr module;

        [FieldOffset(32)]
        internal global::System.IntPtr pName;

        [FieldOffset(40)]
        internal global::System.IntPtr pSpecializationInfo;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineShaderStageCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineShaderStageCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineShaderStageCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineShaderStageCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineShaderStageCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineShaderStageCreateInfo __CreateInstance(global::VkPipelineShaderStageCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineShaderStageCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineShaderStageCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineShaderStageCreateInfo.__Internal));
        *(global::VkPipelineShaderStageCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineShaderStageCreateInfo(global::VkPipelineShaderStageCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineShaderStageCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineShaderStageCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineShaderStageCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineShaderStageCreateInfo(global::VkPipelineShaderStageCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineShaderStageCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance) = *((global::VkPipelineShaderStageCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineShaderStageCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineShaderStageCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineShaderStageCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineShaderStageCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkShaderStageFlagBits Stage
    {
        get
        {
            return ((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->stage;
        }

        set
        {
            ((global::VkPipelineShaderStageCreateInfo.__Internal*)__Instance)->stage = value;
        }
    }

    public global::VkShaderModuleT Module
    {
        get
        {
            global::VkShaderModuleT __result0;
            if (((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->module == IntPtr.Zero) __result0 = null;
            else if (global::VkShaderModuleT.NativeToManagedMap.ContainsKey(((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->module))
                __result0 = (global::VkShaderModuleT) global::VkShaderModuleT.NativeToManagedMap[((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->module];
            else __result0 = global::VkShaderModuleT.__CreateInstance(((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->module);
            return __result0;
        }

        set
        {
            ((global::VkPipelineShaderStageCreateInfo.__Internal*)__Instance)->module = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public string PName
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->pName);
        }

        set
        {
            ((global::VkPipelineShaderStageCreateInfo.__Internal*)__Instance)->pName = Marshal.StringToHGlobalAnsi(value);
        }
    }

    public global::VkSpecializationInfo PSpecializationInfo
    {
        get
        {
            global::VkSpecializationInfo __result0;
            if (((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->pSpecializationInfo == IntPtr.Zero) __result0 = null;
            else if (global::VkSpecializationInfo.NativeToManagedMap.ContainsKey(((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->pSpecializationInfo))
                __result0 = (global::VkSpecializationInfo) global::VkSpecializationInfo.NativeToManagedMap[((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->pSpecializationInfo];
            else __result0 = global::VkSpecializationInfo.__CreateInstance(((global::VkPipelineShaderStageCreateInfo.__Internal*) __Instance)->pSpecializationInfo);
            return __result0;
        }

        set
        {
            ((global::VkPipelineShaderStageCreateInfo.__Internal*)__Instance)->pSpecializationInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkVertexInputBindingDescription : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint binding;

        [FieldOffset(4)]
        internal uint stride;

        [FieldOffset(8)]
        internal global::VkVertexInputRate inputRate;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkVertexInputBindingDescription@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkVertexInputBindingDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkVertexInputBindingDescription>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkVertexInputBindingDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkVertexInputBindingDescription(native.ToPointer(), skipVTables);
    }

    internal static global::VkVertexInputBindingDescription __CreateInstance(global::VkVertexInputBindingDescription.__Internal native, bool skipVTables = false)
    {
        return new global::VkVertexInputBindingDescription(native, skipVTables);
    }

    private static void* __CopyValue(global::VkVertexInputBindingDescription.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkVertexInputBindingDescription.__Internal));
        *(global::VkVertexInputBindingDescription.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkVertexInputBindingDescription(global::VkVertexInputBindingDescription.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkVertexInputBindingDescription(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkVertexInputBindingDescription()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkVertexInputBindingDescription.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkVertexInputBindingDescription(global::VkVertexInputBindingDescription _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkVertexInputBindingDescription.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkVertexInputBindingDescription.__Internal*) __Instance) = *((global::VkVertexInputBindingDescription.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkVertexInputBindingDescription __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Binding
    {
        get
        {
            return ((global::VkVertexInputBindingDescription.__Internal*) __Instance)->binding;
        }

        set
        {
            ((global::VkVertexInputBindingDescription.__Internal*)__Instance)->binding = value;
        }
    }

    public uint Stride
    {
        get
        {
            return ((global::VkVertexInputBindingDescription.__Internal*) __Instance)->stride;
        }

        set
        {
            ((global::VkVertexInputBindingDescription.__Internal*)__Instance)->stride = value;
        }
    }

    public global::VkVertexInputRate InputRate
    {
        get
        {
            return ((global::VkVertexInputBindingDescription.__Internal*) __Instance)->inputRate;
        }

        set
        {
            ((global::VkVertexInputBindingDescription.__Internal*)__Instance)->inputRate = value;
        }
    }
}

public unsafe partial class VkVertexInputAttributeDescription : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint location;

        [FieldOffset(4)]
        internal uint binding;

        [FieldOffset(8)]
        internal global::VkFormat format;

        [FieldOffset(12)]
        internal uint offset;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkVertexInputAttributeDescription@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkVertexInputAttributeDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkVertexInputAttributeDescription>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkVertexInputAttributeDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkVertexInputAttributeDescription(native.ToPointer(), skipVTables);
    }

    internal static global::VkVertexInputAttributeDescription __CreateInstance(global::VkVertexInputAttributeDescription.__Internal native, bool skipVTables = false)
    {
        return new global::VkVertexInputAttributeDescription(native, skipVTables);
    }

    private static void* __CopyValue(global::VkVertexInputAttributeDescription.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkVertexInputAttributeDescription.__Internal));
        *(global::VkVertexInputAttributeDescription.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkVertexInputAttributeDescription(global::VkVertexInputAttributeDescription.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkVertexInputAttributeDescription(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkVertexInputAttributeDescription()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkVertexInputAttributeDescription.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkVertexInputAttributeDescription(global::VkVertexInputAttributeDescription _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkVertexInputAttributeDescription.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkVertexInputAttributeDescription.__Internal*) __Instance) = *((global::VkVertexInputAttributeDescription.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkVertexInputAttributeDescription __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Location
    {
        get
        {
            return ((global::VkVertexInputAttributeDescription.__Internal*) __Instance)->location;
        }

        set
        {
            ((global::VkVertexInputAttributeDescription.__Internal*)__Instance)->location = value;
        }
    }

    public uint Binding
    {
        get
        {
            return ((global::VkVertexInputAttributeDescription.__Internal*) __Instance)->binding;
        }

        set
        {
            ((global::VkVertexInputAttributeDescription.__Internal*)__Instance)->binding = value;
        }
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkVertexInputAttributeDescription.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkVertexInputAttributeDescription.__Internal*)__Instance)->format = value;
        }
    }

    public uint Offset
    {
        get
        {
            return ((global::VkVertexInputAttributeDescription.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkVertexInputAttributeDescription.__Internal*)__Instance)->offset = value;
        }
    }
}

public unsafe partial class VkPipelineVertexInputStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint vertexBindingDescriptionCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pVertexBindingDescriptions;

        [FieldOffset(32)]
        internal uint vertexAttributeDescriptionCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pVertexAttributeDescriptions;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineVertexInputStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineVertexInputStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineVertexInputStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineVertexInputStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineVertexInputStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineVertexInputStateCreateInfo __CreateInstance(global::VkPipelineVertexInputStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineVertexInputStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineVertexInputStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineVertexInputStateCreateInfo.__Internal));
        *(global::VkPipelineVertexInputStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineVertexInputStateCreateInfo(global::VkPipelineVertexInputStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineVertexInputStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineVertexInputStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineVertexInputStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineVertexInputStateCreateInfo(global::VkPipelineVertexInputStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineVertexInputStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineVertexInputStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineVertexInputStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineVertexInputStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineVertexInputStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineVertexInputStateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint VertexBindingDescriptionCount
    {
        get
        {
            return ((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->vertexBindingDescriptionCount;
        }

        set
        {
            ((global::VkPipelineVertexInputStateCreateInfo.__Internal*)__Instance)->vertexBindingDescriptionCount = value;
        }
    }

    public global::VkVertexInputBindingDescription PVertexBindingDescriptions
    {
        get
        {
            global::VkVertexInputBindingDescription __result0;
            if (((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->pVertexBindingDescriptions == IntPtr.Zero) __result0 = null;
            else if (global::VkVertexInputBindingDescription.NativeToManagedMap.ContainsKey(((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->pVertexBindingDescriptions))
                __result0 = (global::VkVertexInputBindingDescription) global::VkVertexInputBindingDescription.NativeToManagedMap[((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->pVertexBindingDescriptions];
            else __result0 = global::VkVertexInputBindingDescription.__CreateInstance(((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->pVertexBindingDescriptions);
            return __result0;
        }

        set
        {
            ((global::VkPipelineVertexInputStateCreateInfo.__Internal*)__Instance)->pVertexBindingDescriptions = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint VertexAttributeDescriptionCount
    {
        get
        {
            return ((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->vertexAttributeDescriptionCount;
        }

        set
        {
            ((global::VkPipelineVertexInputStateCreateInfo.__Internal*)__Instance)->vertexAttributeDescriptionCount = value;
        }
    }

    public global::VkVertexInputAttributeDescription PVertexAttributeDescriptions
    {
        get
        {
            global::VkVertexInputAttributeDescription __result0;
            if (((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->pVertexAttributeDescriptions == IntPtr.Zero) __result0 = null;
            else if (global::VkVertexInputAttributeDescription.NativeToManagedMap.ContainsKey(((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->pVertexAttributeDescriptions))
                __result0 = (global::VkVertexInputAttributeDescription) global::VkVertexInputAttributeDescription.NativeToManagedMap[((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->pVertexAttributeDescriptions];
            else __result0 = global::VkVertexInputAttributeDescription.__CreateInstance(((global::VkPipelineVertexInputStateCreateInfo.__Internal*) __Instance)->pVertexAttributeDescriptions);
            return __result0;
        }

        set
        {
            ((global::VkPipelineVertexInputStateCreateInfo.__Internal*)__Instance)->pVertexAttributeDescriptions = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkPipelineInputAssemblyStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkPrimitiveTopology topology;

        [FieldOffset(24)]
        internal uint primitiveRestartEnable;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineInputAssemblyStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineInputAssemblyStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineInputAssemblyStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineInputAssemblyStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineInputAssemblyStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineInputAssemblyStateCreateInfo __CreateInstance(global::VkPipelineInputAssemblyStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineInputAssemblyStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineInputAssemblyStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineInputAssemblyStateCreateInfo.__Internal));
        *(global::VkPipelineInputAssemblyStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineInputAssemblyStateCreateInfo(global::VkPipelineInputAssemblyStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineInputAssemblyStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineInputAssemblyStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineInputAssemblyStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineInputAssemblyStateCreateInfo(global::VkPipelineInputAssemblyStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineInputAssemblyStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineInputAssemblyStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkPrimitiveTopology Topology
    {
        get
        {
            return ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*) __Instance)->topology;
        }

        set
        {
            ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*)__Instance)->topology = value;
        }
    }

    public uint PrimitiveRestartEnable
    {
        get
        {
            return ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*) __Instance)->primitiveRestartEnable;
        }

        set
        {
            ((global::VkPipelineInputAssemblyStateCreateInfo.__Internal*)__Instance)->primitiveRestartEnable = value;
        }
    }
}

public unsafe partial class VkPipelineTessellationStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint patchControlPoints;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineTessellationStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineTessellationStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineTessellationStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineTessellationStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineTessellationStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineTessellationStateCreateInfo __CreateInstance(global::VkPipelineTessellationStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineTessellationStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineTessellationStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineTessellationStateCreateInfo.__Internal));
        *(global::VkPipelineTessellationStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineTessellationStateCreateInfo(global::VkPipelineTessellationStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineTessellationStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineTessellationStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineTessellationStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineTessellationStateCreateInfo(global::VkPipelineTessellationStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineTessellationStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineTessellationStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineTessellationStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineTessellationStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineTessellationStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineTessellationStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineTessellationStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineTessellationStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineTessellationStateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineTessellationStateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint PatchControlPoints
    {
        get
        {
            return ((global::VkPipelineTessellationStateCreateInfo.__Internal*) __Instance)->patchControlPoints;
        }

        set
        {
            ((global::VkPipelineTessellationStateCreateInfo.__Internal*)__Instance)->patchControlPoints = value;
        }
    }
}

public unsafe partial class VkViewport : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal float x;

        [FieldOffset(4)]
        internal float y;

        [FieldOffset(8)]
        internal float width;

        [FieldOffset(12)]
        internal float height;

        [FieldOffset(16)]
        internal float minDepth;

        [FieldOffset(20)]
        internal float maxDepth;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkViewport@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkViewport> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkViewport>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkViewport __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkViewport(native.ToPointer(), skipVTables);
    }

    internal static global::VkViewport __CreateInstance(global::VkViewport.__Internal native, bool skipVTables = false)
    {
        return new global::VkViewport(native, skipVTables);
    }

    private static void* __CopyValue(global::VkViewport.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkViewport.__Internal));
        *(global::VkViewport.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkViewport(global::VkViewport.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkViewport(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkViewport()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkViewport.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkViewport(global::VkViewport _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkViewport.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkViewport.__Internal*) __Instance) = *((global::VkViewport.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkViewport __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public float X
    {
        get
        {
            return ((global::VkViewport.__Internal*) __Instance)->x;
        }

        set
        {
            ((global::VkViewport.__Internal*)__Instance)->x = value;
        }
    }

    public float Y
    {
        get
        {
            return ((global::VkViewport.__Internal*) __Instance)->y;
        }

        set
        {
            ((global::VkViewport.__Internal*)__Instance)->y = value;
        }
    }

    public float Width
    {
        get
        {
            return ((global::VkViewport.__Internal*) __Instance)->width;
        }

        set
        {
            ((global::VkViewport.__Internal*)__Instance)->width = value;
        }
    }

    public float Height
    {
        get
        {
            return ((global::VkViewport.__Internal*) __Instance)->height;
        }

        set
        {
            ((global::VkViewport.__Internal*)__Instance)->height = value;
        }
    }

    public float MinDepth
    {
        get
        {
            return ((global::VkViewport.__Internal*) __Instance)->minDepth;
        }

        set
        {
            ((global::VkViewport.__Internal*)__Instance)->minDepth = value;
        }
    }

    public float MaxDepth
    {
        get
        {
            return ((global::VkViewport.__Internal*) __Instance)->maxDepth;
        }

        set
        {
            ((global::VkViewport.__Internal*)__Instance)->maxDepth = value;
        }
    }
}

public unsafe partial class VkOffset2D : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal int x;

        [FieldOffset(4)]
        internal int y;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkOffset2D@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkOffset2D> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkOffset2D>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkOffset2D __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkOffset2D(native.ToPointer(), skipVTables);
    }

    internal static global::VkOffset2D __CreateInstance(global::VkOffset2D.__Internal native, bool skipVTables = false)
    {
        return new global::VkOffset2D(native, skipVTables);
    }

    private static void* __CopyValue(global::VkOffset2D.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkOffset2D.__Internal));
        *(global::VkOffset2D.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkOffset2D(global::VkOffset2D.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkOffset2D(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkOffset2D()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkOffset2D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkOffset2D(global::VkOffset2D _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkOffset2D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkOffset2D.__Internal*) __Instance) = *((global::VkOffset2D.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkOffset2D __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public int X
    {
        get
        {
            return ((global::VkOffset2D.__Internal*) __Instance)->x;
        }

        set
        {
            ((global::VkOffset2D.__Internal*)__Instance)->x = value;
        }
    }

    public int Y
    {
        get
        {
            return ((global::VkOffset2D.__Internal*) __Instance)->y;
        }

        set
        {
            ((global::VkOffset2D.__Internal*)__Instance)->y = value;
        }
    }
}

public unsafe partial class VkExtent2D : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint width;

        [FieldOffset(4)]
        internal uint height;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExtent2D@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExtent2D> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExtent2D>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExtent2D __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExtent2D(native.ToPointer(), skipVTables);
    }

    internal static global::VkExtent2D __CreateInstance(global::VkExtent2D.__Internal native, bool skipVTables = false)
    {
        return new global::VkExtent2D(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExtent2D.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExtent2D.__Internal));
        *(global::VkExtent2D.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExtent2D(global::VkExtent2D.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExtent2D(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExtent2D(global::VkExtent2D _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExtent2D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExtent2D.__Internal*) __Instance) = *((global::VkExtent2D.__Internal*) _0.__Instance);
    }

    public VkExtent2D()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExtent2D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExtent2D __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Width
    {
        get
        {
            return ((global::VkExtent2D.__Internal*) __Instance)->width;
        }

        set
        {
            ((global::VkExtent2D.__Internal*)__Instance)->width = value;
        }
    }

    public uint Height
    {
        get
        {
            return ((global::VkExtent2D.__Internal*) __Instance)->height;
        }

        set
        {
            ((global::VkExtent2D.__Internal*)__Instance)->height = value;
        }
    }
}

public unsafe partial class VkRect2D : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkOffset2D.__Internal offset;

        [FieldOffset(8)]
        internal global::VkExtent2D.__Internal extent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkRect2D@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRect2D> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRect2D>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRect2D __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRect2D(native.ToPointer(), skipVTables);
    }

    internal static global::VkRect2D __CreateInstance(global::VkRect2D.__Internal native, bool skipVTables = false)
    {
        return new global::VkRect2D(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRect2D.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRect2D.__Internal));
        *(global::VkRect2D.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRect2D(global::VkRect2D.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRect2D(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkRect2D()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRect2D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkRect2D(global::VkRect2D _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRect2D.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkRect2D.__Internal*) __Instance) = *((global::VkRect2D.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkRect2D __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkOffset2D Offset
    {
        get
        {
            return global::VkOffset2D.__CreateInstance(new global::System.IntPtr(&((global::VkRect2D.__Internal*) __Instance)->offset));
        }

        set
        {
            ((global::VkRect2D.__Internal*)__Instance)->offset = ReferenceEquals(value, null) ? new global::VkOffset2D.__Internal() : *(global::VkOffset2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D Extent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkRect2D.__Internal*) __Instance)->extent));
        }

        set
        {
            ((global::VkRect2D.__Internal*)__Instance)->extent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPipelineViewportStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint viewportCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pViewports;

        [FieldOffset(32)]
        internal uint scissorCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pScissors;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineViewportStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineViewportStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineViewportStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineViewportStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineViewportStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineViewportStateCreateInfo __CreateInstance(global::VkPipelineViewportStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineViewportStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineViewportStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineViewportStateCreateInfo.__Internal));
        *(global::VkPipelineViewportStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineViewportStateCreateInfo(global::VkPipelineViewportStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineViewportStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineViewportStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineViewportStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineViewportStateCreateInfo(global::VkPipelineViewportStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineViewportStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineViewportStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineViewportStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineViewportStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineViewportStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineViewportStateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint ViewportCount
    {
        get
        {
            return ((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->viewportCount;
        }

        set
        {
            ((global::VkPipelineViewportStateCreateInfo.__Internal*)__Instance)->viewportCount = value;
        }
    }

    public global::VkViewport PViewports
    {
        get
        {
            global::VkViewport __result0;
            if (((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->pViewports == IntPtr.Zero) __result0 = null;
            else if (global::VkViewport.NativeToManagedMap.ContainsKey(((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->pViewports))
                __result0 = (global::VkViewport) global::VkViewport.NativeToManagedMap[((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->pViewports];
            else __result0 = global::VkViewport.__CreateInstance(((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->pViewports);
            return __result0;
        }

        set
        {
            ((global::VkPipelineViewportStateCreateInfo.__Internal*)__Instance)->pViewports = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint ScissorCount
    {
        get
        {
            return ((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->scissorCount;
        }

        set
        {
            ((global::VkPipelineViewportStateCreateInfo.__Internal*)__Instance)->scissorCount = value;
        }
    }

    public global::VkRect2D PScissors
    {
        get
        {
            global::VkRect2D __result0;
            if (((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->pScissors == IntPtr.Zero) __result0 = null;
            else if (global::VkRect2D.NativeToManagedMap.ContainsKey(((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->pScissors))
                __result0 = (global::VkRect2D) global::VkRect2D.NativeToManagedMap[((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->pScissors];
            else __result0 = global::VkRect2D.__CreateInstance(((global::VkPipelineViewportStateCreateInfo.__Internal*) __Instance)->pScissors);
            return __result0;
        }

        set
        {
            ((global::VkPipelineViewportStateCreateInfo.__Internal*)__Instance)->pScissors = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkPipelineRasterizationStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint depthClampEnable;

        [FieldOffset(24)]
        internal uint rasterizerDiscardEnable;

        [FieldOffset(28)]
        internal global::VkPolygonMode polygonMode;

        [FieldOffset(32)]
        internal uint cullMode;

        [FieldOffset(36)]
        internal global::VkFrontFace frontFace;

        [FieldOffset(40)]
        internal uint depthBiasEnable;

        [FieldOffset(44)]
        internal float depthBiasConstantFactor;

        [FieldOffset(48)]
        internal float depthBiasClamp;

        [FieldOffset(52)]
        internal float depthBiasSlopeFactor;

        [FieldOffset(56)]
        internal float lineWidth;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineRasterizationStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineRasterizationStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineRasterizationStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineRasterizationStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineRasterizationStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineRasterizationStateCreateInfo __CreateInstance(global::VkPipelineRasterizationStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineRasterizationStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineRasterizationStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineRasterizationStateCreateInfo.__Internal));
        *(global::VkPipelineRasterizationStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineRasterizationStateCreateInfo(global::VkPipelineRasterizationStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineRasterizationStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineRasterizationStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineRasterizationStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineRasterizationStateCreateInfo(global::VkPipelineRasterizationStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineRasterizationStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineRasterizationStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineRasterizationStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint DepthClampEnable
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->depthClampEnable;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->depthClampEnable = value;
        }
    }

    public uint RasterizerDiscardEnable
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->rasterizerDiscardEnable;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->rasterizerDiscardEnable = value;
        }
    }

    public global::VkPolygonMode PolygonMode
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->polygonMode;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->polygonMode = value;
        }
    }

    public uint CullMode
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->cullMode;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->cullMode = value;
        }
    }

    public global::VkFrontFace FrontFace
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->frontFace;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->frontFace = value;
        }
    }

    public uint DepthBiasEnable
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->depthBiasEnable;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->depthBiasEnable = value;
        }
    }

    public float DepthBiasConstantFactor
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->depthBiasConstantFactor;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->depthBiasConstantFactor = value;
        }
    }

    public float DepthBiasClamp
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->depthBiasClamp;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->depthBiasClamp = value;
        }
    }

    public float DepthBiasSlopeFactor
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->depthBiasSlopeFactor;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->depthBiasSlopeFactor = value;
        }
    }

    public float LineWidth
    {
        get
        {
            return ((global::VkPipelineRasterizationStateCreateInfo.__Internal*) __Instance)->lineWidth;
        }

        set
        {
            ((global::VkPipelineRasterizationStateCreateInfo.__Internal*)__Instance)->lineWidth = value;
        }
    }
}

public unsafe partial class VkPipelineMultisampleStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkSampleCountFlagBits rasterizationSamples;

        [FieldOffset(24)]
        internal uint sampleShadingEnable;

        [FieldOffset(28)]
        internal float minSampleShading;

        [FieldOffset(32)]
        internal global::System.IntPtr pSampleMask;

        [FieldOffset(40)]
        internal uint alphaToCoverageEnable;

        [FieldOffset(44)]
        internal uint alphaToOneEnable;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineMultisampleStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineMultisampleStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineMultisampleStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineMultisampleStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineMultisampleStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineMultisampleStateCreateInfo __CreateInstance(global::VkPipelineMultisampleStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineMultisampleStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineMultisampleStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineMultisampleStateCreateInfo.__Internal));
        *(global::VkPipelineMultisampleStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineMultisampleStateCreateInfo(global::VkPipelineMultisampleStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineMultisampleStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineMultisampleStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineMultisampleStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineMultisampleStateCreateInfo(global::VkPipelineMultisampleStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineMultisampleStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineMultisampleStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineMultisampleStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineMultisampleStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineMultisampleStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineMultisampleStateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkSampleCountFlagBits RasterizationSamples
    {
        get
        {
            return ((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance)->rasterizationSamples;
        }

        set
        {
            ((global::VkPipelineMultisampleStateCreateInfo.__Internal*)__Instance)->rasterizationSamples = value;
        }
    }

    public uint SampleShadingEnable
    {
        get
        {
            return ((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance)->sampleShadingEnable;
        }

        set
        {
            ((global::VkPipelineMultisampleStateCreateInfo.__Internal*)__Instance)->sampleShadingEnable = value;
        }
    }

    public float MinSampleShading
    {
        get
        {
            return ((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance)->minSampleShading;
        }

        set
        {
            ((global::VkPipelineMultisampleStateCreateInfo.__Internal*)__Instance)->minSampleShading = value;
        }
    }

    public uint* PSampleMask
    {
        get
        {
            return (uint*) ((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance)->pSampleMask;
        }

        set
        {
            ((global::VkPipelineMultisampleStateCreateInfo.__Internal*)__Instance)->pSampleMask = (global::System.IntPtr) value;
        }
    }

    public uint AlphaToCoverageEnable
    {
        get
        {
            return ((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance)->alphaToCoverageEnable;
        }

        set
        {
            ((global::VkPipelineMultisampleStateCreateInfo.__Internal*)__Instance)->alphaToCoverageEnable = value;
        }
    }

    public uint AlphaToOneEnable
    {
        get
        {
            return ((global::VkPipelineMultisampleStateCreateInfo.__Internal*) __Instance)->alphaToOneEnable;
        }

        set
        {
            ((global::VkPipelineMultisampleStateCreateInfo.__Internal*)__Instance)->alphaToOneEnable = value;
        }
    }
}

public unsafe partial class VkStencilOpState : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 28)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStencilOp failOp;

        [FieldOffset(4)]
        internal global::VkStencilOp passOp;

        [FieldOffset(8)]
        internal global::VkStencilOp depthFailOp;

        [FieldOffset(12)]
        internal global::VkCompareOp compareOp;

        [FieldOffset(16)]
        internal uint compareMask;

        [FieldOffset(20)]
        internal uint writeMask;

        [FieldOffset(24)]
        internal uint reference;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkStencilOpState@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkStencilOpState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkStencilOpState>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkStencilOpState __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkStencilOpState(native.ToPointer(), skipVTables);
    }

    internal static global::VkStencilOpState __CreateInstance(global::VkStencilOpState.__Internal native, bool skipVTables = false)
    {
        return new global::VkStencilOpState(native, skipVTables);
    }

    private static void* __CopyValue(global::VkStencilOpState.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkStencilOpState.__Internal));
        *(global::VkStencilOpState.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkStencilOpState(global::VkStencilOpState.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkStencilOpState(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkStencilOpState()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkStencilOpState.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkStencilOpState(global::VkStencilOpState _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkStencilOpState.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkStencilOpState.__Internal*) __Instance) = *((global::VkStencilOpState.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkStencilOpState __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStencilOp FailOp
    {
        get
        {
            return ((global::VkStencilOpState.__Internal*) __Instance)->failOp;
        }

        set
        {
            ((global::VkStencilOpState.__Internal*)__Instance)->failOp = value;
        }
    }

    public global::VkStencilOp PassOp
    {
        get
        {
            return ((global::VkStencilOpState.__Internal*) __Instance)->passOp;
        }

        set
        {
            ((global::VkStencilOpState.__Internal*)__Instance)->passOp = value;
        }
    }

    public global::VkStencilOp DepthFailOp
    {
        get
        {
            return ((global::VkStencilOpState.__Internal*) __Instance)->depthFailOp;
        }

        set
        {
            ((global::VkStencilOpState.__Internal*)__Instance)->depthFailOp = value;
        }
    }

    public global::VkCompareOp CompareOp
    {
        get
        {
            return ((global::VkStencilOpState.__Internal*) __Instance)->compareOp;
        }

        set
        {
            ((global::VkStencilOpState.__Internal*)__Instance)->compareOp = value;
        }
    }

    public uint CompareMask
    {
        get
        {
            return ((global::VkStencilOpState.__Internal*) __Instance)->compareMask;
        }

        set
        {
            ((global::VkStencilOpState.__Internal*)__Instance)->compareMask = value;
        }
    }

    public uint WriteMask
    {
        get
        {
            return ((global::VkStencilOpState.__Internal*) __Instance)->writeMask;
        }

        set
        {
            ((global::VkStencilOpState.__Internal*)__Instance)->writeMask = value;
        }
    }

    public uint Reference
    {
        get
        {
            return ((global::VkStencilOpState.__Internal*) __Instance)->reference;
        }

        set
        {
            ((global::VkStencilOpState.__Internal*)__Instance)->reference = value;
        }
    }
}

public unsafe partial class VkPipelineDepthStencilStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 104)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint depthTestEnable;

        [FieldOffset(24)]
        internal uint depthWriteEnable;

        [FieldOffset(28)]
        internal global::VkCompareOp depthCompareOp;

        [FieldOffset(32)]
        internal uint depthBoundsTestEnable;

        [FieldOffset(36)]
        internal uint stencilTestEnable;

        [FieldOffset(40)]
        internal global::VkStencilOpState.__Internal front;

        [FieldOffset(68)]
        internal global::VkStencilOpState.__Internal back;

        [FieldOffset(96)]
        internal float minDepthBounds;

        [FieldOffset(100)]
        internal float maxDepthBounds;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineDepthStencilStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineDepthStencilStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineDepthStencilStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineDepthStencilStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineDepthStencilStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineDepthStencilStateCreateInfo __CreateInstance(global::VkPipelineDepthStencilStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineDepthStencilStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineDepthStencilStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineDepthStencilStateCreateInfo.__Internal));
        *(global::VkPipelineDepthStencilStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineDepthStencilStateCreateInfo(global::VkPipelineDepthStencilStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineDepthStencilStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineDepthStencilStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineDepthStencilStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineDepthStencilStateCreateInfo(global::VkPipelineDepthStencilStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineDepthStencilStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineDepthStencilStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint DepthTestEnable
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->depthTestEnable;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->depthTestEnable = value;
        }
    }

    public uint DepthWriteEnable
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->depthWriteEnable;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->depthWriteEnable = value;
        }
    }

    public global::VkCompareOp DepthCompareOp
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->depthCompareOp;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->depthCompareOp = value;
        }
    }

    public uint DepthBoundsTestEnable
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->depthBoundsTestEnable;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->depthBoundsTestEnable = value;
        }
    }

    public uint StencilTestEnable
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->stencilTestEnable;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->stencilTestEnable = value;
        }
    }

    public global::VkStencilOpState Front
    {
        get
        {
            return global::VkStencilOpState.__CreateInstance(new global::System.IntPtr(&((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->front));
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->front = ReferenceEquals(value, null) ? new global::VkStencilOpState.__Internal() : *(global::VkStencilOpState.__Internal*) value.__Instance;
        }
    }

    public global::VkStencilOpState Back
    {
        get
        {
            return global::VkStencilOpState.__CreateInstance(new global::System.IntPtr(&((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->back));
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->back = ReferenceEquals(value, null) ? new global::VkStencilOpState.__Internal() : *(global::VkStencilOpState.__Internal*) value.__Instance;
        }
    }

    public float MinDepthBounds
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->minDepthBounds;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->minDepthBounds = value;
        }
    }

    public float MaxDepthBounds
    {
        get
        {
            return ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*) __Instance)->maxDepthBounds;
        }

        set
        {
            ((global::VkPipelineDepthStencilStateCreateInfo.__Internal*)__Instance)->maxDepthBounds = value;
        }
    }
}

public unsafe partial class VkPipelineColorBlendAttachmentState : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint blendEnable;

        [FieldOffset(4)]
        internal global::VkBlendFactor srcColorBlendFactor;

        [FieldOffset(8)]
        internal global::VkBlendFactor dstColorBlendFactor;

        [FieldOffset(12)]
        internal global::VkBlendOp colorBlendOp;

        [FieldOffset(16)]
        internal global::VkBlendFactor srcAlphaBlendFactor;

        [FieldOffset(20)]
        internal global::VkBlendFactor dstAlphaBlendFactor;

        [FieldOffset(24)]
        internal global::VkBlendOp alphaBlendOp;

        [FieldOffset(28)]
        internal uint colorWriteMask;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineColorBlendAttachmentState@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineColorBlendAttachmentState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineColorBlendAttachmentState>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineColorBlendAttachmentState __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineColorBlendAttachmentState(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineColorBlendAttachmentState __CreateInstance(global::VkPipelineColorBlendAttachmentState.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineColorBlendAttachmentState(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineColorBlendAttachmentState.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineColorBlendAttachmentState.__Internal));
        *(global::VkPipelineColorBlendAttachmentState.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineColorBlendAttachmentState(global::VkPipelineColorBlendAttachmentState.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineColorBlendAttachmentState(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineColorBlendAttachmentState()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineColorBlendAttachmentState.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineColorBlendAttachmentState(global::VkPipelineColorBlendAttachmentState _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineColorBlendAttachmentState.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineColorBlendAttachmentState.__Internal*) __Instance) = *((global::VkPipelineColorBlendAttachmentState.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineColorBlendAttachmentState __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint BlendEnable
    {
        get
        {
            return ((global::VkPipelineColorBlendAttachmentState.__Internal*) __Instance)->blendEnable;
        }

        set
        {
            ((global::VkPipelineColorBlendAttachmentState.__Internal*)__Instance)->blendEnable = value;
        }
    }

    public global::VkBlendFactor SrcColorBlendFactor
    {
        get
        {
            return ((global::VkPipelineColorBlendAttachmentState.__Internal*) __Instance)->srcColorBlendFactor;
        }

        set
        {
            ((global::VkPipelineColorBlendAttachmentState.__Internal*)__Instance)->srcColorBlendFactor = value;
        }
    }

    public global::VkBlendFactor DstColorBlendFactor
    {
        get
        {
            return ((global::VkPipelineColorBlendAttachmentState.__Internal*) __Instance)->dstColorBlendFactor;
        }

        set
        {
            ((global::VkPipelineColorBlendAttachmentState.__Internal*)__Instance)->dstColorBlendFactor = value;
        }
    }

    public global::VkBlendOp ColorBlendOp
    {
        get
        {
            return ((global::VkPipelineColorBlendAttachmentState.__Internal*) __Instance)->colorBlendOp;
        }

        set
        {
            ((global::VkPipelineColorBlendAttachmentState.__Internal*)__Instance)->colorBlendOp = value;
        }
    }

    public global::VkBlendFactor SrcAlphaBlendFactor
    {
        get
        {
            return ((global::VkPipelineColorBlendAttachmentState.__Internal*) __Instance)->srcAlphaBlendFactor;
        }

        set
        {
            ((global::VkPipelineColorBlendAttachmentState.__Internal*)__Instance)->srcAlphaBlendFactor = value;
        }
    }

    public global::VkBlendFactor DstAlphaBlendFactor
    {
        get
        {
            return ((global::VkPipelineColorBlendAttachmentState.__Internal*) __Instance)->dstAlphaBlendFactor;
        }

        set
        {
            ((global::VkPipelineColorBlendAttachmentState.__Internal*)__Instance)->dstAlphaBlendFactor = value;
        }
    }

    public global::VkBlendOp AlphaBlendOp
    {
        get
        {
            return ((global::VkPipelineColorBlendAttachmentState.__Internal*) __Instance)->alphaBlendOp;
        }

        set
        {
            ((global::VkPipelineColorBlendAttachmentState.__Internal*)__Instance)->alphaBlendOp = value;
        }
    }

    public uint ColorWriteMask
    {
        get
        {
            return ((global::VkPipelineColorBlendAttachmentState.__Internal*) __Instance)->colorWriteMask;
        }

        set
        {
            ((global::VkPipelineColorBlendAttachmentState.__Internal*)__Instance)->colorWriteMask = value;
        }
    }
}

public unsafe partial class VkPipelineColorBlendStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint logicOpEnable;

        [FieldOffset(24)]
        internal global::VkLogicOp logicOp;

        [FieldOffset(28)]
        internal uint attachmentCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pAttachments;

        [FieldOffset(40)]
        internal fixed float blendConstants[4];

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineColorBlendStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineColorBlendStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineColorBlendStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineColorBlendStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineColorBlendStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineColorBlendStateCreateInfo __CreateInstance(global::VkPipelineColorBlendStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineColorBlendStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineColorBlendStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineColorBlendStateCreateInfo.__Internal));
        *(global::VkPipelineColorBlendStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineColorBlendStateCreateInfo(global::VkPipelineColorBlendStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineColorBlendStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineColorBlendStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineColorBlendStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineColorBlendStateCreateInfo(global::VkPipelineColorBlendStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineColorBlendStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineColorBlendStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineColorBlendStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineColorBlendStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineColorBlendStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineColorBlendStateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint LogicOpEnable
    {
        get
        {
            return ((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->logicOpEnable;
        }

        set
        {
            ((global::VkPipelineColorBlendStateCreateInfo.__Internal*)__Instance)->logicOpEnable = value;
        }
    }

    public global::VkLogicOp LogicOp
    {
        get
        {
            return ((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->logicOp;
        }

        set
        {
            ((global::VkPipelineColorBlendStateCreateInfo.__Internal*)__Instance)->logicOp = value;
        }
    }

    public uint AttachmentCount
    {
        get
        {
            return ((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->attachmentCount;
        }

        set
        {
            ((global::VkPipelineColorBlendStateCreateInfo.__Internal*)__Instance)->attachmentCount = value;
        }
    }

    public global::VkPipelineColorBlendAttachmentState PAttachments
    {
        get
        {
            global::VkPipelineColorBlendAttachmentState __result0;
            if (((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->pAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineColorBlendAttachmentState.NativeToManagedMap.ContainsKey(((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->pAttachments))
                __result0 = (global::VkPipelineColorBlendAttachmentState) global::VkPipelineColorBlendAttachmentState.NativeToManagedMap[((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->pAttachments];
            else __result0 = global::VkPipelineColorBlendAttachmentState.__CreateInstance(((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->pAttachments);
            return __result0;
        }

        set
        {
            ((global::VkPipelineColorBlendStateCreateInfo.__Internal*)__Instance)->pAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public float[] BlendConstants
    {
        get
        {
            float[] __value = null;
            if (((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->blendConstants != null)
            {
                __value = new float[4];
                for (int i = 0; i < 4; i++)
                    __value[i] = ((global::VkPipelineColorBlendStateCreateInfo.__Internal*) __Instance)->blendConstants[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 4; i++)
                    ((global::VkPipelineColorBlendStateCreateInfo.__Internal*)__Instance)->blendConstants[i] = value[i];
            }
        }
    }
}

public unsafe partial class VkPipelineDynamicStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint dynamicStateCount;

        [FieldOffset(24)]
        internal global::VkDynamicState* pDynamicStates;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineDynamicStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineDynamicStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineDynamicStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineDynamicStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineDynamicStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineDynamicStateCreateInfo __CreateInstance(global::VkPipelineDynamicStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineDynamicStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineDynamicStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineDynamicStateCreateInfo.__Internal));
        *(global::VkPipelineDynamicStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineDynamicStateCreateInfo(global::VkPipelineDynamicStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineDynamicStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineDynamicStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineDynamicStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineDynamicStateCreateInfo(global::VkPipelineDynamicStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineDynamicStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineDynamicStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineDynamicStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineDynamicStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineDynamicStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineDynamicStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineDynamicStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineDynamicStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineDynamicStateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineDynamicStateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint DynamicStateCount
    {
        get
        {
            return ((global::VkPipelineDynamicStateCreateInfo.__Internal*) __Instance)->dynamicStateCount;
        }

        set
        {
            ((global::VkPipelineDynamicStateCreateInfo.__Internal*)__Instance)->dynamicStateCount = value;
        }
    }

    public global::VkDynamicState* PDynamicStates
    {
        get
        {
            return ((global::VkPipelineDynamicStateCreateInfo.__Internal*) __Instance)->pDynamicStates;
        }

        set
        {
            ((global::VkPipelineDynamicStateCreateInfo.__Internal*)__Instance)->pDynamicStates = value;
        }
    }
}

public unsafe partial class VkGraphicsPipelineCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 144)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint stageCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pStages;

        [FieldOffset(32)]
        internal global::System.IntPtr pVertexInputState;

        [FieldOffset(40)]
        internal global::System.IntPtr pInputAssemblyState;

        [FieldOffset(48)]
        internal global::System.IntPtr pTessellationState;

        [FieldOffset(56)]
        internal global::System.IntPtr pViewportState;

        [FieldOffset(64)]
        internal global::System.IntPtr pRasterizationState;

        [FieldOffset(72)]
        internal global::System.IntPtr pMultisampleState;

        [FieldOffset(80)]
        internal global::System.IntPtr pDepthStencilState;

        [FieldOffset(88)]
        internal global::System.IntPtr pColorBlendState;

        [FieldOffset(96)]
        internal global::System.IntPtr pDynamicState;

        [FieldOffset(104)]
        internal global::System.IntPtr layout;

        [FieldOffset(112)]
        internal global::System.IntPtr renderPass;

        [FieldOffset(120)]
        internal uint subpass;

        [FieldOffset(128)]
        internal global::System.IntPtr basePipelineHandle;

        [FieldOffset(136)]
        internal int basePipelineIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkGraphicsPipelineCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkGraphicsPipelineCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkGraphicsPipelineCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkGraphicsPipelineCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkGraphicsPipelineCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkGraphicsPipelineCreateInfo __CreateInstance(global::VkGraphicsPipelineCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkGraphicsPipelineCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkGraphicsPipelineCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkGraphicsPipelineCreateInfo.__Internal));
        *(global::VkGraphicsPipelineCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkGraphicsPipelineCreateInfo(global::VkGraphicsPipelineCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkGraphicsPipelineCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkGraphicsPipelineCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkGraphicsPipelineCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkGraphicsPipelineCreateInfo(global::VkGraphicsPipelineCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkGraphicsPipelineCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance) = *((global::VkGraphicsPipelineCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkGraphicsPipelineCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint StageCount
    {
        get
        {
            return ((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->stageCount;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->stageCount = value;
        }
    }

    public global::VkPipelineShaderStageCreateInfo PStages
    {
        get
        {
            global::VkPipelineShaderStageCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pStages == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineShaderStageCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pStages))
                __result0 = (global::VkPipelineShaderStageCreateInfo) global::VkPipelineShaderStageCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pStages];
            else __result0 = global::VkPipelineShaderStageCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pStages);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pStages = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineVertexInputStateCreateInfo PVertexInputState
    {
        get
        {
            global::VkPipelineVertexInputStateCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pVertexInputState == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineVertexInputStateCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pVertexInputState))
                __result0 = (global::VkPipelineVertexInputStateCreateInfo) global::VkPipelineVertexInputStateCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pVertexInputState];
            else __result0 = global::VkPipelineVertexInputStateCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pVertexInputState);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pVertexInputState = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineInputAssemblyStateCreateInfo PInputAssemblyState
    {
        get
        {
            global::VkPipelineInputAssemblyStateCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pInputAssemblyState == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineInputAssemblyStateCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pInputAssemblyState))
                __result0 = (global::VkPipelineInputAssemblyStateCreateInfo) global::VkPipelineInputAssemblyStateCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pInputAssemblyState];
            else __result0 = global::VkPipelineInputAssemblyStateCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pInputAssemblyState);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pInputAssemblyState = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineTessellationStateCreateInfo PTessellationState
    {
        get
        {
            global::VkPipelineTessellationStateCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pTessellationState == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineTessellationStateCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pTessellationState))
                __result0 = (global::VkPipelineTessellationStateCreateInfo) global::VkPipelineTessellationStateCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pTessellationState];
            else __result0 = global::VkPipelineTessellationStateCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pTessellationState);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pTessellationState = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineViewportStateCreateInfo PViewportState
    {
        get
        {
            global::VkPipelineViewportStateCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pViewportState == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineViewportStateCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pViewportState))
                __result0 = (global::VkPipelineViewportStateCreateInfo) global::VkPipelineViewportStateCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pViewportState];
            else __result0 = global::VkPipelineViewportStateCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pViewportState);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pViewportState = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineRasterizationStateCreateInfo PRasterizationState
    {
        get
        {
            global::VkPipelineRasterizationStateCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pRasterizationState == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineRasterizationStateCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pRasterizationState))
                __result0 = (global::VkPipelineRasterizationStateCreateInfo) global::VkPipelineRasterizationStateCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pRasterizationState];
            else __result0 = global::VkPipelineRasterizationStateCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pRasterizationState);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pRasterizationState = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineMultisampleStateCreateInfo PMultisampleState
    {
        get
        {
            global::VkPipelineMultisampleStateCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pMultisampleState == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineMultisampleStateCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pMultisampleState))
                __result0 = (global::VkPipelineMultisampleStateCreateInfo) global::VkPipelineMultisampleStateCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pMultisampleState];
            else __result0 = global::VkPipelineMultisampleStateCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pMultisampleState);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pMultisampleState = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineDepthStencilStateCreateInfo PDepthStencilState
    {
        get
        {
            global::VkPipelineDepthStencilStateCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pDepthStencilState == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineDepthStencilStateCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pDepthStencilState))
                __result0 = (global::VkPipelineDepthStencilStateCreateInfo) global::VkPipelineDepthStencilStateCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pDepthStencilState];
            else __result0 = global::VkPipelineDepthStencilStateCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pDepthStencilState);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pDepthStencilState = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineColorBlendStateCreateInfo PColorBlendState
    {
        get
        {
            global::VkPipelineColorBlendStateCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pColorBlendState == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineColorBlendStateCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pColorBlendState))
                __result0 = (global::VkPipelineColorBlendStateCreateInfo) global::VkPipelineColorBlendStateCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pColorBlendState];
            else __result0 = global::VkPipelineColorBlendStateCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pColorBlendState);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pColorBlendState = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineDynamicStateCreateInfo PDynamicState
    {
        get
        {
            global::VkPipelineDynamicStateCreateInfo __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pDynamicState == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineDynamicStateCreateInfo.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pDynamicState))
                __result0 = (global::VkPipelineDynamicStateCreateInfo) global::VkPipelineDynamicStateCreateInfo.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pDynamicState];
            else __result0 = global::VkPipelineDynamicStateCreateInfo.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->pDynamicState);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->pDynamicState = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineLayoutT Layout
    {
        get
        {
            global::VkPipelineLayoutT __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->layout == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineLayoutT.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->layout))
                __result0 = (global::VkPipelineLayoutT) global::VkPipelineLayoutT.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->layout];
            else __result0 = global::VkPipelineLayoutT.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->layout);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->layout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkRenderPassT RenderPass
    {
        get
        {
            global::VkRenderPassT __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->renderPass == IntPtr.Zero) __result0 = null;
            else if (global::VkRenderPassT.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->renderPass))
                __result0 = (global::VkRenderPassT) global::VkRenderPassT.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->renderPass];
            else __result0 = global::VkRenderPassT.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->renderPass);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->renderPass = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint Subpass
    {
        get
        {
            return ((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->subpass;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->subpass = value;
        }
    }

    public global::VkPipelineT BasePipelineHandle
    {
        get
        {
            global::VkPipelineT __result0;
            if (((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->basePipelineHandle == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineT.NativeToManagedMap.ContainsKey(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->basePipelineHandle))
                __result0 = (global::VkPipelineT) global::VkPipelineT.NativeToManagedMap[((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->basePipelineHandle];
            else __result0 = global::VkPipelineT.__CreateInstance(((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->basePipelineHandle);
            return __result0;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->basePipelineHandle = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public int BasePipelineIndex
    {
        get
        {
            return ((global::VkGraphicsPipelineCreateInfo.__Internal*) __Instance)->basePipelineIndex;
        }

        set
        {
            ((global::VkGraphicsPipelineCreateInfo.__Internal*)__Instance)->basePipelineIndex = value;
        }
    }
}

public unsafe partial class VkComputePipelineCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 96)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::VkPipelineShaderStageCreateInfo.__Internal stage;

        [FieldOffset(72)]
        internal global::System.IntPtr layout;

        [FieldOffset(80)]
        internal global::System.IntPtr basePipelineHandle;

        [FieldOffset(88)]
        internal int basePipelineIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkComputePipelineCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkComputePipelineCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkComputePipelineCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkComputePipelineCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkComputePipelineCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkComputePipelineCreateInfo __CreateInstance(global::VkComputePipelineCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkComputePipelineCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkComputePipelineCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkComputePipelineCreateInfo.__Internal));
        *(global::VkComputePipelineCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkComputePipelineCreateInfo(global::VkComputePipelineCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkComputePipelineCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkComputePipelineCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkComputePipelineCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkComputePipelineCreateInfo(global::VkComputePipelineCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkComputePipelineCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkComputePipelineCreateInfo.__Internal*) __Instance) = *((global::VkComputePipelineCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkComputePipelineCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkComputePipelineCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkComputePipelineCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkComputePipelineCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkPipelineShaderStageCreateInfo Stage
    {
        get
        {
            return global::VkPipelineShaderStageCreateInfo.__CreateInstance(new global::System.IntPtr(&((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->stage));
        }

        set
        {
            ((global::VkComputePipelineCreateInfo.__Internal*)__Instance)->stage = ReferenceEquals(value, null) ? new global::VkPipelineShaderStageCreateInfo.__Internal() : *(global::VkPipelineShaderStageCreateInfo.__Internal*) value.__Instance;
        }
    }

    public global::VkPipelineLayoutT Layout
    {
        get
        {
            global::VkPipelineLayoutT __result0;
            if (((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->layout == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineLayoutT.NativeToManagedMap.ContainsKey(((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->layout))
                __result0 = (global::VkPipelineLayoutT) global::VkPipelineLayoutT.NativeToManagedMap[((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->layout];
            else __result0 = global::VkPipelineLayoutT.__CreateInstance(((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->layout);
            return __result0;
        }

        set
        {
            ((global::VkComputePipelineCreateInfo.__Internal*)__Instance)->layout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineT BasePipelineHandle
    {
        get
        {
            global::VkPipelineT __result0;
            if (((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->basePipelineHandle == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineT.NativeToManagedMap.ContainsKey(((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->basePipelineHandle))
                __result0 = (global::VkPipelineT) global::VkPipelineT.NativeToManagedMap[((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->basePipelineHandle];
            else __result0 = global::VkPipelineT.__CreateInstance(((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->basePipelineHandle);
            return __result0;
        }

        set
        {
            ((global::VkComputePipelineCreateInfo.__Internal*)__Instance)->basePipelineHandle = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public int BasePipelineIndex
    {
        get
        {
            return ((global::VkComputePipelineCreateInfo.__Internal*) __Instance)->basePipelineIndex;
        }

        set
        {
            ((global::VkComputePipelineCreateInfo.__Internal*)__Instance)->basePipelineIndex = value;
        }
    }
}

public unsafe partial class VkPushConstantRange : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint stageFlags;

        [FieldOffset(4)]
        internal uint offset;

        [FieldOffset(8)]
        internal uint size;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPushConstantRange@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPushConstantRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPushConstantRange>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPushConstantRange __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPushConstantRange(native.ToPointer(), skipVTables);
    }

    internal static global::VkPushConstantRange __CreateInstance(global::VkPushConstantRange.__Internal native, bool skipVTables = false)
    {
        return new global::VkPushConstantRange(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPushConstantRange.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPushConstantRange.__Internal));
        *(global::VkPushConstantRange.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPushConstantRange(global::VkPushConstantRange.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPushConstantRange(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPushConstantRange()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPushConstantRange.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPushConstantRange(global::VkPushConstantRange _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPushConstantRange.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPushConstantRange.__Internal*) __Instance) = *((global::VkPushConstantRange.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPushConstantRange __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint StageFlags
    {
        get
        {
            return ((global::VkPushConstantRange.__Internal*) __Instance)->stageFlags;
        }

        set
        {
            ((global::VkPushConstantRange.__Internal*)__Instance)->stageFlags = value;
        }
    }

    public uint Offset
    {
        get
        {
            return ((global::VkPushConstantRange.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkPushConstantRange.__Internal*)__Instance)->offset = value;
        }
    }

    public uint Size
    {
        get
        {
            return ((global::VkPushConstantRange.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkPushConstantRange.__Internal*)__Instance)->size = value;
        }
    }
}

public unsafe partial class VkPipelineLayoutCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint setLayoutCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pSetLayouts;

        [FieldOffset(32)]
        internal uint pushConstantRangeCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pPushConstantRanges;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineLayoutCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineLayoutCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineLayoutCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineLayoutCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineLayoutCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineLayoutCreateInfo __CreateInstance(global::VkPipelineLayoutCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineLayoutCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineLayoutCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineLayoutCreateInfo.__Internal));
        *(global::VkPipelineLayoutCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineLayoutCreateInfo(global::VkPipelineLayoutCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineLayoutCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineLayoutCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineLayoutCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineLayoutCreateInfo(global::VkPipelineLayoutCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineLayoutCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance) = *((global::VkPipelineLayoutCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineLayoutCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineLayoutCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineLayoutCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineLayoutCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint SetLayoutCount
    {
        get
        {
            return ((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->setLayoutCount;
        }

        set
        {
            ((global::VkPipelineLayoutCreateInfo.__Internal*)__Instance)->setLayoutCount = value;
        }
    }

    public global::VkDescriptorSetLayoutT PSetLayouts
    {
        get
        {
            global::VkDescriptorSetLayoutT __result0;
            if (((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pSetLayouts == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorSetLayoutT.NativeToManagedMap.ContainsKey(((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pSetLayouts))
                __result0 = (global::VkDescriptorSetLayoutT) global::VkDescriptorSetLayoutT.NativeToManagedMap[((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pSetLayouts];
            else __result0 = global::VkDescriptorSetLayoutT.__CreateInstance(((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pSetLayouts);
            return __result0;
        }

        set
        {
            ((global::VkPipelineLayoutCreateInfo.__Internal*)__Instance)->pSetLayouts = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint PushConstantRangeCount
    {
        get
        {
            return ((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pushConstantRangeCount;
        }

        set
        {
            ((global::VkPipelineLayoutCreateInfo.__Internal*)__Instance)->pushConstantRangeCount = value;
        }
    }

    public global::VkPushConstantRange PPushConstantRanges
    {
        get
        {
            global::VkPushConstantRange __result0;
            if (((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pPushConstantRanges == IntPtr.Zero) __result0 = null;
            else if (global::VkPushConstantRange.NativeToManagedMap.ContainsKey(((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pPushConstantRanges))
                __result0 = (global::VkPushConstantRange) global::VkPushConstantRange.NativeToManagedMap[((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pPushConstantRanges];
            else __result0 = global::VkPushConstantRange.__CreateInstance(((global::VkPipelineLayoutCreateInfo.__Internal*) __Instance)->pPushConstantRanges);
            return __result0;
        }

        set
        {
            ((global::VkPipelineLayoutCreateInfo.__Internal*)__Instance)->pPushConstantRanges = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkSamplerCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkFilter magFilter;

        [FieldOffset(24)]
        internal global::VkFilter minFilter;

        [FieldOffset(28)]
        internal global::VkSamplerMipmapMode mipmapMode;

        [FieldOffset(32)]
        internal global::VkSamplerAddressMode addressModeU;

        [FieldOffset(36)]
        internal global::VkSamplerAddressMode addressModeV;

        [FieldOffset(40)]
        internal global::VkSamplerAddressMode addressModeW;

        [FieldOffset(44)]
        internal float mipLodBias;

        [FieldOffset(48)]
        internal uint anisotropyEnable;

        [FieldOffset(52)]
        internal float maxAnisotropy;

        [FieldOffset(56)]
        internal uint compareEnable;

        [FieldOffset(60)]
        internal global::VkCompareOp compareOp;

        [FieldOffset(64)]
        internal float minLod;

        [FieldOffset(68)]
        internal float maxLod;

        [FieldOffset(72)]
        internal global::VkBorderColor borderColor;

        [FieldOffset(76)]
        internal uint unnormalizedCoordinates;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSamplerCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSamplerCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSamplerCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkSamplerCreateInfo __CreateInstance(global::VkSamplerCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkSamplerCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSamplerCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSamplerCreateInfo.__Internal));
        *(global::VkSamplerCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSamplerCreateInfo(global::VkSamplerCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSamplerCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSamplerCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSamplerCreateInfo(global::VkSamplerCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSamplerCreateInfo.__Internal*) __Instance) = *((global::VkSamplerCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSamplerCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkFilter MagFilter
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->magFilter;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->magFilter = value;
        }
    }

    public global::VkFilter MinFilter
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->minFilter;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->minFilter = value;
        }
    }

    public global::VkSamplerMipmapMode MipmapMode
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->mipmapMode;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->mipmapMode = value;
        }
    }

    public global::VkSamplerAddressMode AddressModeU
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->addressModeU;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->addressModeU = value;
        }
    }

    public global::VkSamplerAddressMode AddressModeV
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->addressModeV;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->addressModeV = value;
        }
    }

    public global::VkSamplerAddressMode AddressModeW
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->addressModeW;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->addressModeW = value;
        }
    }

    public float MipLodBias
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->mipLodBias;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->mipLodBias = value;
        }
    }

    public uint AnisotropyEnable
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->anisotropyEnable;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->anisotropyEnable = value;
        }
    }

    public float MaxAnisotropy
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->maxAnisotropy;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->maxAnisotropy = value;
        }
    }

    public uint CompareEnable
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->compareEnable;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->compareEnable = value;
        }
    }

    public global::VkCompareOp CompareOp
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->compareOp;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->compareOp = value;
        }
    }

    public float MinLod
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->minLod;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->minLod = value;
        }
    }

    public float MaxLod
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->maxLod;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->maxLod = value;
        }
    }

    public global::VkBorderColor BorderColor
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->borderColor;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->borderColor = value;
        }
    }

    public uint UnnormalizedCoordinates
    {
        get
        {
            return ((global::VkSamplerCreateInfo.__Internal*) __Instance)->unnormalizedCoordinates;
        }

        set
        {
            ((global::VkSamplerCreateInfo.__Internal*)__Instance)->unnormalizedCoordinates = value;
        }
    }
}

public unsafe partial class VkDescriptorSetLayoutBinding : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint binding;

        [FieldOffset(4)]
        internal global::VkDescriptorType descriptorType;

        [FieldOffset(8)]
        internal uint descriptorCount;

        [FieldOffset(12)]
        internal uint stageFlags;

        [FieldOffset(16)]
        internal global::System.IntPtr pImmutableSamplers;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorSetLayoutBinding@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutBinding> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutBinding>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorSetLayoutBinding __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutBinding(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorSetLayoutBinding __CreateInstance(global::VkDescriptorSetLayoutBinding.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutBinding(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorSetLayoutBinding.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutBinding.__Internal));
        *(global::VkDescriptorSetLayoutBinding.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorSetLayoutBinding(global::VkDescriptorSetLayoutBinding.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorSetLayoutBinding(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorSetLayoutBinding()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutBinding.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorSetLayoutBinding(global::VkDescriptorSetLayoutBinding _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutBinding.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorSetLayoutBinding.__Internal*) __Instance) = *((global::VkDescriptorSetLayoutBinding.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorSetLayoutBinding __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Binding
    {
        get
        {
            return ((global::VkDescriptorSetLayoutBinding.__Internal*) __Instance)->binding;
        }

        set
        {
            ((global::VkDescriptorSetLayoutBinding.__Internal*)__Instance)->binding = value;
        }
    }

    public global::VkDescriptorType DescriptorType
    {
        get
        {
            return ((global::VkDescriptorSetLayoutBinding.__Internal*) __Instance)->descriptorType;
        }

        set
        {
            ((global::VkDescriptorSetLayoutBinding.__Internal*)__Instance)->descriptorType = value;
        }
    }

    public uint DescriptorCount
    {
        get
        {
            return ((global::VkDescriptorSetLayoutBinding.__Internal*) __Instance)->descriptorCount;
        }

        set
        {
            ((global::VkDescriptorSetLayoutBinding.__Internal*)__Instance)->descriptorCount = value;
        }
    }

    public uint StageFlags
    {
        get
        {
            return ((global::VkDescriptorSetLayoutBinding.__Internal*) __Instance)->stageFlags;
        }

        set
        {
            ((global::VkDescriptorSetLayoutBinding.__Internal*)__Instance)->stageFlags = value;
        }
    }

    public global::VkSamplerT PImmutableSamplers
    {
        get
        {
            global::VkSamplerT __result0;
            if (((global::VkDescriptorSetLayoutBinding.__Internal*) __Instance)->pImmutableSamplers == IntPtr.Zero) __result0 = null;
            else if (global::VkSamplerT.NativeToManagedMap.ContainsKey(((global::VkDescriptorSetLayoutBinding.__Internal*) __Instance)->pImmutableSamplers))
                __result0 = (global::VkSamplerT) global::VkSamplerT.NativeToManagedMap[((global::VkDescriptorSetLayoutBinding.__Internal*) __Instance)->pImmutableSamplers];
            else __result0 = global::VkSamplerT.__CreateInstance(((global::VkDescriptorSetLayoutBinding.__Internal*) __Instance)->pImmutableSamplers);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorSetLayoutBinding.__Internal*)__Instance)->pImmutableSamplers = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkDescriptorSetLayoutCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint bindingCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pBindings;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorSetLayoutCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorSetLayoutCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorSetLayoutCreateInfo __CreateInstance(global::VkDescriptorSetLayoutCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorSetLayoutCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutCreateInfo.__Internal));
        *(global::VkDescriptorSetLayoutCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorSetLayoutCreateInfo(global::VkDescriptorSetLayoutCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorSetLayoutCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorSetLayoutCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorSetLayoutCreateInfo(global::VkDescriptorSetLayoutCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorSetLayoutCreateInfo.__Internal*) __Instance) = *((global::VkDescriptorSetLayoutCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorSetLayoutCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDescriptorSetLayoutCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDescriptorSetLayoutCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDescriptorSetLayoutCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDescriptorSetLayoutCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDescriptorSetLayoutCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDescriptorSetLayoutCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint BindingCount
    {
        get
        {
            return ((global::VkDescriptorSetLayoutCreateInfo.__Internal*) __Instance)->bindingCount;
        }

        set
        {
            ((global::VkDescriptorSetLayoutCreateInfo.__Internal*)__Instance)->bindingCount = value;
        }
    }

    public global::VkDescriptorSetLayoutBinding PBindings
    {
        get
        {
            global::VkDescriptorSetLayoutBinding __result0;
            if (((global::VkDescriptorSetLayoutCreateInfo.__Internal*) __Instance)->pBindings == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorSetLayoutBinding.NativeToManagedMap.ContainsKey(((global::VkDescriptorSetLayoutCreateInfo.__Internal*) __Instance)->pBindings))
                __result0 = (global::VkDescriptorSetLayoutBinding) global::VkDescriptorSetLayoutBinding.NativeToManagedMap[((global::VkDescriptorSetLayoutCreateInfo.__Internal*) __Instance)->pBindings];
            else __result0 = global::VkDescriptorSetLayoutBinding.__CreateInstance(((global::VkDescriptorSetLayoutCreateInfo.__Internal*) __Instance)->pBindings);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorSetLayoutCreateInfo.__Internal*)__Instance)->pBindings = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkDescriptorPoolSize : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkDescriptorType type;

        [FieldOffset(4)]
        internal uint descriptorCount;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorPoolSize@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorPoolSize> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorPoolSize>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorPoolSize __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorPoolSize(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorPoolSize __CreateInstance(global::VkDescriptorPoolSize.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorPoolSize(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorPoolSize.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorPoolSize.__Internal));
        *(global::VkDescriptorPoolSize.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorPoolSize(global::VkDescriptorPoolSize.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorPoolSize(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorPoolSize()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorPoolSize.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorPoolSize(global::VkDescriptorPoolSize _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorPoolSize.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorPoolSize.__Internal*) __Instance) = *((global::VkDescriptorPoolSize.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorPoolSize __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkDescriptorType Type
    {
        get
        {
            return ((global::VkDescriptorPoolSize.__Internal*) __Instance)->type;
        }

        set
        {
            ((global::VkDescriptorPoolSize.__Internal*)__Instance)->type = value;
        }
    }

    public uint DescriptorCount
    {
        get
        {
            return ((global::VkDescriptorPoolSize.__Internal*) __Instance)->descriptorCount;
        }

        set
        {
            ((global::VkDescriptorPoolSize.__Internal*)__Instance)->descriptorCount = value;
        }
    }
}

public unsafe partial class VkDescriptorPoolCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint maxSets;

        [FieldOffset(24)]
        internal uint poolSizeCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pPoolSizes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorPoolCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorPoolCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorPoolCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorPoolCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorPoolCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorPoolCreateInfo __CreateInstance(global::VkDescriptorPoolCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorPoolCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorPoolCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorPoolCreateInfo.__Internal));
        *(global::VkDescriptorPoolCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorPoolCreateInfo(global::VkDescriptorPoolCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorPoolCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorPoolCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorPoolCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorPoolCreateInfo(global::VkDescriptorPoolCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorPoolCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance) = *((global::VkDescriptorPoolCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorPoolCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDescriptorPoolCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDescriptorPoolCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDescriptorPoolCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint MaxSets
    {
        get
        {
            return ((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance)->maxSets;
        }

        set
        {
            ((global::VkDescriptorPoolCreateInfo.__Internal*)__Instance)->maxSets = value;
        }
    }

    public uint PoolSizeCount
    {
        get
        {
            return ((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance)->poolSizeCount;
        }

        set
        {
            ((global::VkDescriptorPoolCreateInfo.__Internal*)__Instance)->poolSizeCount = value;
        }
    }

    public global::VkDescriptorPoolSize PPoolSizes
    {
        get
        {
            global::VkDescriptorPoolSize __result0;
            if (((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance)->pPoolSizes == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorPoolSize.NativeToManagedMap.ContainsKey(((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance)->pPoolSizes))
                __result0 = (global::VkDescriptorPoolSize) global::VkDescriptorPoolSize.NativeToManagedMap[((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance)->pPoolSizes];
            else __result0 = global::VkDescriptorPoolSize.__CreateInstance(((global::VkDescriptorPoolCreateInfo.__Internal*) __Instance)->pPoolSizes);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorPoolCreateInfo.__Internal*)__Instance)->pPoolSizes = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkDescriptorSetAllocateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr descriptorPool;

        [FieldOffset(24)]
        internal uint descriptorSetCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pSetLayouts;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorSetAllocateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetAllocateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetAllocateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorSetAllocateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetAllocateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorSetAllocateInfo __CreateInstance(global::VkDescriptorSetAllocateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetAllocateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorSetAllocateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetAllocateInfo.__Internal));
        *(global::VkDescriptorSetAllocateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorSetAllocateInfo(global::VkDescriptorSetAllocateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorSetAllocateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorSetAllocateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorSetAllocateInfo(global::VkDescriptorSetAllocateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance) = *((global::VkDescriptorSetAllocateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorSetAllocateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDescriptorSetAllocateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDescriptorSetAllocateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDescriptorPoolT DescriptorPool
    {
        get
        {
            global::VkDescriptorPoolT __result0;
            if (((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->descriptorPool == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorPoolT.NativeToManagedMap.ContainsKey(((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->descriptorPool))
                __result0 = (global::VkDescriptorPoolT) global::VkDescriptorPoolT.NativeToManagedMap[((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->descriptorPool];
            else __result0 = global::VkDescriptorPoolT.__CreateInstance(((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->descriptorPool);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorSetAllocateInfo.__Internal*)__Instance)->descriptorPool = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint DescriptorSetCount
    {
        get
        {
            return ((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->descriptorSetCount;
        }

        set
        {
            ((global::VkDescriptorSetAllocateInfo.__Internal*)__Instance)->descriptorSetCount = value;
        }
    }

    public global::VkDescriptorSetLayoutT PSetLayouts
    {
        get
        {
            global::VkDescriptorSetLayoutT __result0;
            if (((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->pSetLayouts == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorSetLayoutT.NativeToManagedMap.ContainsKey(((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->pSetLayouts))
                __result0 = (global::VkDescriptorSetLayoutT) global::VkDescriptorSetLayoutT.NativeToManagedMap[((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->pSetLayouts];
            else __result0 = global::VkDescriptorSetLayoutT.__CreateInstance(((global::VkDescriptorSetAllocateInfo.__Internal*) __Instance)->pSetLayouts);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorSetAllocateInfo.__Internal*)__Instance)->pSetLayouts = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkDescriptorImageInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr sampler;

        [FieldOffset(8)]
        internal global::System.IntPtr imageView;

        [FieldOffset(16)]
        internal global::VkImageLayout imageLayout;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorImageInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorImageInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorImageInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorImageInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorImageInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorImageInfo __CreateInstance(global::VkDescriptorImageInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorImageInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorImageInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorImageInfo.__Internal));
        *(global::VkDescriptorImageInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorImageInfo(global::VkDescriptorImageInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorImageInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorImageInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorImageInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorImageInfo(global::VkDescriptorImageInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorImageInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorImageInfo.__Internal*) __Instance) = *((global::VkDescriptorImageInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorImageInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkSamplerT Sampler
    {
        get
        {
            global::VkSamplerT __result0;
            if (((global::VkDescriptorImageInfo.__Internal*) __Instance)->sampler == IntPtr.Zero) __result0 = null;
            else if (global::VkSamplerT.NativeToManagedMap.ContainsKey(((global::VkDescriptorImageInfo.__Internal*) __Instance)->sampler))
                __result0 = (global::VkSamplerT) global::VkSamplerT.NativeToManagedMap[((global::VkDescriptorImageInfo.__Internal*) __Instance)->sampler];
            else __result0 = global::VkSamplerT.__CreateInstance(((global::VkDescriptorImageInfo.__Internal*) __Instance)->sampler);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorImageInfo.__Internal*)__Instance)->sampler = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkImageViewT ImageView
    {
        get
        {
            global::VkImageViewT __result0;
            if (((global::VkDescriptorImageInfo.__Internal*) __Instance)->imageView == IntPtr.Zero) __result0 = null;
            else if (global::VkImageViewT.NativeToManagedMap.ContainsKey(((global::VkDescriptorImageInfo.__Internal*) __Instance)->imageView))
                __result0 = (global::VkImageViewT) global::VkImageViewT.NativeToManagedMap[((global::VkDescriptorImageInfo.__Internal*) __Instance)->imageView];
            else __result0 = global::VkImageViewT.__CreateInstance(((global::VkDescriptorImageInfo.__Internal*) __Instance)->imageView);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorImageInfo.__Internal*)__Instance)->imageView = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkImageLayout ImageLayout
    {
        get
        {
            return ((global::VkDescriptorImageInfo.__Internal*) __Instance)->imageLayout;
        }

        set
        {
            ((global::VkDescriptorImageInfo.__Internal*)__Instance)->imageLayout = value;
        }
    }
}

public unsafe partial class VkDescriptorBufferInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr buffer;

        [FieldOffset(8)]
        internal ulong offset;

        [FieldOffset(16)]
        internal ulong range;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorBufferInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorBufferInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorBufferInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorBufferInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorBufferInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorBufferInfo __CreateInstance(global::VkDescriptorBufferInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorBufferInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorBufferInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorBufferInfo.__Internal));
        *(global::VkDescriptorBufferInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorBufferInfo(global::VkDescriptorBufferInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorBufferInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorBufferInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorBufferInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorBufferInfo(global::VkDescriptorBufferInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorBufferInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorBufferInfo.__Internal*) __Instance) = *((global::VkDescriptorBufferInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorBufferInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkDescriptorBufferInfo.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkDescriptorBufferInfo.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkDescriptorBufferInfo.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkDescriptorBufferInfo.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorBufferInfo.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong Offset
    {
        get
        {
            return ((global::VkDescriptorBufferInfo.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkDescriptorBufferInfo.__Internal*)__Instance)->offset = value;
        }
    }

    public ulong Range
    {
        get
        {
            return ((global::VkDescriptorBufferInfo.__Internal*) __Instance)->range;
        }

        set
        {
            ((global::VkDescriptorBufferInfo.__Internal*)__Instance)->range = value;
        }
    }
}

public unsafe partial class VkWriteDescriptorSet : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr dstSet;

        [FieldOffset(24)]
        internal uint dstBinding;

        [FieldOffset(28)]
        internal uint dstArrayElement;

        [FieldOffset(32)]
        internal uint descriptorCount;

        [FieldOffset(36)]
        internal global::VkDescriptorType descriptorType;

        [FieldOffset(40)]
        internal global::System.IntPtr pImageInfo;

        [FieldOffset(48)]
        internal global::System.IntPtr pBufferInfo;

        [FieldOffset(56)]
        internal global::System.IntPtr pTexelBufferView;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkWriteDescriptorSet@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkWriteDescriptorSet> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkWriteDescriptorSet>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkWriteDescriptorSet __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkWriteDescriptorSet(native.ToPointer(), skipVTables);
    }

    internal static global::VkWriteDescriptorSet __CreateInstance(global::VkWriteDescriptorSet.__Internal native, bool skipVTables = false)
    {
        return new global::VkWriteDescriptorSet(native, skipVTables);
    }

    private static void* __CopyValue(global::VkWriteDescriptorSet.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkWriteDescriptorSet.__Internal));
        *(global::VkWriteDescriptorSet.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkWriteDescriptorSet(global::VkWriteDescriptorSet.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkWriteDescriptorSet(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkWriteDescriptorSet()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkWriteDescriptorSet.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkWriteDescriptorSet(global::VkWriteDescriptorSet _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkWriteDescriptorSet.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkWriteDescriptorSet.__Internal*) __Instance) = *((global::VkWriteDescriptorSet.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkWriteDescriptorSet __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkWriteDescriptorSet.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkWriteDescriptorSet.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDescriptorSetT DstSet
    {
        get
        {
            global::VkDescriptorSetT __result0;
            if (((global::VkWriteDescriptorSet.__Internal*) __Instance)->dstSet == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorSetT.NativeToManagedMap.ContainsKey(((global::VkWriteDescriptorSet.__Internal*) __Instance)->dstSet))
                __result0 = (global::VkDescriptorSetT) global::VkDescriptorSetT.NativeToManagedMap[((global::VkWriteDescriptorSet.__Internal*) __Instance)->dstSet];
            else __result0 = global::VkDescriptorSetT.__CreateInstance(((global::VkWriteDescriptorSet.__Internal*) __Instance)->dstSet);
            return __result0;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->dstSet = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint DstBinding
    {
        get
        {
            return ((global::VkWriteDescriptorSet.__Internal*) __Instance)->dstBinding;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->dstBinding = value;
        }
    }

    public uint DstArrayElement
    {
        get
        {
            return ((global::VkWriteDescriptorSet.__Internal*) __Instance)->dstArrayElement;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->dstArrayElement = value;
        }
    }

    public uint DescriptorCount
    {
        get
        {
            return ((global::VkWriteDescriptorSet.__Internal*) __Instance)->descriptorCount;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->descriptorCount = value;
        }
    }

    public global::VkDescriptorType DescriptorType
    {
        get
        {
            return ((global::VkWriteDescriptorSet.__Internal*) __Instance)->descriptorType;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->descriptorType = value;
        }
    }

    public global::VkDescriptorImageInfo PImageInfo
    {
        get
        {
            global::VkDescriptorImageInfo __result0;
            if (((global::VkWriteDescriptorSet.__Internal*) __Instance)->pImageInfo == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorImageInfo.NativeToManagedMap.ContainsKey(((global::VkWriteDescriptorSet.__Internal*) __Instance)->pImageInfo))
                __result0 = (global::VkDescriptorImageInfo) global::VkDescriptorImageInfo.NativeToManagedMap[((global::VkWriteDescriptorSet.__Internal*) __Instance)->pImageInfo];
            else __result0 = global::VkDescriptorImageInfo.__CreateInstance(((global::VkWriteDescriptorSet.__Internal*) __Instance)->pImageInfo);
            return __result0;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->pImageInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkDescriptorBufferInfo PBufferInfo
    {
        get
        {
            global::VkDescriptorBufferInfo __result0;
            if (((global::VkWriteDescriptorSet.__Internal*) __Instance)->pBufferInfo == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorBufferInfo.NativeToManagedMap.ContainsKey(((global::VkWriteDescriptorSet.__Internal*) __Instance)->pBufferInfo))
                __result0 = (global::VkDescriptorBufferInfo) global::VkDescriptorBufferInfo.NativeToManagedMap[((global::VkWriteDescriptorSet.__Internal*) __Instance)->pBufferInfo];
            else __result0 = global::VkDescriptorBufferInfo.__CreateInstance(((global::VkWriteDescriptorSet.__Internal*) __Instance)->pBufferInfo);
            return __result0;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->pBufferInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkBufferViewT PTexelBufferView
    {
        get
        {
            global::VkBufferViewT __result0;
            if (((global::VkWriteDescriptorSet.__Internal*) __Instance)->pTexelBufferView == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferViewT.NativeToManagedMap.ContainsKey(((global::VkWriteDescriptorSet.__Internal*) __Instance)->pTexelBufferView))
                __result0 = (global::VkBufferViewT) global::VkBufferViewT.NativeToManagedMap[((global::VkWriteDescriptorSet.__Internal*) __Instance)->pTexelBufferView];
            else __result0 = global::VkBufferViewT.__CreateInstance(((global::VkWriteDescriptorSet.__Internal*) __Instance)->pTexelBufferView);
            return __result0;
        }

        set
        {
            ((global::VkWriteDescriptorSet.__Internal*)__Instance)->pTexelBufferView = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkCopyDescriptorSet : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr srcSet;

        [FieldOffset(24)]
        internal uint srcBinding;

        [FieldOffset(28)]
        internal uint srcArrayElement;

        [FieldOffset(32)]
        internal global::System.IntPtr dstSet;

        [FieldOffset(40)]
        internal uint dstBinding;

        [FieldOffset(44)]
        internal uint dstArrayElement;

        [FieldOffset(48)]
        internal uint descriptorCount;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkCopyDescriptorSet@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCopyDescriptorSet> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCopyDescriptorSet>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCopyDescriptorSet __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCopyDescriptorSet(native.ToPointer(), skipVTables);
    }

    internal static global::VkCopyDescriptorSet __CreateInstance(global::VkCopyDescriptorSet.__Internal native, bool skipVTables = false)
    {
        return new global::VkCopyDescriptorSet(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCopyDescriptorSet.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCopyDescriptorSet.__Internal));
        *(global::VkCopyDescriptorSet.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCopyDescriptorSet(global::VkCopyDescriptorSet.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCopyDescriptorSet(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkCopyDescriptorSet()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCopyDescriptorSet.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkCopyDescriptorSet(global::VkCopyDescriptorSet _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCopyDescriptorSet.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkCopyDescriptorSet.__Internal*) __Instance) = *((global::VkCopyDescriptorSet.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkCopyDescriptorSet __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkCopyDescriptorSet.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkCopyDescriptorSet.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkCopyDescriptorSet.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkCopyDescriptorSet.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDescriptorSetT SrcSet
    {
        get
        {
            global::VkDescriptorSetT __result0;
            if (((global::VkCopyDescriptorSet.__Internal*) __Instance)->srcSet == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorSetT.NativeToManagedMap.ContainsKey(((global::VkCopyDescriptorSet.__Internal*) __Instance)->srcSet))
                __result0 = (global::VkDescriptorSetT) global::VkDescriptorSetT.NativeToManagedMap[((global::VkCopyDescriptorSet.__Internal*) __Instance)->srcSet];
            else __result0 = global::VkDescriptorSetT.__CreateInstance(((global::VkCopyDescriptorSet.__Internal*) __Instance)->srcSet);
            return __result0;
        }

        set
        {
            ((global::VkCopyDescriptorSet.__Internal*)__Instance)->srcSet = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint SrcBinding
    {
        get
        {
            return ((global::VkCopyDescriptorSet.__Internal*) __Instance)->srcBinding;
        }

        set
        {
            ((global::VkCopyDescriptorSet.__Internal*)__Instance)->srcBinding = value;
        }
    }

    public uint SrcArrayElement
    {
        get
        {
            return ((global::VkCopyDescriptorSet.__Internal*) __Instance)->srcArrayElement;
        }

        set
        {
            ((global::VkCopyDescriptorSet.__Internal*)__Instance)->srcArrayElement = value;
        }
    }

    public global::VkDescriptorSetT DstSet
    {
        get
        {
            global::VkDescriptorSetT __result0;
            if (((global::VkCopyDescriptorSet.__Internal*) __Instance)->dstSet == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorSetT.NativeToManagedMap.ContainsKey(((global::VkCopyDescriptorSet.__Internal*) __Instance)->dstSet))
                __result0 = (global::VkDescriptorSetT) global::VkDescriptorSetT.NativeToManagedMap[((global::VkCopyDescriptorSet.__Internal*) __Instance)->dstSet];
            else __result0 = global::VkDescriptorSetT.__CreateInstance(((global::VkCopyDescriptorSet.__Internal*) __Instance)->dstSet);
            return __result0;
        }

        set
        {
            ((global::VkCopyDescriptorSet.__Internal*)__Instance)->dstSet = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint DstBinding
    {
        get
        {
            return ((global::VkCopyDescriptorSet.__Internal*) __Instance)->dstBinding;
        }

        set
        {
            ((global::VkCopyDescriptorSet.__Internal*)__Instance)->dstBinding = value;
        }
    }

    public uint DstArrayElement
    {
        get
        {
            return ((global::VkCopyDescriptorSet.__Internal*) __Instance)->dstArrayElement;
        }

        set
        {
            ((global::VkCopyDescriptorSet.__Internal*)__Instance)->dstArrayElement = value;
        }
    }

    public uint DescriptorCount
    {
        get
        {
            return ((global::VkCopyDescriptorSet.__Internal*) __Instance)->descriptorCount;
        }

        set
        {
            ((global::VkCopyDescriptorSet.__Internal*)__Instance)->descriptorCount = value;
        }
    }
}

public unsafe partial class VkFramebufferCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::System.IntPtr renderPass;

        [FieldOffset(32)]
        internal uint attachmentCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pAttachments;

        [FieldOffset(48)]
        internal uint width;

        [FieldOffset(52)]
        internal uint height;

        [FieldOffset(56)]
        internal uint layers;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkFramebufferCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFramebufferCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFramebufferCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkFramebufferCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkFramebufferCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkFramebufferCreateInfo __CreateInstance(global::VkFramebufferCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkFramebufferCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkFramebufferCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkFramebufferCreateInfo.__Internal));
        *(global::VkFramebufferCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkFramebufferCreateInfo(global::VkFramebufferCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkFramebufferCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkFramebufferCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFramebufferCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkFramebufferCreateInfo(global::VkFramebufferCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFramebufferCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkFramebufferCreateInfo.__Internal*) __Instance) = *((global::VkFramebufferCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkFramebufferCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkFramebufferCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkFramebufferCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkFramebufferCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkFramebufferCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkFramebufferCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkFramebufferCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkRenderPassT RenderPass
    {
        get
        {
            global::VkRenderPassT __result0;
            if (((global::VkFramebufferCreateInfo.__Internal*) __Instance)->renderPass == IntPtr.Zero) __result0 = null;
            else if (global::VkRenderPassT.NativeToManagedMap.ContainsKey(((global::VkFramebufferCreateInfo.__Internal*) __Instance)->renderPass))
                __result0 = (global::VkRenderPassT) global::VkRenderPassT.NativeToManagedMap[((global::VkFramebufferCreateInfo.__Internal*) __Instance)->renderPass];
            else __result0 = global::VkRenderPassT.__CreateInstance(((global::VkFramebufferCreateInfo.__Internal*) __Instance)->renderPass);
            return __result0;
        }

        set
        {
            ((global::VkFramebufferCreateInfo.__Internal*)__Instance)->renderPass = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint AttachmentCount
    {
        get
        {
            return ((global::VkFramebufferCreateInfo.__Internal*) __Instance)->attachmentCount;
        }

        set
        {
            ((global::VkFramebufferCreateInfo.__Internal*)__Instance)->attachmentCount = value;
        }
    }

    public global::VkImageViewT PAttachments
    {
        get
        {
            global::VkImageViewT __result0;
            if (((global::VkFramebufferCreateInfo.__Internal*) __Instance)->pAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkImageViewT.NativeToManagedMap.ContainsKey(((global::VkFramebufferCreateInfo.__Internal*) __Instance)->pAttachments))
                __result0 = (global::VkImageViewT) global::VkImageViewT.NativeToManagedMap[((global::VkFramebufferCreateInfo.__Internal*) __Instance)->pAttachments];
            else __result0 = global::VkImageViewT.__CreateInstance(((global::VkFramebufferCreateInfo.__Internal*) __Instance)->pAttachments);
            return __result0;
        }

        set
        {
            ((global::VkFramebufferCreateInfo.__Internal*)__Instance)->pAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint Width
    {
        get
        {
            return ((global::VkFramebufferCreateInfo.__Internal*) __Instance)->width;
        }

        set
        {
            ((global::VkFramebufferCreateInfo.__Internal*)__Instance)->width = value;
        }
    }

    public uint Height
    {
        get
        {
            return ((global::VkFramebufferCreateInfo.__Internal*) __Instance)->height;
        }

        set
        {
            ((global::VkFramebufferCreateInfo.__Internal*)__Instance)->height = value;
        }
    }

    public uint Layers
    {
        get
        {
            return ((global::VkFramebufferCreateInfo.__Internal*) __Instance)->layers;
        }

        set
        {
            ((global::VkFramebufferCreateInfo.__Internal*)__Instance)->layers = value;
        }
    }
}

public unsafe partial class VkAttachmentDescription : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 36)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint flags;

        [FieldOffset(4)]
        internal global::VkFormat format;

        [FieldOffset(8)]
        internal global::VkSampleCountFlagBits samples;

        [FieldOffset(12)]
        internal global::VkAttachmentLoadOp loadOp;

        [FieldOffset(16)]
        internal global::VkAttachmentStoreOp storeOp;

        [FieldOffset(20)]
        internal global::VkAttachmentLoadOp stencilLoadOp;

        [FieldOffset(24)]
        internal global::VkAttachmentStoreOp stencilStoreOp;

        [FieldOffset(28)]
        internal global::VkImageLayout initialLayout;

        [FieldOffset(32)]
        internal global::VkImageLayout finalLayout;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkAttachmentDescription@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentDescription>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkAttachmentDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkAttachmentDescription(native.ToPointer(), skipVTables);
    }

    internal static global::VkAttachmentDescription __CreateInstance(global::VkAttachmentDescription.__Internal native, bool skipVTables = false)
    {
        return new global::VkAttachmentDescription(native, skipVTables);
    }

    private static void* __CopyValue(global::VkAttachmentDescription.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkAttachmentDescription.__Internal));
        *(global::VkAttachmentDescription.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkAttachmentDescription(global::VkAttachmentDescription.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkAttachmentDescription(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkAttachmentDescription()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentDescription.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkAttachmentDescription(global::VkAttachmentDescription _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentDescription.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkAttachmentDescription.__Internal*) __Instance) = *((global::VkAttachmentDescription.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkAttachmentDescription __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Flags
    {
        get
        {
            return ((global::VkAttachmentDescription.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkAttachmentDescription.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkAttachmentDescription.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkAttachmentDescription.__Internal*)__Instance)->format = value;
        }
    }

    public global::VkSampleCountFlagBits Samples
    {
        get
        {
            return ((global::VkAttachmentDescription.__Internal*) __Instance)->samples;
        }

        set
        {
            ((global::VkAttachmentDescription.__Internal*)__Instance)->samples = value;
        }
    }

    public global::VkAttachmentLoadOp LoadOp
    {
        get
        {
            return ((global::VkAttachmentDescription.__Internal*) __Instance)->loadOp;
        }

        set
        {
            ((global::VkAttachmentDescription.__Internal*)__Instance)->loadOp = value;
        }
    }

    public global::VkAttachmentStoreOp StoreOp
    {
        get
        {
            return ((global::VkAttachmentDescription.__Internal*) __Instance)->storeOp;
        }

        set
        {
            ((global::VkAttachmentDescription.__Internal*)__Instance)->storeOp = value;
        }
    }

    public global::VkAttachmentLoadOp StencilLoadOp
    {
        get
        {
            return ((global::VkAttachmentDescription.__Internal*) __Instance)->stencilLoadOp;
        }

        set
        {
            ((global::VkAttachmentDescription.__Internal*)__Instance)->stencilLoadOp = value;
        }
    }

    public global::VkAttachmentStoreOp StencilStoreOp
    {
        get
        {
            return ((global::VkAttachmentDescription.__Internal*) __Instance)->stencilStoreOp;
        }

        set
        {
            ((global::VkAttachmentDescription.__Internal*)__Instance)->stencilStoreOp = value;
        }
    }

    public global::VkImageLayout InitialLayout
    {
        get
        {
            return ((global::VkAttachmentDescription.__Internal*) __Instance)->initialLayout;
        }

        set
        {
            ((global::VkAttachmentDescription.__Internal*)__Instance)->initialLayout = value;
        }
    }

    public global::VkImageLayout FinalLayout
    {
        get
        {
            return ((global::VkAttachmentDescription.__Internal*) __Instance)->finalLayout;
        }

        set
        {
            ((global::VkAttachmentDescription.__Internal*)__Instance)->finalLayout = value;
        }
    }
}

public unsafe partial class VkAttachmentReference : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint attachment;

        [FieldOffset(4)]
        internal global::VkImageLayout layout;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkAttachmentReference@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentReference> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentReference>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkAttachmentReference __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkAttachmentReference(native.ToPointer(), skipVTables);
    }

    internal static global::VkAttachmentReference __CreateInstance(global::VkAttachmentReference.__Internal native, bool skipVTables = false)
    {
        return new global::VkAttachmentReference(native, skipVTables);
    }

    private static void* __CopyValue(global::VkAttachmentReference.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkAttachmentReference.__Internal));
        *(global::VkAttachmentReference.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkAttachmentReference(global::VkAttachmentReference.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkAttachmentReference(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkAttachmentReference()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentReference.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkAttachmentReference(global::VkAttachmentReference _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentReference.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkAttachmentReference.__Internal*) __Instance) = *((global::VkAttachmentReference.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkAttachmentReference __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Attachment
    {
        get
        {
            return ((global::VkAttachmentReference.__Internal*) __Instance)->attachment;
        }

        set
        {
            ((global::VkAttachmentReference.__Internal*)__Instance)->attachment = value;
        }
    }

    public global::VkImageLayout Layout
    {
        get
        {
            return ((global::VkAttachmentReference.__Internal*) __Instance)->layout;
        }

        set
        {
            ((global::VkAttachmentReference.__Internal*)__Instance)->layout = value;
        }
    }
}

public unsafe partial class VkSubpassDescription : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint flags;

        [FieldOffset(4)]
        internal global::VkPipelineBindPoint pipelineBindPoint;

        [FieldOffset(8)]
        internal uint inputAttachmentCount;

        [FieldOffset(16)]
        internal global::System.IntPtr pInputAttachments;

        [FieldOffset(24)]
        internal uint colorAttachmentCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pColorAttachments;

        [FieldOffset(40)]
        internal global::System.IntPtr pResolveAttachments;

        [FieldOffset(48)]
        internal global::System.IntPtr pDepthStencilAttachment;

        [FieldOffset(56)]
        internal uint preserveAttachmentCount;

        [FieldOffset(64)]
        internal global::System.IntPtr pPreserveAttachments;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSubpassDescription@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassDescription>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSubpassDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSubpassDescription(native.ToPointer(), skipVTables);
    }

    internal static global::VkSubpassDescription __CreateInstance(global::VkSubpassDescription.__Internal native, bool skipVTables = false)
    {
        return new global::VkSubpassDescription(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSubpassDescription.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSubpassDescription.__Internal));
        *(global::VkSubpassDescription.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSubpassDescription(global::VkSubpassDescription.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSubpassDescription(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSubpassDescription()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassDescription.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSubpassDescription(global::VkSubpassDescription _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassDescription.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSubpassDescription.__Internal*) __Instance) = *((global::VkSubpassDescription.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSubpassDescription __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Flags
    {
        get
        {
            return ((global::VkSubpassDescription.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkPipelineBindPoint PipelineBindPoint
    {
        get
        {
            return ((global::VkSubpassDescription.__Internal*) __Instance)->pipelineBindPoint;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->pipelineBindPoint = value;
        }
    }

    public uint InputAttachmentCount
    {
        get
        {
            return ((global::VkSubpassDescription.__Internal*) __Instance)->inputAttachmentCount;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->inputAttachmentCount = value;
        }
    }

    public global::VkAttachmentReference PInputAttachments
    {
        get
        {
            global::VkAttachmentReference __result0;
            if (((global::VkSubpassDescription.__Internal*) __Instance)->pInputAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentReference.NativeToManagedMap.ContainsKey(((global::VkSubpassDescription.__Internal*) __Instance)->pInputAttachments))
                __result0 = (global::VkAttachmentReference) global::VkAttachmentReference.NativeToManagedMap[((global::VkSubpassDescription.__Internal*) __Instance)->pInputAttachments];
            else __result0 = global::VkAttachmentReference.__CreateInstance(((global::VkSubpassDescription.__Internal*) __Instance)->pInputAttachments);
            return __result0;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->pInputAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint ColorAttachmentCount
    {
        get
        {
            return ((global::VkSubpassDescription.__Internal*) __Instance)->colorAttachmentCount;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->colorAttachmentCount = value;
        }
    }

    public global::VkAttachmentReference PColorAttachments
    {
        get
        {
            global::VkAttachmentReference __result0;
            if (((global::VkSubpassDescription.__Internal*) __Instance)->pColorAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentReference.NativeToManagedMap.ContainsKey(((global::VkSubpassDescription.__Internal*) __Instance)->pColorAttachments))
                __result0 = (global::VkAttachmentReference) global::VkAttachmentReference.NativeToManagedMap[((global::VkSubpassDescription.__Internal*) __Instance)->pColorAttachments];
            else __result0 = global::VkAttachmentReference.__CreateInstance(((global::VkSubpassDescription.__Internal*) __Instance)->pColorAttachments);
            return __result0;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->pColorAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkAttachmentReference PResolveAttachments
    {
        get
        {
            global::VkAttachmentReference __result0;
            if (((global::VkSubpassDescription.__Internal*) __Instance)->pResolveAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentReference.NativeToManagedMap.ContainsKey(((global::VkSubpassDescription.__Internal*) __Instance)->pResolveAttachments))
                __result0 = (global::VkAttachmentReference) global::VkAttachmentReference.NativeToManagedMap[((global::VkSubpassDescription.__Internal*) __Instance)->pResolveAttachments];
            else __result0 = global::VkAttachmentReference.__CreateInstance(((global::VkSubpassDescription.__Internal*) __Instance)->pResolveAttachments);
            return __result0;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->pResolveAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkAttachmentReference PDepthStencilAttachment
    {
        get
        {
            global::VkAttachmentReference __result0;
            if (((global::VkSubpassDescription.__Internal*) __Instance)->pDepthStencilAttachment == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentReference.NativeToManagedMap.ContainsKey(((global::VkSubpassDescription.__Internal*) __Instance)->pDepthStencilAttachment))
                __result0 = (global::VkAttachmentReference) global::VkAttachmentReference.NativeToManagedMap[((global::VkSubpassDescription.__Internal*) __Instance)->pDepthStencilAttachment];
            else __result0 = global::VkAttachmentReference.__CreateInstance(((global::VkSubpassDescription.__Internal*) __Instance)->pDepthStencilAttachment);
            return __result0;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->pDepthStencilAttachment = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint PreserveAttachmentCount
    {
        get
        {
            return ((global::VkSubpassDescription.__Internal*) __Instance)->preserveAttachmentCount;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->preserveAttachmentCount = value;
        }
    }

    public uint* PPreserveAttachments
    {
        get
        {
            return (uint*) ((global::VkSubpassDescription.__Internal*) __Instance)->pPreserveAttachments;
        }

        set
        {
            ((global::VkSubpassDescription.__Internal*)__Instance)->pPreserveAttachments = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkSubpassDependency : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 28)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint srcSubpass;

        [FieldOffset(4)]
        internal uint dstSubpass;

        [FieldOffset(8)]
        internal uint srcStageMask;

        [FieldOffset(12)]
        internal uint dstStageMask;

        [FieldOffset(16)]
        internal uint srcAccessMask;

        [FieldOffset(20)]
        internal uint dstAccessMask;

        [FieldOffset(24)]
        internal uint dependencyFlags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSubpassDependency@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassDependency> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassDependency>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSubpassDependency __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSubpassDependency(native.ToPointer(), skipVTables);
    }

    internal static global::VkSubpassDependency __CreateInstance(global::VkSubpassDependency.__Internal native, bool skipVTables = false)
    {
        return new global::VkSubpassDependency(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSubpassDependency.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSubpassDependency.__Internal));
        *(global::VkSubpassDependency.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSubpassDependency(global::VkSubpassDependency.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSubpassDependency(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSubpassDependency()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassDependency.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSubpassDependency(global::VkSubpassDependency _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassDependency.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSubpassDependency.__Internal*) __Instance) = *((global::VkSubpassDependency.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSubpassDependency __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint SrcSubpass
    {
        get
        {
            return ((global::VkSubpassDependency.__Internal*) __Instance)->srcSubpass;
        }

        set
        {
            ((global::VkSubpassDependency.__Internal*)__Instance)->srcSubpass = value;
        }
    }

    public uint DstSubpass
    {
        get
        {
            return ((global::VkSubpassDependency.__Internal*) __Instance)->dstSubpass;
        }

        set
        {
            ((global::VkSubpassDependency.__Internal*)__Instance)->dstSubpass = value;
        }
    }

    public uint SrcStageMask
    {
        get
        {
            return ((global::VkSubpassDependency.__Internal*) __Instance)->srcStageMask;
        }

        set
        {
            ((global::VkSubpassDependency.__Internal*)__Instance)->srcStageMask = value;
        }
    }

    public uint DstStageMask
    {
        get
        {
            return ((global::VkSubpassDependency.__Internal*) __Instance)->dstStageMask;
        }

        set
        {
            ((global::VkSubpassDependency.__Internal*)__Instance)->dstStageMask = value;
        }
    }

    public uint SrcAccessMask
    {
        get
        {
            return ((global::VkSubpassDependency.__Internal*) __Instance)->srcAccessMask;
        }

        set
        {
            ((global::VkSubpassDependency.__Internal*)__Instance)->srcAccessMask = value;
        }
    }

    public uint DstAccessMask
    {
        get
        {
            return ((global::VkSubpassDependency.__Internal*) __Instance)->dstAccessMask;
        }

        set
        {
            ((global::VkSubpassDependency.__Internal*)__Instance)->dstAccessMask = value;
        }
    }

    public uint DependencyFlags
    {
        get
        {
            return ((global::VkSubpassDependency.__Internal*) __Instance)->dependencyFlags;
        }

        set
        {
            ((global::VkSubpassDependency.__Internal*)__Instance)->dependencyFlags = value;
        }
    }
}

public unsafe partial class VkRenderPassCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint attachmentCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pAttachments;

        [FieldOffset(32)]
        internal uint subpassCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pSubpasses;

        [FieldOffset(48)]
        internal uint dependencyCount;

        [FieldOffset(56)]
        internal global::System.IntPtr pDependencies;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkRenderPassCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRenderPassCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRenderPassCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkRenderPassCreateInfo __CreateInstance(global::VkRenderPassCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkRenderPassCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRenderPassCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRenderPassCreateInfo.__Internal));
        *(global::VkRenderPassCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRenderPassCreateInfo(global::VkRenderPassCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRenderPassCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkRenderPassCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkRenderPassCreateInfo(global::VkRenderPassCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkRenderPassCreateInfo.__Internal*) __Instance) = *((global::VkRenderPassCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkRenderPassCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkRenderPassCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkRenderPassCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkRenderPassCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkRenderPassCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkRenderPassCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint AttachmentCount
    {
        get
        {
            return ((global::VkRenderPassCreateInfo.__Internal*) __Instance)->attachmentCount;
        }

        set
        {
            ((global::VkRenderPassCreateInfo.__Internal*)__Instance)->attachmentCount = value;
        }
    }

    public global::VkAttachmentDescription PAttachments
    {
        get
        {
            global::VkAttachmentDescription __result0;
            if (((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentDescription.NativeToManagedMap.ContainsKey(((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pAttachments))
                __result0 = (global::VkAttachmentDescription) global::VkAttachmentDescription.NativeToManagedMap[((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pAttachments];
            else __result0 = global::VkAttachmentDescription.__CreateInstance(((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pAttachments);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassCreateInfo.__Internal*)__Instance)->pAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint SubpassCount
    {
        get
        {
            return ((global::VkRenderPassCreateInfo.__Internal*) __Instance)->subpassCount;
        }

        set
        {
            ((global::VkRenderPassCreateInfo.__Internal*)__Instance)->subpassCount = value;
        }
    }

    public global::VkSubpassDescription PSubpasses
    {
        get
        {
            global::VkSubpassDescription __result0;
            if (((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pSubpasses == IntPtr.Zero) __result0 = null;
            else if (global::VkSubpassDescription.NativeToManagedMap.ContainsKey(((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pSubpasses))
                __result0 = (global::VkSubpassDescription) global::VkSubpassDescription.NativeToManagedMap[((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pSubpasses];
            else __result0 = global::VkSubpassDescription.__CreateInstance(((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pSubpasses);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassCreateInfo.__Internal*)__Instance)->pSubpasses = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint DependencyCount
    {
        get
        {
            return ((global::VkRenderPassCreateInfo.__Internal*) __Instance)->dependencyCount;
        }

        set
        {
            ((global::VkRenderPassCreateInfo.__Internal*)__Instance)->dependencyCount = value;
        }
    }

    public global::VkSubpassDependency PDependencies
    {
        get
        {
            global::VkSubpassDependency __result0;
            if (((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pDependencies == IntPtr.Zero) __result0 = null;
            else if (global::VkSubpassDependency.NativeToManagedMap.ContainsKey(((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pDependencies))
                __result0 = (global::VkSubpassDependency) global::VkSubpassDependency.NativeToManagedMap[((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pDependencies];
            else __result0 = global::VkSubpassDependency.__CreateInstance(((global::VkRenderPassCreateInfo.__Internal*) __Instance)->pDependencies);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassCreateInfo.__Internal*)__Instance)->pDependencies = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkCommandPoolCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint queueFamilyIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkCommandPoolCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandPoolCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandPoolCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCommandPoolCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCommandPoolCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkCommandPoolCreateInfo __CreateInstance(global::VkCommandPoolCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkCommandPoolCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCommandPoolCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCommandPoolCreateInfo.__Internal));
        *(global::VkCommandPoolCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCommandPoolCreateInfo(global::VkCommandPoolCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCommandPoolCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkCommandPoolCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandPoolCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkCommandPoolCreateInfo(global::VkCommandPoolCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandPoolCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkCommandPoolCreateInfo.__Internal*) __Instance) = *((global::VkCommandPoolCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkCommandPoolCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkCommandPoolCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkCommandPoolCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkCommandPoolCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkCommandPoolCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkCommandPoolCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkCommandPoolCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint QueueFamilyIndex
    {
        get
        {
            return ((global::VkCommandPoolCreateInfo.__Internal*) __Instance)->queueFamilyIndex;
        }

        set
        {
            ((global::VkCommandPoolCreateInfo.__Internal*)__Instance)->queueFamilyIndex = value;
        }
    }
}

public unsafe partial class VkCommandBufferAllocateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr commandPool;

        [FieldOffset(24)]
        internal global::VkCommandBufferLevel level;

        [FieldOffset(28)]
        internal uint commandBufferCount;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkCommandBufferAllocateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferAllocateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferAllocateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCommandBufferAllocateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCommandBufferAllocateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkCommandBufferAllocateInfo __CreateInstance(global::VkCommandBufferAllocateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkCommandBufferAllocateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCommandBufferAllocateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferAllocateInfo.__Internal));
        *(global::VkCommandBufferAllocateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCommandBufferAllocateInfo(global::VkCommandBufferAllocateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCommandBufferAllocateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkCommandBufferAllocateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkCommandBufferAllocateInfo(global::VkCommandBufferAllocateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkCommandBufferAllocateInfo.__Internal*) __Instance) = *((global::VkCommandBufferAllocateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkCommandBufferAllocateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkCommandBufferAllocateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkCommandBufferAllocateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkCommandBufferAllocateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkCommandBufferAllocateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkCommandPoolT CommandPool
    {
        get
        {
            global::VkCommandPoolT __result0;
            if (((global::VkCommandBufferAllocateInfo.__Internal*) __Instance)->commandPool == IntPtr.Zero) __result0 = null;
            else if (global::VkCommandPoolT.NativeToManagedMap.ContainsKey(((global::VkCommandBufferAllocateInfo.__Internal*) __Instance)->commandPool))
                __result0 = (global::VkCommandPoolT) global::VkCommandPoolT.NativeToManagedMap[((global::VkCommandBufferAllocateInfo.__Internal*) __Instance)->commandPool];
            else __result0 = global::VkCommandPoolT.__CreateInstance(((global::VkCommandBufferAllocateInfo.__Internal*) __Instance)->commandPool);
            return __result0;
        }

        set
        {
            ((global::VkCommandBufferAllocateInfo.__Internal*)__Instance)->commandPool = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkCommandBufferLevel Level
    {
        get
        {
            return ((global::VkCommandBufferAllocateInfo.__Internal*) __Instance)->level;
        }

        set
        {
            ((global::VkCommandBufferAllocateInfo.__Internal*)__Instance)->level = value;
        }
    }

    public uint CommandBufferCount
    {
        get
        {
            return ((global::VkCommandBufferAllocateInfo.__Internal*) __Instance)->commandBufferCount;
        }

        set
        {
            ((global::VkCommandBufferAllocateInfo.__Internal*)__Instance)->commandBufferCount = value;
        }
    }
}

public unsafe partial class VkCommandBufferInheritanceInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr renderPass;

        [FieldOffset(24)]
        internal uint subpass;

        [FieldOffset(32)]
        internal global::System.IntPtr framebuffer;

        [FieldOffset(40)]
        internal uint occlusionQueryEnable;

        [FieldOffset(44)]
        internal uint queryFlags;

        [FieldOffset(48)]
        internal uint pipelineStatistics;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkCommandBufferInheritanceInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferInheritanceInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferInheritanceInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCommandBufferInheritanceInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCommandBufferInheritanceInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkCommandBufferInheritanceInfo __CreateInstance(global::VkCommandBufferInheritanceInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkCommandBufferInheritanceInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCommandBufferInheritanceInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferInheritanceInfo.__Internal));
        *(global::VkCommandBufferInheritanceInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCommandBufferInheritanceInfo(global::VkCommandBufferInheritanceInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCommandBufferInheritanceInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkCommandBufferInheritanceInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferInheritanceInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkCommandBufferInheritanceInfo(global::VkCommandBufferInheritanceInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferInheritanceInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance) = *((global::VkCommandBufferInheritanceInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkCommandBufferInheritanceInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkCommandBufferInheritanceInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkCommandBufferInheritanceInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkRenderPassT RenderPass
    {
        get
        {
            global::VkRenderPassT __result0;
            if (((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->renderPass == IntPtr.Zero) __result0 = null;
            else if (global::VkRenderPassT.NativeToManagedMap.ContainsKey(((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->renderPass))
                __result0 = (global::VkRenderPassT) global::VkRenderPassT.NativeToManagedMap[((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->renderPass];
            else __result0 = global::VkRenderPassT.__CreateInstance(((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->renderPass);
            return __result0;
        }

        set
        {
            ((global::VkCommandBufferInheritanceInfo.__Internal*)__Instance)->renderPass = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint Subpass
    {
        get
        {
            return ((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->subpass;
        }

        set
        {
            ((global::VkCommandBufferInheritanceInfo.__Internal*)__Instance)->subpass = value;
        }
    }

    public global::VkFramebufferT Framebuffer
    {
        get
        {
            global::VkFramebufferT __result0;
            if (((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->framebuffer == IntPtr.Zero) __result0 = null;
            else if (global::VkFramebufferT.NativeToManagedMap.ContainsKey(((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->framebuffer))
                __result0 = (global::VkFramebufferT) global::VkFramebufferT.NativeToManagedMap[((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->framebuffer];
            else __result0 = global::VkFramebufferT.__CreateInstance(((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->framebuffer);
            return __result0;
        }

        set
        {
            ((global::VkCommandBufferInheritanceInfo.__Internal*)__Instance)->framebuffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint OcclusionQueryEnable
    {
        get
        {
            return ((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->occlusionQueryEnable;
        }

        set
        {
            ((global::VkCommandBufferInheritanceInfo.__Internal*)__Instance)->occlusionQueryEnable = value;
        }
    }

    public uint QueryFlags
    {
        get
        {
            return ((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->queryFlags;
        }

        set
        {
            ((global::VkCommandBufferInheritanceInfo.__Internal*)__Instance)->queryFlags = value;
        }
    }

    public uint PipelineStatistics
    {
        get
        {
            return ((global::VkCommandBufferInheritanceInfo.__Internal*) __Instance)->pipelineStatistics;
        }

        set
        {
            ((global::VkCommandBufferInheritanceInfo.__Internal*)__Instance)->pipelineStatistics = value;
        }
    }
}

public unsafe partial class VkCommandBufferBeginInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::System.IntPtr pInheritanceInfo;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkCommandBufferBeginInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferBeginInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferBeginInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCommandBufferBeginInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCommandBufferBeginInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkCommandBufferBeginInfo __CreateInstance(global::VkCommandBufferBeginInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkCommandBufferBeginInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCommandBufferBeginInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferBeginInfo.__Internal));
        *(global::VkCommandBufferBeginInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCommandBufferBeginInfo(global::VkCommandBufferBeginInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCommandBufferBeginInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkCommandBufferBeginInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferBeginInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkCommandBufferBeginInfo(global::VkCommandBufferBeginInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferBeginInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkCommandBufferBeginInfo.__Internal*) __Instance) = *((global::VkCommandBufferBeginInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkCommandBufferBeginInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkCommandBufferBeginInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkCommandBufferBeginInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkCommandBufferBeginInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkCommandBufferBeginInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkCommandBufferBeginInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkCommandBufferBeginInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkCommandBufferInheritanceInfo PInheritanceInfo
    {
        get
        {
            global::VkCommandBufferInheritanceInfo __result0;
            if (((global::VkCommandBufferBeginInfo.__Internal*) __Instance)->pInheritanceInfo == IntPtr.Zero) __result0 = null;
            else if (global::VkCommandBufferInheritanceInfo.NativeToManagedMap.ContainsKey(((global::VkCommandBufferBeginInfo.__Internal*) __Instance)->pInheritanceInfo))
                __result0 = (global::VkCommandBufferInheritanceInfo) global::VkCommandBufferInheritanceInfo.NativeToManagedMap[((global::VkCommandBufferBeginInfo.__Internal*) __Instance)->pInheritanceInfo];
            else __result0 = global::VkCommandBufferInheritanceInfo.__CreateInstance(((global::VkCommandBufferBeginInfo.__Internal*) __Instance)->pInheritanceInfo);
            return __result0;
        }

        set
        {
            ((global::VkCommandBufferBeginInfo.__Internal*)__Instance)->pInheritanceInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkBufferCopy : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal ulong srcOffset;

        [FieldOffset(8)]
        internal ulong dstOffset;

        [FieldOffset(16)]
        internal ulong size;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBufferCopy@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferCopy> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferCopy>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBufferCopy __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBufferCopy(native.ToPointer(), skipVTables);
    }

    internal static global::VkBufferCopy __CreateInstance(global::VkBufferCopy.__Internal native, bool skipVTables = false)
    {
        return new global::VkBufferCopy(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBufferCopy.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBufferCopy.__Internal));
        *(global::VkBufferCopy.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBufferCopy(global::VkBufferCopy.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBufferCopy(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBufferCopy()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferCopy.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBufferCopy(global::VkBufferCopy _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferCopy.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBufferCopy.__Internal*) __Instance) = *((global::VkBufferCopy.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBufferCopy __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public ulong SrcOffset
    {
        get
        {
            return ((global::VkBufferCopy.__Internal*) __Instance)->srcOffset;
        }

        set
        {
            ((global::VkBufferCopy.__Internal*)__Instance)->srcOffset = value;
        }
    }

    public ulong DstOffset
    {
        get
        {
            return ((global::VkBufferCopy.__Internal*) __Instance)->dstOffset;
        }

        set
        {
            ((global::VkBufferCopy.__Internal*)__Instance)->dstOffset = value;
        }
    }

    public ulong Size
    {
        get
        {
            return ((global::VkBufferCopy.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkBufferCopy.__Internal*)__Instance)->size = value;
        }
    }
}

public unsafe partial class VkImageSubresourceLayers : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint aspectMask;

        [FieldOffset(4)]
        internal uint mipLevel;

        [FieldOffset(8)]
        internal uint baseArrayLayer;

        [FieldOffset(12)]
        internal uint layerCount;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageSubresourceLayers@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSubresourceLayers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSubresourceLayers>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageSubresourceLayers __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageSubresourceLayers(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageSubresourceLayers __CreateInstance(global::VkImageSubresourceLayers.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageSubresourceLayers(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageSubresourceLayers.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageSubresourceLayers.__Internal));
        *(global::VkImageSubresourceLayers.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageSubresourceLayers(global::VkImageSubresourceLayers.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageSubresourceLayers(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageSubresourceLayers()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSubresourceLayers.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageSubresourceLayers(global::VkImageSubresourceLayers _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSubresourceLayers.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageSubresourceLayers.__Internal*) __Instance) = *((global::VkImageSubresourceLayers.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageSubresourceLayers __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint AspectMask
    {
        get
        {
            return ((global::VkImageSubresourceLayers.__Internal*) __Instance)->aspectMask;
        }

        set
        {
            ((global::VkImageSubresourceLayers.__Internal*)__Instance)->aspectMask = value;
        }
    }

    public uint MipLevel
    {
        get
        {
            return ((global::VkImageSubresourceLayers.__Internal*) __Instance)->mipLevel;
        }

        set
        {
            ((global::VkImageSubresourceLayers.__Internal*)__Instance)->mipLevel = value;
        }
    }

    public uint BaseArrayLayer
    {
        get
        {
            return ((global::VkImageSubresourceLayers.__Internal*) __Instance)->baseArrayLayer;
        }

        set
        {
            ((global::VkImageSubresourceLayers.__Internal*)__Instance)->baseArrayLayer = value;
        }
    }

    public uint LayerCount
    {
        get
        {
            return ((global::VkImageSubresourceLayers.__Internal*) __Instance)->layerCount;
        }

        set
        {
            ((global::VkImageSubresourceLayers.__Internal*)__Instance)->layerCount = value;
        }
    }
}

public unsafe partial class VkImageCopy : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 68)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkImageSubresourceLayers.__Internal srcSubresource;

        [FieldOffset(16)]
        internal global::VkOffset3D.__Internal srcOffset;

        [FieldOffset(28)]
        internal global::VkImageSubresourceLayers.__Internal dstSubresource;

        [FieldOffset(44)]
        internal global::VkOffset3D.__Internal dstOffset;

        [FieldOffset(56)]
        internal global::VkExtent3D.__Internal extent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageCopy@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageCopy> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageCopy>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageCopy __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageCopy(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageCopy __CreateInstance(global::VkImageCopy.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageCopy(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageCopy.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageCopy.__Internal));
        *(global::VkImageCopy.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageCopy(global::VkImageCopy.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageCopy(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageCopy()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageCopy.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageCopy(global::VkImageCopy _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageCopy.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageCopy.__Internal*) __Instance) = *((global::VkImageCopy.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageCopy __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkImageSubresourceLayers SrcSubresource
    {
        get
        {
            return global::VkImageSubresourceLayers.__CreateInstance(new global::System.IntPtr(&((global::VkImageCopy.__Internal*) __Instance)->srcSubresource));
        }

        set
        {
            ((global::VkImageCopy.__Internal*)__Instance)->srcSubresource = ReferenceEquals(value, null) ? new global::VkImageSubresourceLayers.__Internal() : *(global::VkImageSubresourceLayers.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset3D SrcOffset
    {
        get
        {
            return global::VkOffset3D.__CreateInstance(new global::System.IntPtr(&((global::VkImageCopy.__Internal*) __Instance)->srcOffset));
        }

        set
        {
            ((global::VkImageCopy.__Internal*)__Instance)->srcOffset = ReferenceEquals(value, null) ? new global::VkOffset3D.__Internal() : *(global::VkOffset3D.__Internal*) value.__Instance;
        }
    }

    public global::VkImageSubresourceLayers DstSubresource
    {
        get
        {
            return global::VkImageSubresourceLayers.__CreateInstance(new global::System.IntPtr(&((global::VkImageCopy.__Internal*) __Instance)->dstSubresource));
        }

        set
        {
            ((global::VkImageCopy.__Internal*)__Instance)->dstSubresource = ReferenceEquals(value, null) ? new global::VkImageSubresourceLayers.__Internal() : *(global::VkImageSubresourceLayers.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset3D DstOffset
    {
        get
        {
            return global::VkOffset3D.__CreateInstance(new global::System.IntPtr(&((global::VkImageCopy.__Internal*) __Instance)->dstOffset));
        }

        set
        {
            ((global::VkImageCopy.__Internal*)__Instance)->dstOffset = ReferenceEquals(value, null) ? new global::VkOffset3D.__Internal() : *(global::VkOffset3D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent3D Extent
    {
        get
        {
            return global::VkExtent3D.__CreateInstance(new global::System.IntPtr(&((global::VkImageCopy.__Internal*) __Instance)->extent));
        }

        set
        {
            ((global::VkImageCopy.__Internal*)__Instance)->extent = ReferenceEquals(value, null) ? new global::VkExtent3D.__Internal() : *(global::VkExtent3D.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkImageBlit : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkImageSubresourceLayers.__Internal srcSubresource;

        [FieldOffset(16)]
        internal fixed byte srcOffsets[24];

        [FieldOffset(40)]
        internal global::VkImageSubresourceLayers.__Internal dstSubresource;

        [FieldOffset(56)]
        internal fixed byte dstOffsets[24];

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageBlit@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageBlit> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageBlit>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageBlit __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageBlit(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageBlit __CreateInstance(global::VkImageBlit.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageBlit(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageBlit.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageBlit.__Internal));
        *(global::VkImageBlit.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageBlit(global::VkImageBlit.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageBlit(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageBlit()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageBlit.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageBlit(global::VkImageBlit _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageBlit.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageBlit.__Internal*) __Instance) = *((global::VkImageBlit.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageBlit __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkImageSubresourceLayers SrcSubresource
    {
        get
        {
            return global::VkImageSubresourceLayers.__CreateInstance(new global::System.IntPtr(&((global::VkImageBlit.__Internal*) __Instance)->srcSubresource));
        }

        set
        {
            ((global::VkImageBlit.__Internal*)__Instance)->srcSubresource = ReferenceEquals(value, null) ? new global::VkImageSubresourceLayers.__Internal() : *(global::VkImageSubresourceLayers.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset3D[] SrcOffsets
    {
        get
        {
            global::VkOffset3D[] __value = null;
            if (((global::VkImageBlit.__Internal*) __Instance)->srcOffsets != null)
            {
                __value = new global::VkOffset3D[2];
                for (int i = 0; i < 2; i++)
                    __value[i] = global::VkOffset3D.__CreateInstance(*((global::VkOffset3D.__Internal*)&(((global::VkImageBlit.__Internal*) __Instance)->srcOffsets[i * sizeof(global::VkOffset3D.__Internal)])));
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                if (value.Length != 2)
                    throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                for (int i = 0; i < 2; i++)
                    *(global::VkOffset3D.__Internal*) &((global::VkImageBlit.__Internal*)__Instance)->srcOffsets[i * sizeof(global::VkOffset3D.__Internal)] = *(global::VkOffset3D.__Internal*)value[i].__Instance;
            }
        }
    }

    public global::VkImageSubresourceLayers DstSubresource
    {
        get
        {
            return global::VkImageSubresourceLayers.__CreateInstance(new global::System.IntPtr(&((global::VkImageBlit.__Internal*) __Instance)->dstSubresource));
        }

        set
        {
            ((global::VkImageBlit.__Internal*)__Instance)->dstSubresource = ReferenceEquals(value, null) ? new global::VkImageSubresourceLayers.__Internal() : *(global::VkImageSubresourceLayers.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset3D[] DstOffsets
    {
        get
        {
            global::VkOffset3D[] __value = null;
            if (((global::VkImageBlit.__Internal*) __Instance)->dstOffsets != null)
            {
                __value = new global::VkOffset3D[2];
                for (int i = 0; i < 2; i++)
                    __value[i] = global::VkOffset3D.__CreateInstance(*((global::VkOffset3D.__Internal*)&(((global::VkImageBlit.__Internal*) __Instance)->dstOffsets[i * sizeof(global::VkOffset3D.__Internal)])));
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                if (value.Length != 2)
                    throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                for (int i = 0; i < 2; i++)
                    *(global::VkOffset3D.__Internal*) &((global::VkImageBlit.__Internal*)__Instance)->dstOffsets[i * sizeof(global::VkOffset3D.__Internal)] = *(global::VkOffset3D.__Internal*)value[i].__Instance;
            }
        }
    }
}

public unsafe partial class VkBufferImageCopy : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal ulong bufferOffset;

        [FieldOffset(8)]
        internal uint bufferRowLength;

        [FieldOffset(12)]
        internal uint bufferImageHeight;

        [FieldOffset(16)]
        internal global::VkImageSubresourceLayers.__Internal imageSubresource;

        [FieldOffset(32)]
        internal global::VkOffset3D.__Internal imageOffset;

        [FieldOffset(44)]
        internal global::VkExtent3D.__Internal imageExtent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBufferImageCopy@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferImageCopy> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferImageCopy>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBufferImageCopy __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBufferImageCopy(native.ToPointer(), skipVTables);
    }

    internal static global::VkBufferImageCopy __CreateInstance(global::VkBufferImageCopy.__Internal native, bool skipVTables = false)
    {
        return new global::VkBufferImageCopy(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBufferImageCopy.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBufferImageCopy.__Internal));
        *(global::VkBufferImageCopy.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBufferImageCopy(global::VkBufferImageCopy.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBufferImageCopy(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBufferImageCopy()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferImageCopy.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBufferImageCopy(global::VkBufferImageCopy _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferImageCopy.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBufferImageCopy.__Internal*) __Instance) = *((global::VkBufferImageCopy.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBufferImageCopy __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public ulong BufferOffset
    {
        get
        {
            return ((global::VkBufferImageCopy.__Internal*) __Instance)->bufferOffset;
        }

        set
        {
            ((global::VkBufferImageCopy.__Internal*)__Instance)->bufferOffset = value;
        }
    }

    public uint BufferRowLength
    {
        get
        {
            return ((global::VkBufferImageCopy.__Internal*) __Instance)->bufferRowLength;
        }

        set
        {
            ((global::VkBufferImageCopy.__Internal*)__Instance)->bufferRowLength = value;
        }
    }

    public uint BufferImageHeight
    {
        get
        {
            return ((global::VkBufferImageCopy.__Internal*) __Instance)->bufferImageHeight;
        }

        set
        {
            ((global::VkBufferImageCopy.__Internal*)__Instance)->bufferImageHeight = value;
        }
    }

    public global::VkImageSubresourceLayers ImageSubresource
    {
        get
        {
            return global::VkImageSubresourceLayers.__CreateInstance(new global::System.IntPtr(&((global::VkBufferImageCopy.__Internal*) __Instance)->imageSubresource));
        }

        set
        {
            ((global::VkBufferImageCopy.__Internal*)__Instance)->imageSubresource = ReferenceEquals(value, null) ? new global::VkImageSubresourceLayers.__Internal() : *(global::VkImageSubresourceLayers.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset3D ImageOffset
    {
        get
        {
            return global::VkOffset3D.__CreateInstance(new global::System.IntPtr(&((global::VkBufferImageCopy.__Internal*) __Instance)->imageOffset));
        }

        set
        {
            ((global::VkBufferImageCopy.__Internal*)__Instance)->imageOffset = ReferenceEquals(value, null) ? new global::VkOffset3D.__Internal() : *(global::VkOffset3D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent3D ImageExtent
    {
        get
        {
            return global::VkExtent3D.__CreateInstance(new global::System.IntPtr(&((global::VkBufferImageCopy.__Internal*) __Instance)->imageExtent));
        }

        set
        {
            ((global::VkBufferImageCopy.__Internal*)__Instance)->imageExtent = ReferenceEquals(value, null) ? new global::VkExtent3D.__Internal() : *(global::VkExtent3D.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial struct VkClearColorValue
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal fixed float float32[4];

        [FieldOffset(0)]
        internal fixed int int32[4];

        [FieldOffset(0)]
        internal fixed uint uint32[4];

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkClearColorValue@@QEAA@AEBT0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    private VkClearColorValue.__Internal __instance;
    internal VkClearColorValue.__Internal __Instance { get { return __instance; } }

    internal static global::VkClearColorValue __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkClearColorValue(native.ToPointer(), skipVTables);
    }

    internal static global::VkClearColorValue __CreateInstance(global::VkClearColorValue.__Internal native, bool skipVTables = false)
    {
        return new global::VkClearColorValue(native, skipVTables);
    }

    private VkClearColorValue(global::VkClearColorValue.__Internal native, bool skipVTables = false)
        : this()
    {
        __instance = native;
    }

    private VkClearColorValue(void* native, bool skipVTables = false) : this()
    {
        __instance = *(global::VkClearColorValue.__Internal*) native;
    }

    public VkClearColorValue(global::VkClearColorValue _0)
        : this()
    {
        var ____arg0 = _0.__Instance;
        var __arg0 = new global::System.IntPtr(&____arg0);
        fixed (__Internal* __instancePtr = &__instance)
        {
            __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
        }
    }

    public float[] Float32
    {
        get
        {
            fixed (float* __arrPtr = __instance.float32)
            {
                float[] __value = null;
                if (__arrPtr != null)
                {
                    __value = new float[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = __arrPtr[i];
                }
                return __value;
            }
        }

        set
        {
            fixed (float* __arrPtr = __instance.float32)
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        __arrPtr[i] = value[i];
                }
            }
        }
    }

    public int[] Int32
    {
        get
        {
            fixed (int* __arrPtr = __instance.int32)
            {
                int[] __value = null;
                if (__arrPtr != null)
                {
                    __value = new int[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = __arrPtr[i];
                }
                return __value;
            }
        }

        set
        {
            fixed (int* __arrPtr = __instance.int32)
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        __arrPtr[i] = value[i];
                }
            }
        }
    }

    public uint[] Uint32
    {
        get
        {
            fixed (uint* __arrPtr = __instance.uint32)
            {
                uint[] __value = null;
                if (__arrPtr != null)
                {
                    __value = new uint[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = __arrPtr[i];
                }
                return __value;
            }
        }

        set
        {
            fixed (uint* __arrPtr = __instance.uint32)
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        __arrPtr[i] = value[i];
                }
            }
        }
    }
}

public unsafe partial class VkClearDepthStencilValue : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal float depth;

        [FieldOffset(4)]
        internal uint stencil;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkClearDepthStencilValue@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkClearDepthStencilValue> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkClearDepthStencilValue>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkClearDepthStencilValue __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkClearDepthStencilValue(native.ToPointer(), skipVTables);
    }

    internal static global::VkClearDepthStencilValue __CreateInstance(global::VkClearDepthStencilValue.__Internal native, bool skipVTables = false)
    {
        return new global::VkClearDepthStencilValue(native, skipVTables);
    }

    private static void* __CopyValue(global::VkClearDepthStencilValue.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkClearDepthStencilValue.__Internal));
        *(global::VkClearDepthStencilValue.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkClearDepthStencilValue(global::VkClearDepthStencilValue.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkClearDepthStencilValue(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkClearDepthStencilValue()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkClearDepthStencilValue.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkClearDepthStencilValue(global::VkClearDepthStencilValue _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkClearDepthStencilValue.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkClearDepthStencilValue.__Internal*) __Instance) = *((global::VkClearDepthStencilValue.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkClearDepthStencilValue __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public float Depth
    {
        get
        {
            return ((global::VkClearDepthStencilValue.__Internal*) __Instance)->depth;
        }

        set
        {
            ((global::VkClearDepthStencilValue.__Internal*)__Instance)->depth = value;
        }
    }

    public uint Stencil
    {
        get
        {
            return ((global::VkClearDepthStencilValue.__Internal*) __Instance)->stencil;
        }

        set
        {
            ((global::VkClearDepthStencilValue.__Internal*)__Instance)->stencil = value;
        }
    }
}

public unsafe partial struct VkClearValue
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkClearColorValue.__Internal color;

        [FieldOffset(0)]
        internal global::VkClearDepthStencilValue.__Internal depthStencil;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkClearValue@@QEAA@AEBT0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    private VkClearValue.__Internal __instance;
    internal VkClearValue.__Internal __Instance { get { return __instance; } }

    internal static global::VkClearValue __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkClearValue(native.ToPointer(), skipVTables);
    }

    internal static global::VkClearValue __CreateInstance(global::VkClearValue.__Internal native, bool skipVTables = false)
    {
        return new global::VkClearValue(native, skipVTables);
    }

    private VkClearValue(global::VkClearValue.__Internal native, bool skipVTables = false)
        : this()
    {
        __instance = native;
    }

    private VkClearValue(void* native, bool skipVTables = false) : this()
    {
        __instance = *(global::VkClearValue.__Internal*) native;
    }

    public VkClearValue(global::VkClearValue _0)
        : this()
    {
        var ____arg0 = _0.__Instance;
        var __arg0 = new global::System.IntPtr(&____arg0);
        fixed (__Internal* __instancePtr = &__instance)
        {
            __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
        }
    }

    public global::VkClearColorValue Color;

    public global::VkClearDepthStencilValue DepthStencil
    {
        get
        {
            return global::VkClearDepthStencilValue.__CreateInstance(__instance.depthStencil);
        }

        set
        {
            __instance.depthStencil = ReferenceEquals(value, null) ? new global::VkClearDepthStencilValue.__Internal() : *(global::VkClearDepthStencilValue.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkClearAttachment : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint aspectMask;

        [FieldOffset(4)]
        internal uint colorAttachment;

        [FieldOffset(8)]
        internal global::VkClearValue.__Internal clearValue;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkClearAttachment@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkClearAttachment> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkClearAttachment>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkClearAttachment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkClearAttachment(native.ToPointer(), skipVTables);
    }

    internal static global::VkClearAttachment __CreateInstance(global::VkClearAttachment.__Internal native, bool skipVTables = false)
    {
        return new global::VkClearAttachment(native, skipVTables);
    }

    private static void* __CopyValue(global::VkClearAttachment.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkClearAttachment.__Internal));
        *(global::VkClearAttachment.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkClearAttachment(global::VkClearAttachment.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkClearAttachment(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkClearAttachment()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkClearAttachment.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkClearAttachment(global::VkClearAttachment _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkClearAttachment.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkClearAttachment.__Internal*) __Instance) = *((global::VkClearAttachment.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkClearAttachment __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint AspectMask
    {
        get
        {
            return ((global::VkClearAttachment.__Internal*) __Instance)->aspectMask;
        }

        set
        {
            ((global::VkClearAttachment.__Internal*)__Instance)->aspectMask = value;
        }
    }

    public uint ColorAttachment
    {
        get
        {
            return ((global::VkClearAttachment.__Internal*) __Instance)->colorAttachment;
        }

        set
        {
            ((global::VkClearAttachment.__Internal*)__Instance)->colorAttachment = value;
        }
    }

    public global::VkClearValue ClearValue
    {
        get
        {
            return global::VkClearValue.__CreateInstance(((global::VkClearAttachment.__Internal*) __Instance)->clearValue);
        }

        set
        {
            ((global::VkClearAttachment.__Internal*)__Instance)->clearValue = value.__Instance;
        }
    }
}

public unsafe partial class VkClearRect : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkRect2D.__Internal rect;

        [FieldOffset(16)]
        internal uint baseArrayLayer;

        [FieldOffset(20)]
        internal uint layerCount;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkClearRect@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkClearRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkClearRect>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkClearRect __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkClearRect(native.ToPointer(), skipVTables);
    }

    internal static global::VkClearRect __CreateInstance(global::VkClearRect.__Internal native, bool skipVTables = false)
    {
        return new global::VkClearRect(native, skipVTables);
    }

    private static void* __CopyValue(global::VkClearRect.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkClearRect.__Internal));
        *(global::VkClearRect.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkClearRect(global::VkClearRect.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkClearRect(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkClearRect()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkClearRect.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkClearRect(global::VkClearRect _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkClearRect.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkClearRect.__Internal*) __Instance) = *((global::VkClearRect.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkClearRect __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkRect2D Rect
    {
        get
        {
            return global::VkRect2D.__CreateInstance(new global::System.IntPtr(&((global::VkClearRect.__Internal*) __Instance)->rect));
        }

        set
        {
            ((global::VkClearRect.__Internal*)__Instance)->rect = ReferenceEquals(value, null) ? new global::VkRect2D.__Internal() : *(global::VkRect2D.__Internal*) value.__Instance;
        }
    }

    public uint BaseArrayLayer
    {
        get
        {
            return ((global::VkClearRect.__Internal*) __Instance)->baseArrayLayer;
        }

        set
        {
            ((global::VkClearRect.__Internal*)__Instance)->baseArrayLayer = value;
        }
    }

    public uint LayerCount
    {
        get
        {
            return ((global::VkClearRect.__Internal*) __Instance)->layerCount;
        }

        set
        {
            ((global::VkClearRect.__Internal*)__Instance)->layerCount = value;
        }
    }
}

public unsafe partial class VkImageResolve : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 68)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkImageSubresourceLayers.__Internal srcSubresource;

        [FieldOffset(16)]
        internal global::VkOffset3D.__Internal srcOffset;

        [FieldOffset(28)]
        internal global::VkImageSubresourceLayers.__Internal dstSubresource;

        [FieldOffset(44)]
        internal global::VkOffset3D.__Internal dstOffset;

        [FieldOffset(56)]
        internal global::VkExtent3D.__Internal extent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageResolve@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageResolve> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageResolve>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageResolve __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageResolve(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageResolve __CreateInstance(global::VkImageResolve.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageResolve(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageResolve.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageResolve.__Internal));
        *(global::VkImageResolve.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageResolve(global::VkImageResolve.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageResolve(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageResolve()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageResolve.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageResolve(global::VkImageResolve _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageResolve.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageResolve.__Internal*) __Instance) = *((global::VkImageResolve.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageResolve __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkImageSubresourceLayers SrcSubresource
    {
        get
        {
            return global::VkImageSubresourceLayers.__CreateInstance(new global::System.IntPtr(&((global::VkImageResolve.__Internal*) __Instance)->srcSubresource));
        }

        set
        {
            ((global::VkImageResolve.__Internal*)__Instance)->srcSubresource = ReferenceEquals(value, null) ? new global::VkImageSubresourceLayers.__Internal() : *(global::VkImageSubresourceLayers.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset3D SrcOffset
    {
        get
        {
            return global::VkOffset3D.__CreateInstance(new global::System.IntPtr(&((global::VkImageResolve.__Internal*) __Instance)->srcOffset));
        }

        set
        {
            ((global::VkImageResolve.__Internal*)__Instance)->srcOffset = ReferenceEquals(value, null) ? new global::VkOffset3D.__Internal() : *(global::VkOffset3D.__Internal*) value.__Instance;
        }
    }

    public global::VkImageSubresourceLayers DstSubresource
    {
        get
        {
            return global::VkImageSubresourceLayers.__CreateInstance(new global::System.IntPtr(&((global::VkImageResolve.__Internal*) __Instance)->dstSubresource));
        }

        set
        {
            ((global::VkImageResolve.__Internal*)__Instance)->dstSubresource = ReferenceEquals(value, null) ? new global::VkImageSubresourceLayers.__Internal() : *(global::VkImageSubresourceLayers.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset3D DstOffset
    {
        get
        {
            return global::VkOffset3D.__CreateInstance(new global::System.IntPtr(&((global::VkImageResolve.__Internal*) __Instance)->dstOffset));
        }

        set
        {
            ((global::VkImageResolve.__Internal*)__Instance)->dstOffset = ReferenceEquals(value, null) ? new global::VkOffset3D.__Internal() : *(global::VkOffset3D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent3D Extent
    {
        get
        {
            return global::VkExtent3D.__CreateInstance(new global::System.IntPtr(&((global::VkImageResolve.__Internal*) __Instance)->extent));
        }

        set
        {
            ((global::VkImageResolve.__Internal*)__Instance)->extent = ReferenceEquals(value, null) ? new global::VkExtent3D.__Internal() : *(global::VkExtent3D.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkMemoryBarrier : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint srcAccessMask;

        [FieldOffset(20)]
        internal uint dstAccessMask;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryBarrier@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryBarrier> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryBarrier>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryBarrier __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryBarrier(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryBarrier __CreateInstance(global::VkMemoryBarrier.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryBarrier(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryBarrier.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryBarrier.__Internal));
        *(global::VkMemoryBarrier.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryBarrier(global::VkMemoryBarrier.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryBarrier(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryBarrier()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryBarrier.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryBarrier(global::VkMemoryBarrier _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryBarrier.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryBarrier.__Internal*) __Instance) = *((global::VkMemoryBarrier.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryBarrier __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMemoryBarrier.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMemoryBarrier.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMemoryBarrier.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMemoryBarrier.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SrcAccessMask
    {
        get
        {
            return ((global::VkMemoryBarrier.__Internal*) __Instance)->srcAccessMask;
        }

        set
        {
            ((global::VkMemoryBarrier.__Internal*)__Instance)->srcAccessMask = value;
        }
    }

    public uint DstAccessMask
    {
        get
        {
            return ((global::VkMemoryBarrier.__Internal*) __Instance)->dstAccessMask;
        }

        set
        {
            ((global::VkMemoryBarrier.__Internal*)__Instance)->dstAccessMask = value;
        }
    }
}

public unsafe partial class VkBufferMemoryBarrier : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint srcAccessMask;

        [FieldOffset(20)]
        internal uint dstAccessMask;

        [FieldOffset(24)]
        internal uint srcQueueFamilyIndex;

        [FieldOffset(28)]
        internal uint dstQueueFamilyIndex;

        [FieldOffset(32)]
        internal global::System.IntPtr buffer;

        [FieldOffset(40)]
        internal ulong offset;

        [FieldOffset(48)]
        internal ulong size;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBufferMemoryBarrier@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferMemoryBarrier> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferMemoryBarrier>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBufferMemoryBarrier __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBufferMemoryBarrier(native.ToPointer(), skipVTables);
    }

    internal static global::VkBufferMemoryBarrier __CreateInstance(global::VkBufferMemoryBarrier.__Internal native, bool skipVTables = false)
    {
        return new global::VkBufferMemoryBarrier(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBufferMemoryBarrier.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBufferMemoryBarrier.__Internal));
        *(global::VkBufferMemoryBarrier.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBufferMemoryBarrier(global::VkBufferMemoryBarrier.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBufferMemoryBarrier(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBufferMemoryBarrier()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferMemoryBarrier.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBufferMemoryBarrier(global::VkBufferMemoryBarrier _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferMemoryBarrier.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBufferMemoryBarrier.__Internal*) __Instance) = *((global::VkBufferMemoryBarrier.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBufferMemoryBarrier __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBufferMemoryBarrier.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBufferMemoryBarrier.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBufferMemoryBarrier.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBufferMemoryBarrier.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SrcAccessMask
    {
        get
        {
            return ((global::VkBufferMemoryBarrier.__Internal*) __Instance)->srcAccessMask;
        }

        set
        {
            ((global::VkBufferMemoryBarrier.__Internal*)__Instance)->srcAccessMask = value;
        }
    }

    public uint DstAccessMask
    {
        get
        {
            return ((global::VkBufferMemoryBarrier.__Internal*) __Instance)->dstAccessMask;
        }

        set
        {
            ((global::VkBufferMemoryBarrier.__Internal*)__Instance)->dstAccessMask = value;
        }
    }

    public uint SrcQueueFamilyIndex
    {
        get
        {
            return ((global::VkBufferMemoryBarrier.__Internal*) __Instance)->srcQueueFamilyIndex;
        }

        set
        {
            ((global::VkBufferMemoryBarrier.__Internal*)__Instance)->srcQueueFamilyIndex = value;
        }
    }

    public uint DstQueueFamilyIndex
    {
        get
        {
            return ((global::VkBufferMemoryBarrier.__Internal*) __Instance)->dstQueueFamilyIndex;
        }

        set
        {
            ((global::VkBufferMemoryBarrier.__Internal*)__Instance)->dstQueueFamilyIndex = value;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkBufferMemoryBarrier.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkBufferMemoryBarrier.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkBufferMemoryBarrier.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkBufferMemoryBarrier.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkBufferMemoryBarrier.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong Offset
    {
        get
        {
            return ((global::VkBufferMemoryBarrier.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkBufferMemoryBarrier.__Internal*)__Instance)->offset = value;
        }
    }

    public ulong Size
    {
        get
        {
            return ((global::VkBufferMemoryBarrier.__Internal*) __Instance)->size;
        }

        set
        {
            ((global::VkBufferMemoryBarrier.__Internal*)__Instance)->size = value;
        }
    }
}

public unsafe partial class VkImageMemoryBarrier : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint srcAccessMask;

        [FieldOffset(20)]
        internal uint dstAccessMask;

        [FieldOffset(24)]
        internal global::VkImageLayout oldLayout;

        [FieldOffset(28)]
        internal global::VkImageLayout newLayout;

        [FieldOffset(32)]
        internal uint srcQueueFamilyIndex;

        [FieldOffset(36)]
        internal uint dstQueueFamilyIndex;

        [FieldOffset(40)]
        internal global::System.IntPtr image;

        [FieldOffset(48)]
        internal global::VkImageSubresourceRange.__Internal subresourceRange;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageMemoryBarrier@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageMemoryBarrier> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageMemoryBarrier>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageMemoryBarrier __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageMemoryBarrier(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageMemoryBarrier __CreateInstance(global::VkImageMemoryBarrier.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageMemoryBarrier(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageMemoryBarrier.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageMemoryBarrier.__Internal));
        *(global::VkImageMemoryBarrier.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageMemoryBarrier(global::VkImageMemoryBarrier.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageMemoryBarrier(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageMemoryBarrier()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageMemoryBarrier.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageMemoryBarrier(global::VkImageMemoryBarrier _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageMemoryBarrier.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageMemoryBarrier.__Internal*) __Instance) = *((global::VkImageMemoryBarrier.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageMemoryBarrier __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImageMemoryBarrier.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImageMemoryBarrier.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SrcAccessMask
    {
        get
        {
            return ((global::VkImageMemoryBarrier.__Internal*) __Instance)->srcAccessMask;
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->srcAccessMask = value;
        }
    }

    public uint DstAccessMask
    {
        get
        {
            return ((global::VkImageMemoryBarrier.__Internal*) __Instance)->dstAccessMask;
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->dstAccessMask = value;
        }
    }

    public global::VkImageLayout OldLayout
    {
        get
        {
            return ((global::VkImageMemoryBarrier.__Internal*) __Instance)->oldLayout;
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->oldLayout = value;
        }
    }

    public global::VkImageLayout NewLayout
    {
        get
        {
            return ((global::VkImageMemoryBarrier.__Internal*) __Instance)->newLayout;
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->newLayout = value;
        }
    }

    public uint SrcQueueFamilyIndex
    {
        get
        {
            return ((global::VkImageMemoryBarrier.__Internal*) __Instance)->srcQueueFamilyIndex;
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->srcQueueFamilyIndex = value;
        }
    }

    public uint DstQueueFamilyIndex
    {
        get
        {
            return ((global::VkImageMemoryBarrier.__Internal*) __Instance)->dstQueueFamilyIndex;
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->dstQueueFamilyIndex = value;
        }
    }

    public global::VkImageT Image
    {
        get
        {
            global::VkImageT __result0;
            if (((global::VkImageMemoryBarrier.__Internal*) __Instance)->image == IntPtr.Zero) __result0 = null;
            else if (global::VkImageT.NativeToManagedMap.ContainsKey(((global::VkImageMemoryBarrier.__Internal*) __Instance)->image))
                __result0 = (global::VkImageT) global::VkImageT.NativeToManagedMap[((global::VkImageMemoryBarrier.__Internal*) __Instance)->image];
            else __result0 = global::VkImageT.__CreateInstance(((global::VkImageMemoryBarrier.__Internal*) __Instance)->image);
            return __result0;
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->image = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkImageSubresourceRange SubresourceRange
    {
        get
        {
            return global::VkImageSubresourceRange.__CreateInstance(new global::System.IntPtr(&((global::VkImageMemoryBarrier.__Internal*) __Instance)->subresourceRange));
        }

        set
        {
            ((global::VkImageMemoryBarrier.__Internal*)__Instance)->subresourceRange = ReferenceEquals(value, null) ? new global::VkImageSubresourceRange.__Internal() : *(global::VkImageSubresourceRange.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkRenderPassBeginInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr renderPass;

        [FieldOffset(24)]
        internal global::System.IntPtr framebuffer;

        [FieldOffset(32)]
        internal global::VkRect2D.__Internal renderArea;

        [FieldOffset(48)]
        internal uint clearValueCount;

        [FieldOffset(56)]
        internal global::System.IntPtr pClearValues;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkRenderPassBeginInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassBeginInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassBeginInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRenderPassBeginInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRenderPassBeginInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkRenderPassBeginInfo __CreateInstance(global::VkRenderPassBeginInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkRenderPassBeginInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRenderPassBeginInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRenderPassBeginInfo.__Internal));
        *(global::VkRenderPassBeginInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRenderPassBeginInfo(global::VkRenderPassBeginInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRenderPassBeginInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkRenderPassBeginInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassBeginInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkRenderPassBeginInfo(global::VkRenderPassBeginInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassBeginInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkRenderPassBeginInfo.__Internal*) __Instance) = *((global::VkRenderPassBeginInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkRenderPassBeginInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkRenderPassBeginInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkRenderPassBeginInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkRenderPassBeginInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkRenderPassBeginInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkRenderPassT RenderPass
    {
        get
        {
            global::VkRenderPassT __result0;
            if (((global::VkRenderPassBeginInfo.__Internal*) __Instance)->renderPass == IntPtr.Zero) __result0 = null;
            else if (global::VkRenderPassT.NativeToManagedMap.ContainsKey(((global::VkRenderPassBeginInfo.__Internal*) __Instance)->renderPass))
                __result0 = (global::VkRenderPassT) global::VkRenderPassT.NativeToManagedMap[((global::VkRenderPassBeginInfo.__Internal*) __Instance)->renderPass];
            else __result0 = global::VkRenderPassT.__CreateInstance(((global::VkRenderPassBeginInfo.__Internal*) __Instance)->renderPass);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassBeginInfo.__Internal*)__Instance)->renderPass = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkFramebufferT Framebuffer
    {
        get
        {
            global::VkFramebufferT __result0;
            if (((global::VkRenderPassBeginInfo.__Internal*) __Instance)->framebuffer == IntPtr.Zero) __result0 = null;
            else if (global::VkFramebufferT.NativeToManagedMap.ContainsKey(((global::VkRenderPassBeginInfo.__Internal*) __Instance)->framebuffer))
                __result0 = (global::VkFramebufferT) global::VkFramebufferT.NativeToManagedMap[((global::VkRenderPassBeginInfo.__Internal*) __Instance)->framebuffer];
            else __result0 = global::VkFramebufferT.__CreateInstance(((global::VkRenderPassBeginInfo.__Internal*) __Instance)->framebuffer);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassBeginInfo.__Internal*)__Instance)->framebuffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkRect2D RenderArea
    {
        get
        {
            return global::VkRect2D.__CreateInstance(new global::System.IntPtr(&((global::VkRenderPassBeginInfo.__Internal*) __Instance)->renderArea));
        }

        set
        {
            ((global::VkRenderPassBeginInfo.__Internal*)__Instance)->renderArea = ReferenceEquals(value, null) ? new global::VkRect2D.__Internal() : *(global::VkRect2D.__Internal*) value.__Instance;
        }
    }

    public uint ClearValueCount
    {
        get
        {
            return ((global::VkRenderPassBeginInfo.__Internal*) __Instance)->clearValueCount;
        }

        set
        {
            ((global::VkRenderPassBeginInfo.__Internal*)__Instance)->clearValueCount = value;
        }
    }

    public global::VkClearValue PClearValues
    {
        get
        {
            global::VkClearValue __result0;
            if (((global::VkRenderPassBeginInfo.__Internal*) __Instance)->pClearValues == IntPtr.Zero) __result0 = new global::VkClearValue();
            else __result0 = global::VkClearValue.__CreateInstance(((global::VkRenderPassBeginInfo.__Internal*) __Instance)->pClearValues);
            return __result0;
        }

        set
        {
            var __value = value.__Instance;
            ((global::VkRenderPassBeginInfo.__Internal*)__Instance)->pClearValues = new global::System.IntPtr(&__value);
        }
    }
}

public unsafe partial class VkDispatchIndirectCommand : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint x;

        [FieldOffset(4)]
        internal uint y;

        [FieldOffset(8)]
        internal uint z;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDispatchIndirectCommand@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDispatchIndirectCommand> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDispatchIndirectCommand>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDispatchIndirectCommand __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDispatchIndirectCommand(native.ToPointer(), skipVTables);
    }

    internal static global::VkDispatchIndirectCommand __CreateInstance(global::VkDispatchIndirectCommand.__Internal native, bool skipVTables = false)
    {
        return new global::VkDispatchIndirectCommand(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDispatchIndirectCommand.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDispatchIndirectCommand.__Internal));
        *(global::VkDispatchIndirectCommand.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDispatchIndirectCommand(global::VkDispatchIndirectCommand.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDispatchIndirectCommand(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDispatchIndirectCommand()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDispatchIndirectCommand.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDispatchIndirectCommand(global::VkDispatchIndirectCommand _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDispatchIndirectCommand.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDispatchIndirectCommand.__Internal*) __Instance) = *((global::VkDispatchIndirectCommand.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDispatchIndirectCommand __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint X
    {
        get
        {
            return ((global::VkDispatchIndirectCommand.__Internal*) __Instance)->x;
        }

        set
        {
            ((global::VkDispatchIndirectCommand.__Internal*)__Instance)->x = value;
        }
    }

    public uint Y
    {
        get
        {
            return ((global::VkDispatchIndirectCommand.__Internal*) __Instance)->y;
        }

        set
        {
            ((global::VkDispatchIndirectCommand.__Internal*)__Instance)->y = value;
        }
    }

    public uint Z
    {
        get
        {
            return ((global::VkDispatchIndirectCommand.__Internal*) __Instance)->z;
        }

        set
        {
            ((global::VkDispatchIndirectCommand.__Internal*)__Instance)->z = value;
        }
    }
}

public unsafe partial class VkDrawIndexedIndirectCommand : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint indexCount;

        [FieldOffset(4)]
        internal uint instanceCount;

        [FieldOffset(8)]
        internal uint firstIndex;

        [FieldOffset(12)]
        internal int vertexOffset;

        [FieldOffset(16)]
        internal uint firstInstance;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDrawIndexedIndirectCommand@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDrawIndexedIndirectCommand> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDrawIndexedIndirectCommand>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDrawIndexedIndirectCommand __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDrawIndexedIndirectCommand(native.ToPointer(), skipVTables);
    }

    internal static global::VkDrawIndexedIndirectCommand __CreateInstance(global::VkDrawIndexedIndirectCommand.__Internal native, bool skipVTables = false)
    {
        return new global::VkDrawIndexedIndirectCommand(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDrawIndexedIndirectCommand.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDrawIndexedIndirectCommand.__Internal));
        *(global::VkDrawIndexedIndirectCommand.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDrawIndexedIndirectCommand(global::VkDrawIndexedIndirectCommand.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDrawIndexedIndirectCommand(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDrawIndexedIndirectCommand()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDrawIndexedIndirectCommand.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDrawIndexedIndirectCommand(global::VkDrawIndexedIndirectCommand _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDrawIndexedIndirectCommand.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDrawIndexedIndirectCommand.__Internal*) __Instance) = *((global::VkDrawIndexedIndirectCommand.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDrawIndexedIndirectCommand __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint IndexCount
    {
        get
        {
            return ((global::VkDrawIndexedIndirectCommand.__Internal*) __Instance)->indexCount;
        }

        set
        {
            ((global::VkDrawIndexedIndirectCommand.__Internal*)__Instance)->indexCount = value;
        }
    }

    public uint InstanceCount
    {
        get
        {
            return ((global::VkDrawIndexedIndirectCommand.__Internal*) __Instance)->instanceCount;
        }

        set
        {
            ((global::VkDrawIndexedIndirectCommand.__Internal*)__Instance)->instanceCount = value;
        }
    }

    public uint FirstIndex
    {
        get
        {
            return ((global::VkDrawIndexedIndirectCommand.__Internal*) __Instance)->firstIndex;
        }

        set
        {
            ((global::VkDrawIndexedIndirectCommand.__Internal*)__Instance)->firstIndex = value;
        }
    }

    public int VertexOffset
    {
        get
        {
            return ((global::VkDrawIndexedIndirectCommand.__Internal*) __Instance)->vertexOffset;
        }

        set
        {
            ((global::VkDrawIndexedIndirectCommand.__Internal*)__Instance)->vertexOffset = value;
        }
    }

    public uint FirstInstance
    {
        get
        {
            return ((global::VkDrawIndexedIndirectCommand.__Internal*) __Instance)->firstInstance;
        }

        set
        {
            ((global::VkDrawIndexedIndirectCommand.__Internal*)__Instance)->firstInstance = value;
        }
    }
}

public unsafe partial class VkDrawIndirectCommand : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint vertexCount;

        [FieldOffset(4)]
        internal uint instanceCount;

        [FieldOffset(8)]
        internal uint firstVertex;

        [FieldOffset(12)]
        internal uint firstInstance;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDrawIndirectCommand@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDrawIndirectCommand> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDrawIndirectCommand>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDrawIndirectCommand __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDrawIndirectCommand(native.ToPointer(), skipVTables);
    }

    internal static global::VkDrawIndirectCommand __CreateInstance(global::VkDrawIndirectCommand.__Internal native, bool skipVTables = false)
    {
        return new global::VkDrawIndirectCommand(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDrawIndirectCommand.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDrawIndirectCommand.__Internal));
        *(global::VkDrawIndirectCommand.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDrawIndirectCommand(global::VkDrawIndirectCommand.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDrawIndirectCommand(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDrawIndirectCommand()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDrawIndirectCommand.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDrawIndirectCommand(global::VkDrawIndirectCommand _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDrawIndirectCommand.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDrawIndirectCommand.__Internal*) __Instance) = *((global::VkDrawIndirectCommand.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDrawIndirectCommand __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint VertexCount
    {
        get
        {
            return ((global::VkDrawIndirectCommand.__Internal*) __Instance)->vertexCount;
        }

        set
        {
            ((global::VkDrawIndirectCommand.__Internal*)__Instance)->vertexCount = value;
        }
    }

    public uint InstanceCount
    {
        get
        {
            return ((global::VkDrawIndirectCommand.__Internal*) __Instance)->instanceCount;
        }

        set
        {
            ((global::VkDrawIndirectCommand.__Internal*)__Instance)->instanceCount = value;
        }
    }

    public uint FirstVertex
    {
        get
        {
            return ((global::VkDrawIndirectCommand.__Internal*) __Instance)->firstVertex;
        }

        set
        {
            ((global::VkDrawIndirectCommand.__Internal*)__Instance)->firstVertex = value;
        }
    }

    public uint FirstInstance
    {
        get
        {
            return ((global::VkDrawIndirectCommand.__Internal*) __Instance)->firstInstance;
        }

        set
        {
            ((global::VkDrawIndirectCommand.__Internal*)__Instance)->firstInstance = value;
        }
    }
}

public unsafe partial class VkBaseOutStructure : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBaseOutStructure@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBaseOutStructure> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBaseOutStructure>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBaseOutStructure __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBaseOutStructure(native.ToPointer(), skipVTables);
    }

    internal static global::VkBaseOutStructure __CreateInstance(global::VkBaseOutStructure.__Internal native, bool skipVTables = false)
    {
        return new global::VkBaseOutStructure(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBaseOutStructure.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBaseOutStructure.__Internal));
        *(global::VkBaseOutStructure.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBaseOutStructure(global::VkBaseOutStructure.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBaseOutStructure(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBaseOutStructure()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBaseOutStructure.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBaseOutStructure(global::VkBaseOutStructure _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBaseOutStructure.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBaseOutStructure.__Internal*) __Instance) = *((global::VkBaseOutStructure.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBaseOutStructure __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBaseOutStructure.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBaseOutStructure.__Internal*)__Instance)->sType = value;
        }
    }

    public global::VkBaseOutStructure PNext
    {
        get
        {
            global::VkBaseOutStructure __result0;
            if (((global::VkBaseOutStructure.__Internal*) __Instance)->pNext == IntPtr.Zero) __result0 = null;
            else if (global::VkBaseOutStructure.NativeToManagedMap.ContainsKey(((global::VkBaseOutStructure.__Internal*) __Instance)->pNext))
                __result0 = (global::VkBaseOutStructure) global::VkBaseOutStructure.NativeToManagedMap[((global::VkBaseOutStructure.__Internal*) __Instance)->pNext];
            else __result0 = global::VkBaseOutStructure.__CreateInstance(((global::VkBaseOutStructure.__Internal*) __Instance)->pNext);
            return __result0;
        }

        set
        {
            ((global::VkBaseOutStructure.__Internal*)__Instance)->pNext = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkBaseInStructure : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBaseInStructure@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBaseInStructure> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBaseInStructure>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBaseInStructure __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBaseInStructure(native.ToPointer(), skipVTables);
    }

    internal static global::VkBaseInStructure __CreateInstance(global::VkBaseInStructure.__Internal native, bool skipVTables = false)
    {
        return new global::VkBaseInStructure(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBaseInStructure.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBaseInStructure.__Internal));
        *(global::VkBaseInStructure.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBaseInStructure(global::VkBaseInStructure.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBaseInStructure(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBaseInStructure()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBaseInStructure.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBaseInStructure(global::VkBaseInStructure _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBaseInStructure.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBaseInStructure.__Internal*) __Instance) = *((global::VkBaseInStructure.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBaseInStructure __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBaseInStructure.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBaseInStructure.__Internal*)__Instance)->sType = value;
        }
    }

    public global::VkBaseInStructure PNext
    {
        get
        {
            global::VkBaseInStructure __result0;
            if (((global::VkBaseInStructure.__Internal*) __Instance)->pNext == IntPtr.Zero) __result0 = null;
            else if (global::VkBaseInStructure.NativeToManagedMap.ContainsKey(((global::VkBaseInStructure.__Internal*) __Instance)->pNext))
                __result0 = (global::VkBaseInStructure) global::VkBaseInStructure.NativeToManagedMap[((global::VkBaseInStructure.__Internal*) __Instance)->pNext];
            else __result0 = global::VkBaseInStructure.__CreateInstance(((global::VkBaseInStructure.__Internal*) __Instance)->pNext);
            return __result0;
        }

        set
        {
            ((global::VkBaseInStructure.__Internal*)__Instance)->pNext = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkSamplerYcbcrConversionT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerYcbcrConversionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerYcbcrConversionT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSamplerYcbcrConversionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSamplerYcbcrConversionT(native.ToPointer(), skipVTables);
    }

    internal static global::VkSamplerYcbcrConversionT __CreateInstance(global::VkSamplerYcbcrConversionT.__Internal native, bool skipVTables = false)
    {
        return new global::VkSamplerYcbcrConversionT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSamplerYcbcrConversionT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionT.__Internal));
        *(global::VkSamplerYcbcrConversionT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSamplerYcbcrConversionT(global::VkSamplerYcbcrConversionT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSamplerYcbcrConversionT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDescriptorUpdateTemplateT
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorUpdateTemplateT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorUpdateTemplateT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorUpdateTemplateT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorUpdateTemplateT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorUpdateTemplateT __CreateInstance(global::VkDescriptorUpdateTemplateT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorUpdateTemplateT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorUpdateTemplateT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorUpdateTemplateT.__Internal));
        *(global::VkDescriptorUpdateTemplateT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorUpdateTemplateT(global::VkDescriptorUpdateTemplateT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorUpdateTemplateT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkPhysicalDeviceSubgroupProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint subgroupSize;

        [FieldOffset(20)]
        internal uint supportedStages;

        [FieldOffset(24)]
        internal uint supportedOperations;

        [FieldOffset(28)]
        internal uint quadOperationsInAllStages;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceSubgroupProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSubgroupProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSubgroupProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceSubgroupProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSubgroupProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceSubgroupProperties __CreateInstance(global::VkPhysicalDeviceSubgroupProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSubgroupProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceSubgroupProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSubgroupProperties.__Internal));
        *(global::VkPhysicalDeviceSubgroupProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceSubgroupProperties(global::VkPhysicalDeviceSubgroupProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceSubgroupProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceSubgroupProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSubgroupProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceSubgroupProperties(global::VkPhysicalDeviceSubgroupProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSubgroupProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceSubgroupProperties.__Internal*) __Instance) = *((global::VkPhysicalDeviceSubgroupProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceSubgroupProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceSubgroupProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceSubgroupProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceSubgroupProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceSubgroupProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SubgroupSize
    {
        get
        {
            return ((global::VkPhysicalDeviceSubgroupProperties.__Internal*) __Instance)->subgroupSize;
        }

        set
        {
            ((global::VkPhysicalDeviceSubgroupProperties.__Internal*)__Instance)->subgroupSize = value;
        }
    }

    public uint SupportedStages
    {
        get
        {
            return ((global::VkPhysicalDeviceSubgroupProperties.__Internal*) __Instance)->supportedStages;
        }

        set
        {
            ((global::VkPhysicalDeviceSubgroupProperties.__Internal*)__Instance)->supportedStages = value;
        }
    }

    public uint SupportedOperations
    {
        get
        {
            return ((global::VkPhysicalDeviceSubgroupProperties.__Internal*) __Instance)->supportedOperations;
        }

        set
        {
            ((global::VkPhysicalDeviceSubgroupProperties.__Internal*)__Instance)->supportedOperations = value;
        }
    }

    public uint QuadOperationsInAllStages
    {
        get
        {
            return ((global::VkPhysicalDeviceSubgroupProperties.__Internal*) __Instance)->quadOperationsInAllStages;
        }

        set
        {
            ((global::VkPhysicalDeviceSubgroupProperties.__Internal*)__Instance)->quadOperationsInAllStages = value;
        }
    }
}

public unsafe partial class VkBindBufferMemoryInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr buffer;

        [FieldOffset(24)]
        internal global::System.IntPtr memory;

        [FieldOffset(32)]
        internal ulong memoryOffset;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBindBufferMemoryInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindBufferMemoryInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindBufferMemoryInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBindBufferMemoryInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBindBufferMemoryInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkBindBufferMemoryInfo __CreateInstance(global::VkBindBufferMemoryInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkBindBufferMemoryInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBindBufferMemoryInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBindBufferMemoryInfo.__Internal));
        *(global::VkBindBufferMemoryInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBindBufferMemoryInfo(global::VkBindBufferMemoryInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBindBufferMemoryInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBindBufferMemoryInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindBufferMemoryInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBindBufferMemoryInfo(global::VkBindBufferMemoryInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindBufferMemoryInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBindBufferMemoryInfo.__Internal*) __Instance) = *((global::VkBindBufferMemoryInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBindBufferMemoryInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBindBufferMemoryInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBindBufferMemoryInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkBindBufferMemoryInfo.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkDeviceMemoryT Memory
    {
        get
        {
            global::VkDeviceMemoryT __result0;
            if (((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->memory == IntPtr.Zero) __result0 = null;
            else if (global::VkDeviceMemoryT.NativeToManagedMap.ContainsKey(((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->memory))
                __result0 = (global::VkDeviceMemoryT) global::VkDeviceMemoryT.NativeToManagedMap[((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->memory];
            else __result0 = global::VkDeviceMemoryT.__CreateInstance(((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->memory);
            return __result0;
        }

        set
        {
            ((global::VkBindBufferMemoryInfo.__Internal*)__Instance)->memory = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong MemoryOffset
    {
        get
        {
            return ((global::VkBindBufferMemoryInfo.__Internal*) __Instance)->memoryOffset;
        }

        set
        {
            ((global::VkBindBufferMemoryInfo.__Internal*)__Instance)->memoryOffset = value;
        }
    }
}

public unsafe partial class VkBindImageMemoryInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr image;

        [FieldOffset(24)]
        internal global::System.IntPtr memory;

        [FieldOffset(32)]
        internal ulong memoryOffset;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBindImageMemoryInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindImageMemoryInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindImageMemoryInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBindImageMemoryInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBindImageMemoryInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkBindImageMemoryInfo __CreateInstance(global::VkBindImageMemoryInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkBindImageMemoryInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBindImageMemoryInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBindImageMemoryInfo.__Internal));
        *(global::VkBindImageMemoryInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBindImageMemoryInfo(global::VkBindImageMemoryInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBindImageMemoryInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBindImageMemoryInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindImageMemoryInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBindImageMemoryInfo(global::VkBindImageMemoryInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindImageMemoryInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBindImageMemoryInfo.__Internal*) __Instance) = *((global::VkBindImageMemoryInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBindImageMemoryInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBindImageMemoryInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBindImageMemoryInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBindImageMemoryInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBindImageMemoryInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkImageT Image
    {
        get
        {
            global::VkImageT __result0;
            if (((global::VkBindImageMemoryInfo.__Internal*) __Instance)->image == IntPtr.Zero) __result0 = null;
            else if (global::VkImageT.NativeToManagedMap.ContainsKey(((global::VkBindImageMemoryInfo.__Internal*) __Instance)->image))
                __result0 = (global::VkImageT) global::VkImageT.NativeToManagedMap[((global::VkBindImageMemoryInfo.__Internal*) __Instance)->image];
            else __result0 = global::VkImageT.__CreateInstance(((global::VkBindImageMemoryInfo.__Internal*) __Instance)->image);
            return __result0;
        }

        set
        {
            ((global::VkBindImageMemoryInfo.__Internal*)__Instance)->image = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkDeviceMemoryT Memory
    {
        get
        {
            global::VkDeviceMemoryT __result0;
            if (((global::VkBindImageMemoryInfo.__Internal*) __Instance)->memory == IntPtr.Zero) __result0 = null;
            else if (global::VkDeviceMemoryT.NativeToManagedMap.ContainsKey(((global::VkBindImageMemoryInfo.__Internal*) __Instance)->memory))
                __result0 = (global::VkDeviceMemoryT) global::VkDeviceMemoryT.NativeToManagedMap[((global::VkBindImageMemoryInfo.__Internal*) __Instance)->memory];
            else __result0 = global::VkDeviceMemoryT.__CreateInstance(((global::VkBindImageMemoryInfo.__Internal*) __Instance)->memory);
            return __result0;
        }

        set
        {
            ((global::VkBindImageMemoryInfo.__Internal*)__Instance)->memory = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong MemoryOffset
    {
        get
        {
            return ((global::VkBindImageMemoryInfo.__Internal*) __Instance)->memoryOffset;
        }

        set
        {
            ((global::VkBindImageMemoryInfo.__Internal*)__Instance)->memoryOffset = value;
        }
    }
}

public unsafe partial class VkPhysicalDevice16BitStorageFeatures : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint storageBuffer16BitAccess;

        [FieldOffset(20)]
        internal uint uniformAndStorageBuffer16BitAccess;

        [FieldOffset(24)]
        internal uint storagePushConstant16;

        [FieldOffset(28)]
        internal uint storageInputOutput16;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDevice16BitStorageFeatures@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDevice16BitStorageFeatures> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDevice16BitStorageFeatures>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDevice16BitStorageFeatures __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDevice16BitStorageFeatures(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDevice16BitStorageFeatures __CreateInstance(global::VkPhysicalDevice16BitStorageFeatures.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDevice16BitStorageFeatures(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDevice16BitStorageFeatures.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevice16BitStorageFeatures.__Internal));
        *(global::VkPhysicalDevice16BitStorageFeatures.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDevice16BitStorageFeatures(global::VkPhysicalDevice16BitStorageFeatures.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDevice16BitStorageFeatures(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDevice16BitStorageFeatures()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevice16BitStorageFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDevice16BitStorageFeatures(global::VkPhysicalDevice16BitStorageFeatures _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevice16BitStorageFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDevice16BitStorageFeatures.__Internal*) __Instance) = *((global::VkPhysicalDevice16BitStorageFeatures.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDevice16BitStorageFeatures __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint StorageBuffer16BitAccess
    {
        get
        {
            return ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*) __Instance)->storageBuffer16BitAccess;
        }

        set
        {
            ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*)__Instance)->storageBuffer16BitAccess = value;
        }
    }

    public uint UniformAndStorageBuffer16BitAccess
    {
        get
        {
            return ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*) __Instance)->uniformAndStorageBuffer16BitAccess;
        }

        set
        {
            ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*)__Instance)->uniformAndStorageBuffer16BitAccess = value;
        }
    }

    public uint StoragePushConstant16
    {
        get
        {
            return ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*) __Instance)->storagePushConstant16;
        }

        set
        {
            ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*)__Instance)->storagePushConstant16 = value;
        }
    }

    public uint StorageInputOutput16
    {
        get
        {
            return ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*) __Instance)->storageInputOutput16;
        }

        set
        {
            ((global::VkPhysicalDevice16BitStorageFeatures.__Internal*)__Instance)->storageInputOutput16 = value;
        }
    }
}

public unsafe partial class VkMemoryDedicatedRequirements : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint prefersDedicatedAllocation;

        [FieldOffset(20)]
        internal uint requiresDedicatedAllocation;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryDedicatedRequirements@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryDedicatedRequirements> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryDedicatedRequirements>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryDedicatedRequirements __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryDedicatedRequirements(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryDedicatedRequirements __CreateInstance(global::VkMemoryDedicatedRequirements.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryDedicatedRequirements(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryDedicatedRequirements.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryDedicatedRequirements.__Internal));
        *(global::VkMemoryDedicatedRequirements.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryDedicatedRequirements(global::VkMemoryDedicatedRequirements.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryDedicatedRequirements(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryDedicatedRequirements()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryDedicatedRequirements.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryDedicatedRequirements(global::VkMemoryDedicatedRequirements _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryDedicatedRequirements.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryDedicatedRequirements.__Internal*) __Instance) = *((global::VkMemoryDedicatedRequirements.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryDedicatedRequirements __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMemoryDedicatedRequirements.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMemoryDedicatedRequirements.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMemoryDedicatedRequirements.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMemoryDedicatedRequirements.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint PrefersDedicatedAllocation
    {
        get
        {
            return ((global::VkMemoryDedicatedRequirements.__Internal*) __Instance)->prefersDedicatedAllocation;
        }

        set
        {
            ((global::VkMemoryDedicatedRequirements.__Internal*)__Instance)->prefersDedicatedAllocation = value;
        }
    }

    public uint RequiresDedicatedAllocation
    {
        get
        {
            return ((global::VkMemoryDedicatedRequirements.__Internal*) __Instance)->requiresDedicatedAllocation;
        }

        set
        {
            ((global::VkMemoryDedicatedRequirements.__Internal*)__Instance)->requiresDedicatedAllocation = value;
        }
    }
}

public unsafe partial class VkMemoryDedicatedAllocateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr image;

        [FieldOffset(24)]
        internal global::System.IntPtr buffer;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryDedicatedAllocateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryDedicatedAllocateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryDedicatedAllocateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryDedicatedAllocateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryDedicatedAllocateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryDedicatedAllocateInfo __CreateInstance(global::VkMemoryDedicatedAllocateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryDedicatedAllocateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryDedicatedAllocateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryDedicatedAllocateInfo.__Internal));
        *(global::VkMemoryDedicatedAllocateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryDedicatedAllocateInfo(global::VkMemoryDedicatedAllocateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryDedicatedAllocateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryDedicatedAllocateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryDedicatedAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryDedicatedAllocateInfo(global::VkMemoryDedicatedAllocateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryDedicatedAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance) = *((global::VkMemoryDedicatedAllocateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryDedicatedAllocateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMemoryDedicatedAllocateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMemoryDedicatedAllocateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkImageT Image
    {
        get
        {
            global::VkImageT __result0;
            if (((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->image == IntPtr.Zero) __result0 = null;
            else if (global::VkImageT.NativeToManagedMap.ContainsKey(((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->image))
                __result0 = (global::VkImageT) global::VkImageT.NativeToManagedMap[((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->image];
            else __result0 = global::VkImageT.__CreateInstance(((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->image);
            return __result0;
        }

        set
        {
            ((global::VkMemoryDedicatedAllocateInfo.__Internal*)__Instance)->image = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkMemoryDedicatedAllocateInfo.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkMemoryDedicatedAllocateInfo.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkMemoryAllocateFlagsInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint deviceMask;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryAllocateFlagsInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryAllocateFlagsInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryAllocateFlagsInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryAllocateFlagsInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryAllocateFlagsInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryAllocateFlagsInfo __CreateInstance(global::VkMemoryAllocateFlagsInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryAllocateFlagsInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryAllocateFlagsInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryAllocateFlagsInfo.__Internal));
        *(global::VkMemoryAllocateFlagsInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryAllocateFlagsInfo(global::VkMemoryAllocateFlagsInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryAllocateFlagsInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryAllocateFlagsInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryAllocateFlagsInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryAllocateFlagsInfo(global::VkMemoryAllocateFlagsInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryAllocateFlagsInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryAllocateFlagsInfo.__Internal*) __Instance) = *((global::VkMemoryAllocateFlagsInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryAllocateFlagsInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMemoryAllocateFlagsInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMemoryAllocateFlagsInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMemoryAllocateFlagsInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMemoryAllocateFlagsInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkMemoryAllocateFlagsInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkMemoryAllocateFlagsInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint DeviceMask
    {
        get
        {
            return ((global::VkMemoryAllocateFlagsInfo.__Internal*) __Instance)->deviceMask;
        }

        set
        {
            ((global::VkMemoryAllocateFlagsInfo.__Internal*)__Instance)->deviceMask = value;
        }
    }
}

public unsafe partial class VkDeviceGroupRenderPassBeginInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint deviceMask;

        [FieldOffset(20)]
        internal uint deviceRenderAreaCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pDeviceRenderAreas;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGroupRenderPassBeginInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupRenderPassBeginInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupRenderPassBeginInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGroupRenderPassBeginInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupRenderPassBeginInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGroupRenderPassBeginInfo __CreateInstance(global::VkDeviceGroupRenderPassBeginInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupRenderPassBeginInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGroupRenderPassBeginInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupRenderPassBeginInfo.__Internal));
        *(global::VkDeviceGroupRenderPassBeginInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGroupRenderPassBeginInfo(global::VkDeviceGroupRenderPassBeginInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGroupRenderPassBeginInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGroupRenderPassBeginInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupRenderPassBeginInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGroupRenderPassBeginInfo(global::VkDeviceGroupRenderPassBeginInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupRenderPassBeginInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) __Instance) = *((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGroupRenderPassBeginInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGroupRenderPassBeginInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGroupRenderPassBeginInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint DeviceMask
    {
        get
        {
            return ((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) __Instance)->deviceMask;
        }

        set
        {
            ((global::VkDeviceGroupRenderPassBeginInfo.__Internal*)__Instance)->deviceMask = value;
        }
    }

    public uint DeviceRenderAreaCount
    {
        get
        {
            return ((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) __Instance)->deviceRenderAreaCount;
        }

        set
        {
            ((global::VkDeviceGroupRenderPassBeginInfo.__Internal*)__Instance)->deviceRenderAreaCount = value;
        }
    }

    public global::VkRect2D PDeviceRenderAreas
    {
        get
        {
            global::VkRect2D __result0;
            if (((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) __Instance)->pDeviceRenderAreas == IntPtr.Zero) __result0 = null;
            else if (global::VkRect2D.NativeToManagedMap.ContainsKey(((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) __Instance)->pDeviceRenderAreas))
                __result0 = (global::VkRect2D) global::VkRect2D.NativeToManagedMap[((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) __Instance)->pDeviceRenderAreas];
            else __result0 = global::VkRect2D.__CreateInstance(((global::VkDeviceGroupRenderPassBeginInfo.__Internal*) __Instance)->pDeviceRenderAreas);
            return __result0;
        }

        set
        {
            ((global::VkDeviceGroupRenderPassBeginInfo.__Internal*)__Instance)->pDeviceRenderAreas = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkDeviceGroupCommandBufferBeginInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint deviceMask;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGroupCommandBufferBeginInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupCommandBufferBeginInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupCommandBufferBeginInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGroupCommandBufferBeginInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupCommandBufferBeginInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGroupCommandBufferBeginInfo __CreateInstance(global::VkDeviceGroupCommandBufferBeginInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupCommandBufferBeginInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGroupCommandBufferBeginInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupCommandBufferBeginInfo.__Internal));
        *(global::VkDeviceGroupCommandBufferBeginInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGroupCommandBufferBeginInfo(global::VkDeviceGroupCommandBufferBeginInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGroupCommandBufferBeginInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGroupCommandBufferBeginInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupCommandBufferBeginInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGroupCommandBufferBeginInfo(global::VkDeviceGroupCommandBufferBeginInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupCommandBufferBeginInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGroupCommandBufferBeginInfo.__Internal*) __Instance) = *((global::VkDeviceGroupCommandBufferBeginInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGroupCommandBufferBeginInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGroupCommandBufferBeginInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGroupCommandBufferBeginInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGroupCommandBufferBeginInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGroupCommandBufferBeginInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint DeviceMask
    {
        get
        {
            return ((global::VkDeviceGroupCommandBufferBeginInfo.__Internal*) __Instance)->deviceMask;
        }

        set
        {
            ((global::VkDeviceGroupCommandBufferBeginInfo.__Internal*)__Instance)->deviceMask = value;
        }
    }
}

public unsafe partial class VkDeviceGroupSubmitInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint waitSemaphoreCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pWaitSemaphoreDeviceIndices;

        [FieldOffset(32)]
        internal uint commandBufferCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pCommandBufferDeviceMasks;

        [FieldOffset(48)]
        internal uint signalSemaphoreCount;

        [FieldOffset(56)]
        internal global::System.IntPtr pSignalSemaphoreDeviceIndices;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGroupSubmitInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupSubmitInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupSubmitInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGroupSubmitInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupSubmitInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGroupSubmitInfo __CreateInstance(global::VkDeviceGroupSubmitInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupSubmitInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGroupSubmitInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupSubmitInfo.__Internal));
        *(global::VkDeviceGroupSubmitInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGroupSubmitInfo(global::VkDeviceGroupSubmitInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGroupSubmitInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGroupSubmitInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupSubmitInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGroupSubmitInfo(global::VkDeviceGroupSubmitInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupSubmitInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGroupSubmitInfo.__Internal*) __Instance) = *((global::VkDeviceGroupSubmitInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGroupSubmitInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGroupSubmitInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGroupSubmitInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGroupSubmitInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGroupSubmitInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint WaitSemaphoreCount
    {
        get
        {
            return ((global::VkDeviceGroupSubmitInfo.__Internal*) __Instance)->waitSemaphoreCount;
        }

        set
        {
            ((global::VkDeviceGroupSubmitInfo.__Internal*)__Instance)->waitSemaphoreCount = value;
        }
    }

    public uint* PWaitSemaphoreDeviceIndices
    {
        get
        {
            return (uint*) ((global::VkDeviceGroupSubmitInfo.__Internal*) __Instance)->pWaitSemaphoreDeviceIndices;
        }

        set
        {
            ((global::VkDeviceGroupSubmitInfo.__Internal*)__Instance)->pWaitSemaphoreDeviceIndices = (global::System.IntPtr) value;
        }
    }

    public uint CommandBufferCount
    {
        get
        {
            return ((global::VkDeviceGroupSubmitInfo.__Internal*) __Instance)->commandBufferCount;
        }

        set
        {
            ((global::VkDeviceGroupSubmitInfo.__Internal*)__Instance)->commandBufferCount = value;
        }
    }

    public uint* PCommandBufferDeviceMasks
    {
        get
        {
            return (uint*) ((global::VkDeviceGroupSubmitInfo.__Internal*) __Instance)->pCommandBufferDeviceMasks;
        }

        set
        {
            ((global::VkDeviceGroupSubmitInfo.__Internal*)__Instance)->pCommandBufferDeviceMasks = (global::System.IntPtr) value;
        }
    }

    public uint SignalSemaphoreCount
    {
        get
        {
            return ((global::VkDeviceGroupSubmitInfo.__Internal*) __Instance)->signalSemaphoreCount;
        }

        set
        {
            ((global::VkDeviceGroupSubmitInfo.__Internal*)__Instance)->signalSemaphoreCount = value;
        }
    }

    public uint* PSignalSemaphoreDeviceIndices
    {
        get
        {
            return (uint*) ((global::VkDeviceGroupSubmitInfo.__Internal*) __Instance)->pSignalSemaphoreDeviceIndices;
        }

        set
        {
            ((global::VkDeviceGroupSubmitInfo.__Internal*)__Instance)->pSignalSemaphoreDeviceIndices = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkDeviceGroupBindSparseInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint resourceDeviceIndex;

        [FieldOffset(20)]
        internal uint memoryDeviceIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGroupBindSparseInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupBindSparseInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupBindSparseInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGroupBindSparseInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupBindSparseInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGroupBindSparseInfo __CreateInstance(global::VkDeviceGroupBindSparseInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupBindSparseInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGroupBindSparseInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupBindSparseInfo.__Internal));
        *(global::VkDeviceGroupBindSparseInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGroupBindSparseInfo(global::VkDeviceGroupBindSparseInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGroupBindSparseInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGroupBindSparseInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupBindSparseInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGroupBindSparseInfo(global::VkDeviceGroupBindSparseInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupBindSparseInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGroupBindSparseInfo.__Internal*) __Instance) = *((global::VkDeviceGroupBindSparseInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGroupBindSparseInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGroupBindSparseInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGroupBindSparseInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGroupBindSparseInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGroupBindSparseInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ResourceDeviceIndex
    {
        get
        {
            return ((global::VkDeviceGroupBindSparseInfo.__Internal*) __Instance)->resourceDeviceIndex;
        }

        set
        {
            ((global::VkDeviceGroupBindSparseInfo.__Internal*)__Instance)->resourceDeviceIndex = value;
        }
    }

    public uint MemoryDeviceIndex
    {
        get
        {
            return ((global::VkDeviceGroupBindSparseInfo.__Internal*) __Instance)->memoryDeviceIndex;
        }

        set
        {
            ((global::VkDeviceGroupBindSparseInfo.__Internal*)__Instance)->memoryDeviceIndex = value;
        }
    }
}

public unsafe partial class VkBindBufferMemoryDeviceGroupInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint deviceIndexCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pDeviceIndices;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBindBufferMemoryDeviceGroupInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindBufferMemoryDeviceGroupInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindBufferMemoryDeviceGroupInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBindBufferMemoryDeviceGroupInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBindBufferMemoryDeviceGroupInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkBindBufferMemoryDeviceGroupInfo __CreateInstance(global::VkBindBufferMemoryDeviceGroupInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkBindBufferMemoryDeviceGroupInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBindBufferMemoryDeviceGroupInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBindBufferMemoryDeviceGroupInfo.__Internal));
        *(global::VkBindBufferMemoryDeviceGroupInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBindBufferMemoryDeviceGroupInfo(global::VkBindBufferMemoryDeviceGroupInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBindBufferMemoryDeviceGroupInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBindBufferMemoryDeviceGroupInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindBufferMemoryDeviceGroupInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBindBufferMemoryDeviceGroupInfo(global::VkBindBufferMemoryDeviceGroupInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindBufferMemoryDeviceGroupInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*) __Instance) = *((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBindBufferMemoryDeviceGroupInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint DeviceIndexCount
    {
        get
        {
            return ((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*) __Instance)->deviceIndexCount;
        }

        set
        {
            ((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*)__Instance)->deviceIndexCount = value;
        }
    }

    public uint* PDeviceIndices
    {
        get
        {
            return (uint*) ((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*) __Instance)->pDeviceIndices;
        }

        set
        {
            ((global::VkBindBufferMemoryDeviceGroupInfo.__Internal*)__Instance)->pDeviceIndices = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkBindImageMemoryDeviceGroupInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint deviceIndexCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pDeviceIndices;

        [FieldOffset(32)]
        internal uint splitInstanceBindRegionCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pSplitInstanceBindRegions;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBindImageMemoryDeviceGroupInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindImageMemoryDeviceGroupInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindImageMemoryDeviceGroupInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBindImageMemoryDeviceGroupInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBindImageMemoryDeviceGroupInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkBindImageMemoryDeviceGroupInfo __CreateInstance(global::VkBindImageMemoryDeviceGroupInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkBindImageMemoryDeviceGroupInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBindImageMemoryDeviceGroupInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBindImageMemoryDeviceGroupInfo.__Internal));
        *(global::VkBindImageMemoryDeviceGroupInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBindImageMemoryDeviceGroupInfo(global::VkBindImageMemoryDeviceGroupInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBindImageMemoryDeviceGroupInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBindImageMemoryDeviceGroupInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindImageMemoryDeviceGroupInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBindImageMemoryDeviceGroupInfo(global::VkBindImageMemoryDeviceGroupInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindImageMemoryDeviceGroupInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance) = *((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBindImageMemoryDeviceGroupInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint DeviceIndexCount
    {
        get
        {
            return ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance)->deviceIndexCount;
        }

        set
        {
            ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*)__Instance)->deviceIndexCount = value;
        }
    }

    public uint* PDeviceIndices
    {
        get
        {
            return (uint*) ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance)->pDeviceIndices;
        }

        set
        {
            ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*)__Instance)->pDeviceIndices = (global::System.IntPtr) value;
        }
    }

    public uint SplitInstanceBindRegionCount
    {
        get
        {
            return ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance)->splitInstanceBindRegionCount;
        }

        set
        {
            ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*)__Instance)->splitInstanceBindRegionCount = value;
        }
    }

    public global::VkRect2D PSplitInstanceBindRegions
    {
        get
        {
            global::VkRect2D __result0;
            if (((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance)->pSplitInstanceBindRegions == IntPtr.Zero) __result0 = null;
            else if (global::VkRect2D.NativeToManagedMap.ContainsKey(((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance)->pSplitInstanceBindRegions))
                __result0 = (global::VkRect2D) global::VkRect2D.NativeToManagedMap[((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance)->pSplitInstanceBindRegions];
            else __result0 = global::VkRect2D.__CreateInstance(((global::VkBindImageMemoryDeviceGroupInfo.__Internal*) __Instance)->pSplitInstanceBindRegions);
            return __result0;
        }

        set
        {
            ((global::VkBindImageMemoryDeviceGroupInfo.__Internal*)__Instance)->pSplitInstanceBindRegions = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceGroupProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 288)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint physicalDeviceCount;

        [FieldOffset(24)]
        internal fixed long physicalDevices[32];

        [FieldOffset(280)]
        internal uint subsetAllocation;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceGroupProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceGroupProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceGroupProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceGroupProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceGroupProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceGroupProperties __CreateInstance(global::VkPhysicalDeviceGroupProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceGroupProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceGroupProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceGroupProperties.__Internal));
        *(global::VkPhysicalDeviceGroupProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceGroupProperties(global::VkPhysicalDeviceGroupProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceGroupProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceGroupProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceGroupProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceGroupProperties(global::VkPhysicalDeviceGroupProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceGroupProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceGroupProperties.__Internal*) __Instance) = *((global::VkPhysicalDeviceGroupProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceGroupProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceGroupProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceGroupProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceGroupProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceGroupProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint PhysicalDeviceCount
    {
        get
        {
            return ((global::VkPhysicalDeviceGroupProperties.__Internal*) __Instance)->physicalDeviceCount;
        }

        set
        {
            ((global::VkPhysicalDeviceGroupProperties.__Internal*)__Instance)->physicalDeviceCount = value;
        }
    }

    public global::VkPhysicalDeviceT[] PhysicalDevices
    {
        get
        {
            global::VkPhysicalDeviceT[] __value = null;
            if (((global::VkPhysicalDeviceGroupProperties.__Internal*) __Instance)->physicalDevices != null)
            {
                __value = new global::VkPhysicalDeviceT[32];
                for (int i = 0; i < 32; i++)
                    __value[i] = global::VkPhysicalDeviceT.__CreateInstance((global::System.IntPtr) ((global::VkPhysicalDeviceGroupProperties.__Internal*) __Instance)->physicalDevices[i]);
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                if (value.Length != 32)
                    throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                for (int i = 0; i < 32; i++)
                    ((global::VkPhysicalDeviceGroupProperties.__Internal*)__Instance)->physicalDevices[i] = (long) value[i].__Instance;
            }
        }
    }

    public uint SubsetAllocation
    {
        get
        {
            return ((global::VkPhysicalDeviceGroupProperties.__Internal*) __Instance)->subsetAllocation;
        }

        set
        {
            ((global::VkPhysicalDeviceGroupProperties.__Internal*)__Instance)->subsetAllocation = value;
        }
    }
}

public unsafe partial class VkDeviceGroupDeviceCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint physicalDeviceCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pPhysicalDevices;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGroupDeviceCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupDeviceCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupDeviceCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGroupDeviceCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupDeviceCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGroupDeviceCreateInfo __CreateInstance(global::VkDeviceGroupDeviceCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupDeviceCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGroupDeviceCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupDeviceCreateInfo.__Internal));
        *(global::VkDeviceGroupDeviceCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGroupDeviceCreateInfo(global::VkDeviceGroupDeviceCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGroupDeviceCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGroupDeviceCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupDeviceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGroupDeviceCreateInfo(global::VkDeviceGroupDeviceCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupDeviceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGroupDeviceCreateInfo.__Internal*) __Instance) = *((global::VkDeviceGroupDeviceCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGroupDeviceCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGroupDeviceCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGroupDeviceCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGroupDeviceCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGroupDeviceCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint PhysicalDeviceCount
    {
        get
        {
            return ((global::VkDeviceGroupDeviceCreateInfo.__Internal*) __Instance)->physicalDeviceCount;
        }

        set
        {
            ((global::VkDeviceGroupDeviceCreateInfo.__Internal*)__Instance)->physicalDeviceCount = value;
        }
    }

    public global::VkPhysicalDeviceT PPhysicalDevices
    {
        get
        {
            global::VkPhysicalDeviceT __result0;
            if (((global::VkDeviceGroupDeviceCreateInfo.__Internal*) __Instance)->pPhysicalDevices == IntPtr.Zero) __result0 = null;
            else if (global::VkPhysicalDeviceT.NativeToManagedMap.ContainsKey(((global::VkDeviceGroupDeviceCreateInfo.__Internal*) __Instance)->pPhysicalDevices))
                __result0 = (global::VkPhysicalDeviceT) global::VkPhysicalDeviceT.NativeToManagedMap[((global::VkDeviceGroupDeviceCreateInfo.__Internal*) __Instance)->pPhysicalDevices];
            else __result0 = global::VkPhysicalDeviceT.__CreateInstance(((global::VkDeviceGroupDeviceCreateInfo.__Internal*) __Instance)->pPhysicalDevices);
            return __result0;
        }

        set
        {
            ((global::VkDeviceGroupDeviceCreateInfo.__Internal*)__Instance)->pPhysicalDevices = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkBufferMemoryRequirementsInfo2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr buffer;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBufferMemoryRequirementsInfo2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferMemoryRequirementsInfo2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBufferMemoryRequirementsInfo2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBufferMemoryRequirementsInfo2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBufferMemoryRequirementsInfo2(native.ToPointer(), skipVTables);
    }

    internal static global::VkBufferMemoryRequirementsInfo2 __CreateInstance(global::VkBufferMemoryRequirementsInfo2.__Internal native, bool skipVTables = false)
    {
        return new global::VkBufferMemoryRequirementsInfo2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBufferMemoryRequirementsInfo2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBufferMemoryRequirementsInfo2.__Internal));
        *(global::VkBufferMemoryRequirementsInfo2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBufferMemoryRequirementsInfo2(global::VkBufferMemoryRequirementsInfo2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBufferMemoryRequirementsInfo2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBufferMemoryRequirementsInfo2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferMemoryRequirementsInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBufferMemoryRequirementsInfo2(global::VkBufferMemoryRequirementsInfo2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBufferMemoryRequirementsInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBufferMemoryRequirementsInfo2.__Internal*) __Instance) = *((global::VkBufferMemoryRequirementsInfo2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBufferMemoryRequirementsInfo2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBufferMemoryRequirementsInfo2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBufferMemoryRequirementsInfo2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBufferMemoryRequirementsInfo2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBufferMemoryRequirementsInfo2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkBufferMemoryRequirementsInfo2.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkBufferMemoryRequirementsInfo2.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkBufferMemoryRequirementsInfo2.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkBufferMemoryRequirementsInfo2.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkBufferMemoryRequirementsInfo2.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkImageMemoryRequirementsInfo2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr image;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageMemoryRequirementsInfo2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageMemoryRequirementsInfo2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageMemoryRequirementsInfo2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageMemoryRequirementsInfo2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageMemoryRequirementsInfo2(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageMemoryRequirementsInfo2 __CreateInstance(global::VkImageMemoryRequirementsInfo2.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageMemoryRequirementsInfo2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageMemoryRequirementsInfo2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageMemoryRequirementsInfo2.__Internal));
        *(global::VkImageMemoryRequirementsInfo2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageMemoryRequirementsInfo2(global::VkImageMemoryRequirementsInfo2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageMemoryRequirementsInfo2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageMemoryRequirementsInfo2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageMemoryRequirementsInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageMemoryRequirementsInfo2(global::VkImageMemoryRequirementsInfo2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageMemoryRequirementsInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageMemoryRequirementsInfo2.__Internal*) __Instance) = *((global::VkImageMemoryRequirementsInfo2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageMemoryRequirementsInfo2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImageMemoryRequirementsInfo2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImageMemoryRequirementsInfo2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImageMemoryRequirementsInfo2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImageMemoryRequirementsInfo2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkImageT Image
    {
        get
        {
            global::VkImageT __result0;
            if (((global::VkImageMemoryRequirementsInfo2.__Internal*) __Instance)->image == IntPtr.Zero) __result0 = null;
            else if (global::VkImageT.NativeToManagedMap.ContainsKey(((global::VkImageMemoryRequirementsInfo2.__Internal*) __Instance)->image))
                __result0 = (global::VkImageT) global::VkImageT.NativeToManagedMap[((global::VkImageMemoryRequirementsInfo2.__Internal*) __Instance)->image];
            else __result0 = global::VkImageT.__CreateInstance(((global::VkImageMemoryRequirementsInfo2.__Internal*) __Instance)->image);
            return __result0;
        }

        set
        {
            ((global::VkImageMemoryRequirementsInfo2.__Internal*)__Instance)->image = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkImageSparseMemoryRequirementsInfo2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr image;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageSparseMemoryRequirementsInfo2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSparseMemoryRequirementsInfo2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSparseMemoryRequirementsInfo2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageSparseMemoryRequirementsInfo2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageSparseMemoryRequirementsInfo2(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageSparseMemoryRequirementsInfo2 __CreateInstance(global::VkImageSparseMemoryRequirementsInfo2.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageSparseMemoryRequirementsInfo2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageSparseMemoryRequirementsInfo2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageSparseMemoryRequirementsInfo2.__Internal));
        *(global::VkImageSparseMemoryRequirementsInfo2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageSparseMemoryRequirementsInfo2(global::VkImageSparseMemoryRequirementsInfo2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageSparseMemoryRequirementsInfo2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageSparseMemoryRequirementsInfo2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSparseMemoryRequirementsInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageSparseMemoryRequirementsInfo2(global::VkImageSparseMemoryRequirementsInfo2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSparseMemoryRequirementsInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageSparseMemoryRequirementsInfo2.__Internal*) __Instance) = *((global::VkImageSparseMemoryRequirementsInfo2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageSparseMemoryRequirementsInfo2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImageSparseMemoryRequirementsInfo2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImageSparseMemoryRequirementsInfo2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImageSparseMemoryRequirementsInfo2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImageSparseMemoryRequirementsInfo2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkImageT Image
    {
        get
        {
            global::VkImageT __result0;
            if (((global::VkImageSparseMemoryRequirementsInfo2.__Internal*) __Instance)->image == IntPtr.Zero) __result0 = null;
            else if (global::VkImageT.NativeToManagedMap.ContainsKey(((global::VkImageSparseMemoryRequirementsInfo2.__Internal*) __Instance)->image))
                __result0 = (global::VkImageT) global::VkImageT.NativeToManagedMap[((global::VkImageSparseMemoryRequirementsInfo2.__Internal*) __Instance)->image];
            else __result0 = global::VkImageT.__CreateInstance(((global::VkImageSparseMemoryRequirementsInfo2.__Internal*) __Instance)->image);
            return __result0;
        }

        set
        {
            ((global::VkImageSparseMemoryRequirementsInfo2.__Internal*)__Instance)->image = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkMemoryRequirements2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkMemoryRequirements.__Internal memoryRequirements;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryRequirements2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryRequirements2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryRequirements2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryRequirements2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryRequirements2(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryRequirements2 __CreateInstance(global::VkMemoryRequirements2.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryRequirements2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryRequirements2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryRequirements2.__Internal));
        *(global::VkMemoryRequirements2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryRequirements2(global::VkMemoryRequirements2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryRequirements2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryRequirements2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryRequirements2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryRequirements2(global::VkMemoryRequirements2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryRequirements2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryRequirements2.__Internal*) __Instance) = *((global::VkMemoryRequirements2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryRequirements2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMemoryRequirements2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMemoryRequirements2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMemoryRequirements2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMemoryRequirements2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkMemoryRequirements MemoryRequirements
    {
        get
        {
            return global::VkMemoryRequirements.__CreateInstance(new global::System.IntPtr(&((global::VkMemoryRequirements2.__Internal*) __Instance)->memoryRequirements));
        }

        set
        {
            ((global::VkMemoryRequirements2.__Internal*)__Instance)->memoryRequirements = ReferenceEquals(value, null) ? new global::VkMemoryRequirements.__Internal() : *(global::VkMemoryRequirements.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkSparseImageMemoryRequirements2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkSparseImageMemoryRequirements.__Internal memoryRequirements;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSparseImageMemoryRequirements2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageMemoryRequirements2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageMemoryRequirements2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSparseImageMemoryRequirements2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSparseImageMemoryRequirements2(native.ToPointer(), skipVTables);
    }

    internal static global::VkSparseImageMemoryRequirements2 __CreateInstance(global::VkSparseImageMemoryRequirements2.__Internal native, bool skipVTables = false)
    {
        return new global::VkSparseImageMemoryRequirements2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSparseImageMemoryRequirements2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryRequirements2.__Internal));
        *(global::VkSparseImageMemoryRequirements2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSparseImageMemoryRequirements2(global::VkSparseImageMemoryRequirements2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSparseImageMemoryRequirements2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSparseImageMemoryRequirements2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryRequirements2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSparseImageMemoryRequirements2(global::VkSparseImageMemoryRequirements2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageMemoryRequirements2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSparseImageMemoryRequirements2.__Internal*) __Instance) = *((global::VkSparseImageMemoryRequirements2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSparseImageMemoryRequirements2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSparseImageMemoryRequirements2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSparseImageMemoryRequirements2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSparseImageMemoryRequirements2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSparseImageMemoryRequirements2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSparseImageMemoryRequirements MemoryRequirements
    {
        get
        {
            return global::VkSparseImageMemoryRequirements.__CreateInstance(new global::System.IntPtr(&((global::VkSparseImageMemoryRequirements2.__Internal*) __Instance)->memoryRequirements));
        }

        set
        {
            ((global::VkSparseImageMemoryRequirements2.__Internal*)__Instance)->memoryRequirements = ReferenceEquals(value, null) ? new global::VkSparseImageMemoryRequirements.__Internal() : *(global::VkSparseImageMemoryRequirements.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceFeatures2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 240)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkPhysicalDeviceFeatures.__Internal features;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceFeatures2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceFeatures2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceFeatures2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceFeatures2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceFeatures2(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceFeatures2 __CreateInstance(global::VkPhysicalDeviceFeatures2.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceFeatures2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceFeatures2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceFeatures2.__Internal));
        *(global::VkPhysicalDeviceFeatures2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceFeatures2(global::VkPhysicalDeviceFeatures2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceFeatures2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceFeatures2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceFeatures2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceFeatures2(global::VkPhysicalDeviceFeatures2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceFeatures2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceFeatures2.__Internal*) __Instance) = *((global::VkPhysicalDeviceFeatures2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceFeatures2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceFeatures2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkPhysicalDeviceFeatures Features
    {
        get
        {
            return global::VkPhysicalDeviceFeatures.__CreateInstance(new global::System.IntPtr(&((global::VkPhysicalDeviceFeatures2.__Internal*) __Instance)->features));
        }

        set
        {
            ((global::VkPhysicalDeviceFeatures2.__Internal*)__Instance)->features = ReferenceEquals(value, null) ? new global::VkPhysicalDeviceFeatures.__Internal() : *(global::VkPhysicalDeviceFeatures.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceProperties2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 840)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkPhysicalDeviceProperties.__Internal properties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceProperties2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceProperties2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceProperties2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceProperties2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceProperties2(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceProperties2 __CreateInstance(global::VkPhysicalDeviceProperties2.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceProperties2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceProperties2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProperties2.__Internal));
        *(global::VkPhysicalDeviceProperties2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceProperties2(global::VkPhysicalDeviceProperties2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceProperties2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceProperties2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceProperties2(global::VkPhysicalDeviceProperties2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceProperties2.__Internal*) __Instance) = *((global::VkPhysicalDeviceProperties2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceProperties2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceProperties2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceProperties2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceProperties2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceProperties2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkPhysicalDeviceProperties Properties
    {
        get
        {
            return global::VkPhysicalDeviceProperties.__CreateInstance(new global::System.IntPtr(&((global::VkPhysicalDeviceProperties2.__Internal*) __Instance)->properties));
        }

        set
        {
            ((global::VkPhysicalDeviceProperties2.__Internal*)__Instance)->properties = ReferenceEquals(value, null) ? new global::VkPhysicalDeviceProperties.__Internal() : *(global::VkPhysicalDeviceProperties.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkFormatProperties2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkFormatProperties.__Internal formatProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkFormatProperties2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFormatProperties2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFormatProperties2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkFormatProperties2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkFormatProperties2(native.ToPointer(), skipVTables);
    }

    internal static global::VkFormatProperties2 __CreateInstance(global::VkFormatProperties2.__Internal native, bool skipVTables = false)
    {
        return new global::VkFormatProperties2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkFormatProperties2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkFormatProperties2.__Internal));
        *(global::VkFormatProperties2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkFormatProperties2(global::VkFormatProperties2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkFormatProperties2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkFormatProperties2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFormatProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkFormatProperties2(global::VkFormatProperties2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFormatProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkFormatProperties2.__Internal*) __Instance) = *((global::VkFormatProperties2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkFormatProperties2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkFormatProperties2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkFormatProperties2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkFormatProperties2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkFormatProperties2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkFormatProperties FormatProperties
    {
        get
        {
            return global::VkFormatProperties.__CreateInstance(new global::System.IntPtr(&((global::VkFormatProperties2.__Internal*) __Instance)->formatProperties));
        }

        set
        {
            ((global::VkFormatProperties2.__Internal*)__Instance)->formatProperties = ReferenceEquals(value, null) ? new global::VkFormatProperties.__Internal() : *(global::VkFormatProperties.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkImageFormatProperties2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkImageFormatProperties.__Internal imageFormatProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageFormatProperties2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageFormatProperties2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageFormatProperties2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageFormatProperties2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageFormatProperties2(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageFormatProperties2 __CreateInstance(global::VkImageFormatProperties2.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageFormatProperties2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageFormatProperties2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageFormatProperties2.__Internal));
        *(global::VkImageFormatProperties2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageFormatProperties2(global::VkImageFormatProperties2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageFormatProperties2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageFormatProperties2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageFormatProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageFormatProperties2(global::VkImageFormatProperties2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageFormatProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageFormatProperties2.__Internal*) __Instance) = *((global::VkImageFormatProperties2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageFormatProperties2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImageFormatProperties2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImageFormatProperties2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImageFormatProperties2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImageFormatProperties2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkImageFormatProperties ImageFormatProperties
    {
        get
        {
            return global::VkImageFormatProperties.__CreateInstance(new global::System.IntPtr(&((global::VkImageFormatProperties2.__Internal*) __Instance)->imageFormatProperties));
        }

        set
        {
            ((global::VkImageFormatProperties2.__Internal*)__Instance)->imageFormatProperties = ReferenceEquals(value, null) ? new global::VkImageFormatProperties.__Internal() : *(global::VkImageFormatProperties.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceImageFormatInfo2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkFormat format;

        [FieldOffset(20)]
        internal global::VkImageType type;

        [FieldOffset(24)]
        internal global::VkImageTiling tiling;

        [FieldOffset(28)]
        internal uint usage;

        [FieldOffset(32)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceImageFormatInfo2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceImageFormatInfo2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceImageFormatInfo2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceImageFormatInfo2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceImageFormatInfo2(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceImageFormatInfo2 __CreateInstance(global::VkPhysicalDeviceImageFormatInfo2.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceImageFormatInfo2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceImageFormatInfo2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceImageFormatInfo2.__Internal));
        *(global::VkPhysicalDeviceImageFormatInfo2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceImageFormatInfo2(global::VkPhysicalDeviceImageFormatInfo2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceImageFormatInfo2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceImageFormatInfo2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceImageFormatInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceImageFormatInfo2(global::VkPhysicalDeviceImageFormatInfo2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceImageFormatInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceImageFormatInfo2.__Internal*) __Instance) = *((global::VkPhysicalDeviceImageFormatInfo2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceImageFormatInfo2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*)__Instance)->format = value;
        }
    }

    public global::VkImageType Type
    {
        get
        {
            return ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*) __Instance)->type;
        }

        set
        {
            ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*)__Instance)->type = value;
        }
    }

    public global::VkImageTiling Tiling
    {
        get
        {
            return ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*) __Instance)->tiling;
        }

        set
        {
            ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*)__Instance)->tiling = value;
        }
    }

    public uint Usage
    {
        get
        {
            return ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*) __Instance)->usage;
        }

        set
        {
            ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*)__Instance)->usage = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPhysicalDeviceImageFormatInfo2.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkQueueFamilyProperties2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkQueueFamilyProperties.__Internal queueFamilyProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkQueueFamilyProperties2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueueFamilyProperties2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueueFamilyProperties2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkQueueFamilyProperties2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkQueueFamilyProperties2(native.ToPointer(), skipVTables);
    }

    internal static global::VkQueueFamilyProperties2 __CreateInstance(global::VkQueueFamilyProperties2.__Internal native, bool skipVTables = false)
    {
        return new global::VkQueueFamilyProperties2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkQueueFamilyProperties2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkQueueFamilyProperties2.__Internal));
        *(global::VkQueueFamilyProperties2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkQueueFamilyProperties2(global::VkQueueFamilyProperties2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkQueueFamilyProperties2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkQueueFamilyProperties2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkQueueFamilyProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkQueueFamilyProperties2(global::VkQueueFamilyProperties2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkQueueFamilyProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkQueueFamilyProperties2.__Internal*) __Instance) = *((global::VkQueueFamilyProperties2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkQueueFamilyProperties2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkQueueFamilyProperties2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkQueueFamilyProperties2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkQueueFamilyProperties2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkQueueFamilyProperties2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkQueueFamilyProperties QueueFamilyProperties
    {
        get
        {
            return global::VkQueueFamilyProperties.__CreateInstance(new global::System.IntPtr(&((global::VkQueueFamilyProperties2.__Internal*) __Instance)->queueFamilyProperties));
        }

        set
        {
            ((global::VkQueueFamilyProperties2.__Internal*)__Instance)->queueFamilyProperties = ReferenceEquals(value, null) ? new global::VkQueueFamilyProperties.__Internal() : *(global::VkQueueFamilyProperties.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceMemoryProperties2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 536)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkPhysicalDeviceMemoryProperties.__Internal memoryProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceMemoryProperties2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMemoryProperties2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMemoryProperties2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceMemoryProperties2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMemoryProperties2(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceMemoryProperties2 __CreateInstance(global::VkPhysicalDeviceMemoryProperties2.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMemoryProperties2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceMemoryProperties2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMemoryProperties2.__Internal));
        *(global::VkPhysicalDeviceMemoryProperties2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceMemoryProperties2(global::VkPhysicalDeviceMemoryProperties2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceMemoryProperties2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceMemoryProperties2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMemoryProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceMemoryProperties2(global::VkPhysicalDeviceMemoryProperties2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMemoryProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceMemoryProperties2.__Internal*) __Instance) = *((global::VkPhysicalDeviceMemoryProperties2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceMemoryProperties2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceMemoryProperties2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceMemoryProperties2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceMemoryProperties2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceMemoryProperties2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkPhysicalDeviceMemoryProperties MemoryProperties
    {
        get
        {
            return global::VkPhysicalDeviceMemoryProperties.__CreateInstance(new global::System.IntPtr(&((global::VkPhysicalDeviceMemoryProperties2.__Internal*) __Instance)->memoryProperties));
        }

        set
        {
            ((global::VkPhysicalDeviceMemoryProperties2.__Internal*)__Instance)->memoryProperties = ReferenceEquals(value, null) ? new global::VkPhysicalDeviceMemoryProperties.__Internal() : *(global::VkPhysicalDeviceMemoryProperties.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkSparseImageFormatProperties2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkSparseImageFormatProperties.__Internal properties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSparseImageFormatProperties2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageFormatProperties2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSparseImageFormatProperties2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSparseImageFormatProperties2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSparseImageFormatProperties2(native.ToPointer(), skipVTables);
    }

    internal static global::VkSparseImageFormatProperties2 __CreateInstance(global::VkSparseImageFormatProperties2.__Internal native, bool skipVTables = false)
    {
        return new global::VkSparseImageFormatProperties2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSparseImageFormatProperties2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSparseImageFormatProperties2.__Internal));
        *(global::VkSparseImageFormatProperties2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSparseImageFormatProperties2(global::VkSparseImageFormatProperties2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSparseImageFormatProperties2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSparseImageFormatProperties2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageFormatProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSparseImageFormatProperties2(global::VkSparseImageFormatProperties2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSparseImageFormatProperties2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSparseImageFormatProperties2.__Internal*) __Instance) = *((global::VkSparseImageFormatProperties2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSparseImageFormatProperties2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSparseImageFormatProperties2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSparseImageFormatProperties2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSparseImageFormatProperties2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSparseImageFormatProperties2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSparseImageFormatProperties Properties
    {
        get
        {
            return global::VkSparseImageFormatProperties.__CreateInstance(new global::System.IntPtr(&((global::VkSparseImageFormatProperties2.__Internal*) __Instance)->properties));
        }

        set
        {
            ((global::VkSparseImageFormatProperties2.__Internal*)__Instance)->properties = ReferenceEquals(value, null) ? new global::VkSparseImageFormatProperties.__Internal() : *(global::VkSparseImageFormatProperties.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceSparseImageFormatInfo2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkFormat format;

        [FieldOffset(20)]
        internal global::VkImageType type;

        [FieldOffset(24)]
        internal global::VkSampleCountFlagBits samples;

        [FieldOffset(28)]
        internal uint usage;

        [FieldOffset(32)]
        internal global::VkImageTiling tiling;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceSparseImageFormatInfo2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSparseImageFormatInfo2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSparseImageFormatInfo2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceSparseImageFormatInfo2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSparseImageFormatInfo2(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceSparseImageFormatInfo2 __CreateInstance(global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSparseImageFormatInfo2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal));
        *(global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceSparseImageFormatInfo2(global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceSparseImageFormatInfo2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceSparseImageFormatInfo2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceSparseImageFormatInfo2(global::VkPhysicalDeviceSparseImageFormatInfo2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) __Instance) = *((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceSparseImageFormatInfo2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*)__Instance)->format = value;
        }
    }

    public global::VkImageType Type
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) __Instance)->type;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*)__Instance)->type = value;
        }
    }

    public global::VkSampleCountFlagBits Samples
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) __Instance)->samples;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*)__Instance)->samples = value;
        }
    }

    public uint Usage
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) __Instance)->usage;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*)__Instance)->usage = value;
        }
    }

    public global::VkImageTiling Tiling
    {
        get
        {
            return ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*) __Instance)->tiling;
        }

        set
        {
            ((global::VkPhysicalDeviceSparseImageFormatInfo2.__Internal*)__Instance)->tiling = value;
        }
    }
}

public unsafe partial class VkPhysicalDevicePointClippingProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkPointClippingBehavior pointClippingBehavior;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDevicePointClippingProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDevicePointClippingProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDevicePointClippingProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDevicePointClippingProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDevicePointClippingProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDevicePointClippingProperties __CreateInstance(global::VkPhysicalDevicePointClippingProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDevicePointClippingProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDevicePointClippingProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevicePointClippingProperties.__Internal));
        *(global::VkPhysicalDevicePointClippingProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDevicePointClippingProperties(global::VkPhysicalDevicePointClippingProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDevicePointClippingProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDevicePointClippingProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevicePointClippingProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDevicePointClippingProperties(global::VkPhysicalDevicePointClippingProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevicePointClippingProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDevicePointClippingProperties.__Internal*) __Instance) = *((global::VkPhysicalDevicePointClippingProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDevicePointClippingProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDevicePointClippingProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDevicePointClippingProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDevicePointClippingProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDevicePointClippingProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkPointClippingBehavior PointClippingBehavior
    {
        get
        {
            return ((global::VkPhysicalDevicePointClippingProperties.__Internal*) __Instance)->pointClippingBehavior;
        }

        set
        {
            ((global::VkPhysicalDevicePointClippingProperties.__Internal*)__Instance)->pointClippingBehavior = value;
        }
    }
}

public unsafe partial class VkInputAttachmentAspectReference : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint subpass;

        [FieldOffset(4)]
        internal uint inputAttachmentIndex;

        [FieldOffset(8)]
        internal uint aspectMask;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkInputAttachmentAspectReference@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkInputAttachmentAspectReference> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkInputAttachmentAspectReference>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkInputAttachmentAspectReference __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkInputAttachmentAspectReference(native.ToPointer(), skipVTables);
    }

    internal static global::VkInputAttachmentAspectReference __CreateInstance(global::VkInputAttachmentAspectReference.__Internal native, bool skipVTables = false)
    {
        return new global::VkInputAttachmentAspectReference(native, skipVTables);
    }

    private static void* __CopyValue(global::VkInputAttachmentAspectReference.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkInputAttachmentAspectReference.__Internal));
        *(global::VkInputAttachmentAspectReference.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkInputAttachmentAspectReference(global::VkInputAttachmentAspectReference.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkInputAttachmentAspectReference(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkInputAttachmentAspectReference()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkInputAttachmentAspectReference.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkInputAttachmentAspectReference(global::VkInputAttachmentAspectReference _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkInputAttachmentAspectReference.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkInputAttachmentAspectReference.__Internal*) __Instance) = *((global::VkInputAttachmentAspectReference.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkInputAttachmentAspectReference __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Subpass
    {
        get
        {
            return ((global::VkInputAttachmentAspectReference.__Internal*) __Instance)->subpass;
        }

        set
        {
            ((global::VkInputAttachmentAspectReference.__Internal*)__Instance)->subpass = value;
        }
    }

    public uint InputAttachmentIndex
    {
        get
        {
            return ((global::VkInputAttachmentAspectReference.__Internal*) __Instance)->inputAttachmentIndex;
        }

        set
        {
            ((global::VkInputAttachmentAspectReference.__Internal*)__Instance)->inputAttachmentIndex = value;
        }
    }

    public uint AspectMask
    {
        get
        {
            return ((global::VkInputAttachmentAspectReference.__Internal*) __Instance)->aspectMask;
        }

        set
        {
            ((global::VkInputAttachmentAspectReference.__Internal*)__Instance)->aspectMask = value;
        }
    }
}

public unsafe partial class VkRenderPassInputAttachmentAspectCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint aspectReferenceCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pAspectReferences;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkRenderPassInputAttachmentAspectCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassInputAttachmentAspectCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassInputAttachmentAspectCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRenderPassInputAttachmentAspectCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRenderPassInputAttachmentAspectCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkRenderPassInputAttachmentAspectCreateInfo __CreateInstance(global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkRenderPassInputAttachmentAspectCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal));
        *(global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRenderPassInputAttachmentAspectCreateInfo(global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRenderPassInputAttachmentAspectCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkRenderPassInputAttachmentAspectCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkRenderPassInputAttachmentAspectCreateInfo(global::VkRenderPassInputAttachmentAspectCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) __Instance) = *((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkRenderPassInputAttachmentAspectCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint AspectReferenceCount
    {
        get
        {
            return ((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) __Instance)->aspectReferenceCount;
        }

        set
        {
            ((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*)__Instance)->aspectReferenceCount = value;
        }
    }

    public global::VkInputAttachmentAspectReference PAspectReferences
    {
        get
        {
            global::VkInputAttachmentAspectReference __result0;
            if (((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) __Instance)->pAspectReferences == IntPtr.Zero) __result0 = null;
            else if (global::VkInputAttachmentAspectReference.NativeToManagedMap.ContainsKey(((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) __Instance)->pAspectReferences))
                __result0 = (global::VkInputAttachmentAspectReference) global::VkInputAttachmentAspectReference.NativeToManagedMap[((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) __Instance)->pAspectReferences];
            else __result0 = global::VkInputAttachmentAspectReference.__CreateInstance(((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*) __Instance)->pAspectReferences);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassInputAttachmentAspectCreateInfo.__Internal*)__Instance)->pAspectReferences = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkImageViewUsageCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint usage;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageViewUsageCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageViewUsageCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageViewUsageCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageViewUsageCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageViewUsageCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageViewUsageCreateInfo __CreateInstance(global::VkImageViewUsageCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageViewUsageCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageViewUsageCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageViewUsageCreateInfo.__Internal));
        *(global::VkImageViewUsageCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageViewUsageCreateInfo(global::VkImageViewUsageCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageViewUsageCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageViewUsageCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageViewUsageCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageViewUsageCreateInfo(global::VkImageViewUsageCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageViewUsageCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageViewUsageCreateInfo.__Internal*) __Instance) = *((global::VkImageViewUsageCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageViewUsageCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImageViewUsageCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImageViewUsageCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImageViewUsageCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImageViewUsageCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Usage
    {
        get
        {
            return ((global::VkImageViewUsageCreateInfo.__Internal*) __Instance)->usage;
        }

        set
        {
            ((global::VkImageViewUsageCreateInfo.__Internal*)__Instance)->usage = value;
        }
    }
}

public unsafe partial class VkPipelineTessellationDomainOriginStateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkTessellationDomainOrigin domainOrigin;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineTessellationDomainOriginStateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineTessellationDomainOriginStateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineTessellationDomainOriginStateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineTessellationDomainOriginStateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineTessellationDomainOriginStateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineTessellationDomainOriginStateCreateInfo __CreateInstance(global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineTessellationDomainOriginStateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal));
        *(global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineTessellationDomainOriginStateCreateInfo(global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineTessellationDomainOriginStateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineTessellationDomainOriginStateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineTessellationDomainOriginStateCreateInfo(global::VkPipelineTessellationDomainOriginStateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal*) __Instance) = *((global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineTessellationDomainOriginStateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkTessellationDomainOrigin DomainOrigin
    {
        get
        {
            return ((global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal*) __Instance)->domainOrigin;
        }

        set
        {
            ((global::VkPipelineTessellationDomainOriginStateCreateInfo.__Internal*)__Instance)->domainOrigin = value;
        }
    }
}

public unsafe partial class VkRenderPassMultiviewCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint subpassCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pViewMasks;

        [FieldOffset(32)]
        internal uint dependencyCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pViewOffsets;

        [FieldOffset(48)]
        internal uint correlationMaskCount;

        [FieldOffset(56)]
        internal global::System.IntPtr pCorrelationMasks;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkRenderPassMultiviewCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassMultiviewCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassMultiviewCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRenderPassMultiviewCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRenderPassMultiviewCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkRenderPassMultiviewCreateInfo __CreateInstance(global::VkRenderPassMultiviewCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkRenderPassMultiviewCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRenderPassMultiviewCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRenderPassMultiviewCreateInfo.__Internal));
        *(global::VkRenderPassMultiviewCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRenderPassMultiviewCreateInfo(global::VkRenderPassMultiviewCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRenderPassMultiviewCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkRenderPassMultiviewCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassMultiviewCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkRenderPassMultiviewCreateInfo(global::VkRenderPassMultiviewCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassMultiviewCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkRenderPassMultiviewCreateInfo.__Internal*) __Instance) = *((global::VkRenderPassMultiviewCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkRenderPassMultiviewCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkRenderPassMultiviewCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkRenderPassMultiviewCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkRenderPassMultiviewCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkRenderPassMultiviewCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SubpassCount
    {
        get
        {
            return ((global::VkRenderPassMultiviewCreateInfo.__Internal*) __Instance)->subpassCount;
        }

        set
        {
            ((global::VkRenderPassMultiviewCreateInfo.__Internal*)__Instance)->subpassCount = value;
        }
    }

    public uint* PViewMasks
    {
        get
        {
            return (uint*) ((global::VkRenderPassMultiviewCreateInfo.__Internal*) __Instance)->pViewMasks;
        }

        set
        {
            ((global::VkRenderPassMultiviewCreateInfo.__Internal*)__Instance)->pViewMasks = (global::System.IntPtr) value;
        }
    }

    public uint DependencyCount
    {
        get
        {
            return ((global::VkRenderPassMultiviewCreateInfo.__Internal*) __Instance)->dependencyCount;
        }

        set
        {
            ((global::VkRenderPassMultiviewCreateInfo.__Internal*)__Instance)->dependencyCount = value;
        }
    }

    public int* PViewOffsets
    {
        get
        {
            return (int*) ((global::VkRenderPassMultiviewCreateInfo.__Internal*) __Instance)->pViewOffsets;
        }

        set
        {
            ((global::VkRenderPassMultiviewCreateInfo.__Internal*)__Instance)->pViewOffsets = (global::System.IntPtr) value;
        }
    }

    public uint CorrelationMaskCount
    {
        get
        {
            return ((global::VkRenderPassMultiviewCreateInfo.__Internal*) __Instance)->correlationMaskCount;
        }

        set
        {
            ((global::VkRenderPassMultiviewCreateInfo.__Internal*)__Instance)->correlationMaskCount = value;
        }
    }

    public uint* PCorrelationMasks
    {
        get
        {
            return (uint*) ((global::VkRenderPassMultiviewCreateInfo.__Internal*) __Instance)->pCorrelationMasks;
        }

        set
        {
            ((global::VkRenderPassMultiviewCreateInfo.__Internal*)__Instance)->pCorrelationMasks = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceMultiviewFeatures : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint multiview;

        [FieldOffset(20)]
        internal uint multiviewGeometryShader;

        [FieldOffset(24)]
        internal uint multiviewTessellationShader;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceMultiviewFeatures@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMultiviewFeatures> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMultiviewFeatures>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceMultiviewFeatures __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMultiviewFeatures(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceMultiviewFeatures __CreateInstance(global::VkPhysicalDeviceMultiviewFeatures.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMultiviewFeatures(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceMultiviewFeatures.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMultiviewFeatures.__Internal));
        *(global::VkPhysicalDeviceMultiviewFeatures.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceMultiviewFeatures(global::VkPhysicalDeviceMultiviewFeatures.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceMultiviewFeatures(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceMultiviewFeatures()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMultiviewFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceMultiviewFeatures(global::VkPhysicalDeviceMultiviewFeatures _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMultiviewFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceMultiviewFeatures.__Internal*) __Instance) = *((global::VkPhysicalDeviceMultiviewFeatures.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceMultiviewFeatures __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Multiview
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*) __Instance)->multiview;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*)__Instance)->multiview = value;
        }
    }

    public uint MultiviewGeometryShader
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*) __Instance)->multiviewGeometryShader;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*)__Instance)->multiviewGeometryShader = value;
        }
    }

    public uint MultiviewTessellationShader
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*) __Instance)->multiviewTessellationShader;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewFeatures.__Internal*)__Instance)->multiviewTessellationShader = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceMultiviewProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint maxMultiviewViewCount;

        [FieldOffset(20)]
        internal uint maxMultiviewInstanceIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceMultiviewProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMultiviewProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMultiviewProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceMultiviewProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMultiviewProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceMultiviewProperties __CreateInstance(global::VkPhysicalDeviceMultiviewProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMultiviewProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceMultiviewProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMultiviewProperties.__Internal));
        *(global::VkPhysicalDeviceMultiviewProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceMultiviewProperties(global::VkPhysicalDeviceMultiviewProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceMultiviewProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceMultiviewProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMultiviewProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceMultiviewProperties(global::VkPhysicalDeviceMultiviewProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMultiviewProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceMultiviewProperties.__Internal*) __Instance) = *((global::VkPhysicalDeviceMultiviewProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceMultiviewProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MaxMultiviewViewCount
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewProperties.__Internal*) __Instance)->maxMultiviewViewCount;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewProperties.__Internal*)__Instance)->maxMultiviewViewCount = value;
        }
    }

    public uint MaxMultiviewInstanceIndex
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewProperties.__Internal*) __Instance)->maxMultiviewInstanceIndex;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewProperties.__Internal*)__Instance)->maxMultiviewInstanceIndex = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceVariablePointerFeatures : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint variablePointersStorageBuffer;

        [FieldOffset(20)]
        internal uint variablePointers;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceVariablePointerFeatures@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceVariablePointerFeatures> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceVariablePointerFeatures>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceVariablePointerFeatures __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceVariablePointerFeatures(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceVariablePointerFeatures __CreateInstance(global::VkPhysicalDeviceVariablePointerFeatures.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceVariablePointerFeatures(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceVariablePointerFeatures.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceVariablePointerFeatures.__Internal));
        *(global::VkPhysicalDeviceVariablePointerFeatures.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceVariablePointerFeatures(global::VkPhysicalDeviceVariablePointerFeatures.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceVariablePointerFeatures(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceVariablePointerFeatures()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceVariablePointerFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceVariablePointerFeatures(global::VkPhysicalDeviceVariablePointerFeatures _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceVariablePointerFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*) __Instance) = *((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceVariablePointerFeatures __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint VariablePointersStorageBuffer
    {
        get
        {
            return ((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*) __Instance)->variablePointersStorageBuffer;
        }

        set
        {
            ((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*)__Instance)->variablePointersStorageBuffer = value;
        }
    }

    public uint VariablePointers
    {
        get
        {
            return ((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*) __Instance)->variablePointers;
        }

        set
        {
            ((global::VkPhysicalDeviceVariablePointerFeatures.__Internal*)__Instance)->variablePointers = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceProtectedMemoryFeatures : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint protectedMemory;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceProtectedMemoryFeatures@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceProtectedMemoryFeatures> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceProtectedMemoryFeatures>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceProtectedMemoryFeatures __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceProtectedMemoryFeatures(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceProtectedMemoryFeatures __CreateInstance(global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceProtectedMemoryFeatures(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal));
        *(global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceProtectedMemoryFeatures(global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceProtectedMemoryFeatures(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceProtectedMemoryFeatures()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceProtectedMemoryFeatures(global::VkPhysicalDeviceProtectedMemoryFeatures _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal*) __Instance) = *((global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceProtectedMemoryFeatures __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ProtectedMemory
    {
        get
        {
            return ((global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal*) __Instance)->protectedMemory;
        }

        set
        {
            ((global::VkPhysicalDeviceProtectedMemoryFeatures.__Internal*)__Instance)->protectedMemory = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceProtectedMemoryProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint protectedNoFault;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceProtectedMemoryProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceProtectedMemoryProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceProtectedMemoryProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceProtectedMemoryProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceProtectedMemoryProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceProtectedMemoryProperties __CreateInstance(global::VkPhysicalDeviceProtectedMemoryProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceProtectedMemoryProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceProtectedMemoryProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProtectedMemoryProperties.__Internal));
        *(global::VkPhysicalDeviceProtectedMemoryProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceProtectedMemoryProperties(global::VkPhysicalDeviceProtectedMemoryProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceProtectedMemoryProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceProtectedMemoryProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProtectedMemoryProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceProtectedMemoryProperties(global::VkPhysicalDeviceProtectedMemoryProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceProtectedMemoryProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceProtectedMemoryProperties.__Internal*) __Instance) = *((global::VkPhysicalDeviceProtectedMemoryProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceProtectedMemoryProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceProtectedMemoryProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceProtectedMemoryProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceProtectedMemoryProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceProtectedMemoryProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ProtectedNoFault
    {
        get
        {
            return ((global::VkPhysicalDeviceProtectedMemoryProperties.__Internal*) __Instance)->protectedNoFault;
        }

        set
        {
            ((global::VkPhysicalDeviceProtectedMemoryProperties.__Internal*)__Instance)->protectedNoFault = value;
        }
    }
}

public unsafe partial class VkDeviceQueueInfo2 : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint queueFamilyIndex;

        [FieldOffset(24)]
        internal uint queueIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceQueueInfo2@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceQueueInfo2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceQueueInfo2>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceQueueInfo2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceQueueInfo2(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceQueueInfo2 __CreateInstance(global::VkDeviceQueueInfo2.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceQueueInfo2(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceQueueInfo2.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceQueueInfo2.__Internal));
        *(global::VkDeviceQueueInfo2.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceQueueInfo2(global::VkDeviceQueueInfo2.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceQueueInfo2(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceQueueInfo2()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceQueueInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceQueueInfo2(global::VkDeviceQueueInfo2 _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceQueueInfo2.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceQueueInfo2.__Internal*) __Instance) = *((global::VkDeviceQueueInfo2.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceQueueInfo2 __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceQueueInfo2.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceQueueInfo2.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceQueueInfo2.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceQueueInfo2.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDeviceQueueInfo2.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDeviceQueueInfo2.__Internal*)__Instance)->flags = value;
        }
    }

    public uint QueueFamilyIndex
    {
        get
        {
            return ((global::VkDeviceQueueInfo2.__Internal*) __Instance)->queueFamilyIndex;
        }

        set
        {
            ((global::VkDeviceQueueInfo2.__Internal*)__Instance)->queueFamilyIndex = value;
        }
    }

    public uint QueueIndex
    {
        get
        {
            return ((global::VkDeviceQueueInfo2.__Internal*) __Instance)->queueIndex;
        }

        set
        {
            ((global::VkDeviceQueueInfo2.__Internal*)__Instance)->queueIndex = value;
        }
    }
}

public unsafe partial class VkProtectedSubmitInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint protectedSubmit;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkProtectedSubmitInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkProtectedSubmitInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkProtectedSubmitInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkProtectedSubmitInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkProtectedSubmitInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkProtectedSubmitInfo __CreateInstance(global::VkProtectedSubmitInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkProtectedSubmitInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkProtectedSubmitInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkProtectedSubmitInfo.__Internal));
        *(global::VkProtectedSubmitInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkProtectedSubmitInfo(global::VkProtectedSubmitInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkProtectedSubmitInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkProtectedSubmitInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkProtectedSubmitInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkProtectedSubmitInfo(global::VkProtectedSubmitInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkProtectedSubmitInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkProtectedSubmitInfo.__Internal*) __Instance) = *((global::VkProtectedSubmitInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkProtectedSubmitInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkProtectedSubmitInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkProtectedSubmitInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkProtectedSubmitInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkProtectedSubmitInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ProtectedSubmit
    {
        get
        {
            return ((global::VkProtectedSubmitInfo.__Internal*) __Instance)->protectedSubmit;
        }

        set
        {
            ((global::VkProtectedSubmitInfo.__Internal*)__Instance)->protectedSubmit = value;
        }
    }
}

public unsafe partial class VkSamplerYcbcrConversionCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkFormat format;

        [FieldOffset(20)]
        internal global::VkSamplerYcbcrModelConversion ycbcrModel;

        [FieldOffset(24)]
        internal global::VkSamplerYcbcrRange ycbcrRange;

        [FieldOffset(28)]
        internal global::VkComponentMapping.__Internal components;

        [FieldOffset(44)]
        internal global::VkChromaLocation xChromaOffset;

        [FieldOffset(48)]
        internal global::VkChromaLocation yChromaOffset;

        [FieldOffset(52)]
        internal global::VkFilter chromaFilter;

        [FieldOffset(56)]
        internal uint forceExplicitReconstruction;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSamplerYcbcrConversionCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerYcbcrConversionCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerYcbcrConversionCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSamplerYcbcrConversionCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSamplerYcbcrConversionCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkSamplerYcbcrConversionCreateInfo __CreateInstance(global::VkSamplerYcbcrConversionCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkSamplerYcbcrConversionCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSamplerYcbcrConversionCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionCreateInfo.__Internal));
        *(global::VkSamplerYcbcrConversionCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSamplerYcbcrConversionCreateInfo(global::VkSamplerYcbcrConversionCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSamplerYcbcrConversionCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSamplerYcbcrConversionCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSamplerYcbcrConversionCreateInfo(global::VkSamplerYcbcrConversionCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance) = *((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSamplerYcbcrConversionCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->format = value;
        }
    }

    public global::VkSamplerYcbcrModelConversion YcbcrModel
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->ycbcrModel;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->ycbcrModel = value;
        }
    }

    public global::VkSamplerYcbcrRange YcbcrRange
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->ycbcrRange;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->ycbcrRange = value;
        }
    }

    public global::VkComponentMapping Components
    {
        get
        {
            return global::VkComponentMapping.__CreateInstance(new global::System.IntPtr(&((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->components));
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->components = ReferenceEquals(value, null) ? new global::VkComponentMapping.__Internal() : *(global::VkComponentMapping.__Internal*) value.__Instance;
        }
    }

    public global::VkChromaLocation XChromaOffset
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->xChromaOffset;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->xChromaOffset = value;
        }
    }

    public global::VkChromaLocation YChromaOffset
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->yChromaOffset;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->yChromaOffset = value;
        }
    }

    public global::VkFilter ChromaFilter
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->chromaFilter;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->chromaFilter = value;
        }
    }

    public uint ForceExplicitReconstruction
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*) __Instance)->forceExplicitReconstruction;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionCreateInfo.__Internal*)__Instance)->forceExplicitReconstruction = value;
        }
    }
}

public unsafe partial class VkSamplerYcbcrConversionInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr conversion;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSamplerYcbcrConversionInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerYcbcrConversionInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerYcbcrConversionInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSamplerYcbcrConversionInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSamplerYcbcrConversionInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkSamplerYcbcrConversionInfo __CreateInstance(global::VkSamplerYcbcrConversionInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkSamplerYcbcrConversionInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSamplerYcbcrConversionInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionInfo.__Internal));
        *(global::VkSamplerYcbcrConversionInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSamplerYcbcrConversionInfo(global::VkSamplerYcbcrConversionInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSamplerYcbcrConversionInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSamplerYcbcrConversionInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSamplerYcbcrConversionInfo(global::VkSamplerYcbcrConversionInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSamplerYcbcrConversionInfo.__Internal*) __Instance) = *((global::VkSamplerYcbcrConversionInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSamplerYcbcrConversionInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSamplerYcbcrConversionT Conversion
    {
        get
        {
            global::VkSamplerYcbcrConversionT __result0;
            if (((global::VkSamplerYcbcrConversionInfo.__Internal*) __Instance)->conversion == IntPtr.Zero) __result0 = null;
            else if (global::VkSamplerYcbcrConversionT.NativeToManagedMap.ContainsKey(((global::VkSamplerYcbcrConversionInfo.__Internal*) __Instance)->conversion))
                __result0 = (global::VkSamplerYcbcrConversionT) global::VkSamplerYcbcrConversionT.NativeToManagedMap[((global::VkSamplerYcbcrConversionInfo.__Internal*) __Instance)->conversion];
            else __result0 = global::VkSamplerYcbcrConversionT.__CreateInstance(((global::VkSamplerYcbcrConversionInfo.__Internal*) __Instance)->conversion);
            return __result0;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionInfo.__Internal*)__Instance)->conversion = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkBindImagePlaneMemoryInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkImageAspectFlagBits planeAspect;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBindImagePlaneMemoryInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindImagePlaneMemoryInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindImagePlaneMemoryInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBindImagePlaneMemoryInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBindImagePlaneMemoryInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkBindImagePlaneMemoryInfo __CreateInstance(global::VkBindImagePlaneMemoryInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkBindImagePlaneMemoryInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBindImagePlaneMemoryInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBindImagePlaneMemoryInfo.__Internal));
        *(global::VkBindImagePlaneMemoryInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBindImagePlaneMemoryInfo(global::VkBindImagePlaneMemoryInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBindImagePlaneMemoryInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBindImagePlaneMemoryInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindImagePlaneMemoryInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBindImagePlaneMemoryInfo(global::VkBindImagePlaneMemoryInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindImagePlaneMemoryInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBindImagePlaneMemoryInfo.__Internal*) __Instance) = *((global::VkBindImagePlaneMemoryInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBindImagePlaneMemoryInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBindImagePlaneMemoryInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBindImagePlaneMemoryInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBindImagePlaneMemoryInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBindImagePlaneMemoryInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkImageAspectFlagBits PlaneAspect
    {
        get
        {
            return ((global::VkBindImagePlaneMemoryInfo.__Internal*) __Instance)->planeAspect;
        }

        set
        {
            ((global::VkBindImagePlaneMemoryInfo.__Internal*)__Instance)->planeAspect = value;
        }
    }
}

public unsafe partial class VkImagePlaneMemoryRequirementsInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkImageAspectFlagBits planeAspect;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImagePlaneMemoryRequirementsInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImagePlaneMemoryRequirementsInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImagePlaneMemoryRequirementsInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImagePlaneMemoryRequirementsInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImagePlaneMemoryRequirementsInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkImagePlaneMemoryRequirementsInfo __CreateInstance(global::VkImagePlaneMemoryRequirementsInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkImagePlaneMemoryRequirementsInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImagePlaneMemoryRequirementsInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImagePlaneMemoryRequirementsInfo.__Internal));
        *(global::VkImagePlaneMemoryRequirementsInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImagePlaneMemoryRequirementsInfo(global::VkImagePlaneMemoryRequirementsInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImagePlaneMemoryRequirementsInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImagePlaneMemoryRequirementsInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImagePlaneMemoryRequirementsInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImagePlaneMemoryRequirementsInfo(global::VkImagePlaneMemoryRequirementsInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImagePlaneMemoryRequirementsInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImagePlaneMemoryRequirementsInfo.__Internal*) __Instance) = *((global::VkImagePlaneMemoryRequirementsInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImagePlaneMemoryRequirementsInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImagePlaneMemoryRequirementsInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImagePlaneMemoryRequirementsInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImagePlaneMemoryRequirementsInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImagePlaneMemoryRequirementsInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkImageAspectFlagBits PlaneAspect
    {
        get
        {
            return ((global::VkImagePlaneMemoryRequirementsInfo.__Internal*) __Instance)->planeAspect;
        }

        set
        {
            ((global::VkImagePlaneMemoryRequirementsInfo.__Internal*)__Instance)->planeAspect = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceSamplerYcbcrConversionFeatures : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint samplerYcbcrConversion;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceSamplerYcbcrConversionFeatures@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSamplerYcbcrConversionFeatures> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSamplerYcbcrConversionFeatures>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceSamplerYcbcrConversionFeatures __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSamplerYcbcrConversionFeatures(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceSamplerYcbcrConversionFeatures __CreateInstance(global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSamplerYcbcrConversionFeatures(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal));
        *(global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceSamplerYcbcrConversionFeatures(global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceSamplerYcbcrConversionFeatures(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceSamplerYcbcrConversionFeatures()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceSamplerYcbcrConversionFeatures(global::VkPhysicalDeviceSamplerYcbcrConversionFeatures _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal*) __Instance) = *((global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceSamplerYcbcrConversionFeatures __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SamplerYcbcrConversion
    {
        get
        {
            return ((global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal*) __Instance)->samplerYcbcrConversion;
        }

        set
        {
            ((global::VkPhysicalDeviceSamplerYcbcrConversionFeatures.__Internal*)__Instance)->samplerYcbcrConversion = value;
        }
    }
}

public unsafe partial class VkSamplerYcbcrConversionImageFormatProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint combinedImageSamplerDescriptorCount;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSamplerYcbcrConversionImageFormatProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerYcbcrConversionImageFormatProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerYcbcrConversionImageFormatProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSamplerYcbcrConversionImageFormatProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSamplerYcbcrConversionImageFormatProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkSamplerYcbcrConversionImageFormatProperties __CreateInstance(global::VkSamplerYcbcrConversionImageFormatProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkSamplerYcbcrConversionImageFormatProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSamplerYcbcrConversionImageFormatProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionImageFormatProperties.__Internal));
        *(global::VkSamplerYcbcrConversionImageFormatProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSamplerYcbcrConversionImageFormatProperties(global::VkSamplerYcbcrConversionImageFormatProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSamplerYcbcrConversionImageFormatProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSamplerYcbcrConversionImageFormatProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionImageFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSamplerYcbcrConversionImageFormatProperties(global::VkSamplerYcbcrConversionImageFormatProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerYcbcrConversionImageFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSamplerYcbcrConversionImageFormatProperties.__Internal*) __Instance) = *((global::VkSamplerYcbcrConversionImageFormatProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSamplerYcbcrConversionImageFormatProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionImageFormatProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionImageFormatProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionImageFormatProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionImageFormatProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint CombinedImageSamplerDescriptorCount
    {
        get
        {
            return ((global::VkSamplerYcbcrConversionImageFormatProperties.__Internal*) __Instance)->combinedImageSamplerDescriptorCount;
        }

        set
        {
            ((global::VkSamplerYcbcrConversionImageFormatProperties.__Internal*)__Instance)->combinedImageSamplerDescriptorCount = value;
        }
    }
}

public unsafe partial class VkDescriptorUpdateTemplateEntry : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint dstBinding;

        [FieldOffset(4)]
        internal uint dstArrayElement;

        [FieldOffset(8)]
        internal uint descriptorCount;

        [FieldOffset(12)]
        internal global::VkDescriptorType descriptorType;

        [FieldOffset(16)]
        internal ulong offset;

        [FieldOffset(24)]
        internal ulong stride;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorUpdateTemplateEntry@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorUpdateTemplateEntry> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorUpdateTemplateEntry>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorUpdateTemplateEntry __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorUpdateTemplateEntry(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorUpdateTemplateEntry __CreateInstance(global::VkDescriptorUpdateTemplateEntry.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorUpdateTemplateEntry(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorUpdateTemplateEntry.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorUpdateTemplateEntry.__Internal));
        *(global::VkDescriptorUpdateTemplateEntry.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorUpdateTemplateEntry(global::VkDescriptorUpdateTemplateEntry.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorUpdateTemplateEntry(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorUpdateTemplateEntry()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorUpdateTemplateEntry.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorUpdateTemplateEntry(global::VkDescriptorUpdateTemplateEntry _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorUpdateTemplateEntry.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorUpdateTemplateEntry.__Internal*) __Instance) = *((global::VkDescriptorUpdateTemplateEntry.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorUpdateTemplateEntry __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint DstBinding
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateEntry.__Internal*) __Instance)->dstBinding;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateEntry.__Internal*)__Instance)->dstBinding = value;
        }
    }

    public uint DstArrayElement
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateEntry.__Internal*) __Instance)->dstArrayElement;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateEntry.__Internal*)__Instance)->dstArrayElement = value;
        }
    }

    public uint DescriptorCount
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateEntry.__Internal*) __Instance)->descriptorCount;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateEntry.__Internal*)__Instance)->descriptorCount = value;
        }
    }

    public global::VkDescriptorType DescriptorType
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateEntry.__Internal*) __Instance)->descriptorType;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateEntry.__Internal*)__Instance)->descriptorType = value;
        }
    }

    public ulong Offset
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateEntry.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateEntry.__Internal*)__Instance)->offset = value;
        }
    }

    public ulong Stride
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateEntry.__Internal*) __Instance)->stride;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateEntry.__Internal*)__Instance)->stride = value;
        }
    }
}

public unsafe partial class VkDescriptorUpdateTemplateCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint descriptorUpdateEntryCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pDescriptorUpdateEntries;

        [FieldOffset(32)]
        internal global::VkDescriptorUpdateTemplateType templateType;

        [FieldOffset(40)]
        internal global::System.IntPtr descriptorSetLayout;

        [FieldOffset(48)]
        internal global::VkPipelineBindPoint pipelineBindPoint;

        [FieldOffset(56)]
        internal global::System.IntPtr pipelineLayout;

        [FieldOffset(64)]
        internal uint set;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorUpdateTemplateCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorUpdateTemplateCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorUpdateTemplateCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorUpdateTemplateCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorUpdateTemplateCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorUpdateTemplateCreateInfo __CreateInstance(global::VkDescriptorUpdateTemplateCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorUpdateTemplateCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorUpdateTemplateCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorUpdateTemplateCreateInfo.__Internal));
        *(global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorUpdateTemplateCreateInfo(global::VkDescriptorUpdateTemplateCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorUpdateTemplateCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorUpdateTemplateCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorUpdateTemplateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorUpdateTemplateCreateInfo(global::VkDescriptorUpdateTemplateCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorUpdateTemplateCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance) = *((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorUpdateTemplateCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint DescriptorUpdateEntryCount
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->descriptorUpdateEntryCount;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->descriptorUpdateEntryCount = value;
        }
    }

    public global::VkDescriptorUpdateTemplateEntry PDescriptorUpdateEntries
    {
        get
        {
            global::VkDescriptorUpdateTemplateEntry __result0;
            if (((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pDescriptorUpdateEntries == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorUpdateTemplateEntry.NativeToManagedMap.ContainsKey(((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pDescriptorUpdateEntries))
                __result0 = (global::VkDescriptorUpdateTemplateEntry) global::VkDescriptorUpdateTemplateEntry.NativeToManagedMap[((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pDescriptorUpdateEntries];
            else __result0 = global::VkDescriptorUpdateTemplateEntry.__CreateInstance(((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pDescriptorUpdateEntries);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->pDescriptorUpdateEntries = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkDescriptorUpdateTemplateType TemplateType
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->templateType;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->templateType = value;
        }
    }

    public global::VkDescriptorSetLayoutT DescriptorSetLayout
    {
        get
        {
            global::VkDescriptorSetLayoutT __result0;
            if (((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->descriptorSetLayout == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorSetLayoutT.NativeToManagedMap.ContainsKey(((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->descriptorSetLayout))
                __result0 = (global::VkDescriptorSetLayoutT) global::VkDescriptorSetLayoutT.NativeToManagedMap[((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->descriptorSetLayout];
            else __result0 = global::VkDescriptorSetLayoutT.__CreateInstance(((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->descriptorSetLayout);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->descriptorSetLayout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkPipelineBindPoint PipelineBindPoint
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pipelineBindPoint;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->pipelineBindPoint = value;
        }
    }

    public global::VkPipelineLayoutT PipelineLayout
    {
        get
        {
            global::VkPipelineLayoutT __result0;
            if (((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pipelineLayout == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineLayoutT.NativeToManagedMap.ContainsKey(((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pipelineLayout))
                __result0 = (global::VkPipelineLayoutT) global::VkPipelineLayoutT.NativeToManagedMap[((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pipelineLayout];
            else __result0 = global::VkPipelineLayoutT.__CreateInstance(((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->pipelineLayout);
            return __result0;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->pipelineLayout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint Set
    {
        get
        {
            return ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*) __Instance)->set;
        }

        set
        {
            ((global::VkDescriptorUpdateTemplateCreateInfo.__Internal*)__Instance)->set = value;
        }
    }
}

public unsafe partial class VkExternalMemoryProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint externalMemoryFeatures;

        [FieldOffset(4)]
        internal uint exportFromImportedHandleTypes;

        [FieldOffset(8)]
        internal uint compatibleHandleTypes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExternalMemoryProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalMemoryProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalMemoryProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExternalMemoryProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExternalMemoryProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkExternalMemoryProperties __CreateInstance(global::VkExternalMemoryProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkExternalMemoryProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExternalMemoryProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryProperties.__Internal));
        *(global::VkExternalMemoryProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExternalMemoryProperties(global::VkExternalMemoryProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExternalMemoryProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExternalMemoryProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExternalMemoryProperties(global::VkExternalMemoryProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExternalMemoryProperties.__Internal*) __Instance) = *((global::VkExternalMemoryProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExternalMemoryProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint ExternalMemoryFeatures
    {
        get
        {
            return ((global::VkExternalMemoryProperties.__Internal*) __Instance)->externalMemoryFeatures;
        }

        set
        {
            ((global::VkExternalMemoryProperties.__Internal*)__Instance)->externalMemoryFeatures = value;
        }
    }

    public uint ExportFromImportedHandleTypes
    {
        get
        {
            return ((global::VkExternalMemoryProperties.__Internal*) __Instance)->exportFromImportedHandleTypes;
        }

        set
        {
            ((global::VkExternalMemoryProperties.__Internal*)__Instance)->exportFromImportedHandleTypes = value;
        }
    }

    public uint CompatibleHandleTypes
    {
        get
        {
            return ((global::VkExternalMemoryProperties.__Internal*) __Instance)->compatibleHandleTypes;
        }

        set
        {
            ((global::VkExternalMemoryProperties.__Internal*)__Instance)->compatibleHandleTypes = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceExternalImageFormatInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkExternalMemoryHandleTypeFlagBits handleType;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceExternalImageFormatInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalImageFormatInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalImageFormatInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceExternalImageFormatInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalImageFormatInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceExternalImageFormatInfo __CreateInstance(global::VkPhysicalDeviceExternalImageFormatInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalImageFormatInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceExternalImageFormatInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalImageFormatInfo.__Internal));
        *(global::VkPhysicalDeviceExternalImageFormatInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceExternalImageFormatInfo(global::VkPhysicalDeviceExternalImageFormatInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceExternalImageFormatInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceExternalImageFormatInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalImageFormatInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceExternalImageFormatInfo(global::VkPhysicalDeviceExternalImageFormatInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalImageFormatInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceExternalImageFormatInfo.__Internal*) __Instance) = *((global::VkPhysicalDeviceExternalImageFormatInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceExternalImageFormatInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalImageFormatInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalImageFormatInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalImageFormatInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalImageFormatInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkExternalMemoryHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalImageFormatInfo.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalImageFormatInfo.__Internal*)__Instance)->handleType = value;
        }
    }
}

public unsafe partial class VkExternalImageFormatProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkExternalMemoryProperties.__Internal externalMemoryProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExternalImageFormatProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalImageFormatProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalImageFormatProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExternalImageFormatProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExternalImageFormatProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkExternalImageFormatProperties __CreateInstance(global::VkExternalImageFormatProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkExternalImageFormatProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExternalImageFormatProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExternalImageFormatProperties.__Internal));
        *(global::VkExternalImageFormatProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExternalImageFormatProperties(global::VkExternalImageFormatProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExternalImageFormatProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExternalImageFormatProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalImageFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExternalImageFormatProperties(global::VkExternalImageFormatProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalImageFormatProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExternalImageFormatProperties.__Internal*) __Instance) = *((global::VkExternalImageFormatProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExternalImageFormatProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExternalImageFormatProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExternalImageFormatProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExternalImageFormatProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExternalImageFormatProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkExternalMemoryProperties ExternalMemoryProperties
    {
        get
        {
            return global::VkExternalMemoryProperties.__CreateInstance(new global::System.IntPtr(&((global::VkExternalImageFormatProperties.__Internal*) __Instance)->externalMemoryProperties));
        }

        set
        {
            ((global::VkExternalImageFormatProperties.__Internal*)__Instance)->externalMemoryProperties = ReferenceEquals(value, null) ? new global::VkExternalMemoryProperties.__Internal() : *(global::VkExternalMemoryProperties.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceExternalBufferInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint usage;

        [FieldOffset(24)]
        internal global::VkExternalMemoryHandleTypeFlagBits handleType;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceExternalBufferInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalBufferInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalBufferInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceExternalBufferInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalBufferInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceExternalBufferInfo __CreateInstance(global::VkPhysicalDeviceExternalBufferInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalBufferInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceExternalBufferInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalBufferInfo.__Internal));
        *(global::VkPhysicalDeviceExternalBufferInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceExternalBufferInfo(global::VkPhysicalDeviceExternalBufferInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceExternalBufferInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceExternalBufferInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalBufferInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceExternalBufferInfo(global::VkPhysicalDeviceExternalBufferInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalBufferInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceExternalBufferInfo.__Internal*) __Instance) = *((global::VkPhysicalDeviceExternalBufferInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceExternalBufferInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*)__Instance)->flags = value;
        }
    }

    public uint Usage
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*) __Instance)->usage;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*)__Instance)->usage = value;
        }
    }

    public global::VkExternalMemoryHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalBufferInfo.__Internal*)__Instance)->handleType = value;
        }
    }
}

public unsafe partial class VkExternalBufferProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkExternalMemoryProperties.__Internal externalMemoryProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExternalBufferProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalBufferProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalBufferProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExternalBufferProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExternalBufferProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkExternalBufferProperties __CreateInstance(global::VkExternalBufferProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkExternalBufferProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExternalBufferProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExternalBufferProperties.__Internal));
        *(global::VkExternalBufferProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExternalBufferProperties(global::VkExternalBufferProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExternalBufferProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExternalBufferProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalBufferProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExternalBufferProperties(global::VkExternalBufferProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalBufferProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExternalBufferProperties.__Internal*) __Instance) = *((global::VkExternalBufferProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExternalBufferProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExternalBufferProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExternalBufferProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExternalBufferProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExternalBufferProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkExternalMemoryProperties ExternalMemoryProperties
    {
        get
        {
            return global::VkExternalMemoryProperties.__CreateInstance(new global::System.IntPtr(&((global::VkExternalBufferProperties.__Internal*) __Instance)->externalMemoryProperties));
        }

        set
        {
            ((global::VkExternalBufferProperties.__Internal*)__Instance)->externalMemoryProperties = ReferenceEquals(value, null) ? new global::VkExternalMemoryProperties.__Internal() : *(global::VkExternalMemoryProperties.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceIDProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal fixed byte deviceUUID[16];

        [FieldOffset(32)]
        internal fixed byte driverUUID[16];

        [FieldOffset(48)]
        internal fixed byte deviceLUID[8];

        [FieldOffset(56)]
        internal uint deviceNodeMask;

        [FieldOffset(60)]
        internal uint deviceLUIDValid;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceIDProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceIDProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceIDProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceIDProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceIDProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceIDProperties __CreateInstance(global::VkPhysicalDeviceIDProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceIDProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceIDProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceIDProperties.__Internal));
        *(global::VkPhysicalDeviceIDProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceIDProperties(global::VkPhysicalDeviceIDProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceIDProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceIDProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceIDProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceIDProperties(global::VkPhysicalDeviceIDProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceIDProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance) = *((global::VkPhysicalDeviceIDProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceIDProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceIDProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceIDProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public byte[] DeviceUUID
    {
        get
        {
            byte[] __value = null;
            if (((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->deviceUUID != null)
            {
                __value = new byte[16];
                for (int i = 0; i < 16; i++)
                    __value[i] = ((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->deviceUUID[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 16; i++)
                    ((global::VkPhysicalDeviceIDProperties.__Internal*)__Instance)->deviceUUID[i] = value[i];
            }
        }
    }

    public byte[] DriverUUID
    {
        get
        {
            byte[] __value = null;
            if (((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->driverUUID != null)
            {
                __value = new byte[16];
                for (int i = 0; i < 16; i++)
                    __value[i] = ((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->driverUUID[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 16; i++)
                    ((global::VkPhysicalDeviceIDProperties.__Internal*)__Instance)->driverUUID[i] = value[i];
            }
        }
    }

    public byte[] DeviceLUID
    {
        get
        {
            byte[] __value = null;
            if (((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->deviceLUID != null)
            {
                __value = new byte[8];
                for (int i = 0; i < 8; i++)
                    __value[i] = ((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->deviceLUID[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 8; i++)
                    ((global::VkPhysicalDeviceIDProperties.__Internal*)__Instance)->deviceLUID[i] = value[i];
            }
        }
    }

    public uint DeviceNodeMask
    {
        get
        {
            return ((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->deviceNodeMask;
        }

        set
        {
            ((global::VkPhysicalDeviceIDProperties.__Internal*)__Instance)->deviceNodeMask = value;
        }
    }

    public uint DeviceLUIDValid
    {
        get
        {
            return ((global::VkPhysicalDeviceIDProperties.__Internal*) __Instance)->deviceLUIDValid;
        }

        set
        {
            ((global::VkPhysicalDeviceIDProperties.__Internal*)__Instance)->deviceLUIDValid = value;
        }
    }
}

public unsafe partial class VkExternalMemoryImageCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint handleTypes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExternalMemoryImageCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalMemoryImageCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalMemoryImageCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExternalMemoryImageCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExternalMemoryImageCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkExternalMemoryImageCreateInfo __CreateInstance(global::VkExternalMemoryImageCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkExternalMemoryImageCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExternalMemoryImageCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryImageCreateInfo.__Internal));
        *(global::VkExternalMemoryImageCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExternalMemoryImageCreateInfo(global::VkExternalMemoryImageCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExternalMemoryImageCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExternalMemoryImageCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryImageCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExternalMemoryImageCreateInfo(global::VkExternalMemoryImageCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryImageCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExternalMemoryImageCreateInfo.__Internal*) __Instance) = *((global::VkExternalMemoryImageCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExternalMemoryImageCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExternalMemoryImageCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExternalMemoryImageCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExternalMemoryImageCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExternalMemoryImageCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint HandleTypes
    {
        get
        {
            return ((global::VkExternalMemoryImageCreateInfo.__Internal*) __Instance)->handleTypes;
        }

        set
        {
            ((global::VkExternalMemoryImageCreateInfo.__Internal*)__Instance)->handleTypes = value;
        }
    }
}

public unsafe partial class VkExternalMemoryBufferCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint handleTypes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExternalMemoryBufferCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalMemoryBufferCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalMemoryBufferCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExternalMemoryBufferCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExternalMemoryBufferCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkExternalMemoryBufferCreateInfo __CreateInstance(global::VkExternalMemoryBufferCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkExternalMemoryBufferCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExternalMemoryBufferCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryBufferCreateInfo.__Internal));
        *(global::VkExternalMemoryBufferCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExternalMemoryBufferCreateInfo(global::VkExternalMemoryBufferCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExternalMemoryBufferCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExternalMemoryBufferCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryBufferCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExternalMemoryBufferCreateInfo(global::VkExternalMemoryBufferCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryBufferCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExternalMemoryBufferCreateInfo.__Internal*) __Instance) = *((global::VkExternalMemoryBufferCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExternalMemoryBufferCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExternalMemoryBufferCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExternalMemoryBufferCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExternalMemoryBufferCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExternalMemoryBufferCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint HandleTypes
    {
        get
        {
            return ((global::VkExternalMemoryBufferCreateInfo.__Internal*) __Instance)->handleTypes;
        }

        set
        {
            ((global::VkExternalMemoryBufferCreateInfo.__Internal*)__Instance)->handleTypes = value;
        }
    }
}

public unsafe partial class VkExportMemoryAllocateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint handleTypes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExportMemoryAllocateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExportMemoryAllocateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExportMemoryAllocateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExportMemoryAllocateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExportMemoryAllocateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkExportMemoryAllocateInfo __CreateInstance(global::VkExportMemoryAllocateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkExportMemoryAllocateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExportMemoryAllocateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExportMemoryAllocateInfo.__Internal));
        *(global::VkExportMemoryAllocateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExportMemoryAllocateInfo(global::VkExportMemoryAllocateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExportMemoryAllocateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExportMemoryAllocateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExportMemoryAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExportMemoryAllocateInfo(global::VkExportMemoryAllocateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExportMemoryAllocateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExportMemoryAllocateInfo.__Internal*) __Instance) = *((global::VkExportMemoryAllocateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExportMemoryAllocateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExportMemoryAllocateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExportMemoryAllocateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExportMemoryAllocateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExportMemoryAllocateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint HandleTypes
    {
        get
        {
            return ((global::VkExportMemoryAllocateInfo.__Internal*) __Instance)->handleTypes;
        }

        set
        {
            ((global::VkExportMemoryAllocateInfo.__Internal*)__Instance)->handleTypes = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceExternalFenceInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkExternalFenceHandleTypeFlagBits handleType;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceExternalFenceInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalFenceInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalFenceInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceExternalFenceInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalFenceInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceExternalFenceInfo __CreateInstance(global::VkPhysicalDeviceExternalFenceInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalFenceInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceExternalFenceInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalFenceInfo.__Internal));
        *(global::VkPhysicalDeviceExternalFenceInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceExternalFenceInfo(global::VkPhysicalDeviceExternalFenceInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceExternalFenceInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceExternalFenceInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalFenceInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceExternalFenceInfo(global::VkPhysicalDeviceExternalFenceInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalFenceInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceExternalFenceInfo.__Internal*) __Instance) = *((global::VkPhysicalDeviceExternalFenceInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceExternalFenceInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalFenceInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalFenceInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalFenceInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalFenceInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkExternalFenceHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalFenceInfo.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalFenceInfo.__Internal*)__Instance)->handleType = value;
        }
    }
}

public unsafe partial class VkExternalFenceProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint exportFromImportedHandleTypes;

        [FieldOffset(20)]
        internal uint compatibleHandleTypes;

        [FieldOffset(24)]
        internal uint externalFenceFeatures;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExternalFenceProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalFenceProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalFenceProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExternalFenceProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExternalFenceProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkExternalFenceProperties __CreateInstance(global::VkExternalFenceProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkExternalFenceProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExternalFenceProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExternalFenceProperties.__Internal));
        *(global::VkExternalFenceProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExternalFenceProperties(global::VkExternalFenceProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExternalFenceProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExternalFenceProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalFenceProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExternalFenceProperties(global::VkExternalFenceProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalFenceProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExternalFenceProperties.__Internal*) __Instance) = *((global::VkExternalFenceProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExternalFenceProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExternalFenceProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExternalFenceProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExternalFenceProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExternalFenceProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ExportFromImportedHandleTypes
    {
        get
        {
            return ((global::VkExternalFenceProperties.__Internal*) __Instance)->exportFromImportedHandleTypes;
        }

        set
        {
            ((global::VkExternalFenceProperties.__Internal*)__Instance)->exportFromImportedHandleTypes = value;
        }
    }

    public uint CompatibleHandleTypes
    {
        get
        {
            return ((global::VkExternalFenceProperties.__Internal*) __Instance)->compatibleHandleTypes;
        }

        set
        {
            ((global::VkExternalFenceProperties.__Internal*)__Instance)->compatibleHandleTypes = value;
        }
    }

    public uint ExternalFenceFeatures
    {
        get
        {
            return ((global::VkExternalFenceProperties.__Internal*) __Instance)->externalFenceFeatures;
        }

        set
        {
            ((global::VkExternalFenceProperties.__Internal*)__Instance)->externalFenceFeatures = value;
        }
    }
}

public unsafe partial class VkExportFenceCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint handleTypes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExportFenceCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExportFenceCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExportFenceCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExportFenceCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExportFenceCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkExportFenceCreateInfo __CreateInstance(global::VkExportFenceCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkExportFenceCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExportFenceCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExportFenceCreateInfo.__Internal));
        *(global::VkExportFenceCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExportFenceCreateInfo(global::VkExportFenceCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExportFenceCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExportFenceCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExportFenceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExportFenceCreateInfo(global::VkExportFenceCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExportFenceCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExportFenceCreateInfo.__Internal*) __Instance) = *((global::VkExportFenceCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExportFenceCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExportFenceCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExportFenceCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExportFenceCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExportFenceCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint HandleTypes
    {
        get
        {
            return ((global::VkExportFenceCreateInfo.__Internal*) __Instance)->handleTypes;
        }

        set
        {
            ((global::VkExportFenceCreateInfo.__Internal*)__Instance)->handleTypes = value;
        }
    }
}

public unsafe partial class VkExportSemaphoreCreateInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint handleTypes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExportSemaphoreCreateInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExportSemaphoreCreateInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExportSemaphoreCreateInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExportSemaphoreCreateInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExportSemaphoreCreateInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkExportSemaphoreCreateInfo __CreateInstance(global::VkExportSemaphoreCreateInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkExportSemaphoreCreateInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExportSemaphoreCreateInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExportSemaphoreCreateInfo.__Internal));
        *(global::VkExportSemaphoreCreateInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExportSemaphoreCreateInfo(global::VkExportSemaphoreCreateInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExportSemaphoreCreateInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExportSemaphoreCreateInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExportSemaphoreCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExportSemaphoreCreateInfo(global::VkExportSemaphoreCreateInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExportSemaphoreCreateInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExportSemaphoreCreateInfo.__Internal*) __Instance) = *((global::VkExportSemaphoreCreateInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExportSemaphoreCreateInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExportSemaphoreCreateInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExportSemaphoreCreateInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExportSemaphoreCreateInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExportSemaphoreCreateInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint HandleTypes
    {
        get
        {
            return ((global::VkExportSemaphoreCreateInfo.__Internal*) __Instance)->handleTypes;
        }

        set
        {
            ((global::VkExportSemaphoreCreateInfo.__Internal*)__Instance)->handleTypes = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceExternalSemaphoreInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkExternalSemaphoreHandleTypeFlagBits handleType;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceExternalSemaphoreInfo@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalSemaphoreInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalSemaphoreInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceExternalSemaphoreInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalSemaphoreInfo(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceExternalSemaphoreInfo __CreateInstance(global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalSemaphoreInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal));
        *(global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceExternalSemaphoreInfo(global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceExternalSemaphoreInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceExternalSemaphoreInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceExternalSemaphoreInfo(global::VkPhysicalDeviceExternalSemaphoreInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal*) __Instance) = *((global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceExternalSemaphoreInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkExternalSemaphoreHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalSemaphoreInfo.__Internal*)__Instance)->handleType = value;
        }
    }
}

public unsafe partial class VkExternalSemaphoreProperties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint exportFromImportedHandleTypes;

        [FieldOffset(20)]
        internal uint compatibleHandleTypes;

        [FieldOffset(24)]
        internal uint externalSemaphoreFeatures;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExternalSemaphoreProperties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalSemaphoreProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalSemaphoreProperties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExternalSemaphoreProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExternalSemaphoreProperties(native.ToPointer(), skipVTables);
    }

    internal static global::VkExternalSemaphoreProperties __CreateInstance(global::VkExternalSemaphoreProperties.__Internal native, bool skipVTables = false)
    {
        return new global::VkExternalSemaphoreProperties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExternalSemaphoreProperties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExternalSemaphoreProperties.__Internal));
        *(global::VkExternalSemaphoreProperties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExternalSemaphoreProperties(global::VkExternalSemaphoreProperties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExternalSemaphoreProperties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExternalSemaphoreProperties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalSemaphoreProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExternalSemaphoreProperties(global::VkExternalSemaphoreProperties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalSemaphoreProperties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExternalSemaphoreProperties.__Internal*) __Instance) = *((global::VkExternalSemaphoreProperties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExternalSemaphoreProperties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExternalSemaphoreProperties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExternalSemaphoreProperties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExternalSemaphoreProperties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExternalSemaphoreProperties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ExportFromImportedHandleTypes
    {
        get
        {
            return ((global::VkExternalSemaphoreProperties.__Internal*) __Instance)->exportFromImportedHandleTypes;
        }

        set
        {
            ((global::VkExternalSemaphoreProperties.__Internal*)__Instance)->exportFromImportedHandleTypes = value;
        }
    }

    public uint CompatibleHandleTypes
    {
        get
        {
            return ((global::VkExternalSemaphoreProperties.__Internal*) __Instance)->compatibleHandleTypes;
        }

        set
        {
            ((global::VkExternalSemaphoreProperties.__Internal*)__Instance)->compatibleHandleTypes = value;
        }
    }

    public uint ExternalSemaphoreFeatures
    {
        get
        {
            return ((global::VkExternalSemaphoreProperties.__Internal*) __Instance)->externalSemaphoreFeatures;
        }

        set
        {
            ((global::VkExternalSemaphoreProperties.__Internal*)__Instance)->externalSemaphoreFeatures = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceMaintenance3Properties : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint maxPerSetDescriptors;

        [FieldOffset(24)]
        internal ulong maxMemoryAllocationSize;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceMaintenance3Properties@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMaintenance3Properties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMaintenance3Properties>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceMaintenance3Properties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMaintenance3Properties(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceMaintenance3Properties __CreateInstance(global::VkPhysicalDeviceMaintenance3Properties.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMaintenance3Properties(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceMaintenance3Properties.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMaintenance3Properties.__Internal));
        *(global::VkPhysicalDeviceMaintenance3Properties.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceMaintenance3Properties(global::VkPhysicalDeviceMaintenance3Properties.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceMaintenance3Properties(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceMaintenance3Properties()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMaintenance3Properties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceMaintenance3Properties(global::VkPhysicalDeviceMaintenance3Properties _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMaintenance3Properties.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceMaintenance3Properties.__Internal*) __Instance) = *((global::VkPhysicalDeviceMaintenance3Properties.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceMaintenance3Properties __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceMaintenance3Properties.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceMaintenance3Properties.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceMaintenance3Properties.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceMaintenance3Properties.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MaxPerSetDescriptors
    {
        get
        {
            return ((global::VkPhysicalDeviceMaintenance3Properties.__Internal*) __Instance)->maxPerSetDescriptors;
        }

        set
        {
            ((global::VkPhysicalDeviceMaintenance3Properties.__Internal*)__Instance)->maxPerSetDescriptors = value;
        }
    }

    public ulong MaxMemoryAllocationSize
    {
        get
        {
            return ((global::VkPhysicalDeviceMaintenance3Properties.__Internal*) __Instance)->maxMemoryAllocationSize;
        }

        set
        {
            ((global::VkPhysicalDeviceMaintenance3Properties.__Internal*)__Instance)->maxMemoryAllocationSize = value;
        }
    }
}

public unsafe partial class VkDescriptorSetLayoutSupport : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint supported;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorSetLayoutSupport@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutSupport> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutSupport>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorSetLayoutSupport __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutSupport(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorSetLayoutSupport __CreateInstance(global::VkDescriptorSetLayoutSupport.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutSupport(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorSetLayoutSupport.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutSupport.__Internal));
        *(global::VkDescriptorSetLayoutSupport.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorSetLayoutSupport(global::VkDescriptorSetLayoutSupport.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorSetLayoutSupport(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorSetLayoutSupport()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutSupport.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorSetLayoutSupport(global::VkDescriptorSetLayoutSupport _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutSupport.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorSetLayoutSupport.__Internal*) __Instance) = *((global::VkDescriptorSetLayoutSupport.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorSetLayoutSupport __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDescriptorSetLayoutSupport.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDescriptorSetLayoutSupport.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDescriptorSetLayoutSupport.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDescriptorSetLayoutSupport.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Supported
    {
        get
        {
            return ((global::VkDescriptorSetLayoutSupport.__Internal*) __Instance)->supported;
        }

        set
        {
            ((global::VkDescriptorSetLayoutSupport.__Internal*)__Instance)->supported = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceShaderDrawParameterFeatures : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint shaderDrawParameters;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceShaderDrawParameterFeatures@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceShaderDrawParameterFeatures> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceShaderDrawParameterFeatures>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceShaderDrawParameterFeatures __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceShaderDrawParameterFeatures(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceShaderDrawParameterFeatures __CreateInstance(global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceShaderDrawParameterFeatures(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal));
        *(global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceShaderDrawParameterFeatures(global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceShaderDrawParameterFeatures(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceShaderDrawParameterFeatures()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceShaderDrawParameterFeatures(global::VkPhysicalDeviceShaderDrawParameterFeatures _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal*) __Instance) = *((global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceShaderDrawParameterFeatures __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ShaderDrawParameters
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal*) __Instance)->shaderDrawParameters;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderDrawParameterFeatures.__Internal*)__Instance)->shaderDrawParameters = value;
        }
    }
}

public unsafe partial class VkSurfaceKHR_T
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceKHR_T> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceKHR_T>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSurfaceKHR_T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSurfaceKHR_T(native.ToPointer(), skipVTables);
    }

    internal static global::VkSurfaceKHR_T __CreateInstance(global::VkSurfaceKHR_T.__Internal native, bool skipVTables = false)
    {
        return new global::VkSurfaceKHR_T(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSurfaceKHR_T.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSurfaceKHR_T.__Internal));
        *(global::VkSurfaceKHR_T.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSurfaceKHR_T(global::VkSurfaceKHR_T.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSurfaceKHR_T(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkSurfaceCapabilitiesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 52)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint minImageCount;

        [FieldOffset(4)]
        internal uint maxImageCount;

        [FieldOffset(8)]
        internal global::VkExtent2D.__Internal currentExtent;

        [FieldOffset(16)]
        internal global::VkExtent2D.__Internal minImageExtent;

        [FieldOffset(24)]
        internal global::VkExtent2D.__Internal maxImageExtent;

        [FieldOffset(32)]
        internal uint maxImageArrayLayers;

        [FieldOffset(36)]
        internal uint supportedTransforms;

        [FieldOffset(40)]
        internal global::VkSurfaceTransformFlagBitsKHR currentTransform;

        [FieldOffset(44)]
        internal uint supportedCompositeAlpha;

        [FieldOffset(48)]
        internal uint supportedUsageFlags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSurfaceCapabilitiesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceCapabilitiesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceCapabilitiesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSurfaceCapabilitiesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSurfaceCapabilitiesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSurfaceCapabilitiesKHR __CreateInstance(global::VkSurfaceCapabilitiesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSurfaceCapabilitiesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSurfaceCapabilitiesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSurfaceCapabilitiesKHR.__Internal));
        *(global::VkSurfaceCapabilitiesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSurfaceCapabilitiesKHR(global::VkSurfaceCapabilitiesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSurfaceCapabilitiesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSurfaceCapabilitiesKHR(global::VkSurfaceCapabilitiesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceCapabilitiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance) = *((global::VkSurfaceCapabilitiesKHR.__Internal*) _0.__Instance);
    }

    public VkSurfaceCapabilitiesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceCapabilitiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSurfaceCapabilitiesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint MinImageCount
    {
        get
        {
            return ((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->minImageCount;
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->minImageCount = value;
        }
    }

    public uint MaxImageCount
    {
        get
        {
            return ((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->maxImageCount;
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->maxImageCount = value;
        }
    }

    public global::VkExtent2D CurrentExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->currentExtent));
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->currentExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D MinImageExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->minImageExtent));
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->minImageExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D MaxImageExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->maxImageExtent));
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->maxImageExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public uint MaxImageArrayLayers
    {
        get
        {
            return ((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->maxImageArrayLayers;
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->maxImageArrayLayers = value;
        }
    }

    public uint SupportedTransforms
    {
        get
        {
            return ((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->supportedTransforms;
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->supportedTransforms = value;
        }
    }

    public global::VkSurfaceTransformFlagBitsKHR CurrentTransform
    {
        get
        {
            return ((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->currentTransform;
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->currentTransform = value;
        }
    }

    public uint SupportedCompositeAlpha
    {
        get
        {
            return ((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->supportedCompositeAlpha;
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->supportedCompositeAlpha = value;
        }
    }

    public uint SupportedUsageFlags
    {
        get
        {
            return ((global::VkSurfaceCapabilitiesKHR.__Internal*) __Instance)->supportedUsageFlags;
        }

        set
        {
            ((global::VkSurfaceCapabilitiesKHR.__Internal*)__Instance)->supportedUsageFlags = value;
        }
    }
}

public unsafe partial class VkSurfaceFormatKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkFormat format;

        [FieldOffset(4)]
        internal global::VkColorSpaceKHR colorSpace;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSurfaceFormatKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceFormatKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceFormatKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSurfaceFormatKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSurfaceFormatKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSurfaceFormatKHR __CreateInstance(global::VkSurfaceFormatKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSurfaceFormatKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSurfaceFormatKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSurfaceFormatKHR.__Internal));
        *(global::VkSurfaceFormatKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSurfaceFormatKHR(global::VkSurfaceFormatKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSurfaceFormatKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSurfaceFormatKHR(global::VkSurfaceFormatKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceFormatKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSurfaceFormatKHR.__Internal*) __Instance) = *((global::VkSurfaceFormatKHR.__Internal*) _0.__Instance);
    }

    public VkSurfaceFormatKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceFormatKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSurfaceFormatKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkSurfaceFormatKHR.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkSurfaceFormatKHR.__Internal*)__Instance)->format = value;
        }
    }

    public global::VkColorSpaceKHR ColorSpace
    {
        get
        {
            return ((global::VkSurfaceFormatKHR.__Internal*) __Instance)->colorSpace;
        }

        set
        {
            ((global::VkSurfaceFormatKHR.__Internal*)__Instance)->colorSpace = value;
        }
    }
}

public unsafe partial class VkSwapchainKHR_T
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSwapchainKHR_T> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSwapchainKHR_T>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSwapchainKHR_T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSwapchainKHR_T(native.ToPointer(), skipVTables);
    }

    internal static global::VkSwapchainKHR_T __CreateInstance(global::VkSwapchainKHR_T.__Internal native, bool skipVTables = false)
    {
        return new global::VkSwapchainKHR_T(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSwapchainKHR_T.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSwapchainKHR_T.__Internal));
        *(global::VkSwapchainKHR_T.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSwapchainKHR_T(global::VkSwapchainKHR_T.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSwapchainKHR_T(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkSwapchainCreateInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 104)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::System.IntPtr surface;

        [FieldOffset(32)]
        internal uint minImageCount;

        [FieldOffset(36)]
        internal global::VkFormat imageFormat;

        [FieldOffset(40)]
        internal global::VkColorSpaceKHR imageColorSpace;

        [FieldOffset(44)]
        internal global::VkExtent2D.__Internal imageExtent;

        [FieldOffset(52)]
        internal uint imageArrayLayers;

        [FieldOffset(56)]
        internal uint imageUsage;

        [FieldOffset(60)]
        internal global::VkSharingMode imageSharingMode;

        [FieldOffset(64)]
        internal uint queueFamilyIndexCount;

        [FieldOffset(72)]
        internal global::System.IntPtr pQueueFamilyIndices;

        [FieldOffset(80)]
        internal global::VkSurfaceTransformFlagBitsKHR preTransform;

        [FieldOffset(84)]
        internal global::VkCompositeAlphaFlagBitsKHR compositeAlpha;

        [FieldOffset(88)]
        internal global::VkPresentModeKHR presentMode;

        [FieldOffset(92)]
        internal uint clipped;

        [FieldOffset(96)]
        internal global::System.IntPtr oldSwapchain;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSwapchainCreateInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSwapchainCreateInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSwapchainCreateInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSwapchainCreateInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSwapchainCreateInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSwapchainCreateInfoKHR __CreateInstance(global::VkSwapchainCreateInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSwapchainCreateInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSwapchainCreateInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSwapchainCreateInfoKHR.__Internal));
        *(global::VkSwapchainCreateInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSwapchainCreateInfoKHR(global::VkSwapchainCreateInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSwapchainCreateInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSwapchainCreateInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSwapchainCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSwapchainCreateInfoKHR(global::VkSwapchainCreateInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSwapchainCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance) = *((global::VkSwapchainCreateInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSwapchainCreateInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkSurfaceKHR_T Surface
    {
        get
        {
            global::VkSurfaceKHR_T __result0;
            if (((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->surface == IntPtr.Zero) __result0 = null;
            else if (global::VkSurfaceKHR_T.NativeToManagedMap.ContainsKey(((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->surface))
                __result0 = (global::VkSurfaceKHR_T) global::VkSurfaceKHR_T.NativeToManagedMap[((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->surface];
            else __result0 = global::VkSurfaceKHR_T.__CreateInstance(((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->surface);
            return __result0;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->surface = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint MinImageCount
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->minImageCount;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->minImageCount = value;
        }
    }

    public global::VkFormat ImageFormat
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->imageFormat;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->imageFormat = value;
        }
    }

    public global::VkColorSpaceKHR ImageColorSpace
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->imageColorSpace;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->imageColorSpace = value;
        }
    }

    public global::VkExtent2D ImageExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->imageExtent));
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->imageExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public uint ImageArrayLayers
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->imageArrayLayers;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->imageArrayLayers = value;
        }
    }

    public uint ImageUsage
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->imageUsage;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->imageUsage = value;
        }
    }

    public global::VkSharingMode ImageSharingMode
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->imageSharingMode;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->imageSharingMode = value;
        }
    }

    public uint QueueFamilyIndexCount
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->queueFamilyIndexCount;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->queueFamilyIndexCount = value;
        }
    }

    public uint* PQueueFamilyIndices
    {
        get
        {
            return (uint*) ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->pQueueFamilyIndices;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->pQueueFamilyIndices = (global::System.IntPtr) value;
        }
    }

    public global::VkSurfaceTransformFlagBitsKHR PreTransform
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->preTransform;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->preTransform = value;
        }
    }

    public global::VkCompositeAlphaFlagBitsKHR CompositeAlpha
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->compositeAlpha;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->compositeAlpha = value;
        }
    }

    public global::VkPresentModeKHR PresentMode
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->presentMode;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->presentMode = value;
        }
    }

    public uint Clipped
    {
        get
        {
            return ((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->clipped;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->clipped = value;
        }
    }

    public global::VkSwapchainKHR_T OldSwapchain
    {
        get
        {
            global::VkSwapchainKHR_T __result0;
            if (((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->oldSwapchain == IntPtr.Zero) __result0 = null;
            else if (global::VkSwapchainKHR_T.NativeToManagedMap.ContainsKey(((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->oldSwapchain))
                __result0 = (global::VkSwapchainKHR_T) global::VkSwapchainKHR_T.NativeToManagedMap[((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->oldSwapchain];
            else __result0 = global::VkSwapchainKHR_T.__CreateInstance(((global::VkSwapchainCreateInfoKHR.__Internal*) __Instance)->oldSwapchain);
            return __result0;
        }

        set
        {
            ((global::VkSwapchainCreateInfoKHR.__Internal*)__Instance)->oldSwapchain = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkPresentInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint waitSemaphoreCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pWaitSemaphores;

        [FieldOffset(32)]
        internal uint swapchainCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pSwapchains;

        [FieldOffset(48)]
        internal global::System.IntPtr pImageIndices;

        [FieldOffset(56)]
        internal global::VkResult* pResults;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPresentInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPresentInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPresentInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkPresentInfoKHR __CreateInstance(global::VkPresentInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkPresentInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPresentInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPresentInfoKHR.__Internal));
        *(global::VkPresentInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPresentInfoKHR(global::VkPresentInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPresentInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPresentInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPresentInfoKHR(global::VkPresentInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPresentInfoKHR.__Internal*) __Instance) = *((global::VkPresentInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPresentInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPresentInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPresentInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPresentInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPresentInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint WaitSemaphoreCount
    {
        get
        {
            return ((global::VkPresentInfoKHR.__Internal*) __Instance)->waitSemaphoreCount;
        }

        set
        {
            ((global::VkPresentInfoKHR.__Internal*)__Instance)->waitSemaphoreCount = value;
        }
    }

    public global::VkSemaphoreT PWaitSemaphores
    {
        get
        {
            global::VkSemaphoreT __result0;
            if (((global::VkPresentInfoKHR.__Internal*) __Instance)->pWaitSemaphores == IntPtr.Zero) __result0 = null;
            else if (global::VkSemaphoreT.NativeToManagedMap.ContainsKey(((global::VkPresentInfoKHR.__Internal*) __Instance)->pWaitSemaphores))
                __result0 = (global::VkSemaphoreT) global::VkSemaphoreT.NativeToManagedMap[((global::VkPresentInfoKHR.__Internal*) __Instance)->pWaitSemaphores];
            else __result0 = global::VkSemaphoreT.__CreateInstance(((global::VkPresentInfoKHR.__Internal*) __Instance)->pWaitSemaphores);
            return __result0;
        }

        set
        {
            ((global::VkPresentInfoKHR.__Internal*)__Instance)->pWaitSemaphores = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint SwapchainCount
    {
        get
        {
            return ((global::VkPresentInfoKHR.__Internal*) __Instance)->swapchainCount;
        }

        set
        {
            ((global::VkPresentInfoKHR.__Internal*)__Instance)->swapchainCount = value;
        }
    }

    public global::VkSwapchainKHR_T PSwapchains
    {
        get
        {
            global::VkSwapchainKHR_T __result0;
            if (((global::VkPresentInfoKHR.__Internal*) __Instance)->pSwapchains == IntPtr.Zero) __result0 = null;
            else if (global::VkSwapchainKHR_T.NativeToManagedMap.ContainsKey(((global::VkPresentInfoKHR.__Internal*) __Instance)->pSwapchains))
                __result0 = (global::VkSwapchainKHR_T) global::VkSwapchainKHR_T.NativeToManagedMap[((global::VkPresentInfoKHR.__Internal*) __Instance)->pSwapchains];
            else __result0 = global::VkSwapchainKHR_T.__CreateInstance(((global::VkPresentInfoKHR.__Internal*) __Instance)->pSwapchains);
            return __result0;
        }

        set
        {
            ((global::VkPresentInfoKHR.__Internal*)__Instance)->pSwapchains = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint* PImageIndices
    {
        get
        {
            return (uint*) ((global::VkPresentInfoKHR.__Internal*) __Instance)->pImageIndices;
        }

        set
        {
            ((global::VkPresentInfoKHR.__Internal*)__Instance)->pImageIndices = (global::System.IntPtr) value;
        }
    }

    public global::VkResult* PResults
    {
        get
        {
            return ((global::VkPresentInfoKHR.__Internal*) __Instance)->pResults;
        }

        set
        {
            ((global::VkPresentInfoKHR.__Internal*)__Instance)->pResults = value;
        }
    }
}

public unsafe partial class VkImageSwapchainCreateInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr swapchain;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageSwapchainCreateInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSwapchainCreateInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageSwapchainCreateInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageSwapchainCreateInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageSwapchainCreateInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageSwapchainCreateInfoKHR __CreateInstance(global::VkImageSwapchainCreateInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageSwapchainCreateInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageSwapchainCreateInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageSwapchainCreateInfoKHR.__Internal));
        *(global::VkImageSwapchainCreateInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageSwapchainCreateInfoKHR(global::VkImageSwapchainCreateInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageSwapchainCreateInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageSwapchainCreateInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSwapchainCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageSwapchainCreateInfoKHR(global::VkImageSwapchainCreateInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageSwapchainCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageSwapchainCreateInfoKHR.__Internal*) __Instance) = *((global::VkImageSwapchainCreateInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageSwapchainCreateInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImageSwapchainCreateInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImageSwapchainCreateInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImageSwapchainCreateInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImageSwapchainCreateInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSwapchainKHR_T Swapchain
    {
        get
        {
            global::VkSwapchainKHR_T __result0;
            if (((global::VkImageSwapchainCreateInfoKHR.__Internal*) __Instance)->swapchain == IntPtr.Zero) __result0 = null;
            else if (global::VkSwapchainKHR_T.NativeToManagedMap.ContainsKey(((global::VkImageSwapchainCreateInfoKHR.__Internal*) __Instance)->swapchain))
                __result0 = (global::VkSwapchainKHR_T) global::VkSwapchainKHR_T.NativeToManagedMap[((global::VkImageSwapchainCreateInfoKHR.__Internal*) __Instance)->swapchain];
            else __result0 = global::VkSwapchainKHR_T.__CreateInstance(((global::VkImageSwapchainCreateInfoKHR.__Internal*) __Instance)->swapchain);
            return __result0;
        }

        set
        {
            ((global::VkImageSwapchainCreateInfoKHR.__Internal*)__Instance)->swapchain = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkBindImageMemorySwapchainInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr swapchain;

        [FieldOffset(24)]
        internal uint imageIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkBindImageMemorySwapchainInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindImageMemorySwapchainInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkBindImageMemorySwapchainInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkBindImageMemorySwapchainInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkBindImageMemorySwapchainInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkBindImageMemorySwapchainInfoKHR __CreateInstance(global::VkBindImageMemorySwapchainInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkBindImageMemorySwapchainInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkBindImageMemorySwapchainInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkBindImageMemorySwapchainInfoKHR.__Internal));
        *(global::VkBindImageMemorySwapchainInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkBindImageMemorySwapchainInfoKHR(global::VkBindImageMemorySwapchainInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkBindImageMemorySwapchainInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkBindImageMemorySwapchainInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindImageMemorySwapchainInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkBindImageMemorySwapchainInfoKHR(global::VkBindImageMemorySwapchainInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkBindImageMemorySwapchainInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkBindImageMemorySwapchainInfoKHR.__Internal*) __Instance) = *((global::VkBindImageMemorySwapchainInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkBindImageMemorySwapchainInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkBindImageMemorySwapchainInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkBindImageMemorySwapchainInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkBindImageMemorySwapchainInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkBindImageMemorySwapchainInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSwapchainKHR_T Swapchain
    {
        get
        {
            global::VkSwapchainKHR_T __result0;
            if (((global::VkBindImageMemorySwapchainInfoKHR.__Internal*) __Instance)->swapchain == IntPtr.Zero) __result0 = null;
            else if (global::VkSwapchainKHR_T.NativeToManagedMap.ContainsKey(((global::VkBindImageMemorySwapchainInfoKHR.__Internal*) __Instance)->swapchain))
                __result0 = (global::VkSwapchainKHR_T) global::VkSwapchainKHR_T.NativeToManagedMap[((global::VkBindImageMemorySwapchainInfoKHR.__Internal*) __Instance)->swapchain];
            else __result0 = global::VkSwapchainKHR_T.__CreateInstance(((global::VkBindImageMemorySwapchainInfoKHR.__Internal*) __Instance)->swapchain);
            return __result0;
        }

        set
        {
            ((global::VkBindImageMemorySwapchainInfoKHR.__Internal*)__Instance)->swapchain = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint ImageIndex
    {
        get
        {
            return ((global::VkBindImageMemorySwapchainInfoKHR.__Internal*) __Instance)->imageIndex;
        }

        set
        {
            ((global::VkBindImageMemorySwapchainInfoKHR.__Internal*)__Instance)->imageIndex = value;
        }
    }
}

public unsafe partial class VkAcquireNextImageInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr swapchain;

        [FieldOffset(24)]
        internal ulong timeout;

        [FieldOffset(32)]
        internal global::System.IntPtr semaphore;

        [FieldOffset(40)]
        internal global::System.IntPtr fence;

        [FieldOffset(48)]
        internal uint deviceMask;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkAcquireNextImageInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAcquireNextImageInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAcquireNextImageInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkAcquireNextImageInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkAcquireNextImageInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkAcquireNextImageInfoKHR __CreateInstance(global::VkAcquireNextImageInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkAcquireNextImageInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkAcquireNextImageInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkAcquireNextImageInfoKHR.__Internal));
        *(global::VkAcquireNextImageInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkAcquireNextImageInfoKHR(global::VkAcquireNextImageInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkAcquireNextImageInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkAcquireNextImageInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAcquireNextImageInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkAcquireNextImageInfoKHR(global::VkAcquireNextImageInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAcquireNextImageInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance) = *((global::VkAcquireNextImageInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkAcquireNextImageInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkAcquireNextImageInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkAcquireNextImageInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSwapchainKHR_T Swapchain
    {
        get
        {
            global::VkSwapchainKHR_T __result0;
            if (((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->swapchain == IntPtr.Zero) __result0 = null;
            else if (global::VkSwapchainKHR_T.NativeToManagedMap.ContainsKey(((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->swapchain))
                __result0 = (global::VkSwapchainKHR_T) global::VkSwapchainKHR_T.NativeToManagedMap[((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->swapchain];
            else __result0 = global::VkSwapchainKHR_T.__CreateInstance(((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->swapchain);
            return __result0;
        }

        set
        {
            ((global::VkAcquireNextImageInfoKHR.__Internal*)__Instance)->swapchain = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong Timeout
    {
        get
        {
            return ((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->timeout;
        }

        set
        {
            ((global::VkAcquireNextImageInfoKHR.__Internal*)__Instance)->timeout = value;
        }
    }

    public global::VkSemaphoreT Semaphore
    {
        get
        {
            global::VkSemaphoreT __result0;
            if (((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->semaphore == IntPtr.Zero) __result0 = null;
            else if (global::VkSemaphoreT.NativeToManagedMap.ContainsKey(((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->semaphore))
                __result0 = (global::VkSemaphoreT) global::VkSemaphoreT.NativeToManagedMap[((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->semaphore];
            else __result0 = global::VkSemaphoreT.__CreateInstance(((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->semaphore);
            return __result0;
        }

        set
        {
            ((global::VkAcquireNextImageInfoKHR.__Internal*)__Instance)->semaphore = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkFenceT Fence
    {
        get
        {
            global::VkFenceT __result0;
            if (((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->fence == IntPtr.Zero) __result0 = null;
            else if (global::VkFenceT.NativeToManagedMap.ContainsKey(((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->fence))
                __result0 = (global::VkFenceT) global::VkFenceT.NativeToManagedMap[((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->fence];
            else __result0 = global::VkFenceT.__CreateInstance(((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->fence);
            return __result0;
        }

        set
        {
            ((global::VkAcquireNextImageInfoKHR.__Internal*)__Instance)->fence = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint DeviceMask
    {
        get
        {
            return ((global::VkAcquireNextImageInfoKHR.__Internal*) __Instance)->deviceMask;
        }

        set
        {
            ((global::VkAcquireNextImageInfoKHR.__Internal*)__Instance)->deviceMask = value;
        }
    }
}

public unsafe partial class VkDeviceGroupPresentCapabilitiesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 152)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal fixed uint presentMask[32];

        [FieldOffset(144)]
        internal uint modes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGroupPresentCapabilitiesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupPresentCapabilitiesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupPresentCapabilitiesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGroupPresentCapabilitiesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupPresentCapabilitiesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGroupPresentCapabilitiesKHR __CreateInstance(global::VkDeviceGroupPresentCapabilitiesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupPresentCapabilitiesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGroupPresentCapabilitiesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupPresentCapabilitiesKHR.__Internal));
        *(global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGroupPresentCapabilitiesKHR(global::VkDeviceGroupPresentCapabilitiesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGroupPresentCapabilitiesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGroupPresentCapabilitiesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupPresentCapabilitiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGroupPresentCapabilitiesKHR(global::VkDeviceGroupPresentCapabilitiesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupPresentCapabilitiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*) __Instance) = *((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGroupPresentCapabilitiesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint[] PresentMask
    {
        get
        {
            uint[] __value = null;
            if (((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*) __Instance)->presentMask != null)
            {
                __value = new uint[32];
                for (int i = 0; i < 32; i++)
                    __value[i] = ((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*) __Instance)->presentMask[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 32; i++)
                    ((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*)__Instance)->presentMask[i] = value[i];
            }
        }
    }

    public uint Modes
    {
        get
        {
            return ((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*) __Instance)->modes;
        }

        set
        {
            ((global::VkDeviceGroupPresentCapabilitiesKHR.__Internal*)__Instance)->modes = value;
        }
    }
}

public unsafe partial class VkDeviceGroupPresentInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint swapchainCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pDeviceMasks;

        [FieldOffset(32)]
        internal global::VkDeviceGroupPresentModeFlagBitsKHR mode;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGroupPresentInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupPresentInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupPresentInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGroupPresentInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupPresentInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGroupPresentInfoKHR __CreateInstance(global::VkDeviceGroupPresentInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupPresentInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGroupPresentInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupPresentInfoKHR.__Internal));
        *(global::VkDeviceGroupPresentInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGroupPresentInfoKHR(global::VkDeviceGroupPresentInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGroupPresentInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGroupPresentInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupPresentInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGroupPresentInfoKHR(global::VkDeviceGroupPresentInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupPresentInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGroupPresentInfoKHR.__Internal*) __Instance) = *((global::VkDeviceGroupPresentInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGroupPresentInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGroupPresentInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGroupPresentInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGroupPresentInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGroupPresentInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SwapchainCount
    {
        get
        {
            return ((global::VkDeviceGroupPresentInfoKHR.__Internal*) __Instance)->swapchainCount;
        }

        set
        {
            ((global::VkDeviceGroupPresentInfoKHR.__Internal*)__Instance)->swapchainCount = value;
        }
    }

    public uint* PDeviceMasks
    {
        get
        {
            return (uint*) ((global::VkDeviceGroupPresentInfoKHR.__Internal*) __Instance)->pDeviceMasks;
        }

        set
        {
            ((global::VkDeviceGroupPresentInfoKHR.__Internal*)__Instance)->pDeviceMasks = (global::System.IntPtr) value;
        }
    }

    public global::VkDeviceGroupPresentModeFlagBitsKHR Mode
    {
        get
        {
            return ((global::VkDeviceGroupPresentInfoKHR.__Internal*) __Instance)->mode;
        }

        set
        {
            ((global::VkDeviceGroupPresentInfoKHR.__Internal*)__Instance)->mode = value;
        }
    }
}

public unsafe partial class VkDeviceGroupSwapchainCreateInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint modes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGroupSwapchainCreateInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupSwapchainCreateInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGroupSwapchainCreateInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGroupSwapchainCreateInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupSwapchainCreateInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGroupSwapchainCreateInfoKHR __CreateInstance(global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGroupSwapchainCreateInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal));
        *(global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGroupSwapchainCreateInfoKHR(global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGroupSwapchainCreateInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGroupSwapchainCreateInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGroupSwapchainCreateInfoKHR(global::VkDeviceGroupSwapchainCreateInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal*) __Instance) = *((global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGroupSwapchainCreateInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Modes
    {
        get
        {
            return ((global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal*) __Instance)->modes;
        }

        set
        {
            ((global::VkDeviceGroupSwapchainCreateInfoKHR.__Internal*)__Instance)->modes = value;
        }
    }
}

public unsafe partial class VkDisplayKHR_T
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayKHR_T> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayKHR_T>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayKHR_T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayKHR_T(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayKHR_T __CreateInstance(global::VkDisplayKHR_T.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayKHR_T(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayKHR_T.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayKHR_T.__Internal));
        *(global::VkDisplayKHR_T.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayKHR_T(global::VkDisplayKHR_T.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayKHR_T(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDisplayModeKHR_T
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModeKHR_T> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModeKHR_T>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayModeKHR_T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayModeKHR_T(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayModeKHR_T __CreateInstance(global::VkDisplayModeKHR_T.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayModeKHR_T(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayModeKHR_T.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeKHR_T.__Internal));
        *(global::VkDisplayModeKHR_T.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayModeKHR_T(global::VkDisplayModeKHR_T.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayModeKHR_T(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDisplayPropertiesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr display;

        [FieldOffset(8)]
        internal global::System.IntPtr displayName;

        [FieldOffset(16)]
        internal global::VkExtent2D.__Internal physicalDimensions;

        [FieldOffset(24)]
        internal global::VkExtent2D.__Internal physicalResolution;

        [FieldOffset(32)]
        internal uint supportedTransforms;

        [FieldOffset(36)]
        internal uint planeReorderPossible;

        [FieldOffset(40)]
        internal uint persistentContent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayPropertiesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPropertiesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPropertiesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayPropertiesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayPropertiesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayPropertiesKHR __CreateInstance(global::VkDisplayPropertiesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayPropertiesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayPropertiesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayPropertiesKHR.__Internal));
        *(global::VkDisplayPropertiesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayPropertiesKHR(global::VkDisplayPropertiesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayPropertiesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayPropertiesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayPropertiesKHR(global::VkDisplayPropertiesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayPropertiesKHR.__Internal*) __Instance) = *((global::VkDisplayPropertiesKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayPropertiesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkDisplayKHR_T Display
    {
        get
        {
            global::VkDisplayKHR_T __result0;
            if (((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->display == IntPtr.Zero) __result0 = null;
            else if (global::VkDisplayKHR_T.NativeToManagedMap.ContainsKey(((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->display))
                __result0 = (global::VkDisplayKHR_T) global::VkDisplayKHR_T.NativeToManagedMap[((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->display];
            else __result0 = global::VkDisplayKHR_T.__CreateInstance(((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->display);
            return __result0;
        }

        set
        {
            ((global::VkDisplayPropertiesKHR.__Internal*)__Instance)->display = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public string DisplayName
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->displayName);
        }

        set
        {
            ((global::VkDisplayPropertiesKHR.__Internal*)__Instance)->displayName = Marshal.StringToHGlobalAnsi(value);
        }
    }

    public global::VkExtent2D PhysicalDimensions
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->physicalDimensions));
        }

        set
        {
            ((global::VkDisplayPropertiesKHR.__Internal*)__Instance)->physicalDimensions = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D PhysicalResolution
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->physicalResolution));
        }

        set
        {
            ((global::VkDisplayPropertiesKHR.__Internal*)__Instance)->physicalResolution = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public uint SupportedTransforms
    {
        get
        {
            return ((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->supportedTransforms;
        }

        set
        {
            ((global::VkDisplayPropertiesKHR.__Internal*)__Instance)->supportedTransforms = value;
        }
    }

    public uint PlaneReorderPossible
    {
        get
        {
            return ((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->planeReorderPossible;
        }

        set
        {
            ((global::VkDisplayPropertiesKHR.__Internal*)__Instance)->planeReorderPossible = value;
        }
    }

    public uint PersistentContent
    {
        get
        {
            return ((global::VkDisplayPropertiesKHR.__Internal*) __Instance)->persistentContent;
        }

        set
        {
            ((global::VkDisplayPropertiesKHR.__Internal*)__Instance)->persistentContent = value;
        }
    }
}

public unsafe partial class VkDisplayModeParametersKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkExtent2D.__Internal visibleRegion;

        [FieldOffset(8)]
        internal uint refreshRate;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayModeParametersKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModeParametersKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModeParametersKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayModeParametersKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayModeParametersKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayModeParametersKHR __CreateInstance(global::VkDisplayModeParametersKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayModeParametersKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayModeParametersKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeParametersKHR.__Internal));
        *(global::VkDisplayModeParametersKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayModeParametersKHR(global::VkDisplayModeParametersKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayModeParametersKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayModeParametersKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeParametersKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayModeParametersKHR(global::VkDisplayModeParametersKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeParametersKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayModeParametersKHR.__Internal*) __Instance) = *((global::VkDisplayModeParametersKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayModeParametersKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkExtent2D VisibleRegion
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayModeParametersKHR.__Internal*) __Instance)->visibleRegion));
        }

        set
        {
            ((global::VkDisplayModeParametersKHR.__Internal*)__Instance)->visibleRegion = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public uint RefreshRate
    {
        get
        {
            return ((global::VkDisplayModeParametersKHR.__Internal*) __Instance)->refreshRate;
        }

        set
        {
            ((global::VkDisplayModeParametersKHR.__Internal*)__Instance)->refreshRate = value;
        }
    }
}

public unsafe partial class VkDisplayModePropertiesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr displayMode;

        [FieldOffset(8)]
        internal global::VkDisplayModeParametersKHR.__Internal parameters;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayModePropertiesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModePropertiesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModePropertiesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayModePropertiesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayModePropertiesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayModePropertiesKHR __CreateInstance(global::VkDisplayModePropertiesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayModePropertiesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayModePropertiesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayModePropertiesKHR.__Internal));
        *(global::VkDisplayModePropertiesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayModePropertiesKHR(global::VkDisplayModePropertiesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayModePropertiesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayModePropertiesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayModePropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayModePropertiesKHR(global::VkDisplayModePropertiesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayModePropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayModePropertiesKHR.__Internal*) __Instance) = *((global::VkDisplayModePropertiesKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayModePropertiesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkDisplayModeKHR_T DisplayMode
    {
        get
        {
            global::VkDisplayModeKHR_T __result0;
            if (((global::VkDisplayModePropertiesKHR.__Internal*) __Instance)->displayMode == IntPtr.Zero) __result0 = null;
            else if (global::VkDisplayModeKHR_T.NativeToManagedMap.ContainsKey(((global::VkDisplayModePropertiesKHR.__Internal*) __Instance)->displayMode))
                __result0 = (global::VkDisplayModeKHR_T) global::VkDisplayModeKHR_T.NativeToManagedMap[((global::VkDisplayModePropertiesKHR.__Internal*) __Instance)->displayMode];
            else __result0 = global::VkDisplayModeKHR_T.__CreateInstance(((global::VkDisplayModePropertiesKHR.__Internal*) __Instance)->displayMode);
            return __result0;
        }

        set
        {
            ((global::VkDisplayModePropertiesKHR.__Internal*)__Instance)->displayMode = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkDisplayModeParametersKHR Parameters
    {
        get
        {
            return global::VkDisplayModeParametersKHR.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayModePropertiesKHR.__Internal*) __Instance)->parameters));
        }

        set
        {
            ((global::VkDisplayModePropertiesKHR.__Internal*)__Instance)->parameters = ReferenceEquals(value, null) ? new global::VkDisplayModeParametersKHR.__Internal() : *(global::VkDisplayModeParametersKHR.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkDisplayModeCreateInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkDisplayModeParametersKHR.__Internal parameters;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayModeCreateInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModeCreateInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModeCreateInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayModeCreateInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayModeCreateInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayModeCreateInfoKHR __CreateInstance(global::VkDisplayModeCreateInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayModeCreateInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayModeCreateInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeCreateInfoKHR.__Internal));
        *(global::VkDisplayModeCreateInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayModeCreateInfoKHR(global::VkDisplayModeCreateInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayModeCreateInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayModeCreateInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayModeCreateInfoKHR(global::VkDisplayModeCreateInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayModeCreateInfoKHR.__Internal*) __Instance) = *((global::VkDisplayModeCreateInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayModeCreateInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplayModeCreateInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplayModeCreateInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplayModeCreateInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplayModeCreateInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDisplayModeCreateInfoKHR.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDisplayModeCreateInfoKHR.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkDisplayModeParametersKHR Parameters
    {
        get
        {
            return global::VkDisplayModeParametersKHR.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayModeCreateInfoKHR.__Internal*) __Instance)->parameters));
        }

        set
        {
            ((global::VkDisplayModeCreateInfoKHR.__Internal*)__Instance)->parameters = ReferenceEquals(value, null) ? new global::VkDisplayModeParametersKHR.__Internal() : *(global::VkDisplayModeParametersKHR.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkDisplayPlaneCapabilitiesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 68)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint supportedAlpha;

        [FieldOffset(4)]
        internal global::VkOffset2D.__Internal minSrcPosition;

        [FieldOffset(12)]
        internal global::VkOffset2D.__Internal maxSrcPosition;

        [FieldOffset(20)]
        internal global::VkExtent2D.__Internal minSrcExtent;

        [FieldOffset(28)]
        internal global::VkExtent2D.__Internal maxSrcExtent;

        [FieldOffset(36)]
        internal global::VkOffset2D.__Internal minDstPosition;

        [FieldOffset(44)]
        internal global::VkOffset2D.__Internal maxDstPosition;

        [FieldOffset(52)]
        internal global::VkExtent2D.__Internal minDstExtent;

        [FieldOffset(60)]
        internal global::VkExtent2D.__Internal maxDstExtent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayPlaneCapabilitiesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlaneCapabilitiesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlaneCapabilitiesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayPlaneCapabilitiesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayPlaneCapabilitiesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayPlaneCapabilitiesKHR __CreateInstance(global::VkDisplayPlaneCapabilitiesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayPlaneCapabilitiesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayPlaneCapabilitiesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneCapabilitiesKHR.__Internal));
        *(global::VkDisplayPlaneCapabilitiesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayPlaneCapabilitiesKHR(global::VkDisplayPlaneCapabilitiesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayPlaneCapabilitiesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayPlaneCapabilitiesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneCapabilitiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayPlaneCapabilitiesKHR(global::VkDisplayPlaneCapabilitiesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneCapabilitiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance) = *((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayPlaneCapabilitiesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint SupportedAlpha
    {
        get
        {
            return ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance)->supportedAlpha;
        }

        set
        {
            ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*)__Instance)->supportedAlpha = value;
        }
    }

    public global::VkOffset2D MinSrcPosition
    {
        get
        {
            return global::VkOffset2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance)->minSrcPosition));
        }

        set
        {
            ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*)__Instance)->minSrcPosition = ReferenceEquals(value, null) ? new global::VkOffset2D.__Internal() : *(global::VkOffset2D.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset2D MaxSrcPosition
    {
        get
        {
            return global::VkOffset2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance)->maxSrcPosition));
        }

        set
        {
            ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*)__Instance)->maxSrcPosition = ReferenceEquals(value, null) ? new global::VkOffset2D.__Internal() : *(global::VkOffset2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D MinSrcExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance)->minSrcExtent));
        }

        set
        {
            ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*)__Instance)->minSrcExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D MaxSrcExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance)->maxSrcExtent));
        }

        set
        {
            ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*)__Instance)->maxSrcExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset2D MinDstPosition
    {
        get
        {
            return global::VkOffset2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance)->minDstPosition));
        }

        set
        {
            ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*)__Instance)->minDstPosition = ReferenceEquals(value, null) ? new global::VkOffset2D.__Internal() : *(global::VkOffset2D.__Internal*) value.__Instance;
        }
    }

    public global::VkOffset2D MaxDstPosition
    {
        get
        {
            return global::VkOffset2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance)->maxDstPosition));
        }

        set
        {
            ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*)__Instance)->maxDstPosition = ReferenceEquals(value, null) ? new global::VkOffset2D.__Internal() : *(global::VkOffset2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D MinDstExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance)->minDstExtent));
        }

        set
        {
            ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*)__Instance)->minDstExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D MaxDstExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneCapabilitiesKHR.__Internal*) __Instance)->maxDstExtent));
        }

        set
        {
            ((global::VkDisplayPlaneCapabilitiesKHR.__Internal*)__Instance)->maxDstExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkDisplayPlanePropertiesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr currentDisplay;

        [FieldOffset(8)]
        internal uint currentStackIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayPlanePropertiesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlanePropertiesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlanePropertiesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayPlanePropertiesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayPlanePropertiesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayPlanePropertiesKHR __CreateInstance(global::VkDisplayPlanePropertiesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayPlanePropertiesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayPlanePropertiesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlanePropertiesKHR.__Internal));
        *(global::VkDisplayPlanePropertiesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayPlanePropertiesKHR(global::VkDisplayPlanePropertiesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayPlanePropertiesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayPlanePropertiesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlanePropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayPlanePropertiesKHR(global::VkDisplayPlanePropertiesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlanePropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayPlanePropertiesKHR.__Internal*) __Instance) = *((global::VkDisplayPlanePropertiesKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayPlanePropertiesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkDisplayKHR_T CurrentDisplay
    {
        get
        {
            global::VkDisplayKHR_T __result0;
            if (((global::VkDisplayPlanePropertiesKHR.__Internal*) __Instance)->currentDisplay == IntPtr.Zero) __result0 = null;
            else if (global::VkDisplayKHR_T.NativeToManagedMap.ContainsKey(((global::VkDisplayPlanePropertiesKHR.__Internal*) __Instance)->currentDisplay))
                __result0 = (global::VkDisplayKHR_T) global::VkDisplayKHR_T.NativeToManagedMap[((global::VkDisplayPlanePropertiesKHR.__Internal*) __Instance)->currentDisplay];
            else __result0 = global::VkDisplayKHR_T.__CreateInstance(((global::VkDisplayPlanePropertiesKHR.__Internal*) __Instance)->currentDisplay);
            return __result0;
        }

        set
        {
            ((global::VkDisplayPlanePropertiesKHR.__Internal*)__Instance)->currentDisplay = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint CurrentStackIndex
    {
        get
        {
            return ((global::VkDisplayPlanePropertiesKHR.__Internal*) __Instance)->currentStackIndex;
        }

        set
        {
            ((global::VkDisplayPlanePropertiesKHR.__Internal*)__Instance)->currentStackIndex = value;
        }
    }
}

public unsafe partial class VkDisplaySurfaceCreateInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::System.IntPtr displayMode;

        [FieldOffset(32)]
        internal uint planeIndex;

        [FieldOffset(36)]
        internal uint planeStackIndex;

        [FieldOffset(40)]
        internal global::VkSurfaceTransformFlagBitsKHR transform;

        [FieldOffset(44)]
        internal float globalAlpha;

        [FieldOffset(48)]
        internal global::VkDisplayPlaneAlphaFlagBitsKHR alphaMode;

        [FieldOffset(52)]
        internal global::VkExtent2D.__Internal imageExtent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplaySurfaceCreateInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplaySurfaceCreateInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplaySurfaceCreateInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplaySurfaceCreateInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplaySurfaceCreateInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplaySurfaceCreateInfoKHR __CreateInstance(global::VkDisplaySurfaceCreateInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplaySurfaceCreateInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplaySurfaceCreateInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplaySurfaceCreateInfoKHR.__Internal));
        *(global::VkDisplaySurfaceCreateInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplaySurfaceCreateInfoKHR(global::VkDisplaySurfaceCreateInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplaySurfaceCreateInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplaySurfaceCreateInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplaySurfaceCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplaySurfaceCreateInfoKHR(global::VkDisplaySurfaceCreateInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplaySurfaceCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance) = *((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplaySurfaceCreateInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkDisplayModeKHR_T DisplayMode
    {
        get
        {
            global::VkDisplayModeKHR_T __result0;
            if (((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->displayMode == IntPtr.Zero) __result0 = null;
            else if (global::VkDisplayModeKHR_T.NativeToManagedMap.ContainsKey(((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->displayMode))
                __result0 = (global::VkDisplayModeKHR_T) global::VkDisplayModeKHR_T.NativeToManagedMap[((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->displayMode];
            else __result0 = global::VkDisplayModeKHR_T.__CreateInstance(((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->displayMode);
            return __result0;
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->displayMode = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint PlaneIndex
    {
        get
        {
            return ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->planeIndex;
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->planeIndex = value;
        }
    }

    public uint PlaneStackIndex
    {
        get
        {
            return ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->planeStackIndex;
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->planeStackIndex = value;
        }
    }

    public global::VkSurfaceTransformFlagBitsKHR Transform
    {
        get
        {
            return ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->transform;
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->transform = value;
        }
    }

    public float GlobalAlpha
    {
        get
        {
            return ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->globalAlpha;
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->globalAlpha = value;
        }
    }

    public global::VkDisplayPlaneAlphaFlagBitsKHR AlphaMode
    {
        get
        {
            return ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->alphaMode;
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->alphaMode = value;
        }
    }

    public global::VkExtent2D ImageExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplaySurfaceCreateInfoKHR.__Internal*) __Instance)->imageExtent));
        }

        set
        {
            ((global::VkDisplaySurfaceCreateInfoKHR.__Internal*)__Instance)->imageExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkDisplayPresentInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkRect2D.__Internal srcRect;

        [FieldOffset(32)]
        internal global::VkRect2D.__Internal dstRect;

        [FieldOffset(48)]
        internal uint persistent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayPresentInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPresentInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPresentInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayPresentInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayPresentInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayPresentInfoKHR __CreateInstance(global::VkDisplayPresentInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayPresentInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayPresentInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayPresentInfoKHR.__Internal));
        *(global::VkDisplayPresentInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayPresentInfoKHR(global::VkDisplayPresentInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayPresentInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayPresentInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPresentInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayPresentInfoKHR(global::VkDisplayPresentInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPresentInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayPresentInfoKHR.__Internal*) __Instance) = *((global::VkDisplayPresentInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayPresentInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplayPresentInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplayPresentInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplayPresentInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplayPresentInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkRect2D SrcRect
    {
        get
        {
            return global::VkRect2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPresentInfoKHR.__Internal*) __Instance)->srcRect));
        }

        set
        {
            ((global::VkDisplayPresentInfoKHR.__Internal*)__Instance)->srcRect = ReferenceEquals(value, null) ? new global::VkRect2D.__Internal() : *(global::VkRect2D.__Internal*) value.__Instance;
        }
    }

    public global::VkRect2D DstRect
    {
        get
        {
            return global::VkRect2D.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPresentInfoKHR.__Internal*) __Instance)->dstRect));
        }

        set
        {
            ((global::VkDisplayPresentInfoKHR.__Internal*)__Instance)->dstRect = ReferenceEquals(value, null) ? new global::VkRect2D.__Internal() : *(global::VkRect2D.__Internal*) value.__Instance;
        }
    }

    public uint Persistent
    {
        get
        {
            return ((global::VkDisplayPresentInfoKHR.__Internal*) __Instance)->persistent;
        }

        set
        {
            ((global::VkDisplayPresentInfoKHR.__Internal*)__Instance)->persistent = value;
        }
    }
}

public unsafe partial class VkImportMemoryFdInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkExternalMemoryHandleTypeFlagBits handleType;

        [FieldOffset(20)]
        internal int fd;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImportMemoryFdInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImportMemoryFdInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImportMemoryFdInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImportMemoryFdInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImportMemoryFdInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkImportMemoryFdInfoKHR __CreateInstance(global::VkImportMemoryFdInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkImportMemoryFdInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImportMemoryFdInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImportMemoryFdInfoKHR.__Internal));
        *(global::VkImportMemoryFdInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImportMemoryFdInfoKHR(global::VkImportMemoryFdInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImportMemoryFdInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImportMemoryFdInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImportMemoryFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImportMemoryFdInfoKHR(global::VkImportMemoryFdInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImportMemoryFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImportMemoryFdInfoKHR.__Internal*) __Instance) = *((global::VkImportMemoryFdInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImportMemoryFdInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImportMemoryFdInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImportMemoryFdInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImportMemoryFdInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImportMemoryFdInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkExternalMemoryHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkImportMemoryFdInfoKHR.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkImportMemoryFdInfoKHR.__Internal*)__Instance)->handleType = value;
        }
    }

    public int Fd
    {
        get
        {
            return ((global::VkImportMemoryFdInfoKHR.__Internal*) __Instance)->fd;
        }

        set
        {
            ((global::VkImportMemoryFdInfoKHR.__Internal*)__Instance)->fd = value;
        }
    }
}

public unsafe partial class VkMemoryFdPropertiesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint memoryTypeBits;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryFdPropertiesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryFdPropertiesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryFdPropertiesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryFdPropertiesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryFdPropertiesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryFdPropertiesKHR __CreateInstance(global::VkMemoryFdPropertiesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryFdPropertiesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryFdPropertiesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryFdPropertiesKHR.__Internal));
        *(global::VkMemoryFdPropertiesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryFdPropertiesKHR(global::VkMemoryFdPropertiesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryFdPropertiesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryFdPropertiesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryFdPropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryFdPropertiesKHR(global::VkMemoryFdPropertiesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryFdPropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryFdPropertiesKHR.__Internal*) __Instance) = *((global::VkMemoryFdPropertiesKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryFdPropertiesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMemoryFdPropertiesKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMemoryFdPropertiesKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMemoryFdPropertiesKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMemoryFdPropertiesKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MemoryTypeBits
    {
        get
        {
            return ((global::VkMemoryFdPropertiesKHR.__Internal*) __Instance)->memoryTypeBits;
        }

        set
        {
            ((global::VkMemoryFdPropertiesKHR.__Internal*)__Instance)->memoryTypeBits = value;
        }
    }
}

public unsafe partial class VkMemoryGetFdInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr memory;

        [FieldOffset(24)]
        internal global::VkExternalMemoryHandleTypeFlagBits handleType;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryGetFdInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryGetFdInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryGetFdInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryGetFdInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryGetFdInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryGetFdInfoKHR __CreateInstance(global::VkMemoryGetFdInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryGetFdInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryGetFdInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryGetFdInfoKHR.__Internal));
        *(global::VkMemoryGetFdInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryGetFdInfoKHR(global::VkMemoryGetFdInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryGetFdInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryGetFdInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryGetFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryGetFdInfoKHR(global::VkMemoryGetFdInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryGetFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryGetFdInfoKHR.__Internal*) __Instance) = *((global::VkMemoryGetFdInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryGetFdInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMemoryGetFdInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMemoryGetFdInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMemoryGetFdInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMemoryGetFdInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDeviceMemoryT Memory
    {
        get
        {
            global::VkDeviceMemoryT __result0;
            if (((global::VkMemoryGetFdInfoKHR.__Internal*) __Instance)->memory == IntPtr.Zero) __result0 = null;
            else if (global::VkDeviceMemoryT.NativeToManagedMap.ContainsKey(((global::VkMemoryGetFdInfoKHR.__Internal*) __Instance)->memory))
                __result0 = (global::VkDeviceMemoryT) global::VkDeviceMemoryT.NativeToManagedMap[((global::VkMemoryGetFdInfoKHR.__Internal*) __Instance)->memory];
            else __result0 = global::VkDeviceMemoryT.__CreateInstance(((global::VkMemoryGetFdInfoKHR.__Internal*) __Instance)->memory);
            return __result0;
        }

        set
        {
            ((global::VkMemoryGetFdInfoKHR.__Internal*)__Instance)->memory = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkExternalMemoryHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkMemoryGetFdInfoKHR.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkMemoryGetFdInfoKHR.__Internal*)__Instance)->handleType = value;
        }
    }
}

public unsafe partial class VkImportSemaphoreFdInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr semaphore;

        [FieldOffset(24)]
        internal uint flags;

        [FieldOffset(28)]
        internal global::VkExternalSemaphoreHandleTypeFlagBits handleType;

        [FieldOffset(32)]
        internal int fd;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImportSemaphoreFdInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImportSemaphoreFdInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImportSemaphoreFdInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImportSemaphoreFdInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImportSemaphoreFdInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkImportSemaphoreFdInfoKHR __CreateInstance(global::VkImportSemaphoreFdInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkImportSemaphoreFdInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImportSemaphoreFdInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImportSemaphoreFdInfoKHR.__Internal));
        *(global::VkImportSemaphoreFdInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImportSemaphoreFdInfoKHR(global::VkImportSemaphoreFdInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImportSemaphoreFdInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImportSemaphoreFdInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImportSemaphoreFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImportSemaphoreFdInfoKHR(global::VkImportSemaphoreFdInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImportSemaphoreFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance) = *((global::VkImportSemaphoreFdInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImportSemaphoreFdInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImportSemaphoreFdInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImportSemaphoreFdInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSemaphoreT Semaphore
    {
        get
        {
            global::VkSemaphoreT __result0;
            if (((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance)->semaphore == IntPtr.Zero) __result0 = null;
            else if (global::VkSemaphoreT.NativeToManagedMap.ContainsKey(((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance)->semaphore))
                __result0 = (global::VkSemaphoreT) global::VkSemaphoreT.NativeToManagedMap[((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance)->semaphore];
            else __result0 = global::VkSemaphoreT.__CreateInstance(((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance)->semaphore);
            return __result0;
        }

        set
        {
            ((global::VkImportSemaphoreFdInfoKHR.__Internal*)__Instance)->semaphore = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkImportSemaphoreFdInfoKHR.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkExternalSemaphoreHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkImportSemaphoreFdInfoKHR.__Internal*)__Instance)->handleType = value;
        }
    }

    public int Fd
    {
        get
        {
            return ((global::VkImportSemaphoreFdInfoKHR.__Internal*) __Instance)->fd;
        }

        set
        {
            ((global::VkImportSemaphoreFdInfoKHR.__Internal*)__Instance)->fd = value;
        }
    }
}

public unsafe partial class VkSemaphoreGetFdInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr semaphore;

        [FieldOffset(24)]
        internal global::VkExternalSemaphoreHandleTypeFlagBits handleType;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSemaphoreGetFdInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSemaphoreGetFdInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSemaphoreGetFdInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSemaphoreGetFdInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSemaphoreGetFdInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSemaphoreGetFdInfoKHR __CreateInstance(global::VkSemaphoreGetFdInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSemaphoreGetFdInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSemaphoreGetFdInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSemaphoreGetFdInfoKHR.__Internal));
        *(global::VkSemaphoreGetFdInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSemaphoreGetFdInfoKHR(global::VkSemaphoreGetFdInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSemaphoreGetFdInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSemaphoreGetFdInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSemaphoreGetFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSemaphoreGetFdInfoKHR(global::VkSemaphoreGetFdInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSemaphoreGetFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSemaphoreGetFdInfoKHR.__Internal*) __Instance) = *((global::VkSemaphoreGetFdInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSemaphoreGetFdInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSemaphoreGetFdInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSemaphoreGetFdInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSemaphoreGetFdInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSemaphoreGetFdInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSemaphoreT Semaphore
    {
        get
        {
            global::VkSemaphoreT __result0;
            if (((global::VkSemaphoreGetFdInfoKHR.__Internal*) __Instance)->semaphore == IntPtr.Zero) __result0 = null;
            else if (global::VkSemaphoreT.NativeToManagedMap.ContainsKey(((global::VkSemaphoreGetFdInfoKHR.__Internal*) __Instance)->semaphore))
                __result0 = (global::VkSemaphoreT) global::VkSemaphoreT.NativeToManagedMap[((global::VkSemaphoreGetFdInfoKHR.__Internal*) __Instance)->semaphore];
            else __result0 = global::VkSemaphoreT.__CreateInstance(((global::VkSemaphoreGetFdInfoKHR.__Internal*) __Instance)->semaphore);
            return __result0;
        }

        set
        {
            ((global::VkSemaphoreGetFdInfoKHR.__Internal*)__Instance)->semaphore = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkExternalSemaphoreHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkSemaphoreGetFdInfoKHR.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkSemaphoreGetFdInfoKHR.__Internal*)__Instance)->handleType = value;
        }
    }
}

public unsafe partial class VkPhysicalDevicePushDescriptorPropertiesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint maxPushDescriptors;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDevicePushDescriptorPropertiesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDevicePushDescriptorPropertiesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDevicePushDescriptorPropertiesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDevicePushDescriptorPropertiesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDevicePushDescriptorPropertiesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDevicePushDescriptorPropertiesKHR __CreateInstance(global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDevicePushDescriptorPropertiesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal));
        *(global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDevicePushDescriptorPropertiesKHR(global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDevicePushDescriptorPropertiesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDevicePushDescriptorPropertiesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDevicePushDescriptorPropertiesKHR(global::VkPhysicalDevicePushDescriptorPropertiesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal*) __Instance) = *((global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDevicePushDescriptorPropertiesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MaxPushDescriptors
    {
        get
        {
            return ((global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal*) __Instance)->maxPushDescriptors;
        }

        set
        {
            ((global::VkPhysicalDevicePushDescriptorPropertiesKHR.__Internal*)__Instance)->maxPushDescriptors = value;
        }
    }
}

public unsafe partial class VkRectLayerKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkOffset2D.__Internal offset;

        [FieldOffset(8)]
        internal global::VkExtent2D.__Internal extent;

        [FieldOffset(16)]
        internal uint layer;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkRectLayerKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRectLayerKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRectLayerKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRectLayerKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRectLayerKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkRectLayerKHR __CreateInstance(global::VkRectLayerKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkRectLayerKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRectLayerKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRectLayerKHR.__Internal));
        *(global::VkRectLayerKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRectLayerKHR(global::VkRectLayerKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRectLayerKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkRectLayerKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRectLayerKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkRectLayerKHR(global::VkRectLayerKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRectLayerKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkRectLayerKHR.__Internal*) __Instance) = *((global::VkRectLayerKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkRectLayerKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkOffset2D Offset
    {
        get
        {
            return global::VkOffset2D.__CreateInstance(new global::System.IntPtr(&((global::VkRectLayerKHR.__Internal*) __Instance)->offset));
        }

        set
        {
            ((global::VkRectLayerKHR.__Internal*)__Instance)->offset = ReferenceEquals(value, null) ? new global::VkOffset2D.__Internal() : *(global::VkOffset2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D Extent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkRectLayerKHR.__Internal*) __Instance)->extent));
        }

        set
        {
            ((global::VkRectLayerKHR.__Internal*)__Instance)->extent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public uint Layer
    {
        get
        {
            return ((global::VkRectLayerKHR.__Internal*) __Instance)->layer;
        }

        set
        {
            ((global::VkRectLayerKHR.__Internal*)__Instance)->layer = value;
        }
    }
}

public unsafe partial class VkPresentRegionKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint rectangleCount;

        [FieldOffset(8)]
        internal global::System.IntPtr pRectangles;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPresentRegionKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentRegionKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentRegionKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPresentRegionKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPresentRegionKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkPresentRegionKHR __CreateInstance(global::VkPresentRegionKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkPresentRegionKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPresentRegionKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPresentRegionKHR.__Internal));
        *(global::VkPresentRegionKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPresentRegionKHR(global::VkPresentRegionKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPresentRegionKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPresentRegionKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentRegionKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPresentRegionKHR(global::VkPresentRegionKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentRegionKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPresentRegionKHR.__Internal*) __Instance) = *((global::VkPresentRegionKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPresentRegionKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint RectangleCount
    {
        get
        {
            return ((global::VkPresentRegionKHR.__Internal*) __Instance)->rectangleCount;
        }

        set
        {
            ((global::VkPresentRegionKHR.__Internal*)__Instance)->rectangleCount = value;
        }
    }

    public global::VkRectLayerKHR PRectangles
    {
        get
        {
            global::VkRectLayerKHR __result0;
            if (((global::VkPresentRegionKHR.__Internal*) __Instance)->pRectangles == IntPtr.Zero) __result0 = null;
            else if (global::VkRectLayerKHR.NativeToManagedMap.ContainsKey(((global::VkPresentRegionKHR.__Internal*) __Instance)->pRectangles))
                __result0 = (global::VkRectLayerKHR) global::VkRectLayerKHR.NativeToManagedMap[((global::VkPresentRegionKHR.__Internal*) __Instance)->pRectangles];
            else __result0 = global::VkRectLayerKHR.__CreateInstance(((global::VkPresentRegionKHR.__Internal*) __Instance)->pRectangles);
            return __result0;
        }

        set
        {
            ((global::VkPresentRegionKHR.__Internal*)__Instance)->pRectangles = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkPresentRegionsKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint swapchainCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pRegions;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPresentRegionsKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentRegionsKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentRegionsKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPresentRegionsKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPresentRegionsKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkPresentRegionsKHR __CreateInstance(global::VkPresentRegionsKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkPresentRegionsKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPresentRegionsKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPresentRegionsKHR.__Internal));
        *(global::VkPresentRegionsKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPresentRegionsKHR(global::VkPresentRegionsKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPresentRegionsKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPresentRegionsKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentRegionsKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPresentRegionsKHR(global::VkPresentRegionsKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentRegionsKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPresentRegionsKHR.__Internal*) __Instance) = *((global::VkPresentRegionsKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPresentRegionsKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPresentRegionsKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPresentRegionsKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPresentRegionsKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPresentRegionsKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SwapchainCount
    {
        get
        {
            return ((global::VkPresentRegionsKHR.__Internal*) __Instance)->swapchainCount;
        }

        set
        {
            ((global::VkPresentRegionsKHR.__Internal*)__Instance)->swapchainCount = value;
        }
    }

    public global::VkPresentRegionKHR PRegions
    {
        get
        {
            global::VkPresentRegionKHR __result0;
            if (((global::VkPresentRegionsKHR.__Internal*) __Instance)->pRegions == IntPtr.Zero) __result0 = null;
            else if (global::VkPresentRegionKHR.NativeToManagedMap.ContainsKey(((global::VkPresentRegionsKHR.__Internal*) __Instance)->pRegions))
                __result0 = (global::VkPresentRegionKHR) global::VkPresentRegionKHR.NativeToManagedMap[((global::VkPresentRegionsKHR.__Internal*) __Instance)->pRegions];
            else __result0 = global::VkPresentRegionKHR.__CreateInstance(((global::VkPresentRegionsKHR.__Internal*) __Instance)->pRegions);
            return __result0;
        }

        set
        {
            ((global::VkPresentRegionsKHR.__Internal*)__Instance)->pRegions = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkAttachmentDescription2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkFormat format;

        [FieldOffset(24)]
        internal global::VkSampleCountFlagBits samples;

        [FieldOffset(28)]
        internal global::VkAttachmentLoadOp loadOp;

        [FieldOffset(32)]
        internal global::VkAttachmentStoreOp storeOp;

        [FieldOffset(36)]
        internal global::VkAttachmentLoadOp stencilLoadOp;

        [FieldOffset(40)]
        internal global::VkAttachmentStoreOp stencilStoreOp;

        [FieldOffset(44)]
        internal global::VkImageLayout initialLayout;

        [FieldOffset(48)]
        internal global::VkImageLayout finalLayout;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkAttachmentDescription2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentDescription2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentDescription2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkAttachmentDescription2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkAttachmentDescription2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkAttachmentDescription2KHR __CreateInstance(global::VkAttachmentDescription2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkAttachmentDescription2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkAttachmentDescription2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkAttachmentDescription2KHR.__Internal));
        *(global::VkAttachmentDescription2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkAttachmentDescription2KHR(global::VkAttachmentDescription2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkAttachmentDescription2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkAttachmentDescription2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentDescription2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkAttachmentDescription2KHR(global::VkAttachmentDescription2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentDescription2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkAttachmentDescription2KHR.__Internal*) __Instance) = *((global::VkAttachmentDescription2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkAttachmentDescription2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkFormat Format
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->format;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->format = value;
        }
    }

    public global::VkSampleCountFlagBits Samples
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->samples;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->samples = value;
        }
    }

    public global::VkAttachmentLoadOp LoadOp
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->loadOp;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->loadOp = value;
        }
    }

    public global::VkAttachmentStoreOp StoreOp
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->storeOp;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->storeOp = value;
        }
    }

    public global::VkAttachmentLoadOp StencilLoadOp
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->stencilLoadOp;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->stencilLoadOp = value;
        }
    }

    public global::VkAttachmentStoreOp StencilStoreOp
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->stencilStoreOp;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->stencilStoreOp = value;
        }
    }

    public global::VkImageLayout InitialLayout
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->initialLayout;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->initialLayout = value;
        }
    }

    public global::VkImageLayout FinalLayout
    {
        get
        {
            return ((global::VkAttachmentDescription2KHR.__Internal*) __Instance)->finalLayout;
        }

        set
        {
            ((global::VkAttachmentDescription2KHR.__Internal*)__Instance)->finalLayout = value;
        }
    }
}

public unsafe partial class VkAttachmentReference2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint attachment;

        [FieldOffset(20)]
        internal global::VkImageLayout layout;

        [FieldOffset(24)]
        internal uint aspectMask;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkAttachmentReference2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentReference2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentReference2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkAttachmentReference2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkAttachmentReference2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkAttachmentReference2KHR __CreateInstance(global::VkAttachmentReference2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkAttachmentReference2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkAttachmentReference2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkAttachmentReference2KHR.__Internal));
        *(global::VkAttachmentReference2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkAttachmentReference2KHR(global::VkAttachmentReference2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkAttachmentReference2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkAttachmentReference2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentReference2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkAttachmentReference2KHR(global::VkAttachmentReference2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentReference2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkAttachmentReference2KHR.__Internal*) __Instance) = *((global::VkAttachmentReference2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkAttachmentReference2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkAttachmentReference2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkAttachmentReference2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkAttachmentReference2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkAttachmentReference2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Attachment
    {
        get
        {
            return ((global::VkAttachmentReference2KHR.__Internal*) __Instance)->attachment;
        }

        set
        {
            ((global::VkAttachmentReference2KHR.__Internal*)__Instance)->attachment = value;
        }
    }

    public global::VkImageLayout Layout
    {
        get
        {
            return ((global::VkAttachmentReference2KHR.__Internal*) __Instance)->layout;
        }

        set
        {
            ((global::VkAttachmentReference2KHR.__Internal*)__Instance)->layout = value;
        }
    }

    public uint AspectMask
    {
        get
        {
            return ((global::VkAttachmentReference2KHR.__Internal*) __Instance)->aspectMask;
        }

        set
        {
            ((global::VkAttachmentReference2KHR.__Internal*)__Instance)->aspectMask = value;
        }
    }
}

public unsafe partial class VkSubpassDescription2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 88)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkPipelineBindPoint pipelineBindPoint;

        [FieldOffset(24)]
        internal uint viewMask;

        [FieldOffset(28)]
        internal uint inputAttachmentCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pInputAttachments;

        [FieldOffset(40)]
        internal uint colorAttachmentCount;

        [FieldOffset(48)]
        internal global::System.IntPtr pColorAttachments;

        [FieldOffset(56)]
        internal global::System.IntPtr pResolveAttachments;

        [FieldOffset(64)]
        internal global::System.IntPtr pDepthStencilAttachment;

        [FieldOffset(72)]
        internal uint preserveAttachmentCount;

        [FieldOffset(80)]
        internal global::System.IntPtr pPreserveAttachments;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSubpassDescription2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassDescription2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassDescription2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSubpassDescription2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSubpassDescription2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSubpassDescription2KHR __CreateInstance(global::VkSubpassDescription2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSubpassDescription2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSubpassDescription2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSubpassDescription2KHR.__Internal));
        *(global::VkSubpassDescription2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSubpassDescription2KHR(global::VkSubpassDescription2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSubpassDescription2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSubpassDescription2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassDescription2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSubpassDescription2KHR(global::VkSubpassDescription2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassDescription2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSubpassDescription2KHR.__Internal*) __Instance) = *((global::VkSubpassDescription2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSubpassDescription2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSubpassDescription2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkSubpassDescription2KHR.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkPipelineBindPoint PipelineBindPoint
    {
        get
        {
            return ((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pipelineBindPoint;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->pipelineBindPoint = value;
        }
    }

    public uint ViewMask
    {
        get
        {
            return ((global::VkSubpassDescription2KHR.__Internal*) __Instance)->viewMask;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->viewMask = value;
        }
    }

    public uint InputAttachmentCount
    {
        get
        {
            return ((global::VkSubpassDescription2KHR.__Internal*) __Instance)->inputAttachmentCount;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->inputAttachmentCount = value;
        }
    }

    public global::VkAttachmentReference2KHR PInputAttachments
    {
        get
        {
            global::VkAttachmentReference2KHR __result0;
            if (((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pInputAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentReference2KHR.NativeToManagedMap.ContainsKey(((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pInputAttachments))
                __result0 = (global::VkAttachmentReference2KHR) global::VkAttachmentReference2KHR.NativeToManagedMap[((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pInputAttachments];
            else __result0 = global::VkAttachmentReference2KHR.__CreateInstance(((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pInputAttachments);
            return __result0;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->pInputAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint ColorAttachmentCount
    {
        get
        {
            return ((global::VkSubpassDescription2KHR.__Internal*) __Instance)->colorAttachmentCount;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->colorAttachmentCount = value;
        }
    }

    public global::VkAttachmentReference2KHR PColorAttachments
    {
        get
        {
            global::VkAttachmentReference2KHR __result0;
            if (((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pColorAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentReference2KHR.NativeToManagedMap.ContainsKey(((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pColorAttachments))
                __result0 = (global::VkAttachmentReference2KHR) global::VkAttachmentReference2KHR.NativeToManagedMap[((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pColorAttachments];
            else __result0 = global::VkAttachmentReference2KHR.__CreateInstance(((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pColorAttachments);
            return __result0;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->pColorAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkAttachmentReference2KHR PResolveAttachments
    {
        get
        {
            global::VkAttachmentReference2KHR __result0;
            if (((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pResolveAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentReference2KHR.NativeToManagedMap.ContainsKey(((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pResolveAttachments))
                __result0 = (global::VkAttachmentReference2KHR) global::VkAttachmentReference2KHR.NativeToManagedMap[((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pResolveAttachments];
            else __result0 = global::VkAttachmentReference2KHR.__CreateInstance(((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pResolveAttachments);
            return __result0;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->pResolveAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkAttachmentReference2KHR PDepthStencilAttachment
    {
        get
        {
            global::VkAttachmentReference2KHR __result0;
            if (((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pDepthStencilAttachment == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentReference2KHR.NativeToManagedMap.ContainsKey(((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pDepthStencilAttachment))
                __result0 = (global::VkAttachmentReference2KHR) global::VkAttachmentReference2KHR.NativeToManagedMap[((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pDepthStencilAttachment];
            else __result0 = global::VkAttachmentReference2KHR.__CreateInstance(((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pDepthStencilAttachment);
            return __result0;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->pDepthStencilAttachment = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint PreserveAttachmentCount
    {
        get
        {
            return ((global::VkSubpassDescription2KHR.__Internal*) __Instance)->preserveAttachmentCount;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->preserveAttachmentCount = value;
        }
    }

    public uint* PPreserveAttachments
    {
        get
        {
            return (uint*) ((global::VkSubpassDescription2KHR.__Internal*) __Instance)->pPreserveAttachments;
        }

        set
        {
            ((global::VkSubpassDescription2KHR.__Internal*)__Instance)->pPreserveAttachments = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkSubpassDependency2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint srcSubpass;

        [FieldOffset(20)]
        internal uint dstSubpass;

        [FieldOffset(24)]
        internal uint srcStageMask;

        [FieldOffset(28)]
        internal uint dstStageMask;

        [FieldOffset(32)]
        internal uint srcAccessMask;

        [FieldOffset(36)]
        internal uint dstAccessMask;

        [FieldOffset(40)]
        internal uint dependencyFlags;

        [FieldOffset(44)]
        internal int viewOffset;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSubpassDependency2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassDependency2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassDependency2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSubpassDependency2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSubpassDependency2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSubpassDependency2KHR __CreateInstance(global::VkSubpassDependency2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSubpassDependency2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSubpassDependency2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSubpassDependency2KHR.__Internal));
        *(global::VkSubpassDependency2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSubpassDependency2KHR(global::VkSubpassDependency2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSubpassDependency2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSubpassDependency2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassDependency2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSubpassDependency2KHR(global::VkSubpassDependency2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassDependency2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSubpassDependency2KHR.__Internal*) __Instance) = *((global::VkSubpassDependency2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSubpassDependency2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SrcSubpass
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->srcSubpass;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->srcSubpass = value;
        }
    }

    public uint DstSubpass
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->dstSubpass;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->dstSubpass = value;
        }
    }

    public uint SrcStageMask
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->srcStageMask;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->srcStageMask = value;
        }
    }

    public uint DstStageMask
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->dstStageMask;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->dstStageMask = value;
        }
    }

    public uint SrcAccessMask
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->srcAccessMask;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->srcAccessMask = value;
        }
    }

    public uint DstAccessMask
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->dstAccessMask;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->dstAccessMask = value;
        }
    }

    public uint DependencyFlags
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->dependencyFlags;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->dependencyFlags = value;
        }
    }

    public int ViewOffset
    {
        get
        {
            return ((global::VkSubpassDependency2KHR.__Internal*) __Instance)->viewOffset;
        }

        set
        {
            ((global::VkSubpassDependency2KHR.__Internal*)__Instance)->viewOffset = value;
        }
    }
}

public unsafe partial class VkRenderPassCreateInfo2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint attachmentCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pAttachments;

        [FieldOffset(32)]
        internal uint subpassCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pSubpasses;

        [FieldOffset(48)]
        internal uint dependencyCount;

        [FieldOffset(56)]
        internal global::System.IntPtr pDependencies;

        [FieldOffset(64)]
        internal uint correlatedViewMaskCount;

        [FieldOffset(72)]
        internal global::System.IntPtr pCorrelatedViewMasks;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkRenderPassCreateInfo2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassCreateInfo2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassCreateInfo2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRenderPassCreateInfo2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRenderPassCreateInfo2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkRenderPassCreateInfo2KHR __CreateInstance(global::VkRenderPassCreateInfo2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkRenderPassCreateInfo2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRenderPassCreateInfo2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRenderPassCreateInfo2KHR.__Internal));
        *(global::VkRenderPassCreateInfo2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRenderPassCreateInfo2KHR(global::VkRenderPassCreateInfo2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRenderPassCreateInfo2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkRenderPassCreateInfo2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassCreateInfo2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkRenderPassCreateInfo2KHR(global::VkRenderPassCreateInfo2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassCreateInfo2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance) = *((global::VkRenderPassCreateInfo2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkRenderPassCreateInfo2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->flags = value;
        }
    }

    public uint AttachmentCount
    {
        get
        {
            return ((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->attachmentCount;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->attachmentCount = value;
        }
    }

    public global::VkAttachmentDescription2KHR PAttachments
    {
        get
        {
            global::VkAttachmentDescription2KHR __result0;
            if (((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pAttachments == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentDescription2KHR.NativeToManagedMap.ContainsKey(((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pAttachments))
                __result0 = (global::VkAttachmentDescription2KHR) global::VkAttachmentDescription2KHR.NativeToManagedMap[((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pAttachments];
            else __result0 = global::VkAttachmentDescription2KHR.__CreateInstance(((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pAttachments);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->pAttachments = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint SubpassCount
    {
        get
        {
            return ((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->subpassCount;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->subpassCount = value;
        }
    }

    public global::VkSubpassDescription2KHR PSubpasses
    {
        get
        {
            global::VkSubpassDescription2KHR __result0;
            if (((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pSubpasses == IntPtr.Zero) __result0 = null;
            else if (global::VkSubpassDescription2KHR.NativeToManagedMap.ContainsKey(((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pSubpasses))
                __result0 = (global::VkSubpassDescription2KHR) global::VkSubpassDescription2KHR.NativeToManagedMap[((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pSubpasses];
            else __result0 = global::VkSubpassDescription2KHR.__CreateInstance(((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pSubpasses);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->pSubpasses = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint DependencyCount
    {
        get
        {
            return ((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->dependencyCount;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->dependencyCount = value;
        }
    }

    public global::VkSubpassDependency2KHR PDependencies
    {
        get
        {
            global::VkSubpassDependency2KHR __result0;
            if (((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pDependencies == IntPtr.Zero) __result0 = null;
            else if (global::VkSubpassDependency2KHR.NativeToManagedMap.ContainsKey(((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pDependencies))
                __result0 = (global::VkSubpassDependency2KHR) global::VkSubpassDependency2KHR.NativeToManagedMap[((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pDependencies];
            else __result0 = global::VkSubpassDependency2KHR.__CreateInstance(((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pDependencies);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->pDependencies = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint CorrelatedViewMaskCount
    {
        get
        {
            return ((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->correlatedViewMaskCount;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->correlatedViewMaskCount = value;
        }
    }

    public uint* PCorrelatedViewMasks
    {
        get
        {
            return (uint*) ((global::VkRenderPassCreateInfo2KHR.__Internal*) __Instance)->pCorrelatedViewMasks;
        }

        set
        {
            ((global::VkRenderPassCreateInfo2KHR.__Internal*)__Instance)->pCorrelatedViewMasks = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkSubpassBeginInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkSubpassContents contents;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSubpassBeginInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassBeginInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassBeginInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSubpassBeginInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSubpassBeginInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSubpassBeginInfoKHR __CreateInstance(global::VkSubpassBeginInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSubpassBeginInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSubpassBeginInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSubpassBeginInfoKHR.__Internal));
        *(global::VkSubpassBeginInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSubpassBeginInfoKHR(global::VkSubpassBeginInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSubpassBeginInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSubpassBeginInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassBeginInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSubpassBeginInfoKHR(global::VkSubpassBeginInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassBeginInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSubpassBeginInfoKHR.__Internal*) __Instance) = *((global::VkSubpassBeginInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSubpassBeginInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSubpassBeginInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSubpassBeginInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSubpassBeginInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSubpassBeginInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSubpassContents Contents
    {
        get
        {
            return ((global::VkSubpassBeginInfoKHR.__Internal*) __Instance)->contents;
        }

        set
        {
            ((global::VkSubpassBeginInfoKHR.__Internal*)__Instance)->contents = value;
        }
    }
}

public unsafe partial class VkSubpassEndInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSubpassEndInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassEndInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassEndInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSubpassEndInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSubpassEndInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSubpassEndInfoKHR __CreateInstance(global::VkSubpassEndInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSubpassEndInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSubpassEndInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSubpassEndInfoKHR.__Internal));
        *(global::VkSubpassEndInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSubpassEndInfoKHR(global::VkSubpassEndInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSubpassEndInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSubpassEndInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassEndInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSubpassEndInfoKHR(global::VkSubpassEndInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassEndInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSubpassEndInfoKHR.__Internal*) __Instance) = *((global::VkSubpassEndInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSubpassEndInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSubpassEndInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSubpassEndInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSubpassEndInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSubpassEndInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkSharedPresentSurfaceCapabilitiesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint sharedPresentSupportedUsageFlags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSharedPresentSurfaceCapabilitiesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSharedPresentSurfaceCapabilitiesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSharedPresentSurfaceCapabilitiesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSharedPresentSurfaceCapabilitiesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSharedPresentSurfaceCapabilitiesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSharedPresentSurfaceCapabilitiesKHR __CreateInstance(global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSharedPresentSurfaceCapabilitiesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal));
        *(global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSharedPresentSurfaceCapabilitiesKHR(global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSharedPresentSurfaceCapabilitiesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSharedPresentSurfaceCapabilitiesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSharedPresentSurfaceCapabilitiesKHR(global::VkSharedPresentSurfaceCapabilitiesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal*) __Instance) = *((global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSharedPresentSurfaceCapabilitiesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SharedPresentSupportedUsageFlags
    {
        get
        {
            return ((global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal*) __Instance)->sharedPresentSupportedUsageFlags;
        }

        set
        {
            ((global::VkSharedPresentSurfaceCapabilitiesKHR.__Internal*)__Instance)->sharedPresentSupportedUsageFlags = value;
        }
    }
}

public unsafe partial class VkImportFenceFdInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr fence;

        [FieldOffset(24)]
        internal uint flags;

        [FieldOffset(28)]
        internal global::VkExternalFenceHandleTypeFlagBits handleType;

        [FieldOffset(32)]
        internal int fd;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImportFenceFdInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImportFenceFdInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImportFenceFdInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImportFenceFdInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImportFenceFdInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkImportFenceFdInfoKHR __CreateInstance(global::VkImportFenceFdInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkImportFenceFdInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImportFenceFdInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImportFenceFdInfoKHR.__Internal));
        *(global::VkImportFenceFdInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImportFenceFdInfoKHR(global::VkImportFenceFdInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImportFenceFdInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImportFenceFdInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImportFenceFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImportFenceFdInfoKHR(global::VkImportFenceFdInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImportFenceFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImportFenceFdInfoKHR.__Internal*) __Instance) = *((global::VkImportFenceFdInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImportFenceFdInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImportFenceFdInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImportFenceFdInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImportFenceFdInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImportFenceFdInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkFenceT Fence
    {
        get
        {
            global::VkFenceT __result0;
            if (((global::VkImportFenceFdInfoKHR.__Internal*) __Instance)->fence == IntPtr.Zero) __result0 = null;
            else if (global::VkFenceT.NativeToManagedMap.ContainsKey(((global::VkImportFenceFdInfoKHR.__Internal*) __Instance)->fence))
                __result0 = (global::VkFenceT) global::VkFenceT.NativeToManagedMap[((global::VkImportFenceFdInfoKHR.__Internal*) __Instance)->fence];
            else __result0 = global::VkFenceT.__CreateInstance(((global::VkImportFenceFdInfoKHR.__Internal*) __Instance)->fence);
            return __result0;
        }

        set
        {
            ((global::VkImportFenceFdInfoKHR.__Internal*)__Instance)->fence = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkImportFenceFdInfoKHR.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkImportFenceFdInfoKHR.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkExternalFenceHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkImportFenceFdInfoKHR.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkImportFenceFdInfoKHR.__Internal*)__Instance)->handleType = value;
        }
    }

    public int Fd
    {
        get
        {
            return ((global::VkImportFenceFdInfoKHR.__Internal*) __Instance)->fd;
        }

        set
        {
            ((global::VkImportFenceFdInfoKHR.__Internal*)__Instance)->fd = value;
        }
    }
}

public unsafe partial class VkFenceGetFdInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr fence;

        [FieldOffset(24)]
        internal global::VkExternalFenceHandleTypeFlagBits handleType;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkFenceGetFdInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFenceGetFdInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkFenceGetFdInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkFenceGetFdInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkFenceGetFdInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkFenceGetFdInfoKHR __CreateInstance(global::VkFenceGetFdInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkFenceGetFdInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkFenceGetFdInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkFenceGetFdInfoKHR.__Internal));
        *(global::VkFenceGetFdInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkFenceGetFdInfoKHR(global::VkFenceGetFdInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkFenceGetFdInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkFenceGetFdInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFenceGetFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkFenceGetFdInfoKHR(global::VkFenceGetFdInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkFenceGetFdInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkFenceGetFdInfoKHR.__Internal*) __Instance) = *((global::VkFenceGetFdInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkFenceGetFdInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkFenceGetFdInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkFenceGetFdInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkFenceGetFdInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkFenceGetFdInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkFenceT Fence
    {
        get
        {
            global::VkFenceT __result0;
            if (((global::VkFenceGetFdInfoKHR.__Internal*) __Instance)->fence == IntPtr.Zero) __result0 = null;
            else if (global::VkFenceT.NativeToManagedMap.ContainsKey(((global::VkFenceGetFdInfoKHR.__Internal*) __Instance)->fence))
                __result0 = (global::VkFenceT) global::VkFenceT.NativeToManagedMap[((global::VkFenceGetFdInfoKHR.__Internal*) __Instance)->fence];
            else __result0 = global::VkFenceT.__CreateInstance(((global::VkFenceGetFdInfoKHR.__Internal*) __Instance)->fence);
            return __result0;
        }

        set
        {
            ((global::VkFenceGetFdInfoKHR.__Internal*)__Instance)->fence = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkExternalFenceHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkFenceGetFdInfoKHR.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkFenceGetFdInfoKHR.__Internal*)__Instance)->handleType = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceSurfaceInfo2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr surface;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceSurfaceInfo2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSurfaceInfo2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSurfaceInfo2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceSurfaceInfo2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSurfaceInfo2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceSurfaceInfo2KHR __CreateInstance(global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSurfaceInfo2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal));
        *(global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceSurfaceInfo2KHR(global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceSurfaceInfo2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceSurfaceInfo2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceSurfaceInfo2KHR(global::VkPhysicalDeviceSurfaceInfo2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*) __Instance) = *((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceSurfaceInfo2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSurfaceKHR_T Surface
    {
        get
        {
            global::VkSurfaceKHR_T __result0;
            if (((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*) __Instance)->surface == IntPtr.Zero) __result0 = null;
            else if (global::VkSurfaceKHR_T.NativeToManagedMap.ContainsKey(((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*) __Instance)->surface))
                __result0 = (global::VkSurfaceKHR_T) global::VkSurfaceKHR_T.NativeToManagedMap[((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*) __Instance)->surface];
            else __result0 = global::VkSurfaceKHR_T.__CreateInstance(((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*) __Instance)->surface);
            return __result0;
        }

        set
        {
            ((global::VkPhysicalDeviceSurfaceInfo2KHR.__Internal*)__Instance)->surface = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkSurfaceCapabilities2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkSurfaceCapabilitiesKHR.__Internal surfaceCapabilities;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSurfaceCapabilities2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceCapabilities2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceCapabilities2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSurfaceCapabilities2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSurfaceCapabilities2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSurfaceCapabilities2KHR __CreateInstance(global::VkSurfaceCapabilities2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSurfaceCapabilities2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSurfaceCapabilities2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSurfaceCapabilities2KHR.__Internal));
        *(global::VkSurfaceCapabilities2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSurfaceCapabilities2KHR(global::VkSurfaceCapabilities2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSurfaceCapabilities2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSurfaceCapabilities2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceCapabilities2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSurfaceCapabilities2KHR(global::VkSurfaceCapabilities2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceCapabilities2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSurfaceCapabilities2KHR.__Internal*) __Instance) = *((global::VkSurfaceCapabilities2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSurfaceCapabilities2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSurfaceCapabilities2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSurfaceCapabilities2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSurfaceCapabilities2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSurfaceCapabilities2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSurfaceCapabilitiesKHR SurfaceCapabilities
    {
        get
        {
            return global::VkSurfaceCapabilitiesKHR.__CreateInstance(new global::System.IntPtr(&((global::VkSurfaceCapabilities2KHR.__Internal*) __Instance)->surfaceCapabilities));
        }

        set
        {
            ((global::VkSurfaceCapabilities2KHR.__Internal*)__Instance)->surfaceCapabilities = ReferenceEquals(value, null) ? new global::VkSurfaceCapabilitiesKHR.__Internal() : *(global::VkSurfaceCapabilitiesKHR.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkSurfaceFormat2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkSurfaceFormatKHR.__Internal surfaceFormat;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSurfaceFormat2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceFormat2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceFormat2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSurfaceFormat2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSurfaceFormat2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkSurfaceFormat2KHR __CreateInstance(global::VkSurfaceFormat2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkSurfaceFormat2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSurfaceFormat2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSurfaceFormat2KHR.__Internal));
        *(global::VkSurfaceFormat2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSurfaceFormat2KHR(global::VkSurfaceFormat2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSurfaceFormat2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSurfaceFormat2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceFormat2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSurfaceFormat2KHR(global::VkSurfaceFormat2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceFormat2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSurfaceFormat2KHR.__Internal*) __Instance) = *((global::VkSurfaceFormat2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSurfaceFormat2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSurfaceFormat2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSurfaceFormat2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSurfaceFormat2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSurfaceFormat2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSurfaceFormatKHR SurfaceFormat
    {
        get
        {
            return global::VkSurfaceFormatKHR.__CreateInstance(new global::System.IntPtr(&((global::VkSurfaceFormat2KHR.__Internal*) __Instance)->surfaceFormat));
        }

        set
        {
            ((global::VkSurfaceFormat2KHR.__Internal*)__Instance)->surfaceFormat = ReferenceEquals(value, null) ? new global::VkSurfaceFormatKHR.__Internal() : *(global::VkSurfaceFormatKHR.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkDisplayProperties2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkDisplayPropertiesKHR.__Internal displayProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayProperties2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayProperties2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayProperties2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayProperties2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayProperties2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayProperties2KHR __CreateInstance(global::VkDisplayProperties2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayProperties2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayProperties2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayProperties2KHR.__Internal));
        *(global::VkDisplayProperties2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayProperties2KHR(global::VkDisplayProperties2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayProperties2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayProperties2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayProperties2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayProperties2KHR(global::VkDisplayProperties2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayProperties2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayProperties2KHR.__Internal*) __Instance) = *((global::VkDisplayProperties2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayProperties2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplayProperties2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplayProperties2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplayProperties2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplayProperties2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDisplayPropertiesKHR DisplayProperties
    {
        get
        {
            return global::VkDisplayPropertiesKHR.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayProperties2KHR.__Internal*) __Instance)->displayProperties));
        }

        set
        {
            ((global::VkDisplayProperties2KHR.__Internal*)__Instance)->displayProperties = ReferenceEquals(value, null) ? new global::VkDisplayPropertiesKHR.__Internal() : *(global::VkDisplayPropertiesKHR.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkDisplayPlaneProperties2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkDisplayPlanePropertiesKHR.__Internal displayPlaneProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayPlaneProperties2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlaneProperties2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlaneProperties2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayPlaneProperties2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayPlaneProperties2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayPlaneProperties2KHR __CreateInstance(global::VkDisplayPlaneProperties2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayPlaneProperties2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayPlaneProperties2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneProperties2KHR.__Internal));
        *(global::VkDisplayPlaneProperties2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayPlaneProperties2KHR(global::VkDisplayPlaneProperties2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayPlaneProperties2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayPlaneProperties2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneProperties2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayPlaneProperties2KHR(global::VkDisplayPlaneProperties2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneProperties2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayPlaneProperties2KHR.__Internal*) __Instance) = *((global::VkDisplayPlaneProperties2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayPlaneProperties2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplayPlaneProperties2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplayPlaneProperties2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplayPlaneProperties2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplayPlaneProperties2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDisplayPlanePropertiesKHR DisplayPlaneProperties
    {
        get
        {
            return global::VkDisplayPlanePropertiesKHR.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneProperties2KHR.__Internal*) __Instance)->displayPlaneProperties));
        }

        set
        {
            ((global::VkDisplayPlaneProperties2KHR.__Internal*)__Instance)->displayPlaneProperties = ReferenceEquals(value, null) ? new global::VkDisplayPlanePropertiesKHR.__Internal() : *(global::VkDisplayPlanePropertiesKHR.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkDisplayModeProperties2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkDisplayModePropertiesKHR.__Internal displayModeProperties;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayModeProperties2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModeProperties2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayModeProperties2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayModeProperties2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayModeProperties2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayModeProperties2KHR __CreateInstance(global::VkDisplayModeProperties2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayModeProperties2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayModeProperties2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeProperties2KHR.__Internal));
        *(global::VkDisplayModeProperties2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayModeProperties2KHR(global::VkDisplayModeProperties2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayModeProperties2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayModeProperties2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeProperties2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayModeProperties2KHR(global::VkDisplayModeProperties2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayModeProperties2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayModeProperties2KHR.__Internal*) __Instance) = *((global::VkDisplayModeProperties2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayModeProperties2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplayModeProperties2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplayModeProperties2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplayModeProperties2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplayModeProperties2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDisplayModePropertiesKHR DisplayModeProperties
    {
        get
        {
            return global::VkDisplayModePropertiesKHR.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayModeProperties2KHR.__Internal*) __Instance)->displayModeProperties));
        }

        set
        {
            ((global::VkDisplayModeProperties2KHR.__Internal*)__Instance)->displayModeProperties = ReferenceEquals(value, null) ? new global::VkDisplayModePropertiesKHR.__Internal() : *(global::VkDisplayModePropertiesKHR.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkDisplayPlaneInfo2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr mode;

        [FieldOffset(24)]
        internal uint planeIndex;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayPlaneInfo2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlaneInfo2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlaneInfo2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayPlaneInfo2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayPlaneInfo2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayPlaneInfo2KHR __CreateInstance(global::VkDisplayPlaneInfo2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayPlaneInfo2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayPlaneInfo2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneInfo2KHR.__Internal));
        *(global::VkDisplayPlaneInfo2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayPlaneInfo2KHR(global::VkDisplayPlaneInfo2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayPlaneInfo2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayPlaneInfo2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneInfo2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayPlaneInfo2KHR(global::VkDisplayPlaneInfo2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneInfo2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayPlaneInfo2KHR.__Internal*) __Instance) = *((global::VkDisplayPlaneInfo2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayPlaneInfo2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplayPlaneInfo2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplayPlaneInfo2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplayPlaneInfo2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplayPlaneInfo2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDisplayModeKHR_T Mode
    {
        get
        {
            global::VkDisplayModeKHR_T __result0;
            if (((global::VkDisplayPlaneInfo2KHR.__Internal*) __Instance)->mode == IntPtr.Zero) __result0 = null;
            else if (global::VkDisplayModeKHR_T.NativeToManagedMap.ContainsKey(((global::VkDisplayPlaneInfo2KHR.__Internal*) __Instance)->mode))
                __result0 = (global::VkDisplayModeKHR_T) global::VkDisplayModeKHR_T.NativeToManagedMap[((global::VkDisplayPlaneInfo2KHR.__Internal*) __Instance)->mode];
            else __result0 = global::VkDisplayModeKHR_T.__CreateInstance(((global::VkDisplayPlaneInfo2KHR.__Internal*) __Instance)->mode);
            return __result0;
        }

        set
        {
            ((global::VkDisplayPlaneInfo2KHR.__Internal*)__Instance)->mode = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint PlaneIndex
    {
        get
        {
            return ((global::VkDisplayPlaneInfo2KHR.__Internal*) __Instance)->planeIndex;
        }

        set
        {
            ((global::VkDisplayPlaneInfo2KHR.__Internal*)__Instance)->planeIndex = value;
        }
    }
}

public unsafe partial class VkDisplayPlaneCapabilities2KHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 88)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkDisplayPlaneCapabilitiesKHR.__Internal capabilities;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayPlaneCapabilities2KHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlaneCapabilities2KHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPlaneCapabilities2KHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayPlaneCapabilities2KHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayPlaneCapabilities2KHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayPlaneCapabilities2KHR __CreateInstance(global::VkDisplayPlaneCapabilities2KHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayPlaneCapabilities2KHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayPlaneCapabilities2KHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneCapabilities2KHR.__Internal));
        *(global::VkDisplayPlaneCapabilities2KHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayPlaneCapabilities2KHR(global::VkDisplayPlaneCapabilities2KHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayPlaneCapabilities2KHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayPlaneCapabilities2KHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneCapabilities2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayPlaneCapabilities2KHR(global::VkDisplayPlaneCapabilities2KHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPlaneCapabilities2KHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayPlaneCapabilities2KHR.__Internal*) __Instance) = *((global::VkDisplayPlaneCapabilities2KHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayPlaneCapabilities2KHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplayPlaneCapabilities2KHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplayPlaneCapabilities2KHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplayPlaneCapabilities2KHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplayPlaneCapabilities2KHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDisplayPlaneCapabilitiesKHR Capabilities
    {
        get
        {
            return global::VkDisplayPlaneCapabilitiesKHR.__CreateInstance(new global::System.IntPtr(&((global::VkDisplayPlaneCapabilities2KHR.__Internal*) __Instance)->capabilities));
        }

        set
        {
            ((global::VkDisplayPlaneCapabilities2KHR.__Internal*)__Instance)->capabilities = ReferenceEquals(value, null) ? new global::VkDisplayPlaneCapabilitiesKHR.__Internal() : *(global::VkDisplayPlaneCapabilitiesKHR.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkImageFormatListCreateInfoKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint viewFormatCount;

        [FieldOffset(24)]
        internal global::VkFormat* pViewFormats;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImageFormatListCreateInfoKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageFormatListCreateInfoKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImageFormatListCreateInfoKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImageFormatListCreateInfoKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImageFormatListCreateInfoKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkImageFormatListCreateInfoKHR __CreateInstance(global::VkImageFormatListCreateInfoKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkImageFormatListCreateInfoKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImageFormatListCreateInfoKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImageFormatListCreateInfoKHR.__Internal));
        *(global::VkImageFormatListCreateInfoKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImageFormatListCreateInfoKHR(global::VkImageFormatListCreateInfoKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImageFormatListCreateInfoKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImageFormatListCreateInfoKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageFormatListCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImageFormatListCreateInfoKHR(global::VkImageFormatListCreateInfoKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImageFormatListCreateInfoKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImageFormatListCreateInfoKHR.__Internal*) __Instance) = *((global::VkImageFormatListCreateInfoKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImageFormatListCreateInfoKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImageFormatListCreateInfoKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImageFormatListCreateInfoKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImageFormatListCreateInfoKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImageFormatListCreateInfoKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ViewFormatCount
    {
        get
        {
            return ((global::VkImageFormatListCreateInfoKHR.__Internal*) __Instance)->viewFormatCount;
        }

        set
        {
            ((global::VkImageFormatListCreateInfoKHR.__Internal*)__Instance)->viewFormatCount = value;
        }
    }

    public global::VkFormat* PViewFormats
    {
        get
        {
            return ((global::VkImageFormatListCreateInfoKHR.__Internal*) __Instance)->pViewFormats;
        }

        set
        {
            ((global::VkImageFormatListCreateInfoKHR.__Internal*)__Instance)->pViewFormats = value;
        }
    }
}

public unsafe partial class VkPhysicalDevice8BitStorageFeaturesKHR : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint storageBuffer8BitAccess;

        [FieldOffset(20)]
        internal uint uniformAndStorageBuffer8BitAccess;

        [FieldOffset(24)]
        internal uint storagePushConstant8;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDevice8BitStorageFeaturesKHR@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDevice8BitStorageFeaturesKHR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDevice8BitStorageFeaturesKHR>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDevice8BitStorageFeaturesKHR __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDevice8BitStorageFeaturesKHR(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDevice8BitStorageFeaturesKHR __CreateInstance(global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDevice8BitStorageFeaturesKHR(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal));
        *(global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDevice8BitStorageFeaturesKHR(global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDevice8BitStorageFeaturesKHR(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDevice8BitStorageFeaturesKHR()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDevice8BitStorageFeaturesKHR(global::VkPhysicalDevice8BitStorageFeaturesKHR _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*) __Instance) = *((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDevice8BitStorageFeaturesKHR __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint StorageBuffer8BitAccess
    {
        get
        {
            return ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*) __Instance)->storageBuffer8BitAccess;
        }

        set
        {
            ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*)__Instance)->storageBuffer8BitAccess = value;
        }
    }

    public uint UniformAndStorageBuffer8BitAccess
    {
        get
        {
            return ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*) __Instance)->uniformAndStorageBuffer8BitAccess;
        }

        set
        {
            ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*)__Instance)->uniformAndStorageBuffer8BitAccess = value;
        }
    }

    public uint StoragePushConstant8
    {
        get
        {
            return ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*) __Instance)->storagePushConstant8;
        }

        set
        {
            ((global::VkPhysicalDevice8BitStorageFeaturesKHR.__Internal*)__Instance)->storagePushConstant8 = value;
        }
    }
}

public unsafe partial class VkDebugReportCallbackEXT_T
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugReportCallbackEXT_T> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugReportCallbackEXT_T>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugReportCallbackEXT_T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugReportCallbackEXT_T(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugReportCallbackEXT_T __CreateInstance(global::VkDebugReportCallbackEXT_T.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugReportCallbackEXT_T(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugReportCallbackEXT_T.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugReportCallbackEXT_T.__Internal));
        *(global::VkDebugReportCallbackEXT_T.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugReportCallbackEXT_T(global::VkDebugReportCallbackEXT_T.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugReportCallbackEXT_T(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDebugReportCallbackCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::System.IntPtr pfnCallback;

        [FieldOffset(32)]
        internal global::System.IntPtr pUserData;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDebugReportCallbackCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugReportCallbackCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugReportCallbackCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugReportCallbackCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugReportCallbackCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugReportCallbackCreateInfoEXT __CreateInstance(global::VkDebugReportCallbackCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugReportCallbackCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugReportCallbackCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugReportCallbackCreateInfoEXT.__Internal));
        *(global::VkDebugReportCallbackCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugReportCallbackCreateInfoEXT(global::VkDebugReportCallbackCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugReportCallbackCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDebugReportCallbackCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugReportCallbackCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDebugReportCallbackCreateInfoEXT(global::VkDebugReportCallbackCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugReportCallbackCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDebugReportCallbackCreateInfoEXT.__Internal*) __Instance) = *((global::VkDebugReportCallbackCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDebugReportCallbackCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*)__Instance)->flags = value;
        }
    }

    public global::PFN_vkDebugReportCallbackEXT PfnCallback
    {
        get
        {
            var __ptr0 = ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*) __Instance)->pfnCallback;
            return __ptr0 == IntPtr.Zero? null : (global::PFN_vkDebugReportCallbackEXT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PFN_vkDebugReportCallbackEXT));
        }

        set
        {
            ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*)__Instance)->pfnCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
        }
    }

    public global::System.IntPtr PUserData
    {
        get
        {
            return ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*) __Instance)->pUserData;
        }

        set
        {
            ((global::VkDebugReportCallbackCreateInfoEXT.__Internal*)__Instance)->pUserData = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkPipelineRasterizationStateRasterizationOrderAMD : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkRasterizationOrderAMD rasterizationOrder;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineRasterizationStateRasterizationOrderAMD@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineRasterizationStateRasterizationOrderAMD> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineRasterizationStateRasterizationOrderAMD>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineRasterizationStateRasterizationOrderAMD __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineRasterizationStateRasterizationOrderAMD(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineRasterizationStateRasterizationOrderAMD __CreateInstance(global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineRasterizationStateRasterizationOrderAMD(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal));
        *(global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineRasterizationStateRasterizationOrderAMD(global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineRasterizationStateRasterizationOrderAMD(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineRasterizationStateRasterizationOrderAMD()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineRasterizationStateRasterizationOrderAMD(global::VkPipelineRasterizationStateRasterizationOrderAMD _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal*) __Instance) = *((global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineRasterizationStateRasterizationOrderAMD __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkRasterizationOrderAMD RasterizationOrder
    {
        get
        {
            return ((global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal*) __Instance)->rasterizationOrder;
        }

        set
        {
            ((global::VkPipelineRasterizationStateRasterizationOrderAMD.__Internal*)__Instance)->rasterizationOrder = value;
        }
    }
}

public unsafe partial class VkDebugMarkerObjectNameInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkDebugReportObjectTypeEXT objectType;

        [FieldOffset(24)]
        internal ulong @object;

        [FieldOffset(32)]
        internal global::System.IntPtr pObjectName;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDebugMarkerObjectNameInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugMarkerObjectNameInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugMarkerObjectNameInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugMarkerObjectNameInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugMarkerObjectNameInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugMarkerObjectNameInfoEXT __CreateInstance(global::VkDebugMarkerObjectNameInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugMarkerObjectNameInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugMarkerObjectNameInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugMarkerObjectNameInfoEXT.__Internal));
        *(global::VkDebugMarkerObjectNameInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugMarkerObjectNameInfoEXT(global::VkDebugMarkerObjectNameInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugMarkerObjectNameInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDebugMarkerObjectNameInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugMarkerObjectNameInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDebugMarkerObjectNameInfoEXT(global::VkDebugMarkerObjectNameInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugMarkerObjectNameInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDebugMarkerObjectNameInfoEXT.__Internal*) __Instance) = *((global::VkDebugMarkerObjectNameInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDebugMarkerObjectNameInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDebugMarkerObjectNameInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDebugMarkerObjectNameInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDebugMarkerObjectNameInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDebugMarkerObjectNameInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDebugReportObjectTypeEXT ObjectType
    {
        get
        {
            return ((global::VkDebugMarkerObjectNameInfoEXT.__Internal*) __Instance)->objectType;
        }

        set
        {
            ((global::VkDebugMarkerObjectNameInfoEXT.__Internal*)__Instance)->objectType = value;
        }
    }

    public ulong Object
    {
        get
        {
            return ((global::VkDebugMarkerObjectNameInfoEXT.__Internal*) __Instance)->@object;
        }

        set
        {
            ((global::VkDebugMarkerObjectNameInfoEXT.__Internal*)__Instance)->@object = value;
        }
    }

    public string PObjectName
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkDebugMarkerObjectNameInfoEXT.__Internal*) __Instance)->pObjectName);
        }

        set
        {
            ((global::VkDebugMarkerObjectNameInfoEXT.__Internal*)__Instance)->pObjectName = Marshal.StringToHGlobalAnsi(value);
        }
    }
}

public unsafe partial class VkDebugMarkerObjectTagInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkDebugReportObjectTypeEXT objectType;

        [FieldOffset(24)]
        internal ulong @object;

        [FieldOffset(32)]
        internal ulong tagName;

        [FieldOffset(40)]
        internal ulong tagSize;

        [FieldOffset(48)]
        internal global::System.IntPtr pTag;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDebugMarkerObjectTagInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugMarkerObjectTagInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugMarkerObjectTagInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugMarkerObjectTagInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugMarkerObjectTagInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugMarkerObjectTagInfoEXT __CreateInstance(global::VkDebugMarkerObjectTagInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugMarkerObjectTagInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugMarkerObjectTagInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugMarkerObjectTagInfoEXT.__Internal));
        *(global::VkDebugMarkerObjectTagInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugMarkerObjectTagInfoEXT(global::VkDebugMarkerObjectTagInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugMarkerObjectTagInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDebugMarkerObjectTagInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugMarkerObjectTagInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDebugMarkerObjectTagInfoEXT(global::VkDebugMarkerObjectTagInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugMarkerObjectTagInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDebugMarkerObjectTagInfoEXT.__Internal*) __Instance) = *((global::VkDebugMarkerObjectTagInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDebugMarkerObjectTagInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDebugReportObjectTypeEXT ObjectType
    {
        get
        {
            return ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*) __Instance)->objectType;
        }

        set
        {
            ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*)__Instance)->objectType = value;
        }
    }

    public ulong Object
    {
        get
        {
            return ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*) __Instance)->@object;
        }

        set
        {
            ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*)__Instance)->@object = value;
        }
    }

    public ulong TagName
    {
        get
        {
            return ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*) __Instance)->tagName;
        }

        set
        {
            ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*)__Instance)->tagName = value;
        }
    }

    public ulong TagSize
    {
        get
        {
            return ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*) __Instance)->tagSize;
        }

        set
        {
            ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*)__Instance)->tagSize = value;
        }
    }

    public global::System.IntPtr PTag
    {
        get
        {
            return ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*) __Instance)->pTag;
        }

        set
        {
            ((global::VkDebugMarkerObjectTagInfoEXT.__Internal*)__Instance)->pTag = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkDebugMarkerMarkerInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr pMarkerName;

        [FieldOffset(24)]
        internal fixed float color[4];

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDebugMarkerMarkerInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugMarkerMarkerInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugMarkerMarkerInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugMarkerMarkerInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugMarkerMarkerInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugMarkerMarkerInfoEXT __CreateInstance(global::VkDebugMarkerMarkerInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugMarkerMarkerInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugMarkerMarkerInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugMarkerMarkerInfoEXT.__Internal));
        *(global::VkDebugMarkerMarkerInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugMarkerMarkerInfoEXT(global::VkDebugMarkerMarkerInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugMarkerMarkerInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDebugMarkerMarkerInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugMarkerMarkerInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDebugMarkerMarkerInfoEXT(global::VkDebugMarkerMarkerInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugMarkerMarkerInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDebugMarkerMarkerInfoEXT.__Internal*) __Instance) = *((global::VkDebugMarkerMarkerInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDebugMarkerMarkerInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDebugMarkerMarkerInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDebugMarkerMarkerInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDebugMarkerMarkerInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDebugMarkerMarkerInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public string PMarkerName
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkDebugMarkerMarkerInfoEXT.__Internal*) __Instance)->pMarkerName);
        }

        set
        {
            ((global::VkDebugMarkerMarkerInfoEXT.__Internal*)__Instance)->pMarkerName = Marshal.StringToHGlobalAnsi(value);
        }
    }

    public float[] Color
    {
        get
        {
            float[] __value = null;
            if (((global::VkDebugMarkerMarkerInfoEXT.__Internal*) __Instance)->color != null)
            {
                __value = new float[4];
                for (int i = 0; i < 4; i++)
                    __value[i] = ((global::VkDebugMarkerMarkerInfoEXT.__Internal*) __Instance)->color[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 4; i++)
                    ((global::VkDebugMarkerMarkerInfoEXT.__Internal*)__Instance)->color[i] = value[i];
            }
        }
    }
}

public unsafe partial class VkDedicatedAllocationImageCreateInfoNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint dedicatedAllocation;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDedicatedAllocationImageCreateInfoNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDedicatedAllocationImageCreateInfoNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDedicatedAllocationImageCreateInfoNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDedicatedAllocationImageCreateInfoNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDedicatedAllocationImageCreateInfoNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkDedicatedAllocationImageCreateInfoNV __CreateInstance(global::VkDedicatedAllocationImageCreateInfoNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkDedicatedAllocationImageCreateInfoNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDedicatedAllocationImageCreateInfoNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDedicatedAllocationImageCreateInfoNV.__Internal));
        *(global::VkDedicatedAllocationImageCreateInfoNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDedicatedAllocationImageCreateInfoNV(global::VkDedicatedAllocationImageCreateInfoNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDedicatedAllocationImageCreateInfoNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDedicatedAllocationImageCreateInfoNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDedicatedAllocationImageCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDedicatedAllocationImageCreateInfoNV(global::VkDedicatedAllocationImageCreateInfoNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDedicatedAllocationImageCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDedicatedAllocationImageCreateInfoNV.__Internal*) __Instance) = *((global::VkDedicatedAllocationImageCreateInfoNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDedicatedAllocationImageCreateInfoNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDedicatedAllocationImageCreateInfoNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDedicatedAllocationImageCreateInfoNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDedicatedAllocationImageCreateInfoNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDedicatedAllocationImageCreateInfoNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint DedicatedAllocation
    {
        get
        {
            return ((global::VkDedicatedAllocationImageCreateInfoNV.__Internal*) __Instance)->dedicatedAllocation;
        }

        set
        {
            ((global::VkDedicatedAllocationImageCreateInfoNV.__Internal*)__Instance)->dedicatedAllocation = value;
        }
    }
}

public unsafe partial class VkDedicatedAllocationBufferCreateInfoNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint dedicatedAllocation;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDedicatedAllocationBufferCreateInfoNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDedicatedAllocationBufferCreateInfoNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDedicatedAllocationBufferCreateInfoNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDedicatedAllocationBufferCreateInfoNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDedicatedAllocationBufferCreateInfoNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkDedicatedAllocationBufferCreateInfoNV __CreateInstance(global::VkDedicatedAllocationBufferCreateInfoNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkDedicatedAllocationBufferCreateInfoNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDedicatedAllocationBufferCreateInfoNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDedicatedAllocationBufferCreateInfoNV.__Internal));
        *(global::VkDedicatedAllocationBufferCreateInfoNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDedicatedAllocationBufferCreateInfoNV(global::VkDedicatedAllocationBufferCreateInfoNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDedicatedAllocationBufferCreateInfoNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDedicatedAllocationBufferCreateInfoNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDedicatedAllocationBufferCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDedicatedAllocationBufferCreateInfoNV(global::VkDedicatedAllocationBufferCreateInfoNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDedicatedAllocationBufferCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDedicatedAllocationBufferCreateInfoNV.__Internal*) __Instance) = *((global::VkDedicatedAllocationBufferCreateInfoNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDedicatedAllocationBufferCreateInfoNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDedicatedAllocationBufferCreateInfoNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDedicatedAllocationBufferCreateInfoNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDedicatedAllocationBufferCreateInfoNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDedicatedAllocationBufferCreateInfoNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint DedicatedAllocation
    {
        get
        {
            return ((global::VkDedicatedAllocationBufferCreateInfoNV.__Internal*) __Instance)->dedicatedAllocation;
        }

        set
        {
            ((global::VkDedicatedAllocationBufferCreateInfoNV.__Internal*)__Instance)->dedicatedAllocation = value;
        }
    }
}

public unsafe partial class VkDedicatedAllocationMemoryAllocateInfoNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr image;

        [FieldOffset(24)]
        internal global::System.IntPtr buffer;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDedicatedAllocationMemoryAllocateInfoNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDedicatedAllocationMemoryAllocateInfoNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDedicatedAllocationMemoryAllocateInfoNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDedicatedAllocationMemoryAllocateInfoNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDedicatedAllocationMemoryAllocateInfoNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkDedicatedAllocationMemoryAllocateInfoNV __CreateInstance(global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkDedicatedAllocationMemoryAllocateInfoNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal));
        *(global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDedicatedAllocationMemoryAllocateInfoNV(global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDedicatedAllocationMemoryAllocateInfoNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDedicatedAllocationMemoryAllocateInfoNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDedicatedAllocationMemoryAllocateInfoNV(global::VkDedicatedAllocationMemoryAllocateInfoNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance) = *((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDedicatedAllocationMemoryAllocateInfoNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkImageT Image
    {
        get
        {
            global::VkImageT __result0;
            if (((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->image == IntPtr.Zero) __result0 = null;
            else if (global::VkImageT.NativeToManagedMap.ContainsKey(((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->image))
                __result0 = (global::VkImageT) global::VkImageT.NativeToManagedMap[((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->image];
            else __result0 = global::VkImageT.__CreateInstance(((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->image);
            return __result0;
        }

        set
        {
            ((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*)__Instance)->image = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkDedicatedAllocationMemoryAllocateInfoNV.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkTextureLODGatherFormatPropertiesAMD : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint supportsTextureGatherLODBiasAMD;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkTextureLODGatherFormatPropertiesAMD@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkTextureLODGatherFormatPropertiesAMD> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkTextureLODGatherFormatPropertiesAMD>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkTextureLODGatherFormatPropertiesAMD __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkTextureLODGatherFormatPropertiesAMD(native.ToPointer(), skipVTables);
    }

    internal static global::VkTextureLODGatherFormatPropertiesAMD __CreateInstance(global::VkTextureLODGatherFormatPropertiesAMD.__Internal native, bool skipVTables = false)
    {
        return new global::VkTextureLODGatherFormatPropertiesAMD(native, skipVTables);
    }

    private static void* __CopyValue(global::VkTextureLODGatherFormatPropertiesAMD.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkTextureLODGatherFormatPropertiesAMD.__Internal));
        *(global::VkTextureLODGatherFormatPropertiesAMD.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkTextureLODGatherFormatPropertiesAMD(global::VkTextureLODGatherFormatPropertiesAMD.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkTextureLODGatherFormatPropertiesAMD(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkTextureLODGatherFormatPropertiesAMD()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkTextureLODGatherFormatPropertiesAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkTextureLODGatherFormatPropertiesAMD(global::VkTextureLODGatherFormatPropertiesAMD _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkTextureLODGatherFormatPropertiesAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkTextureLODGatherFormatPropertiesAMD.__Internal*) __Instance) = *((global::VkTextureLODGatherFormatPropertiesAMD.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkTextureLODGatherFormatPropertiesAMD __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkTextureLODGatherFormatPropertiesAMD.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkTextureLODGatherFormatPropertiesAMD.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkTextureLODGatherFormatPropertiesAMD.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkTextureLODGatherFormatPropertiesAMD.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SupportsTextureGatherLODBiasAMD
    {
        get
        {
            return ((global::VkTextureLODGatherFormatPropertiesAMD.__Internal*) __Instance)->supportsTextureGatherLODBiasAMD;
        }

        set
        {
            ((global::VkTextureLODGatherFormatPropertiesAMD.__Internal*)__Instance)->supportsTextureGatherLODBiasAMD = value;
        }
    }
}

public unsafe partial class VkShaderResourceUsageAMD : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint numUsedVgprs;

        [FieldOffset(4)]
        internal uint numUsedSgprs;

        [FieldOffset(8)]
        internal uint ldsSizePerLocalWorkGroup;

        [FieldOffset(16)]
        internal ulong ldsUsageSizeInBytes;

        [FieldOffset(24)]
        internal ulong scratchMemUsageInBytes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkShaderResourceUsageAMD@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderResourceUsageAMD> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderResourceUsageAMD>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkShaderResourceUsageAMD __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkShaderResourceUsageAMD(native.ToPointer(), skipVTables);
    }

    internal static global::VkShaderResourceUsageAMD __CreateInstance(global::VkShaderResourceUsageAMD.__Internal native, bool skipVTables = false)
    {
        return new global::VkShaderResourceUsageAMD(native, skipVTables);
    }

    private static void* __CopyValue(global::VkShaderResourceUsageAMD.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkShaderResourceUsageAMD.__Internal));
        *(global::VkShaderResourceUsageAMD.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkShaderResourceUsageAMD(global::VkShaderResourceUsageAMD.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkShaderResourceUsageAMD(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkShaderResourceUsageAMD()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkShaderResourceUsageAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkShaderResourceUsageAMD(global::VkShaderResourceUsageAMD _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkShaderResourceUsageAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkShaderResourceUsageAMD.__Internal*) __Instance) = *((global::VkShaderResourceUsageAMD.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkShaderResourceUsageAMD __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint NumUsedVgprs
    {
        get
        {
            return ((global::VkShaderResourceUsageAMD.__Internal*) __Instance)->numUsedVgprs;
        }

        set
        {
            ((global::VkShaderResourceUsageAMD.__Internal*)__Instance)->numUsedVgprs = value;
        }
    }

    public uint NumUsedSgprs
    {
        get
        {
            return ((global::VkShaderResourceUsageAMD.__Internal*) __Instance)->numUsedSgprs;
        }

        set
        {
            ((global::VkShaderResourceUsageAMD.__Internal*)__Instance)->numUsedSgprs = value;
        }
    }

    public uint LdsSizePerLocalWorkGroup
    {
        get
        {
            return ((global::VkShaderResourceUsageAMD.__Internal*) __Instance)->ldsSizePerLocalWorkGroup;
        }

        set
        {
            ((global::VkShaderResourceUsageAMD.__Internal*)__Instance)->ldsSizePerLocalWorkGroup = value;
        }
    }

    public ulong LdsUsageSizeInBytes
    {
        get
        {
            return ((global::VkShaderResourceUsageAMD.__Internal*) __Instance)->ldsUsageSizeInBytes;
        }

        set
        {
            ((global::VkShaderResourceUsageAMD.__Internal*)__Instance)->ldsUsageSizeInBytes = value;
        }
    }

    public ulong ScratchMemUsageInBytes
    {
        get
        {
            return ((global::VkShaderResourceUsageAMD.__Internal*) __Instance)->scratchMemUsageInBytes;
        }

        set
        {
            ((global::VkShaderResourceUsageAMD.__Internal*)__Instance)->scratchMemUsageInBytes = value;
        }
    }
}

public unsafe partial class VkShaderStatisticsInfoAMD : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint shaderStageMask;

        [FieldOffset(8)]
        internal global::VkShaderResourceUsageAMD.__Internal resourceUsage;

        [FieldOffset(40)]
        internal uint numPhysicalVgprs;

        [FieldOffset(44)]
        internal uint numPhysicalSgprs;

        [FieldOffset(48)]
        internal uint numAvailableVgprs;

        [FieldOffset(52)]
        internal uint numAvailableSgprs;

        [FieldOffset(56)]
        internal fixed uint computeWorkGroupSize[3];

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkShaderStatisticsInfoAMD@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderStatisticsInfoAMD> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderStatisticsInfoAMD>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkShaderStatisticsInfoAMD __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkShaderStatisticsInfoAMD(native.ToPointer(), skipVTables);
    }

    internal static global::VkShaderStatisticsInfoAMD __CreateInstance(global::VkShaderStatisticsInfoAMD.__Internal native, bool skipVTables = false)
    {
        return new global::VkShaderStatisticsInfoAMD(native, skipVTables);
    }

    private static void* __CopyValue(global::VkShaderStatisticsInfoAMD.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkShaderStatisticsInfoAMD.__Internal));
        *(global::VkShaderStatisticsInfoAMD.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkShaderStatisticsInfoAMD(global::VkShaderStatisticsInfoAMD.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkShaderStatisticsInfoAMD(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkShaderStatisticsInfoAMD()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkShaderStatisticsInfoAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkShaderStatisticsInfoAMD(global::VkShaderStatisticsInfoAMD _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkShaderStatisticsInfoAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkShaderStatisticsInfoAMD.__Internal*) __Instance) = *((global::VkShaderStatisticsInfoAMD.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkShaderStatisticsInfoAMD __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint ShaderStageMask
    {
        get
        {
            return ((global::VkShaderStatisticsInfoAMD.__Internal*) __Instance)->shaderStageMask;
        }

        set
        {
            ((global::VkShaderStatisticsInfoAMD.__Internal*)__Instance)->shaderStageMask = value;
        }
    }

    public global::VkShaderResourceUsageAMD ResourceUsage
    {
        get
        {
            return global::VkShaderResourceUsageAMD.__CreateInstance(new global::System.IntPtr(&((global::VkShaderStatisticsInfoAMD.__Internal*) __Instance)->resourceUsage));
        }

        set
        {
            ((global::VkShaderStatisticsInfoAMD.__Internal*)__Instance)->resourceUsage = ReferenceEquals(value, null) ? new global::VkShaderResourceUsageAMD.__Internal() : *(global::VkShaderResourceUsageAMD.__Internal*) value.__Instance;
        }
    }

    public uint NumPhysicalVgprs
    {
        get
        {
            return ((global::VkShaderStatisticsInfoAMD.__Internal*) __Instance)->numPhysicalVgprs;
        }

        set
        {
            ((global::VkShaderStatisticsInfoAMD.__Internal*)__Instance)->numPhysicalVgprs = value;
        }
    }

    public uint NumPhysicalSgprs
    {
        get
        {
            return ((global::VkShaderStatisticsInfoAMD.__Internal*) __Instance)->numPhysicalSgprs;
        }

        set
        {
            ((global::VkShaderStatisticsInfoAMD.__Internal*)__Instance)->numPhysicalSgprs = value;
        }
    }

    public uint NumAvailableVgprs
    {
        get
        {
            return ((global::VkShaderStatisticsInfoAMD.__Internal*) __Instance)->numAvailableVgprs;
        }

        set
        {
            ((global::VkShaderStatisticsInfoAMD.__Internal*)__Instance)->numAvailableVgprs = value;
        }
    }

    public uint NumAvailableSgprs
    {
        get
        {
            return ((global::VkShaderStatisticsInfoAMD.__Internal*) __Instance)->numAvailableSgprs;
        }

        set
        {
            ((global::VkShaderStatisticsInfoAMD.__Internal*)__Instance)->numAvailableSgprs = value;
        }
    }

    public uint[] ComputeWorkGroupSize
    {
        get
        {
            uint[] __value = null;
            if (((global::VkShaderStatisticsInfoAMD.__Internal*) __Instance)->computeWorkGroupSize != null)
            {
                __value = new uint[3];
                for (int i = 0; i < 3; i++)
                    __value[i] = ((global::VkShaderStatisticsInfoAMD.__Internal*) __Instance)->computeWorkGroupSize[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 3; i++)
                    ((global::VkShaderStatisticsInfoAMD.__Internal*)__Instance)->computeWorkGroupSize[i] = value[i];
            }
        }
    }
}

public unsafe partial class VkExternalImageFormatPropertiesNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkImageFormatProperties.__Internal imageFormatProperties;

        [FieldOffset(32)]
        internal uint externalMemoryFeatures;

        [FieldOffset(36)]
        internal uint exportFromImportedHandleTypes;

        [FieldOffset(40)]
        internal uint compatibleHandleTypes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExternalImageFormatPropertiesNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalImageFormatPropertiesNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalImageFormatPropertiesNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExternalImageFormatPropertiesNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExternalImageFormatPropertiesNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkExternalImageFormatPropertiesNV __CreateInstance(global::VkExternalImageFormatPropertiesNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkExternalImageFormatPropertiesNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExternalImageFormatPropertiesNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExternalImageFormatPropertiesNV.__Internal));
        *(global::VkExternalImageFormatPropertiesNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExternalImageFormatPropertiesNV(global::VkExternalImageFormatPropertiesNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExternalImageFormatPropertiesNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExternalImageFormatPropertiesNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalImageFormatPropertiesNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExternalImageFormatPropertiesNV(global::VkExternalImageFormatPropertiesNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalImageFormatPropertiesNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExternalImageFormatPropertiesNV.__Internal*) __Instance) = *((global::VkExternalImageFormatPropertiesNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExternalImageFormatPropertiesNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkImageFormatProperties ImageFormatProperties
    {
        get
        {
            return global::VkImageFormatProperties.__CreateInstance(new global::System.IntPtr(&((global::VkExternalImageFormatPropertiesNV.__Internal*) __Instance)->imageFormatProperties));
        }

        set
        {
            ((global::VkExternalImageFormatPropertiesNV.__Internal*)__Instance)->imageFormatProperties = ReferenceEquals(value, null) ? new global::VkImageFormatProperties.__Internal() : *(global::VkImageFormatProperties.__Internal*) value.__Instance;
        }
    }

    public uint ExternalMemoryFeatures
    {
        get
        {
            return ((global::VkExternalImageFormatPropertiesNV.__Internal*) __Instance)->externalMemoryFeatures;
        }

        set
        {
            ((global::VkExternalImageFormatPropertiesNV.__Internal*)__Instance)->externalMemoryFeatures = value;
        }
    }

    public uint ExportFromImportedHandleTypes
    {
        get
        {
            return ((global::VkExternalImageFormatPropertiesNV.__Internal*) __Instance)->exportFromImportedHandleTypes;
        }

        set
        {
            ((global::VkExternalImageFormatPropertiesNV.__Internal*)__Instance)->exportFromImportedHandleTypes = value;
        }
    }

    public uint CompatibleHandleTypes
    {
        get
        {
            return ((global::VkExternalImageFormatPropertiesNV.__Internal*) __Instance)->compatibleHandleTypes;
        }

        set
        {
            ((global::VkExternalImageFormatPropertiesNV.__Internal*)__Instance)->compatibleHandleTypes = value;
        }
    }
}

public unsafe partial class VkExternalMemoryImageCreateInfoNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint handleTypes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExternalMemoryImageCreateInfoNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalMemoryImageCreateInfoNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExternalMemoryImageCreateInfoNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExternalMemoryImageCreateInfoNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExternalMemoryImageCreateInfoNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkExternalMemoryImageCreateInfoNV __CreateInstance(global::VkExternalMemoryImageCreateInfoNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkExternalMemoryImageCreateInfoNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExternalMemoryImageCreateInfoNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryImageCreateInfoNV.__Internal));
        *(global::VkExternalMemoryImageCreateInfoNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExternalMemoryImageCreateInfoNV(global::VkExternalMemoryImageCreateInfoNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExternalMemoryImageCreateInfoNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExternalMemoryImageCreateInfoNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryImageCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExternalMemoryImageCreateInfoNV(global::VkExternalMemoryImageCreateInfoNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExternalMemoryImageCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExternalMemoryImageCreateInfoNV.__Internal*) __Instance) = *((global::VkExternalMemoryImageCreateInfoNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExternalMemoryImageCreateInfoNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExternalMemoryImageCreateInfoNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExternalMemoryImageCreateInfoNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExternalMemoryImageCreateInfoNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExternalMemoryImageCreateInfoNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint HandleTypes
    {
        get
        {
            return ((global::VkExternalMemoryImageCreateInfoNV.__Internal*) __Instance)->handleTypes;
        }

        set
        {
            ((global::VkExternalMemoryImageCreateInfoNV.__Internal*)__Instance)->handleTypes = value;
        }
    }
}

public unsafe partial class VkExportMemoryAllocateInfoNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint handleTypes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkExportMemoryAllocateInfoNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExportMemoryAllocateInfoNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkExportMemoryAllocateInfoNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkExportMemoryAllocateInfoNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkExportMemoryAllocateInfoNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkExportMemoryAllocateInfoNV __CreateInstance(global::VkExportMemoryAllocateInfoNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkExportMemoryAllocateInfoNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkExportMemoryAllocateInfoNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkExportMemoryAllocateInfoNV.__Internal));
        *(global::VkExportMemoryAllocateInfoNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkExportMemoryAllocateInfoNV(global::VkExportMemoryAllocateInfoNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkExportMemoryAllocateInfoNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkExportMemoryAllocateInfoNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExportMemoryAllocateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkExportMemoryAllocateInfoNV(global::VkExportMemoryAllocateInfoNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkExportMemoryAllocateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkExportMemoryAllocateInfoNV.__Internal*) __Instance) = *((global::VkExportMemoryAllocateInfoNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkExportMemoryAllocateInfoNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkExportMemoryAllocateInfoNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkExportMemoryAllocateInfoNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkExportMemoryAllocateInfoNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkExportMemoryAllocateInfoNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint HandleTypes
    {
        get
        {
            return ((global::VkExportMemoryAllocateInfoNV.__Internal*) __Instance)->handleTypes;
        }

        set
        {
            ((global::VkExportMemoryAllocateInfoNV.__Internal*)__Instance)->handleTypes = value;
        }
    }
}

public unsafe partial class VkValidationFlagsEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint disabledValidationCheckCount;

        [FieldOffset(24)]
        internal global::VkValidationCheckEXT* pDisabledValidationChecks;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkValidationFlagsEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkValidationFlagsEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkValidationFlagsEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkValidationFlagsEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkValidationFlagsEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkValidationFlagsEXT __CreateInstance(global::VkValidationFlagsEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkValidationFlagsEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkValidationFlagsEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkValidationFlagsEXT.__Internal));
        *(global::VkValidationFlagsEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkValidationFlagsEXT(global::VkValidationFlagsEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkValidationFlagsEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkValidationFlagsEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkValidationFlagsEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkValidationFlagsEXT(global::VkValidationFlagsEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkValidationFlagsEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkValidationFlagsEXT.__Internal*) __Instance) = *((global::VkValidationFlagsEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkValidationFlagsEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkValidationFlagsEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkValidationFlagsEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkValidationFlagsEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkValidationFlagsEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint DisabledValidationCheckCount
    {
        get
        {
            return ((global::VkValidationFlagsEXT.__Internal*) __Instance)->disabledValidationCheckCount;
        }

        set
        {
            ((global::VkValidationFlagsEXT.__Internal*)__Instance)->disabledValidationCheckCount = value;
        }
    }

    public global::VkValidationCheckEXT* PDisabledValidationChecks
    {
        get
        {
            return ((global::VkValidationFlagsEXT.__Internal*) __Instance)->pDisabledValidationChecks;
        }

        set
        {
            ((global::VkValidationFlagsEXT.__Internal*)__Instance)->pDisabledValidationChecks = value;
        }
    }
}

public unsafe partial class VkConditionalRenderingBeginInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr buffer;

        [FieldOffset(24)]
        internal ulong offset;

        [FieldOffset(32)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkConditionalRenderingBeginInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkConditionalRenderingBeginInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkConditionalRenderingBeginInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkConditionalRenderingBeginInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkConditionalRenderingBeginInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkConditionalRenderingBeginInfoEXT __CreateInstance(global::VkConditionalRenderingBeginInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkConditionalRenderingBeginInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkConditionalRenderingBeginInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkConditionalRenderingBeginInfoEXT.__Internal));
        *(global::VkConditionalRenderingBeginInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkConditionalRenderingBeginInfoEXT(global::VkConditionalRenderingBeginInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkConditionalRenderingBeginInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkConditionalRenderingBeginInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkConditionalRenderingBeginInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkConditionalRenderingBeginInfoEXT(global::VkConditionalRenderingBeginInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkConditionalRenderingBeginInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkConditionalRenderingBeginInfoEXT.__Internal*) __Instance) = *((global::VkConditionalRenderingBeginInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkConditionalRenderingBeginInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkConditionalRenderingBeginInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkConditionalRenderingBeginInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkConditionalRenderingBeginInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkConditionalRenderingBeginInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkConditionalRenderingBeginInfoEXT.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkConditionalRenderingBeginInfoEXT.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkConditionalRenderingBeginInfoEXT.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkConditionalRenderingBeginInfoEXT.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkConditionalRenderingBeginInfoEXT.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong Offset
    {
        get
        {
            return ((global::VkConditionalRenderingBeginInfoEXT.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkConditionalRenderingBeginInfoEXT.__Internal*)__Instance)->offset = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkConditionalRenderingBeginInfoEXT.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkConditionalRenderingBeginInfoEXT.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceConditionalRenderingFeaturesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint conditionalRendering;

        [FieldOffset(20)]
        internal uint inheritedConditionalRendering;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceConditionalRenderingFeaturesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceConditionalRenderingFeaturesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceConditionalRenderingFeaturesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceConditionalRenderingFeaturesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceConditionalRenderingFeaturesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceConditionalRenderingFeaturesEXT __CreateInstance(global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceConditionalRenderingFeaturesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal));
        *(global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceConditionalRenderingFeaturesEXT(global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceConditionalRenderingFeaturesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceConditionalRenderingFeaturesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceConditionalRenderingFeaturesEXT(global::VkPhysicalDeviceConditionalRenderingFeaturesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceConditionalRenderingFeaturesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ConditionalRendering
    {
        get
        {
            return ((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*) __Instance)->conditionalRendering;
        }

        set
        {
            ((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*)__Instance)->conditionalRendering = value;
        }
    }

    public uint InheritedConditionalRendering
    {
        get
        {
            return ((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*) __Instance)->inheritedConditionalRendering;
        }

        set
        {
            ((global::VkPhysicalDeviceConditionalRenderingFeaturesEXT.__Internal*)__Instance)->inheritedConditionalRendering = value;
        }
    }
}

public unsafe partial class VkCommandBufferInheritanceConditionalRenderingInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint conditionalRenderingEnable;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkCommandBufferInheritanceConditionalRenderingInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferInheritanceConditionalRenderingInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCommandBufferInheritanceConditionalRenderingInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCommandBufferInheritanceConditionalRenderingInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCommandBufferInheritanceConditionalRenderingInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkCommandBufferInheritanceConditionalRenderingInfoEXT __CreateInstance(global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkCommandBufferInheritanceConditionalRenderingInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal));
        *(global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCommandBufferInheritanceConditionalRenderingInfoEXT(global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCommandBufferInheritanceConditionalRenderingInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkCommandBufferInheritanceConditionalRenderingInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkCommandBufferInheritanceConditionalRenderingInfoEXT(global::VkCommandBufferInheritanceConditionalRenderingInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal*) __Instance) = *((global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkCommandBufferInheritanceConditionalRenderingInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ConditionalRenderingEnable
    {
        get
        {
            return ((global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal*) __Instance)->conditionalRenderingEnable;
        }

        set
        {
            ((global::VkCommandBufferInheritanceConditionalRenderingInfoEXT.__Internal*)__Instance)->conditionalRenderingEnable = value;
        }
    }
}

public unsafe partial class VkObjectTableNVX_T
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableNVX_T> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableNVX_T>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkObjectTableNVX_T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkObjectTableNVX_T(native.ToPointer(), skipVTables);
    }

    internal static global::VkObjectTableNVX_T __CreateInstance(global::VkObjectTableNVX_T.__Internal native, bool skipVTables = false)
    {
        return new global::VkObjectTableNVX_T(native, skipVTables);
    }

    private static void* __CopyValue(global::VkObjectTableNVX_T.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkObjectTableNVX_T.__Internal));
        *(global::VkObjectTableNVX_T.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkObjectTableNVX_T(global::VkObjectTableNVX_T.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkObjectTableNVX_T(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkIndirectCommandsLayoutNVX_T
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkIndirectCommandsLayoutNVX_T> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkIndirectCommandsLayoutNVX_T>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkIndirectCommandsLayoutNVX_T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkIndirectCommandsLayoutNVX_T(native.ToPointer(), skipVTables);
    }

    internal static global::VkIndirectCommandsLayoutNVX_T __CreateInstance(global::VkIndirectCommandsLayoutNVX_T.__Internal native, bool skipVTables = false)
    {
        return new global::VkIndirectCommandsLayoutNVX_T(native, skipVTables);
    }

    private static void* __CopyValue(global::VkIndirectCommandsLayoutNVX_T.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsLayoutNVX_T.__Internal));
        *(global::VkIndirectCommandsLayoutNVX_T.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkIndirectCommandsLayoutNVX_T(global::VkIndirectCommandsLayoutNVX_T.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkIndirectCommandsLayoutNVX_T(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDeviceGeneratedCommandsFeaturesNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint computeBindingPointSupport;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGeneratedCommandsFeaturesNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGeneratedCommandsFeaturesNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGeneratedCommandsFeaturesNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGeneratedCommandsFeaturesNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGeneratedCommandsFeaturesNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGeneratedCommandsFeaturesNVX __CreateInstance(global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGeneratedCommandsFeaturesNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal));
        *(global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGeneratedCommandsFeaturesNVX(global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGeneratedCommandsFeaturesNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGeneratedCommandsFeaturesNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGeneratedCommandsFeaturesNVX(global::VkDeviceGeneratedCommandsFeaturesNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal*) __Instance) = *((global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGeneratedCommandsFeaturesNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ComputeBindingPointSupport
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal*) __Instance)->computeBindingPointSupport;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsFeaturesNVX.__Internal*)__Instance)->computeBindingPointSupport = value;
        }
    }
}

public unsafe partial class VkDeviceGeneratedCommandsLimitsNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint maxIndirectCommandsLayoutTokenCount;

        [FieldOffset(20)]
        internal uint maxObjectEntryCounts;

        [FieldOffset(24)]
        internal uint minSequenceCountBufferOffsetAlignment;

        [FieldOffset(28)]
        internal uint minSequenceIndexBufferOffsetAlignment;

        [FieldOffset(32)]
        internal uint minCommandsTokenBufferOffsetAlignment;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceGeneratedCommandsLimitsNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGeneratedCommandsLimitsNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceGeneratedCommandsLimitsNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceGeneratedCommandsLimitsNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceGeneratedCommandsLimitsNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceGeneratedCommandsLimitsNVX __CreateInstance(global::VkDeviceGeneratedCommandsLimitsNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceGeneratedCommandsLimitsNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceGeneratedCommandsLimitsNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceGeneratedCommandsLimitsNVX.__Internal));
        *(global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceGeneratedCommandsLimitsNVX(global::VkDeviceGeneratedCommandsLimitsNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceGeneratedCommandsLimitsNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceGeneratedCommandsLimitsNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGeneratedCommandsLimitsNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceGeneratedCommandsLimitsNVX(global::VkDeviceGeneratedCommandsLimitsNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceGeneratedCommandsLimitsNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) __Instance) = *((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceGeneratedCommandsLimitsNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MaxIndirectCommandsLayoutTokenCount
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) __Instance)->maxIndirectCommandsLayoutTokenCount;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*)__Instance)->maxIndirectCommandsLayoutTokenCount = value;
        }
    }

    public uint MaxObjectEntryCounts
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) __Instance)->maxObjectEntryCounts;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*)__Instance)->maxObjectEntryCounts = value;
        }
    }

    public uint MinSequenceCountBufferOffsetAlignment
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) __Instance)->minSequenceCountBufferOffsetAlignment;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*)__Instance)->minSequenceCountBufferOffsetAlignment = value;
        }
    }

    public uint MinSequenceIndexBufferOffsetAlignment
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) __Instance)->minSequenceIndexBufferOffsetAlignment;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*)__Instance)->minSequenceIndexBufferOffsetAlignment = value;
        }
    }

    public uint MinCommandsTokenBufferOffsetAlignment
    {
        get
        {
            return ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*) __Instance)->minCommandsTokenBufferOffsetAlignment;
        }

        set
        {
            ((global::VkDeviceGeneratedCommandsLimitsNVX.__Internal*)__Instance)->minCommandsTokenBufferOffsetAlignment = value;
        }
    }
}

public unsafe partial class VkIndirectCommandsTokenNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkIndirectCommandsTokenTypeNVX tokenType;

        [FieldOffset(8)]
        internal global::System.IntPtr buffer;

        [FieldOffset(16)]
        internal ulong offset;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkIndirectCommandsTokenNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkIndirectCommandsTokenNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkIndirectCommandsTokenNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkIndirectCommandsTokenNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkIndirectCommandsTokenNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkIndirectCommandsTokenNVX __CreateInstance(global::VkIndirectCommandsTokenNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkIndirectCommandsTokenNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkIndirectCommandsTokenNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsTokenNVX.__Internal));
        *(global::VkIndirectCommandsTokenNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkIndirectCommandsTokenNVX(global::VkIndirectCommandsTokenNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkIndirectCommandsTokenNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkIndirectCommandsTokenNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsTokenNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkIndirectCommandsTokenNVX(global::VkIndirectCommandsTokenNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsTokenNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkIndirectCommandsTokenNVX.__Internal*) __Instance) = *((global::VkIndirectCommandsTokenNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkIndirectCommandsTokenNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkIndirectCommandsTokenTypeNVX TokenType
    {
        get
        {
            return ((global::VkIndirectCommandsTokenNVX.__Internal*) __Instance)->tokenType;
        }

        set
        {
            ((global::VkIndirectCommandsTokenNVX.__Internal*)__Instance)->tokenType = value;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkIndirectCommandsTokenNVX.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkIndirectCommandsTokenNVX.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkIndirectCommandsTokenNVX.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkIndirectCommandsTokenNVX.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkIndirectCommandsTokenNVX.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong Offset
    {
        get
        {
            return ((global::VkIndirectCommandsTokenNVX.__Internal*) __Instance)->offset;
        }

        set
        {
            ((global::VkIndirectCommandsTokenNVX.__Internal*)__Instance)->offset = value;
        }
    }
}

public unsafe partial class VkIndirectCommandsLayoutTokenNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkIndirectCommandsTokenTypeNVX tokenType;

        [FieldOffset(4)]
        internal uint bindingUnit;

        [FieldOffset(8)]
        internal uint dynamicCount;

        [FieldOffset(12)]
        internal uint divisor;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkIndirectCommandsLayoutTokenNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkIndirectCommandsLayoutTokenNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkIndirectCommandsLayoutTokenNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkIndirectCommandsLayoutTokenNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkIndirectCommandsLayoutTokenNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkIndirectCommandsLayoutTokenNVX __CreateInstance(global::VkIndirectCommandsLayoutTokenNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkIndirectCommandsLayoutTokenNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkIndirectCommandsLayoutTokenNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsLayoutTokenNVX.__Internal));
        *(global::VkIndirectCommandsLayoutTokenNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkIndirectCommandsLayoutTokenNVX(global::VkIndirectCommandsLayoutTokenNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkIndirectCommandsLayoutTokenNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkIndirectCommandsLayoutTokenNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsLayoutTokenNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkIndirectCommandsLayoutTokenNVX(global::VkIndirectCommandsLayoutTokenNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsLayoutTokenNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkIndirectCommandsLayoutTokenNVX.__Internal*) __Instance) = *((global::VkIndirectCommandsLayoutTokenNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkIndirectCommandsLayoutTokenNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkIndirectCommandsTokenTypeNVX TokenType
    {
        get
        {
            return ((global::VkIndirectCommandsLayoutTokenNVX.__Internal*) __Instance)->tokenType;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutTokenNVX.__Internal*)__Instance)->tokenType = value;
        }
    }

    public uint BindingUnit
    {
        get
        {
            return ((global::VkIndirectCommandsLayoutTokenNVX.__Internal*) __Instance)->bindingUnit;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutTokenNVX.__Internal*)__Instance)->bindingUnit = value;
        }
    }

    public uint DynamicCount
    {
        get
        {
            return ((global::VkIndirectCommandsLayoutTokenNVX.__Internal*) __Instance)->dynamicCount;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutTokenNVX.__Internal*)__Instance)->dynamicCount = value;
        }
    }

    public uint Divisor
    {
        get
        {
            return ((global::VkIndirectCommandsLayoutTokenNVX.__Internal*) __Instance)->divisor;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutTokenNVX.__Internal*)__Instance)->divisor = value;
        }
    }
}

public unsafe partial class VkIndirectCommandsLayoutCreateInfoNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkPipelineBindPoint pipelineBindPoint;

        [FieldOffset(20)]
        internal uint flags;

        [FieldOffset(24)]
        internal uint tokenCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pTokens;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkIndirectCommandsLayoutCreateInfoNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkIndirectCommandsLayoutCreateInfoNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkIndirectCommandsLayoutCreateInfoNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkIndirectCommandsLayoutCreateInfoNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkIndirectCommandsLayoutCreateInfoNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkIndirectCommandsLayoutCreateInfoNVX __CreateInstance(global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkIndirectCommandsLayoutCreateInfoNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal));
        *(global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkIndirectCommandsLayoutCreateInfoNVX(global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkIndirectCommandsLayoutCreateInfoNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkIndirectCommandsLayoutCreateInfoNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkIndirectCommandsLayoutCreateInfoNVX(global::VkIndirectCommandsLayoutCreateInfoNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance) = *((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkIndirectCommandsLayoutCreateInfoNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkPipelineBindPoint PipelineBindPoint
    {
        get
        {
            return ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance)->pipelineBindPoint;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*)__Instance)->pipelineBindPoint = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*)__Instance)->flags = value;
        }
    }

    public uint TokenCount
    {
        get
        {
            return ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance)->tokenCount;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*)__Instance)->tokenCount = value;
        }
    }

    public global::VkIndirectCommandsLayoutTokenNVX PTokens
    {
        get
        {
            global::VkIndirectCommandsLayoutTokenNVX __result0;
            if (((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance)->pTokens == IntPtr.Zero) __result0 = null;
            else if (global::VkIndirectCommandsLayoutTokenNVX.NativeToManagedMap.ContainsKey(((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance)->pTokens))
                __result0 = (global::VkIndirectCommandsLayoutTokenNVX) global::VkIndirectCommandsLayoutTokenNVX.NativeToManagedMap[((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance)->pTokens];
            else __result0 = global::VkIndirectCommandsLayoutTokenNVX.__CreateInstance(((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*) __Instance)->pTokens);
            return __result0;
        }

        set
        {
            ((global::VkIndirectCommandsLayoutCreateInfoNVX.__Internal*)__Instance)->pTokens = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkCmdProcessCommandsInfoNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 96)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr objectTable;

        [FieldOffset(24)]
        internal global::System.IntPtr indirectCommandsLayout;

        [FieldOffset(32)]
        internal uint indirectCommandsTokenCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pIndirectCommandsTokens;

        [FieldOffset(48)]
        internal uint maxSequencesCount;

        [FieldOffset(56)]
        internal global::System.IntPtr targetCommandBuffer;

        [FieldOffset(64)]
        internal global::System.IntPtr sequencesCountBuffer;

        [FieldOffset(72)]
        internal ulong sequencesCountOffset;

        [FieldOffset(80)]
        internal global::System.IntPtr sequencesIndexBuffer;

        [FieldOffset(88)]
        internal ulong sequencesIndexOffset;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkCmdProcessCommandsInfoNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCmdProcessCommandsInfoNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCmdProcessCommandsInfoNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCmdProcessCommandsInfoNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCmdProcessCommandsInfoNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkCmdProcessCommandsInfoNVX __CreateInstance(global::VkCmdProcessCommandsInfoNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkCmdProcessCommandsInfoNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCmdProcessCommandsInfoNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCmdProcessCommandsInfoNVX.__Internal));
        *(global::VkCmdProcessCommandsInfoNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCmdProcessCommandsInfoNVX(global::VkCmdProcessCommandsInfoNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCmdProcessCommandsInfoNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkCmdProcessCommandsInfoNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCmdProcessCommandsInfoNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkCmdProcessCommandsInfoNVX(global::VkCmdProcessCommandsInfoNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCmdProcessCommandsInfoNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance) = *((global::VkCmdProcessCommandsInfoNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkCmdProcessCommandsInfoNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkObjectTableNVX_T ObjectTable
    {
        get
        {
            global::VkObjectTableNVX_T __result0;
            if (((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->objectTable == IntPtr.Zero) __result0 = null;
            else if (global::VkObjectTableNVX_T.NativeToManagedMap.ContainsKey(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->objectTable))
                __result0 = (global::VkObjectTableNVX_T) global::VkObjectTableNVX_T.NativeToManagedMap[((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->objectTable];
            else __result0 = global::VkObjectTableNVX_T.__CreateInstance(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->objectTable);
            return __result0;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->objectTable = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkIndirectCommandsLayoutNVX_T IndirectCommandsLayout
    {
        get
        {
            global::VkIndirectCommandsLayoutNVX_T __result0;
            if (((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->indirectCommandsLayout == IntPtr.Zero) __result0 = null;
            else if (global::VkIndirectCommandsLayoutNVX_T.NativeToManagedMap.ContainsKey(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->indirectCommandsLayout))
                __result0 = (global::VkIndirectCommandsLayoutNVX_T) global::VkIndirectCommandsLayoutNVX_T.NativeToManagedMap[((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->indirectCommandsLayout];
            else __result0 = global::VkIndirectCommandsLayoutNVX_T.__CreateInstance(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->indirectCommandsLayout);
            return __result0;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->indirectCommandsLayout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint IndirectCommandsTokenCount
    {
        get
        {
            return ((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->indirectCommandsTokenCount;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->indirectCommandsTokenCount = value;
        }
    }

    public global::VkIndirectCommandsTokenNVX PIndirectCommandsTokens
    {
        get
        {
            global::VkIndirectCommandsTokenNVX __result0;
            if (((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->pIndirectCommandsTokens == IntPtr.Zero) __result0 = null;
            else if (global::VkIndirectCommandsTokenNVX.NativeToManagedMap.ContainsKey(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->pIndirectCommandsTokens))
                __result0 = (global::VkIndirectCommandsTokenNVX) global::VkIndirectCommandsTokenNVX.NativeToManagedMap[((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->pIndirectCommandsTokens];
            else __result0 = global::VkIndirectCommandsTokenNVX.__CreateInstance(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->pIndirectCommandsTokens);
            return __result0;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->pIndirectCommandsTokens = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint MaxSequencesCount
    {
        get
        {
            return ((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->maxSequencesCount;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->maxSequencesCount = value;
        }
    }

    public global::VkCommandBufferT TargetCommandBuffer
    {
        get
        {
            global::VkCommandBufferT __result0;
            if (((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->targetCommandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::VkCommandBufferT.NativeToManagedMap.ContainsKey(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->targetCommandBuffer))
                __result0 = (global::VkCommandBufferT) global::VkCommandBufferT.NativeToManagedMap[((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->targetCommandBuffer];
            else __result0 = global::VkCommandBufferT.__CreateInstance(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->targetCommandBuffer);
            return __result0;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->targetCommandBuffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkBufferT SequencesCountBuffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesCountBuffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesCountBuffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesCountBuffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesCountBuffer);
            return __result0;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->sequencesCountBuffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong SequencesCountOffset
    {
        get
        {
            return ((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesCountOffset;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->sequencesCountOffset = value;
        }
    }

    public global::VkBufferT SequencesIndexBuffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesIndexBuffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesIndexBuffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesIndexBuffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesIndexBuffer);
            return __result0;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->sequencesIndexBuffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public ulong SequencesIndexOffset
    {
        get
        {
            return ((global::VkCmdProcessCommandsInfoNVX.__Internal*) __Instance)->sequencesIndexOffset;
        }

        set
        {
            ((global::VkCmdProcessCommandsInfoNVX.__Internal*)__Instance)->sequencesIndexOffset = value;
        }
    }
}

public unsafe partial class VkCmdReserveSpaceForCommandsInfoNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr objectTable;

        [FieldOffset(24)]
        internal global::System.IntPtr indirectCommandsLayout;

        [FieldOffset(32)]
        internal uint maxSequencesCount;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkCmdReserveSpaceForCommandsInfoNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCmdReserveSpaceForCommandsInfoNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCmdReserveSpaceForCommandsInfoNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCmdReserveSpaceForCommandsInfoNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCmdReserveSpaceForCommandsInfoNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkCmdReserveSpaceForCommandsInfoNVX __CreateInstance(global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkCmdReserveSpaceForCommandsInfoNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal));
        *(global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCmdReserveSpaceForCommandsInfoNVX(global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCmdReserveSpaceForCommandsInfoNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkCmdReserveSpaceForCommandsInfoNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkCmdReserveSpaceForCommandsInfoNVX(global::VkCmdReserveSpaceForCommandsInfoNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance) = *((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkCmdReserveSpaceForCommandsInfoNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkObjectTableNVX_T ObjectTable
    {
        get
        {
            global::VkObjectTableNVX_T __result0;
            if (((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->objectTable == IntPtr.Zero) __result0 = null;
            else if (global::VkObjectTableNVX_T.NativeToManagedMap.ContainsKey(((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->objectTable))
                __result0 = (global::VkObjectTableNVX_T) global::VkObjectTableNVX_T.NativeToManagedMap[((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->objectTable];
            else __result0 = global::VkObjectTableNVX_T.__CreateInstance(((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->objectTable);
            return __result0;
        }

        set
        {
            ((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*)__Instance)->objectTable = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkIndirectCommandsLayoutNVX_T IndirectCommandsLayout
    {
        get
        {
            global::VkIndirectCommandsLayoutNVX_T __result0;
            if (((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->indirectCommandsLayout == IntPtr.Zero) __result0 = null;
            else if (global::VkIndirectCommandsLayoutNVX_T.NativeToManagedMap.ContainsKey(((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->indirectCommandsLayout))
                __result0 = (global::VkIndirectCommandsLayoutNVX_T) global::VkIndirectCommandsLayoutNVX_T.NativeToManagedMap[((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->indirectCommandsLayout];
            else __result0 = global::VkIndirectCommandsLayoutNVX_T.__CreateInstance(((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->indirectCommandsLayout);
            return __result0;
        }

        set
        {
            ((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*)__Instance)->indirectCommandsLayout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint MaxSequencesCount
    {
        get
        {
            return ((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*) __Instance)->maxSequencesCount;
        }

        set
        {
            ((global::VkCmdReserveSpaceForCommandsInfoNVX.__Internal*)__Instance)->maxSequencesCount = value;
        }
    }
}

public unsafe partial class VkObjectTableCreateInfoNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint objectCount;

        [FieldOffset(24)]
        internal global::VkObjectEntryTypeNVX* pObjectEntryTypes;

        [FieldOffset(32)]
        internal global::System.IntPtr pObjectEntryCounts;

        [FieldOffset(40)]
        internal global::System.IntPtr pObjectEntryUsageFlags;

        [FieldOffset(48)]
        internal uint maxUniformBuffersPerDescriptor;

        [FieldOffset(52)]
        internal uint maxStorageBuffersPerDescriptor;

        [FieldOffset(56)]
        internal uint maxStorageImagesPerDescriptor;

        [FieldOffset(60)]
        internal uint maxSampledImagesPerDescriptor;

        [FieldOffset(64)]
        internal uint maxPipelineLayouts;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkObjectTableCreateInfoNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableCreateInfoNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableCreateInfoNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkObjectTableCreateInfoNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkObjectTableCreateInfoNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkObjectTableCreateInfoNVX __CreateInstance(global::VkObjectTableCreateInfoNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkObjectTableCreateInfoNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkObjectTableCreateInfoNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkObjectTableCreateInfoNVX.__Internal));
        *(global::VkObjectTableCreateInfoNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkObjectTableCreateInfoNVX(global::VkObjectTableCreateInfoNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkObjectTableCreateInfoNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkObjectTableCreateInfoNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableCreateInfoNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkObjectTableCreateInfoNVX(global::VkObjectTableCreateInfoNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableCreateInfoNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance) = *((global::VkObjectTableCreateInfoNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkObjectTableCreateInfoNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ObjectCount
    {
        get
        {
            return ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->objectCount;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->objectCount = value;
        }
    }

    public global::VkObjectEntryTypeNVX* PObjectEntryTypes
    {
        get
        {
            return ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->pObjectEntryTypes;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->pObjectEntryTypes = value;
        }
    }

    public uint* PObjectEntryCounts
    {
        get
        {
            return (uint*) ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->pObjectEntryCounts;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->pObjectEntryCounts = (global::System.IntPtr) value;
        }
    }

    public uint* PObjectEntryUsageFlags
    {
        get
        {
            return (uint*) ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->pObjectEntryUsageFlags;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->pObjectEntryUsageFlags = (global::System.IntPtr) value;
        }
    }

    public uint MaxUniformBuffersPerDescriptor
    {
        get
        {
            return ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->maxUniformBuffersPerDescriptor;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->maxUniformBuffersPerDescriptor = value;
        }
    }

    public uint MaxStorageBuffersPerDescriptor
    {
        get
        {
            return ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->maxStorageBuffersPerDescriptor;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->maxStorageBuffersPerDescriptor = value;
        }
    }

    public uint MaxStorageImagesPerDescriptor
    {
        get
        {
            return ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->maxStorageImagesPerDescriptor;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->maxStorageImagesPerDescriptor = value;
        }
    }

    public uint MaxSampledImagesPerDescriptor
    {
        get
        {
            return ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->maxSampledImagesPerDescriptor;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->maxSampledImagesPerDescriptor = value;
        }
    }

    public uint MaxPipelineLayouts
    {
        get
        {
            return ((global::VkObjectTableCreateInfoNVX.__Internal*) __Instance)->maxPipelineLayouts;
        }

        set
        {
            ((global::VkObjectTableCreateInfoNVX.__Internal*)__Instance)->maxPipelineLayouts = value;
        }
    }
}

public unsafe partial class VkObjectTableEntryNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkObjectEntryTypeNVX type;

        [FieldOffset(4)]
        internal uint flags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkObjectTableEntryNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableEntryNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableEntryNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkObjectTableEntryNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkObjectTableEntryNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkObjectTableEntryNVX __CreateInstance(global::VkObjectTableEntryNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkObjectTableEntryNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkObjectTableEntryNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkObjectTableEntryNVX.__Internal));
        *(global::VkObjectTableEntryNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkObjectTableEntryNVX(global::VkObjectTableEntryNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkObjectTableEntryNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkObjectTableEntryNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkObjectTableEntryNVX(global::VkObjectTableEntryNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkObjectTableEntryNVX.__Internal*) __Instance) = *((global::VkObjectTableEntryNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkObjectTableEntryNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkObjectEntryTypeNVX Type
    {
        get
        {
            return ((global::VkObjectTableEntryNVX.__Internal*) __Instance)->type;
        }

        set
        {
            ((global::VkObjectTableEntryNVX.__Internal*)__Instance)->type = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkObjectTableEntryNVX.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkObjectTableEntryNVX.__Internal*)__Instance)->flags = value;
        }
    }
}

public unsafe partial class VkObjectTablePipelineEntryNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkObjectEntryTypeNVX type;

        [FieldOffset(4)]
        internal uint flags;

        [FieldOffset(8)]
        internal global::System.IntPtr pipeline;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkObjectTablePipelineEntryNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTablePipelineEntryNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTablePipelineEntryNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkObjectTablePipelineEntryNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkObjectTablePipelineEntryNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkObjectTablePipelineEntryNVX __CreateInstance(global::VkObjectTablePipelineEntryNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkObjectTablePipelineEntryNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkObjectTablePipelineEntryNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkObjectTablePipelineEntryNVX.__Internal));
        *(global::VkObjectTablePipelineEntryNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkObjectTablePipelineEntryNVX(global::VkObjectTablePipelineEntryNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkObjectTablePipelineEntryNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkObjectTablePipelineEntryNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTablePipelineEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkObjectTablePipelineEntryNVX(global::VkObjectTablePipelineEntryNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTablePipelineEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkObjectTablePipelineEntryNVX.__Internal*) __Instance) = *((global::VkObjectTablePipelineEntryNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkObjectTablePipelineEntryNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkObjectEntryTypeNVX Type
    {
        get
        {
            return ((global::VkObjectTablePipelineEntryNVX.__Internal*) __Instance)->type;
        }

        set
        {
            ((global::VkObjectTablePipelineEntryNVX.__Internal*)__Instance)->type = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkObjectTablePipelineEntryNVX.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkObjectTablePipelineEntryNVX.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkPipelineT Pipeline
    {
        get
        {
            global::VkPipelineT __result0;
            if (((global::VkObjectTablePipelineEntryNVX.__Internal*) __Instance)->pipeline == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineT.NativeToManagedMap.ContainsKey(((global::VkObjectTablePipelineEntryNVX.__Internal*) __Instance)->pipeline))
                __result0 = (global::VkPipelineT) global::VkPipelineT.NativeToManagedMap[((global::VkObjectTablePipelineEntryNVX.__Internal*) __Instance)->pipeline];
            else __result0 = global::VkPipelineT.__CreateInstance(((global::VkObjectTablePipelineEntryNVX.__Internal*) __Instance)->pipeline);
            return __result0;
        }

        set
        {
            ((global::VkObjectTablePipelineEntryNVX.__Internal*)__Instance)->pipeline = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkObjectTableDescriptorSetEntryNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkObjectEntryTypeNVX type;

        [FieldOffset(4)]
        internal uint flags;

        [FieldOffset(8)]
        internal global::System.IntPtr pipelineLayout;

        [FieldOffset(16)]
        internal global::System.IntPtr descriptorSet;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkObjectTableDescriptorSetEntryNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableDescriptorSetEntryNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableDescriptorSetEntryNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkObjectTableDescriptorSetEntryNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkObjectTableDescriptorSetEntryNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkObjectTableDescriptorSetEntryNVX __CreateInstance(global::VkObjectTableDescriptorSetEntryNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkObjectTableDescriptorSetEntryNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkObjectTableDescriptorSetEntryNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkObjectTableDescriptorSetEntryNVX.__Internal));
        *(global::VkObjectTableDescriptorSetEntryNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkObjectTableDescriptorSetEntryNVX(global::VkObjectTableDescriptorSetEntryNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkObjectTableDescriptorSetEntryNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkObjectTableDescriptorSetEntryNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableDescriptorSetEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkObjectTableDescriptorSetEntryNVX(global::VkObjectTableDescriptorSetEntryNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableDescriptorSetEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance) = *((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkObjectTableDescriptorSetEntryNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkObjectEntryTypeNVX Type
    {
        get
        {
            return ((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->type;
        }

        set
        {
            ((global::VkObjectTableDescriptorSetEntryNVX.__Internal*)__Instance)->type = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkObjectTableDescriptorSetEntryNVX.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkPipelineLayoutT PipelineLayout
    {
        get
        {
            global::VkPipelineLayoutT __result0;
            if (((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->pipelineLayout == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineLayoutT.NativeToManagedMap.ContainsKey(((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->pipelineLayout))
                __result0 = (global::VkPipelineLayoutT) global::VkPipelineLayoutT.NativeToManagedMap[((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->pipelineLayout];
            else __result0 = global::VkPipelineLayoutT.__CreateInstance(((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->pipelineLayout);
            return __result0;
        }

        set
        {
            ((global::VkObjectTableDescriptorSetEntryNVX.__Internal*)__Instance)->pipelineLayout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkDescriptorSetT DescriptorSet
    {
        get
        {
            global::VkDescriptorSetT __result0;
            if (((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::VkDescriptorSetT.NativeToManagedMap.ContainsKey(((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->descriptorSet))
                __result0 = (global::VkDescriptorSetT) global::VkDescriptorSetT.NativeToManagedMap[((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->descriptorSet];
            else __result0 = global::VkDescriptorSetT.__CreateInstance(((global::VkObjectTableDescriptorSetEntryNVX.__Internal*) __Instance)->descriptorSet);
            return __result0;
        }

        set
        {
            ((global::VkObjectTableDescriptorSetEntryNVX.__Internal*)__Instance)->descriptorSet = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkObjectTableVertexBufferEntryNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkObjectEntryTypeNVX type;

        [FieldOffset(4)]
        internal uint flags;

        [FieldOffset(8)]
        internal global::System.IntPtr buffer;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkObjectTableVertexBufferEntryNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableVertexBufferEntryNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableVertexBufferEntryNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkObjectTableVertexBufferEntryNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkObjectTableVertexBufferEntryNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkObjectTableVertexBufferEntryNVX __CreateInstance(global::VkObjectTableVertexBufferEntryNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkObjectTableVertexBufferEntryNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkObjectTableVertexBufferEntryNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkObjectTableVertexBufferEntryNVX.__Internal));
        *(global::VkObjectTableVertexBufferEntryNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkObjectTableVertexBufferEntryNVX(global::VkObjectTableVertexBufferEntryNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkObjectTableVertexBufferEntryNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkObjectTableVertexBufferEntryNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableVertexBufferEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkObjectTableVertexBufferEntryNVX(global::VkObjectTableVertexBufferEntryNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableVertexBufferEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkObjectTableVertexBufferEntryNVX.__Internal*) __Instance) = *((global::VkObjectTableVertexBufferEntryNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkObjectTableVertexBufferEntryNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkObjectEntryTypeNVX Type
    {
        get
        {
            return ((global::VkObjectTableVertexBufferEntryNVX.__Internal*) __Instance)->type;
        }

        set
        {
            ((global::VkObjectTableVertexBufferEntryNVX.__Internal*)__Instance)->type = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkObjectTableVertexBufferEntryNVX.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkObjectTableVertexBufferEntryNVX.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkObjectTableVertexBufferEntryNVX.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkObjectTableVertexBufferEntryNVX.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkObjectTableVertexBufferEntryNVX.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkObjectTableVertexBufferEntryNVX.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkObjectTableVertexBufferEntryNVX.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkObjectTableIndexBufferEntryNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkObjectEntryTypeNVX type;

        [FieldOffset(4)]
        internal uint flags;

        [FieldOffset(8)]
        internal global::System.IntPtr buffer;

        [FieldOffset(16)]
        internal global::VkIndexType indexType;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkObjectTableIndexBufferEntryNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableIndexBufferEntryNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTableIndexBufferEntryNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkObjectTableIndexBufferEntryNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkObjectTableIndexBufferEntryNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkObjectTableIndexBufferEntryNVX __CreateInstance(global::VkObjectTableIndexBufferEntryNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkObjectTableIndexBufferEntryNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkObjectTableIndexBufferEntryNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkObjectTableIndexBufferEntryNVX.__Internal));
        *(global::VkObjectTableIndexBufferEntryNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkObjectTableIndexBufferEntryNVX(global::VkObjectTableIndexBufferEntryNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkObjectTableIndexBufferEntryNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkObjectTableIndexBufferEntryNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableIndexBufferEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkObjectTableIndexBufferEntryNVX(global::VkObjectTableIndexBufferEntryNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTableIndexBufferEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkObjectTableIndexBufferEntryNVX.__Internal*) __Instance) = *((global::VkObjectTableIndexBufferEntryNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkObjectTableIndexBufferEntryNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkObjectEntryTypeNVX Type
    {
        get
        {
            return ((global::VkObjectTableIndexBufferEntryNVX.__Internal*) __Instance)->type;
        }

        set
        {
            ((global::VkObjectTableIndexBufferEntryNVX.__Internal*)__Instance)->type = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkObjectTableIndexBufferEntryNVX.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkObjectTableIndexBufferEntryNVX.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkBufferT Buffer
    {
        get
        {
            global::VkBufferT __result0;
            if (((global::VkObjectTableIndexBufferEntryNVX.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
            else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::VkObjectTableIndexBufferEntryNVX.__Internal*) __Instance)->buffer))
                __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::VkObjectTableIndexBufferEntryNVX.__Internal*) __Instance)->buffer];
            else __result0 = global::VkBufferT.__CreateInstance(((global::VkObjectTableIndexBufferEntryNVX.__Internal*) __Instance)->buffer);
            return __result0;
        }

        set
        {
            ((global::VkObjectTableIndexBufferEntryNVX.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public global::VkIndexType IndexType
    {
        get
        {
            return ((global::VkObjectTableIndexBufferEntryNVX.__Internal*) __Instance)->indexType;
        }

        set
        {
            ((global::VkObjectTableIndexBufferEntryNVX.__Internal*)__Instance)->indexType = value;
        }
    }
}

public unsafe partial class VkObjectTablePushConstantEntryNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkObjectEntryTypeNVX type;

        [FieldOffset(4)]
        internal uint flags;

        [FieldOffset(8)]
        internal global::System.IntPtr pipelineLayout;

        [FieldOffset(16)]
        internal uint stageFlags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkObjectTablePushConstantEntryNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTablePushConstantEntryNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkObjectTablePushConstantEntryNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkObjectTablePushConstantEntryNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkObjectTablePushConstantEntryNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkObjectTablePushConstantEntryNVX __CreateInstance(global::VkObjectTablePushConstantEntryNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkObjectTablePushConstantEntryNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkObjectTablePushConstantEntryNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkObjectTablePushConstantEntryNVX.__Internal));
        *(global::VkObjectTablePushConstantEntryNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkObjectTablePushConstantEntryNVX(global::VkObjectTablePushConstantEntryNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkObjectTablePushConstantEntryNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkObjectTablePushConstantEntryNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTablePushConstantEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkObjectTablePushConstantEntryNVX(global::VkObjectTablePushConstantEntryNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkObjectTablePushConstantEntryNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkObjectTablePushConstantEntryNVX.__Internal*) __Instance) = *((global::VkObjectTablePushConstantEntryNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkObjectTablePushConstantEntryNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkObjectEntryTypeNVX Type
    {
        get
        {
            return ((global::VkObjectTablePushConstantEntryNVX.__Internal*) __Instance)->type;
        }

        set
        {
            ((global::VkObjectTablePushConstantEntryNVX.__Internal*)__Instance)->type = value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkObjectTablePushConstantEntryNVX.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkObjectTablePushConstantEntryNVX.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkPipelineLayoutT PipelineLayout
    {
        get
        {
            global::VkPipelineLayoutT __result0;
            if (((global::VkObjectTablePushConstantEntryNVX.__Internal*) __Instance)->pipelineLayout == IntPtr.Zero) __result0 = null;
            else if (global::VkPipelineLayoutT.NativeToManagedMap.ContainsKey(((global::VkObjectTablePushConstantEntryNVX.__Internal*) __Instance)->pipelineLayout))
                __result0 = (global::VkPipelineLayoutT) global::VkPipelineLayoutT.NativeToManagedMap[((global::VkObjectTablePushConstantEntryNVX.__Internal*) __Instance)->pipelineLayout];
            else __result0 = global::VkPipelineLayoutT.__CreateInstance(((global::VkObjectTablePushConstantEntryNVX.__Internal*) __Instance)->pipelineLayout);
            return __result0;
        }

        set
        {
            ((global::VkObjectTablePushConstantEntryNVX.__Internal*)__Instance)->pipelineLayout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint StageFlags
    {
        get
        {
            return ((global::VkObjectTablePushConstantEntryNVX.__Internal*) __Instance)->stageFlags;
        }

        set
        {
            ((global::VkObjectTablePushConstantEntryNVX.__Internal*)__Instance)->stageFlags = value;
        }
    }
}

public unsafe partial class VkViewportWScalingNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal float xcoeff;

        [FieldOffset(4)]
        internal float ycoeff;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkViewportWScalingNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkViewportWScalingNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkViewportWScalingNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkViewportWScalingNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkViewportWScalingNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkViewportWScalingNV __CreateInstance(global::VkViewportWScalingNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkViewportWScalingNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkViewportWScalingNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkViewportWScalingNV.__Internal));
        *(global::VkViewportWScalingNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkViewportWScalingNV(global::VkViewportWScalingNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkViewportWScalingNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkViewportWScalingNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkViewportWScalingNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkViewportWScalingNV(global::VkViewportWScalingNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkViewportWScalingNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkViewportWScalingNV.__Internal*) __Instance) = *((global::VkViewportWScalingNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkViewportWScalingNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public float Xcoeff
    {
        get
        {
            return ((global::VkViewportWScalingNV.__Internal*) __Instance)->xcoeff;
        }

        set
        {
            ((global::VkViewportWScalingNV.__Internal*)__Instance)->xcoeff = value;
        }
    }

    public float Ycoeff
    {
        get
        {
            return ((global::VkViewportWScalingNV.__Internal*) __Instance)->ycoeff;
        }

        set
        {
            ((global::VkViewportWScalingNV.__Internal*)__Instance)->ycoeff = value;
        }
    }
}

public unsafe partial class VkPipelineViewportWScalingStateCreateInfoNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint viewportWScalingEnable;

        [FieldOffset(20)]
        internal uint viewportCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pViewportWScalings;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineViewportWScalingStateCreateInfoNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineViewportWScalingStateCreateInfoNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineViewportWScalingStateCreateInfoNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineViewportWScalingStateCreateInfoNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineViewportWScalingStateCreateInfoNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineViewportWScalingStateCreateInfoNV __CreateInstance(global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineViewportWScalingStateCreateInfoNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal));
        *(global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineViewportWScalingStateCreateInfoNV(global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineViewportWScalingStateCreateInfoNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineViewportWScalingStateCreateInfoNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineViewportWScalingStateCreateInfoNV(global::VkPipelineViewportWScalingStateCreateInfoNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) __Instance) = *((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineViewportWScalingStateCreateInfoNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ViewportWScalingEnable
    {
        get
        {
            return ((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) __Instance)->viewportWScalingEnable;
        }

        set
        {
            ((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*)__Instance)->viewportWScalingEnable = value;
        }
    }

    public uint ViewportCount
    {
        get
        {
            return ((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) __Instance)->viewportCount;
        }

        set
        {
            ((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*)__Instance)->viewportCount = value;
        }
    }

    public global::VkViewportWScalingNV PViewportWScalings
    {
        get
        {
            global::VkViewportWScalingNV __result0;
            if (((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) __Instance)->pViewportWScalings == IntPtr.Zero) __result0 = null;
            else if (global::VkViewportWScalingNV.NativeToManagedMap.ContainsKey(((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) __Instance)->pViewportWScalings))
                __result0 = (global::VkViewportWScalingNV) global::VkViewportWScalingNV.NativeToManagedMap[((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) __Instance)->pViewportWScalings];
            else __result0 = global::VkViewportWScalingNV.__CreateInstance(((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*) __Instance)->pViewportWScalings);
            return __result0;
        }

        set
        {
            ((global::VkPipelineViewportWScalingStateCreateInfoNV.__Internal*)__Instance)->pViewportWScalings = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkSurfaceCapabilities2EXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint minImageCount;

        [FieldOffset(20)]
        internal uint maxImageCount;

        [FieldOffset(24)]
        internal global::VkExtent2D.__Internal currentExtent;

        [FieldOffset(32)]
        internal global::VkExtent2D.__Internal minImageExtent;

        [FieldOffset(40)]
        internal global::VkExtent2D.__Internal maxImageExtent;

        [FieldOffset(48)]
        internal uint maxImageArrayLayers;

        [FieldOffset(52)]
        internal uint supportedTransforms;

        [FieldOffset(56)]
        internal global::VkSurfaceTransformFlagBitsKHR currentTransform;

        [FieldOffset(60)]
        internal uint supportedCompositeAlpha;

        [FieldOffset(64)]
        internal uint supportedUsageFlags;

        [FieldOffset(68)]
        internal uint supportedSurfaceCounters;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSurfaceCapabilities2EXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceCapabilities2EXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSurfaceCapabilities2EXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSurfaceCapabilities2EXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSurfaceCapabilities2EXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkSurfaceCapabilities2EXT __CreateInstance(global::VkSurfaceCapabilities2EXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkSurfaceCapabilities2EXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSurfaceCapabilities2EXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSurfaceCapabilities2EXT.__Internal));
        *(global::VkSurfaceCapabilities2EXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSurfaceCapabilities2EXT(global::VkSurfaceCapabilities2EXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSurfaceCapabilities2EXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSurfaceCapabilities2EXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceCapabilities2EXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSurfaceCapabilities2EXT(global::VkSurfaceCapabilities2EXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSurfaceCapabilities2EXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance) = *((global::VkSurfaceCapabilities2EXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSurfaceCapabilities2EXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MinImageCount
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->minImageCount;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->minImageCount = value;
        }
    }

    public uint MaxImageCount
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->maxImageCount;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->maxImageCount = value;
        }
    }

    public global::VkExtent2D CurrentExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->currentExtent));
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->currentExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D MinImageExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->minImageExtent));
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->minImageExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public global::VkExtent2D MaxImageExtent
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->maxImageExtent));
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->maxImageExtent = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public uint MaxImageArrayLayers
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->maxImageArrayLayers;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->maxImageArrayLayers = value;
        }
    }

    public uint SupportedTransforms
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->supportedTransforms;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->supportedTransforms = value;
        }
    }

    public global::VkSurfaceTransformFlagBitsKHR CurrentTransform
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->currentTransform;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->currentTransform = value;
        }
    }

    public uint SupportedCompositeAlpha
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->supportedCompositeAlpha;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->supportedCompositeAlpha = value;
        }
    }

    public uint SupportedUsageFlags
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->supportedUsageFlags;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->supportedUsageFlags = value;
        }
    }

    public uint SupportedSurfaceCounters
    {
        get
        {
            return ((global::VkSurfaceCapabilities2EXT.__Internal*) __Instance)->supportedSurfaceCounters;
        }

        set
        {
            ((global::VkSurfaceCapabilities2EXT.__Internal*)__Instance)->supportedSurfaceCounters = value;
        }
    }
}

public unsafe partial class VkDisplayPowerInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkDisplayPowerStateEXT powerState;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayPowerInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPowerInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayPowerInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayPowerInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayPowerInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayPowerInfoEXT __CreateInstance(global::VkDisplayPowerInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayPowerInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayPowerInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayPowerInfoEXT.__Internal));
        *(global::VkDisplayPowerInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayPowerInfoEXT(global::VkDisplayPowerInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayPowerInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayPowerInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPowerInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayPowerInfoEXT(global::VkDisplayPowerInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayPowerInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayPowerInfoEXT.__Internal*) __Instance) = *((global::VkDisplayPowerInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayPowerInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplayPowerInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplayPowerInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplayPowerInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplayPowerInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDisplayPowerStateEXT PowerState
    {
        get
        {
            return ((global::VkDisplayPowerInfoEXT.__Internal*) __Instance)->powerState;
        }

        set
        {
            ((global::VkDisplayPowerInfoEXT.__Internal*)__Instance)->powerState = value;
        }
    }
}

public unsafe partial class VkDeviceEventInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkDeviceEventTypeEXT deviceEvent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceEventInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceEventInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceEventInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceEventInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceEventInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceEventInfoEXT __CreateInstance(global::VkDeviceEventInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceEventInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceEventInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceEventInfoEXT.__Internal));
        *(global::VkDeviceEventInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceEventInfoEXT(global::VkDeviceEventInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceEventInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceEventInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceEventInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceEventInfoEXT(global::VkDeviceEventInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceEventInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceEventInfoEXT.__Internal*) __Instance) = *((global::VkDeviceEventInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceEventInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceEventInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceEventInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceEventInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceEventInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDeviceEventTypeEXT DeviceEvent
    {
        get
        {
            return ((global::VkDeviceEventInfoEXT.__Internal*) __Instance)->deviceEvent;
        }

        set
        {
            ((global::VkDeviceEventInfoEXT.__Internal*)__Instance)->deviceEvent = value;
        }
    }
}

public unsafe partial class VkDisplayEventInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkDisplayEventTypeEXT displayEvent;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDisplayEventInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayEventInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDisplayEventInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDisplayEventInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDisplayEventInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDisplayEventInfoEXT __CreateInstance(global::VkDisplayEventInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDisplayEventInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDisplayEventInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDisplayEventInfoEXT.__Internal));
        *(global::VkDisplayEventInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDisplayEventInfoEXT(global::VkDisplayEventInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDisplayEventInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDisplayEventInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayEventInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDisplayEventInfoEXT(global::VkDisplayEventInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDisplayEventInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDisplayEventInfoEXT.__Internal*) __Instance) = *((global::VkDisplayEventInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDisplayEventInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDisplayEventInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDisplayEventInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDisplayEventInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDisplayEventInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkDisplayEventTypeEXT DisplayEvent
    {
        get
        {
            return ((global::VkDisplayEventInfoEXT.__Internal*) __Instance)->displayEvent;
        }

        set
        {
            ((global::VkDisplayEventInfoEXT.__Internal*)__Instance)->displayEvent = value;
        }
    }
}

public unsafe partial class VkSwapchainCounterCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint surfaceCounters;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSwapchainCounterCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSwapchainCounterCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSwapchainCounterCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSwapchainCounterCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSwapchainCounterCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkSwapchainCounterCreateInfoEXT __CreateInstance(global::VkSwapchainCounterCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkSwapchainCounterCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSwapchainCounterCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSwapchainCounterCreateInfoEXT.__Internal));
        *(global::VkSwapchainCounterCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSwapchainCounterCreateInfoEXT(global::VkSwapchainCounterCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSwapchainCounterCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSwapchainCounterCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSwapchainCounterCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSwapchainCounterCreateInfoEXT(global::VkSwapchainCounterCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSwapchainCounterCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSwapchainCounterCreateInfoEXT.__Internal*) __Instance) = *((global::VkSwapchainCounterCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSwapchainCounterCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSwapchainCounterCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSwapchainCounterCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSwapchainCounterCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSwapchainCounterCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SurfaceCounters
    {
        get
        {
            return ((global::VkSwapchainCounterCreateInfoEXT.__Internal*) __Instance)->surfaceCounters;
        }

        set
        {
            ((global::VkSwapchainCounterCreateInfoEXT.__Internal*)__Instance)->surfaceCounters = value;
        }
    }
}

public unsafe partial class VkRefreshCycleDurationGOOGLE : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal ulong refreshDuration;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkRefreshCycleDurationGOOGLE@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRefreshCycleDurationGOOGLE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRefreshCycleDurationGOOGLE>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRefreshCycleDurationGOOGLE __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRefreshCycleDurationGOOGLE(native.ToPointer(), skipVTables);
    }

    internal static global::VkRefreshCycleDurationGOOGLE __CreateInstance(global::VkRefreshCycleDurationGOOGLE.__Internal native, bool skipVTables = false)
    {
        return new global::VkRefreshCycleDurationGOOGLE(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRefreshCycleDurationGOOGLE.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRefreshCycleDurationGOOGLE.__Internal));
        *(global::VkRefreshCycleDurationGOOGLE.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRefreshCycleDurationGOOGLE(global::VkRefreshCycleDurationGOOGLE.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRefreshCycleDurationGOOGLE(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkRefreshCycleDurationGOOGLE()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRefreshCycleDurationGOOGLE.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkRefreshCycleDurationGOOGLE(global::VkRefreshCycleDurationGOOGLE _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRefreshCycleDurationGOOGLE.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkRefreshCycleDurationGOOGLE.__Internal*) __Instance) = *((global::VkRefreshCycleDurationGOOGLE.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkRefreshCycleDurationGOOGLE __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public ulong RefreshDuration
    {
        get
        {
            return ((global::VkRefreshCycleDurationGOOGLE.__Internal*) __Instance)->refreshDuration;
        }

        set
        {
            ((global::VkRefreshCycleDurationGOOGLE.__Internal*)__Instance)->refreshDuration = value;
        }
    }
}

public unsafe partial class VkPastPresentationTimingGOOGLE : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint presentID;

        [FieldOffset(8)]
        internal ulong desiredPresentTime;

        [FieldOffset(16)]
        internal ulong actualPresentTime;

        [FieldOffset(24)]
        internal ulong earliestPresentTime;

        [FieldOffset(32)]
        internal ulong presentMargin;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPastPresentationTimingGOOGLE@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPastPresentationTimingGOOGLE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPastPresentationTimingGOOGLE>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPastPresentationTimingGOOGLE __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPastPresentationTimingGOOGLE(native.ToPointer(), skipVTables);
    }

    internal static global::VkPastPresentationTimingGOOGLE __CreateInstance(global::VkPastPresentationTimingGOOGLE.__Internal native, bool skipVTables = false)
    {
        return new global::VkPastPresentationTimingGOOGLE(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPastPresentationTimingGOOGLE.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPastPresentationTimingGOOGLE.__Internal));
        *(global::VkPastPresentationTimingGOOGLE.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPastPresentationTimingGOOGLE(global::VkPastPresentationTimingGOOGLE.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPastPresentationTimingGOOGLE(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPastPresentationTimingGOOGLE()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPastPresentationTimingGOOGLE.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPastPresentationTimingGOOGLE(global::VkPastPresentationTimingGOOGLE _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPastPresentationTimingGOOGLE.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPastPresentationTimingGOOGLE.__Internal*) __Instance) = *((global::VkPastPresentationTimingGOOGLE.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPastPresentationTimingGOOGLE __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint PresentID
    {
        get
        {
            return ((global::VkPastPresentationTimingGOOGLE.__Internal*) __Instance)->presentID;
        }

        set
        {
            ((global::VkPastPresentationTimingGOOGLE.__Internal*)__Instance)->presentID = value;
        }
    }

    public ulong DesiredPresentTime
    {
        get
        {
            return ((global::VkPastPresentationTimingGOOGLE.__Internal*) __Instance)->desiredPresentTime;
        }

        set
        {
            ((global::VkPastPresentationTimingGOOGLE.__Internal*)__Instance)->desiredPresentTime = value;
        }
    }

    public ulong ActualPresentTime
    {
        get
        {
            return ((global::VkPastPresentationTimingGOOGLE.__Internal*) __Instance)->actualPresentTime;
        }

        set
        {
            ((global::VkPastPresentationTimingGOOGLE.__Internal*)__Instance)->actualPresentTime = value;
        }
    }

    public ulong EarliestPresentTime
    {
        get
        {
            return ((global::VkPastPresentationTimingGOOGLE.__Internal*) __Instance)->earliestPresentTime;
        }

        set
        {
            ((global::VkPastPresentationTimingGOOGLE.__Internal*)__Instance)->earliestPresentTime = value;
        }
    }

    public ulong PresentMargin
    {
        get
        {
            return ((global::VkPastPresentationTimingGOOGLE.__Internal*) __Instance)->presentMargin;
        }

        set
        {
            ((global::VkPastPresentationTimingGOOGLE.__Internal*)__Instance)->presentMargin = value;
        }
    }
}

public unsafe partial class VkPresentTimeGOOGLE : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint presentID;

        [FieldOffset(8)]
        internal ulong desiredPresentTime;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPresentTimeGOOGLE@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentTimeGOOGLE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentTimeGOOGLE>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPresentTimeGOOGLE __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPresentTimeGOOGLE(native.ToPointer(), skipVTables);
    }

    internal static global::VkPresentTimeGOOGLE __CreateInstance(global::VkPresentTimeGOOGLE.__Internal native, bool skipVTables = false)
    {
        return new global::VkPresentTimeGOOGLE(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPresentTimeGOOGLE.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPresentTimeGOOGLE.__Internal));
        *(global::VkPresentTimeGOOGLE.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPresentTimeGOOGLE(global::VkPresentTimeGOOGLE.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPresentTimeGOOGLE(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPresentTimeGOOGLE()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentTimeGOOGLE.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPresentTimeGOOGLE(global::VkPresentTimeGOOGLE _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentTimeGOOGLE.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPresentTimeGOOGLE.__Internal*) __Instance) = *((global::VkPresentTimeGOOGLE.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPresentTimeGOOGLE __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint PresentID
    {
        get
        {
            return ((global::VkPresentTimeGOOGLE.__Internal*) __Instance)->presentID;
        }

        set
        {
            ((global::VkPresentTimeGOOGLE.__Internal*)__Instance)->presentID = value;
        }
    }

    public ulong DesiredPresentTime
    {
        get
        {
            return ((global::VkPresentTimeGOOGLE.__Internal*) __Instance)->desiredPresentTime;
        }

        set
        {
            ((global::VkPresentTimeGOOGLE.__Internal*)__Instance)->desiredPresentTime = value;
        }
    }
}

public unsafe partial class VkPresentTimesInfoGOOGLE : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint swapchainCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pTimes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPresentTimesInfoGOOGLE@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentTimesInfoGOOGLE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPresentTimesInfoGOOGLE>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPresentTimesInfoGOOGLE __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPresentTimesInfoGOOGLE(native.ToPointer(), skipVTables);
    }

    internal static global::VkPresentTimesInfoGOOGLE __CreateInstance(global::VkPresentTimesInfoGOOGLE.__Internal native, bool skipVTables = false)
    {
        return new global::VkPresentTimesInfoGOOGLE(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPresentTimesInfoGOOGLE.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPresentTimesInfoGOOGLE.__Internal));
        *(global::VkPresentTimesInfoGOOGLE.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPresentTimesInfoGOOGLE(global::VkPresentTimesInfoGOOGLE.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPresentTimesInfoGOOGLE(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPresentTimesInfoGOOGLE()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentTimesInfoGOOGLE.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPresentTimesInfoGOOGLE(global::VkPresentTimesInfoGOOGLE _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPresentTimesInfoGOOGLE.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPresentTimesInfoGOOGLE.__Internal*) __Instance) = *((global::VkPresentTimesInfoGOOGLE.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPresentTimesInfoGOOGLE __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPresentTimesInfoGOOGLE.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPresentTimesInfoGOOGLE.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPresentTimesInfoGOOGLE.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPresentTimesInfoGOOGLE.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SwapchainCount
    {
        get
        {
            return ((global::VkPresentTimesInfoGOOGLE.__Internal*) __Instance)->swapchainCount;
        }

        set
        {
            ((global::VkPresentTimesInfoGOOGLE.__Internal*)__Instance)->swapchainCount = value;
        }
    }

    public global::VkPresentTimeGOOGLE PTimes
    {
        get
        {
            global::VkPresentTimeGOOGLE __result0;
            if (((global::VkPresentTimesInfoGOOGLE.__Internal*) __Instance)->pTimes == IntPtr.Zero) __result0 = null;
            else if (global::VkPresentTimeGOOGLE.NativeToManagedMap.ContainsKey(((global::VkPresentTimesInfoGOOGLE.__Internal*) __Instance)->pTimes))
                __result0 = (global::VkPresentTimeGOOGLE) global::VkPresentTimeGOOGLE.NativeToManagedMap[((global::VkPresentTimesInfoGOOGLE.__Internal*) __Instance)->pTimes];
            else __result0 = global::VkPresentTimeGOOGLE.__CreateInstance(((global::VkPresentTimesInfoGOOGLE.__Internal*) __Instance)->pTimes);
            return __result0;
        }

        set
        {
            ((global::VkPresentTimesInfoGOOGLE.__Internal*)__Instance)->pTimes = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint perViewPositionAllComponents;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX __CreateInstance(global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal));
        *(global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal*) __Instance) = *((global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint PerViewPositionAllComponents
    {
        get
        {
            return ((global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal*) __Instance)->perViewPositionAllComponents;
        }

        set
        {
            ((global::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.__Internal*)__Instance)->perViewPositionAllComponents = value;
        }
    }
}

public unsafe partial class VkViewportSwizzleNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkViewportCoordinateSwizzleNV x;

        [FieldOffset(4)]
        internal global::VkViewportCoordinateSwizzleNV y;

        [FieldOffset(8)]
        internal global::VkViewportCoordinateSwizzleNV z;

        [FieldOffset(12)]
        internal global::VkViewportCoordinateSwizzleNV w;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkViewportSwizzleNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkViewportSwizzleNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkViewportSwizzleNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkViewportSwizzleNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkViewportSwizzleNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkViewportSwizzleNV __CreateInstance(global::VkViewportSwizzleNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkViewportSwizzleNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkViewportSwizzleNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkViewportSwizzleNV.__Internal));
        *(global::VkViewportSwizzleNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkViewportSwizzleNV(global::VkViewportSwizzleNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkViewportSwizzleNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkViewportSwizzleNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkViewportSwizzleNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkViewportSwizzleNV(global::VkViewportSwizzleNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkViewportSwizzleNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkViewportSwizzleNV.__Internal*) __Instance) = *((global::VkViewportSwizzleNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkViewportSwizzleNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkViewportCoordinateSwizzleNV X
    {
        get
        {
            return ((global::VkViewportSwizzleNV.__Internal*) __Instance)->x;
        }

        set
        {
            ((global::VkViewportSwizzleNV.__Internal*)__Instance)->x = value;
        }
    }

    public global::VkViewportCoordinateSwizzleNV Y
    {
        get
        {
            return ((global::VkViewportSwizzleNV.__Internal*) __Instance)->y;
        }

        set
        {
            ((global::VkViewportSwizzleNV.__Internal*)__Instance)->y = value;
        }
    }

    public global::VkViewportCoordinateSwizzleNV Z
    {
        get
        {
            return ((global::VkViewportSwizzleNV.__Internal*) __Instance)->z;
        }

        set
        {
            ((global::VkViewportSwizzleNV.__Internal*)__Instance)->z = value;
        }
    }

    public global::VkViewportCoordinateSwizzleNV W
    {
        get
        {
            return ((global::VkViewportSwizzleNV.__Internal*) __Instance)->w;
        }

        set
        {
            ((global::VkViewportSwizzleNV.__Internal*)__Instance)->w = value;
        }
    }
}

public unsafe partial class VkPipelineViewportSwizzleStateCreateInfoNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint viewportCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pViewportSwizzles;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineViewportSwizzleStateCreateInfoNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineViewportSwizzleStateCreateInfoNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineViewportSwizzleStateCreateInfoNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineViewportSwizzleStateCreateInfoNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineViewportSwizzleStateCreateInfoNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineViewportSwizzleStateCreateInfoNV __CreateInstance(global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineViewportSwizzleStateCreateInfoNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal));
        *(global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineViewportSwizzleStateCreateInfoNV(global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineViewportSwizzleStateCreateInfoNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineViewportSwizzleStateCreateInfoNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineViewportSwizzleStateCreateInfoNV(global::VkPipelineViewportSwizzleStateCreateInfoNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) __Instance) = *((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineViewportSwizzleStateCreateInfoNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*)__Instance)->flags = value;
        }
    }

    public uint ViewportCount
    {
        get
        {
            return ((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) __Instance)->viewportCount;
        }

        set
        {
            ((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*)__Instance)->viewportCount = value;
        }
    }

    public global::VkViewportSwizzleNV PViewportSwizzles
    {
        get
        {
            global::VkViewportSwizzleNV __result0;
            if (((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) __Instance)->pViewportSwizzles == IntPtr.Zero) __result0 = null;
            else if (global::VkViewportSwizzleNV.NativeToManagedMap.ContainsKey(((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) __Instance)->pViewportSwizzles))
                __result0 = (global::VkViewportSwizzleNV) global::VkViewportSwizzleNV.NativeToManagedMap[((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) __Instance)->pViewportSwizzles];
            else __result0 = global::VkViewportSwizzleNV.__CreateInstance(((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*) __Instance)->pViewportSwizzles);
            return __result0;
        }

        set
        {
            ((global::VkPipelineViewportSwizzleStateCreateInfoNV.__Internal*)__Instance)->pViewportSwizzles = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceDiscardRectanglePropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint maxDiscardRectangles;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceDiscardRectanglePropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceDiscardRectanglePropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceDiscardRectanglePropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceDiscardRectanglePropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceDiscardRectanglePropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceDiscardRectanglePropertiesEXT __CreateInstance(global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceDiscardRectanglePropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal));
        *(global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceDiscardRectanglePropertiesEXT(global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceDiscardRectanglePropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceDiscardRectanglePropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceDiscardRectanglePropertiesEXT(global::VkPhysicalDeviceDiscardRectanglePropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceDiscardRectanglePropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MaxDiscardRectangles
    {
        get
        {
            return ((global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal*) __Instance)->maxDiscardRectangles;
        }

        set
        {
            ((global::VkPhysicalDeviceDiscardRectanglePropertiesEXT.__Internal*)__Instance)->maxDiscardRectangles = value;
        }
    }
}

public unsafe partial class VkPipelineDiscardRectangleStateCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkDiscardRectangleModeEXT discardRectangleMode;

        [FieldOffset(24)]
        internal uint discardRectangleCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pDiscardRectangles;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineDiscardRectangleStateCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineDiscardRectangleStateCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineDiscardRectangleStateCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineDiscardRectangleStateCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineDiscardRectangleStateCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineDiscardRectangleStateCreateInfoEXT __CreateInstance(global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineDiscardRectangleStateCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal));
        *(global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineDiscardRectangleStateCreateInfoEXT(global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineDiscardRectangleStateCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineDiscardRectangleStateCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineDiscardRectangleStateCreateInfoEXT(global::VkPipelineDiscardRectangleStateCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance) = *((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineDiscardRectangleStateCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkDiscardRectangleModeEXT DiscardRectangleMode
    {
        get
        {
            return ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance)->discardRectangleMode;
        }

        set
        {
            ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*)__Instance)->discardRectangleMode = value;
        }
    }

    public uint DiscardRectangleCount
    {
        get
        {
            return ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance)->discardRectangleCount;
        }

        set
        {
            ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*)__Instance)->discardRectangleCount = value;
        }
    }

    public global::VkRect2D PDiscardRectangles
    {
        get
        {
            global::VkRect2D __result0;
            if (((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance)->pDiscardRectangles == IntPtr.Zero) __result0 = null;
            else if (global::VkRect2D.NativeToManagedMap.ContainsKey(((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance)->pDiscardRectangles))
                __result0 = (global::VkRect2D) global::VkRect2D.NativeToManagedMap[((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance)->pDiscardRectangles];
            else __result0 = global::VkRect2D.__CreateInstance(((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*) __Instance)->pDiscardRectangles);
            return __result0;
        }

        set
        {
            ((global::VkPipelineDiscardRectangleStateCreateInfoEXT.__Internal*)__Instance)->pDiscardRectangles = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceConservativeRasterizationPropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal float primitiveOverestimationSize;

        [FieldOffset(20)]
        internal float maxExtraPrimitiveOverestimationSize;

        [FieldOffset(24)]
        internal float extraPrimitiveOverestimationSizeGranularity;

        [FieldOffset(28)]
        internal uint primitiveUnderestimation;

        [FieldOffset(32)]
        internal uint conservativePointAndLineRasterization;

        [FieldOffset(36)]
        internal uint degenerateTrianglesRasterized;

        [FieldOffset(40)]
        internal uint degenerateLinesRasterized;

        [FieldOffset(44)]
        internal uint fullyCoveredFragmentShaderInputVariable;

        [FieldOffset(48)]
        internal uint conservativeRasterizationPostDepthCoverage;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceConservativeRasterizationPropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT __CreateInstance(global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal));
        *(global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceConservativeRasterizationPropertiesEXT(global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceConservativeRasterizationPropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceConservativeRasterizationPropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceConservativeRasterizationPropertiesEXT(global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public float PrimitiveOverestimationSize
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->primitiveOverestimationSize;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->primitiveOverestimationSize = value;
        }
    }

    public float MaxExtraPrimitiveOverestimationSize
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->maxExtraPrimitiveOverestimationSize;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->maxExtraPrimitiveOverestimationSize = value;
        }
    }

    public float ExtraPrimitiveOverestimationSizeGranularity
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->extraPrimitiveOverestimationSizeGranularity;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->extraPrimitiveOverestimationSizeGranularity = value;
        }
    }

    public uint PrimitiveUnderestimation
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->primitiveUnderestimation;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->primitiveUnderestimation = value;
        }
    }

    public uint ConservativePointAndLineRasterization
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->conservativePointAndLineRasterization;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->conservativePointAndLineRasterization = value;
        }
    }

    public uint DegenerateTrianglesRasterized
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->degenerateTrianglesRasterized;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->degenerateTrianglesRasterized = value;
        }
    }

    public uint DegenerateLinesRasterized
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->degenerateLinesRasterized;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->degenerateLinesRasterized = value;
        }
    }

    public uint FullyCoveredFragmentShaderInputVariable
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->fullyCoveredFragmentShaderInputVariable;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->fullyCoveredFragmentShaderInputVariable = value;
        }
    }

    public uint ConservativeRasterizationPostDepthCoverage
    {
        get
        {
            return ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*) __Instance)->conservativeRasterizationPostDepthCoverage;
        }

        set
        {
            ((global::VkPhysicalDeviceConservativeRasterizationPropertiesEXT.__Internal*)__Instance)->conservativeRasterizationPostDepthCoverage = value;
        }
    }
}

public unsafe partial class VkPipelineRasterizationConservativeStateCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkConservativeRasterizationModeEXT conservativeRasterizationMode;

        [FieldOffset(24)]
        internal float extraPrimitiveOverestimationSize;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineRasterizationConservativeStateCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineRasterizationConservativeStateCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineRasterizationConservativeStateCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineRasterizationConservativeStateCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineRasterizationConservativeStateCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineRasterizationConservativeStateCreateInfoEXT __CreateInstance(global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineRasterizationConservativeStateCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal));
        *(global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineRasterizationConservativeStateCreateInfoEXT(global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineRasterizationConservativeStateCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineRasterizationConservativeStateCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineRasterizationConservativeStateCreateInfoEXT(global::VkPipelineRasterizationConservativeStateCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*) __Instance) = *((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineRasterizationConservativeStateCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkConservativeRasterizationModeEXT ConservativeRasterizationMode
    {
        get
        {
            return ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*) __Instance)->conservativeRasterizationMode;
        }

        set
        {
            ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*)__Instance)->conservativeRasterizationMode = value;
        }
    }

    public float ExtraPrimitiveOverestimationSize
    {
        get
        {
            return ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*) __Instance)->extraPrimitiveOverestimationSize;
        }

        set
        {
            ((global::VkPipelineRasterizationConservativeStateCreateInfoEXT.__Internal*)__Instance)->extraPrimitiveOverestimationSize = value;
        }
    }
}

public unsafe partial class VkXYColorEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal float x;

        [FieldOffset(4)]
        internal float y;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkXYColorEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkXYColorEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkXYColorEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkXYColorEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkXYColorEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkXYColorEXT __CreateInstance(global::VkXYColorEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkXYColorEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkXYColorEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkXYColorEXT.__Internal));
        *(global::VkXYColorEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkXYColorEXT(global::VkXYColorEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkXYColorEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkXYColorEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkXYColorEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkXYColorEXT(global::VkXYColorEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkXYColorEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkXYColorEXT.__Internal*) __Instance) = *((global::VkXYColorEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkXYColorEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public float X
    {
        get
        {
            return ((global::VkXYColorEXT.__Internal*) __Instance)->x;
        }

        set
        {
            ((global::VkXYColorEXT.__Internal*)__Instance)->x = value;
        }
    }

    public float Y
    {
        get
        {
            return ((global::VkXYColorEXT.__Internal*) __Instance)->y;
        }

        set
        {
            ((global::VkXYColorEXT.__Internal*)__Instance)->y = value;
        }
    }
}

public unsafe partial class VkHdrMetadataEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkXYColorEXT.__Internal displayPrimaryRed;

        [FieldOffset(24)]
        internal global::VkXYColorEXT.__Internal displayPrimaryGreen;

        [FieldOffset(32)]
        internal global::VkXYColorEXT.__Internal displayPrimaryBlue;

        [FieldOffset(40)]
        internal global::VkXYColorEXT.__Internal whitePoint;

        [FieldOffset(48)]
        internal float maxLuminance;

        [FieldOffset(52)]
        internal float minLuminance;

        [FieldOffset(56)]
        internal float maxContentLightLevel;

        [FieldOffset(60)]
        internal float maxFrameAverageLightLevel;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkHdrMetadataEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkHdrMetadataEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkHdrMetadataEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkHdrMetadataEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkHdrMetadataEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkHdrMetadataEXT __CreateInstance(global::VkHdrMetadataEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkHdrMetadataEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkHdrMetadataEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkHdrMetadataEXT.__Internal));
        *(global::VkHdrMetadataEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkHdrMetadataEXT(global::VkHdrMetadataEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkHdrMetadataEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkHdrMetadataEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkHdrMetadataEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkHdrMetadataEXT(global::VkHdrMetadataEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkHdrMetadataEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkHdrMetadataEXT.__Internal*) __Instance) = *((global::VkHdrMetadataEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkHdrMetadataEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkHdrMetadataEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkHdrMetadataEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkXYColorEXT DisplayPrimaryRed
    {
        get
        {
            return global::VkXYColorEXT.__CreateInstance(new global::System.IntPtr(&((global::VkHdrMetadataEXT.__Internal*) __Instance)->displayPrimaryRed));
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->displayPrimaryRed = ReferenceEquals(value, null) ? new global::VkXYColorEXT.__Internal() : *(global::VkXYColorEXT.__Internal*) value.__Instance;
        }
    }

    public global::VkXYColorEXT DisplayPrimaryGreen
    {
        get
        {
            return global::VkXYColorEXT.__CreateInstance(new global::System.IntPtr(&((global::VkHdrMetadataEXT.__Internal*) __Instance)->displayPrimaryGreen));
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->displayPrimaryGreen = ReferenceEquals(value, null) ? new global::VkXYColorEXT.__Internal() : *(global::VkXYColorEXT.__Internal*) value.__Instance;
        }
    }

    public global::VkXYColorEXT DisplayPrimaryBlue
    {
        get
        {
            return global::VkXYColorEXT.__CreateInstance(new global::System.IntPtr(&((global::VkHdrMetadataEXT.__Internal*) __Instance)->displayPrimaryBlue));
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->displayPrimaryBlue = ReferenceEquals(value, null) ? new global::VkXYColorEXT.__Internal() : *(global::VkXYColorEXT.__Internal*) value.__Instance;
        }
    }

    public global::VkXYColorEXT WhitePoint
    {
        get
        {
            return global::VkXYColorEXT.__CreateInstance(new global::System.IntPtr(&((global::VkHdrMetadataEXT.__Internal*) __Instance)->whitePoint));
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->whitePoint = ReferenceEquals(value, null) ? new global::VkXYColorEXT.__Internal() : *(global::VkXYColorEXT.__Internal*) value.__Instance;
        }
    }

    public float MaxLuminance
    {
        get
        {
            return ((global::VkHdrMetadataEXT.__Internal*) __Instance)->maxLuminance;
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->maxLuminance = value;
        }
    }

    public float MinLuminance
    {
        get
        {
            return ((global::VkHdrMetadataEXT.__Internal*) __Instance)->minLuminance;
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->minLuminance = value;
        }
    }

    public float MaxContentLightLevel
    {
        get
        {
            return ((global::VkHdrMetadataEXT.__Internal*) __Instance)->maxContentLightLevel;
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->maxContentLightLevel = value;
        }
    }

    public float MaxFrameAverageLightLevel
    {
        get
        {
            return ((global::VkHdrMetadataEXT.__Internal*) __Instance)->maxFrameAverageLightLevel;
        }

        set
        {
            ((global::VkHdrMetadataEXT.__Internal*)__Instance)->maxFrameAverageLightLevel = value;
        }
    }
}

public unsafe partial class VkDebugUtilsMessengerEXT_T
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsMessengerEXT_T> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsMessengerEXT_T>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugUtilsMessengerEXT_T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsMessengerEXT_T(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugUtilsMessengerEXT_T __CreateInstance(global::VkDebugUtilsMessengerEXT_T.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsMessengerEXT_T(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugUtilsMessengerEXT_T.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsMessengerEXT_T.__Internal));
        *(global::VkDebugUtilsMessengerEXT_T.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugUtilsMessengerEXT_T(global::VkDebugUtilsMessengerEXT_T.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugUtilsMessengerEXT_T(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkDebugUtilsObjectNameInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkObjectType objectType;

        [FieldOffset(24)]
        internal ulong objectHandle;

        [FieldOffset(32)]
        internal global::System.IntPtr pObjectName;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDebugUtilsObjectNameInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsObjectNameInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsObjectNameInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugUtilsObjectNameInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsObjectNameInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugUtilsObjectNameInfoEXT __CreateInstance(global::VkDebugUtilsObjectNameInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsObjectNameInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugUtilsObjectNameInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsObjectNameInfoEXT.__Internal));
        *(global::VkDebugUtilsObjectNameInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugUtilsObjectNameInfoEXT(global::VkDebugUtilsObjectNameInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugUtilsObjectNameInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDebugUtilsObjectNameInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsObjectNameInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDebugUtilsObjectNameInfoEXT(global::VkDebugUtilsObjectNameInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsObjectNameInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDebugUtilsObjectNameInfoEXT.__Internal*) __Instance) = *((global::VkDebugUtilsObjectNameInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDebugUtilsObjectNameInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDebugUtilsObjectNameInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDebugUtilsObjectNameInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDebugUtilsObjectNameInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDebugUtilsObjectNameInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkObjectType ObjectType
    {
        get
        {
            return ((global::VkDebugUtilsObjectNameInfoEXT.__Internal*) __Instance)->objectType;
        }

        set
        {
            ((global::VkDebugUtilsObjectNameInfoEXT.__Internal*)__Instance)->objectType = value;
        }
    }

    public ulong ObjectHandle
    {
        get
        {
            return ((global::VkDebugUtilsObjectNameInfoEXT.__Internal*) __Instance)->objectHandle;
        }

        set
        {
            ((global::VkDebugUtilsObjectNameInfoEXT.__Internal*)__Instance)->objectHandle = value;
        }
    }

    public string PObjectName
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkDebugUtilsObjectNameInfoEXT.__Internal*) __Instance)->pObjectName);
        }

        set
        {
            ((global::VkDebugUtilsObjectNameInfoEXT.__Internal*)__Instance)->pObjectName = Marshal.StringToHGlobalAnsi(value);
        }
    }
}

public unsafe partial class VkDebugUtilsObjectTagInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkObjectType objectType;

        [FieldOffset(24)]
        internal ulong objectHandle;

        [FieldOffset(32)]
        internal ulong tagName;

        [FieldOffset(40)]
        internal ulong tagSize;

        [FieldOffset(48)]
        internal global::System.IntPtr pTag;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDebugUtilsObjectTagInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsObjectTagInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsObjectTagInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugUtilsObjectTagInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsObjectTagInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugUtilsObjectTagInfoEXT __CreateInstance(global::VkDebugUtilsObjectTagInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsObjectTagInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugUtilsObjectTagInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsObjectTagInfoEXT.__Internal));
        *(global::VkDebugUtilsObjectTagInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugUtilsObjectTagInfoEXT(global::VkDebugUtilsObjectTagInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugUtilsObjectTagInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDebugUtilsObjectTagInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsObjectTagInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDebugUtilsObjectTagInfoEXT(global::VkDebugUtilsObjectTagInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsObjectTagInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDebugUtilsObjectTagInfoEXT.__Internal*) __Instance) = *((global::VkDebugUtilsObjectTagInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDebugUtilsObjectTagInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkObjectType ObjectType
    {
        get
        {
            return ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*) __Instance)->objectType;
        }

        set
        {
            ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*)__Instance)->objectType = value;
        }
    }

    public ulong ObjectHandle
    {
        get
        {
            return ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*) __Instance)->objectHandle;
        }

        set
        {
            ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*)__Instance)->objectHandle = value;
        }
    }

    public ulong TagName
    {
        get
        {
            return ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*) __Instance)->tagName;
        }

        set
        {
            ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*)__Instance)->tagName = value;
        }
    }

    public ulong TagSize
    {
        get
        {
            return ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*) __Instance)->tagSize;
        }

        set
        {
            ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*)__Instance)->tagSize = value;
        }
    }

    public global::System.IntPtr PTag
    {
        get
        {
            return ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*) __Instance)->pTag;
        }

        set
        {
            ((global::VkDebugUtilsObjectTagInfoEXT.__Internal*)__Instance)->pTag = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkDebugUtilsLabelEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr pLabelName;

        [FieldOffset(24)]
        internal fixed float color[4];

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDebugUtilsLabelEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsLabelEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsLabelEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugUtilsLabelEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsLabelEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugUtilsLabelEXT __CreateInstance(global::VkDebugUtilsLabelEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsLabelEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugUtilsLabelEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsLabelEXT.__Internal));
        *(global::VkDebugUtilsLabelEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugUtilsLabelEXT(global::VkDebugUtilsLabelEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugUtilsLabelEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDebugUtilsLabelEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsLabelEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDebugUtilsLabelEXT(global::VkDebugUtilsLabelEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsLabelEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDebugUtilsLabelEXT.__Internal*) __Instance) = *((global::VkDebugUtilsLabelEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDebugUtilsLabelEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDebugUtilsLabelEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDebugUtilsLabelEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDebugUtilsLabelEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDebugUtilsLabelEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public string PLabelName
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkDebugUtilsLabelEXT.__Internal*) __Instance)->pLabelName);
        }

        set
        {
            ((global::VkDebugUtilsLabelEXT.__Internal*)__Instance)->pLabelName = Marshal.StringToHGlobalAnsi(value);
        }
    }

    public float[] Color
    {
        get
        {
            float[] __value = null;
            if (((global::VkDebugUtilsLabelEXT.__Internal*) __Instance)->color != null)
            {
                __value = new float[4];
                for (int i = 0; i < 4; i++)
                    __value[i] = ((global::VkDebugUtilsLabelEXT.__Internal*) __Instance)->color[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 4; i++)
                    ((global::VkDebugUtilsLabelEXT.__Internal*)__Instance)->color[i] = value[i];
            }
        }
    }
}

public unsafe partial class VkDebugUtilsMessengerCallbackDataEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 96)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal global::System.IntPtr pMessageIdName;

        [FieldOffset(32)]
        internal int messageIdNumber;

        [FieldOffset(40)]
        internal global::System.IntPtr pMessage;

        [FieldOffset(48)]
        internal uint queueLabelCount;

        [FieldOffset(56)]
        internal global::System.IntPtr pQueueLabels;

        [FieldOffset(64)]
        internal uint cmdBufLabelCount;

        [FieldOffset(72)]
        internal global::System.IntPtr pCmdBufLabels;

        [FieldOffset(80)]
        internal uint objectCount;

        [FieldOffset(88)]
        internal global::System.IntPtr pObjects;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDebugUtilsMessengerCallbackDataEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsMessengerCallbackDataEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsMessengerCallbackDataEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugUtilsMessengerCallbackDataEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsMessengerCallbackDataEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugUtilsMessengerCallbackDataEXT __CreateInstance(global::VkDebugUtilsMessengerCallbackDataEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsMessengerCallbackDataEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugUtilsMessengerCallbackDataEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsMessengerCallbackDataEXT.__Internal));
        *(global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugUtilsMessengerCallbackDataEXT(global::VkDebugUtilsMessengerCallbackDataEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugUtilsMessengerCallbackDataEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDebugUtilsMessengerCallbackDataEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsMessengerCallbackDataEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDebugUtilsMessengerCallbackDataEXT(global::VkDebugUtilsMessengerCallbackDataEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsMessengerCallbackDataEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance) = *((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDebugUtilsMessengerCallbackDataEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->flags = value;
        }
    }

    public string PMessageIdName
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pMessageIdName);
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->pMessageIdName = Marshal.StringToHGlobalAnsi(value);
        }
    }

    public int MessageIdNumber
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->messageIdNumber;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->messageIdNumber = value;
        }
    }

    public string PMessage
    {
        get
        {
            return Marshal.PtrToStringAnsi(((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pMessage);
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->pMessage = Marshal.StringToHGlobalAnsi(value);
        }
    }

    public uint QueueLabelCount
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->queueLabelCount;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->queueLabelCount = value;
        }
    }

    public global::VkDebugUtilsLabelEXT PQueueLabels
    {
        get
        {
            global::VkDebugUtilsLabelEXT __result0;
            if (((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pQueueLabels == IntPtr.Zero) __result0 = null;
            else if (global::VkDebugUtilsLabelEXT.NativeToManagedMap.ContainsKey(((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pQueueLabels))
                __result0 = (global::VkDebugUtilsLabelEXT) global::VkDebugUtilsLabelEXT.NativeToManagedMap[((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pQueueLabels];
            else __result0 = global::VkDebugUtilsLabelEXT.__CreateInstance(((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pQueueLabels);
            return __result0;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->pQueueLabels = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint CmdBufLabelCount
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->cmdBufLabelCount;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->cmdBufLabelCount = value;
        }
    }

    public global::VkDebugUtilsLabelEXT PCmdBufLabels
    {
        get
        {
            global::VkDebugUtilsLabelEXT __result0;
            if (((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pCmdBufLabels == IntPtr.Zero) __result0 = null;
            else if (global::VkDebugUtilsLabelEXT.NativeToManagedMap.ContainsKey(((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pCmdBufLabels))
                __result0 = (global::VkDebugUtilsLabelEXT) global::VkDebugUtilsLabelEXT.NativeToManagedMap[((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pCmdBufLabels];
            else __result0 = global::VkDebugUtilsLabelEXT.__CreateInstance(((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pCmdBufLabels);
            return __result0;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->pCmdBufLabels = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint ObjectCount
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->objectCount;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->objectCount = value;
        }
    }

    public global::VkDebugUtilsObjectNameInfoEXT PObjects
    {
        get
        {
            global::VkDebugUtilsObjectNameInfoEXT __result0;
            if (((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pObjects == IntPtr.Zero) __result0 = null;
            else if (global::VkDebugUtilsObjectNameInfoEXT.NativeToManagedMap.ContainsKey(((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pObjects))
                __result0 = (global::VkDebugUtilsObjectNameInfoEXT) global::VkDebugUtilsObjectNameInfoEXT.NativeToManagedMap[((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pObjects];
            else __result0 = global::VkDebugUtilsObjectNameInfoEXT.__CreateInstance(((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*) __Instance)->pObjects);
            return __result0;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCallbackDataEXT.__Internal*)__Instance)->pObjects = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkDebugUtilsMessengerCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint messageSeverity;

        [FieldOffset(24)]
        internal uint messageType;

        [FieldOffset(32)]
        internal global::System.IntPtr pfnUserCallback;

        [FieldOffset(40)]
        internal global::System.IntPtr pUserData;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDebugUtilsMessengerCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsMessengerCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDebugUtilsMessengerCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDebugUtilsMessengerCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsMessengerCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDebugUtilsMessengerCreateInfoEXT __CreateInstance(global::VkDebugUtilsMessengerCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDebugUtilsMessengerCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDebugUtilsMessengerCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsMessengerCreateInfoEXT.__Internal));
        *(global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDebugUtilsMessengerCreateInfoEXT(global::VkDebugUtilsMessengerCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDebugUtilsMessengerCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDebugUtilsMessengerCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsMessengerCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDebugUtilsMessengerCreateInfoEXT(global::VkDebugUtilsMessengerCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDebugUtilsMessengerCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) __Instance) = *((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDebugUtilsMessengerCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*)__Instance)->flags = value;
        }
    }

    public uint MessageSeverity
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) __Instance)->messageSeverity;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*)__Instance)->messageSeverity = value;
        }
    }

    public uint MessageType
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) __Instance)->messageType;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*)__Instance)->messageType = value;
        }
    }

    public global::PFN_vkDebugUtilsMessengerCallbackEXT PfnUserCallback
    {
        get
        {
            var __ptr0 = ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) __Instance)->pfnUserCallback;
            return __ptr0 == IntPtr.Zero? null : (global::PFN_vkDebugUtilsMessengerCallbackEXT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PFN_vkDebugUtilsMessengerCallbackEXT));
        }

        set
        {
            ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*)__Instance)->pfnUserCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
        }
    }

    public global::System.IntPtr PUserData
    {
        get
        {
            return ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*) __Instance)->pUserData;
        }

        set
        {
            ((global::VkDebugUtilsMessengerCreateInfoEXT.__Internal*)__Instance)->pUserData = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkSamplerReductionModeCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkSamplerReductionModeEXT reductionMode;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSamplerReductionModeCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerReductionModeCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSamplerReductionModeCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSamplerReductionModeCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSamplerReductionModeCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkSamplerReductionModeCreateInfoEXT __CreateInstance(global::VkSamplerReductionModeCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkSamplerReductionModeCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSamplerReductionModeCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSamplerReductionModeCreateInfoEXT.__Internal));
        *(global::VkSamplerReductionModeCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSamplerReductionModeCreateInfoEXT(global::VkSamplerReductionModeCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSamplerReductionModeCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSamplerReductionModeCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerReductionModeCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSamplerReductionModeCreateInfoEXT(global::VkSamplerReductionModeCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSamplerReductionModeCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSamplerReductionModeCreateInfoEXT.__Internal*) __Instance) = *((global::VkSamplerReductionModeCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSamplerReductionModeCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSamplerReductionModeCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSamplerReductionModeCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSamplerReductionModeCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSamplerReductionModeCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSamplerReductionModeEXT ReductionMode
    {
        get
        {
            return ((global::VkSamplerReductionModeCreateInfoEXT.__Internal*) __Instance)->reductionMode;
        }

        set
        {
            ((global::VkSamplerReductionModeCreateInfoEXT.__Internal*)__Instance)->reductionMode = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint filterMinmaxSingleComponentFormats;

        [FieldOffset(20)]
        internal uint filterMinmaxImageComponentMapping;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT __CreateInstance(global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal));
        *(global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint FilterMinmaxSingleComponentFormats
    {
        get
        {
            return ((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*) __Instance)->filterMinmaxSingleComponentFormats;
        }

        set
        {
            ((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*)__Instance)->filterMinmaxSingleComponentFormats = value;
        }
    }

    public uint FilterMinmaxImageComponentMapping
    {
        get
        {
            return ((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*) __Instance)->filterMinmaxImageComponentMapping;
        }

        set
        {
            ((global::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.__Internal*)__Instance)->filterMinmaxImageComponentMapping = value;
        }
    }
}

public unsafe partial class VkSampleLocationEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal float x;

        [FieldOffset(4)]
        internal float y;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSampleLocationEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSampleLocationEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSampleLocationEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSampleLocationEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSampleLocationEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkSampleLocationEXT __CreateInstance(global::VkSampleLocationEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkSampleLocationEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSampleLocationEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSampleLocationEXT.__Internal));
        *(global::VkSampleLocationEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSampleLocationEXT(global::VkSampleLocationEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSampleLocationEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSampleLocationEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSampleLocationEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSampleLocationEXT(global::VkSampleLocationEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSampleLocationEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSampleLocationEXT.__Internal*) __Instance) = *((global::VkSampleLocationEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSampleLocationEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public float X
    {
        get
        {
            return ((global::VkSampleLocationEXT.__Internal*) __Instance)->x;
        }

        set
        {
            ((global::VkSampleLocationEXT.__Internal*)__Instance)->x = value;
        }
    }

    public float Y
    {
        get
        {
            return ((global::VkSampleLocationEXT.__Internal*) __Instance)->y;
        }

        set
        {
            ((global::VkSampleLocationEXT.__Internal*)__Instance)->y = value;
        }
    }
}

public unsafe partial class VkSampleLocationsInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkSampleCountFlagBits sampleLocationsPerPixel;

        [FieldOffset(20)]
        internal global::VkExtent2D.__Internal sampleLocationGridSize;

        [FieldOffset(28)]
        internal uint sampleLocationsCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pSampleLocations;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSampleLocationsInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSampleLocationsInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSampleLocationsInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSampleLocationsInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSampleLocationsInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkSampleLocationsInfoEXT __CreateInstance(global::VkSampleLocationsInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkSampleLocationsInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSampleLocationsInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSampleLocationsInfoEXT.__Internal));
        *(global::VkSampleLocationsInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSampleLocationsInfoEXT(global::VkSampleLocationsInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSampleLocationsInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSampleLocationsInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSampleLocationsInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSampleLocationsInfoEXT(global::VkSampleLocationsInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSampleLocationsInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSampleLocationsInfoEXT.__Internal*) __Instance) = *((global::VkSampleLocationsInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSampleLocationsInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkSampleLocationsInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkSampleLocationsInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkSampleLocationsInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkSampleLocationsInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkSampleCountFlagBits SampleLocationsPerPixel
    {
        get
        {
            return ((global::VkSampleLocationsInfoEXT.__Internal*) __Instance)->sampleLocationsPerPixel;
        }

        set
        {
            ((global::VkSampleLocationsInfoEXT.__Internal*)__Instance)->sampleLocationsPerPixel = value;
        }
    }

    public global::VkExtent2D SampleLocationGridSize
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkSampleLocationsInfoEXT.__Internal*) __Instance)->sampleLocationGridSize));
        }

        set
        {
            ((global::VkSampleLocationsInfoEXT.__Internal*)__Instance)->sampleLocationGridSize = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public uint SampleLocationsCount
    {
        get
        {
            return ((global::VkSampleLocationsInfoEXT.__Internal*) __Instance)->sampleLocationsCount;
        }

        set
        {
            ((global::VkSampleLocationsInfoEXT.__Internal*)__Instance)->sampleLocationsCount = value;
        }
    }

    public global::VkSampleLocationEXT PSampleLocations
    {
        get
        {
            global::VkSampleLocationEXT __result0;
            if (((global::VkSampleLocationsInfoEXT.__Internal*) __Instance)->pSampleLocations == IntPtr.Zero) __result0 = null;
            else if (global::VkSampleLocationEXT.NativeToManagedMap.ContainsKey(((global::VkSampleLocationsInfoEXT.__Internal*) __Instance)->pSampleLocations))
                __result0 = (global::VkSampleLocationEXT) global::VkSampleLocationEXT.NativeToManagedMap[((global::VkSampleLocationsInfoEXT.__Internal*) __Instance)->pSampleLocations];
            else __result0 = global::VkSampleLocationEXT.__CreateInstance(((global::VkSampleLocationsInfoEXT.__Internal*) __Instance)->pSampleLocations);
            return __result0;
        }

        set
        {
            ((global::VkSampleLocationsInfoEXT.__Internal*)__Instance)->pSampleLocations = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkAttachmentSampleLocationsEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint attachmentIndex;

        [FieldOffset(8)]
        internal global::VkSampleLocationsInfoEXT.__Internal sampleLocationsInfo;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkAttachmentSampleLocationsEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentSampleLocationsEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkAttachmentSampleLocationsEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkAttachmentSampleLocationsEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkAttachmentSampleLocationsEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkAttachmentSampleLocationsEXT __CreateInstance(global::VkAttachmentSampleLocationsEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkAttachmentSampleLocationsEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkAttachmentSampleLocationsEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkAttachmentSampleLocationsEXT.__Internal));
        *(global::VkAttachmentSampleLocationsEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkAttachmentSampleLocationsEXT(global::VkAttachmentSampleLocationsEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkAttachmentSampleLocationsEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkAttachmentSampleLocationsEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentSampleLocationsEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkAttachmentSampleLocationsEXT(global::VkAttachmentSampleLocationsEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkAttachmentSampleLocationsEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkAttachmentSampleLocationsEXT.__Internal*) __Instance) = *((global::VkAttachmentSampleLocationsEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkAttachmentSampleLocationsEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint AttachmentIndex
    {
        get
        {
            return ((global::VkAttachmentSampleLocationsEXT.__Internal*) __Instance)->attachmentIndex;
        }

        set
        {
            ((global::VkAttachmentSampleLocationsEXT.__Internal*)__Instance)->attachmentIndex = value;
        }
    }

    public global::VkSampleLocationsInfoEXT SampleLocationsInfo
    {
        get
        {
            return global::VkSampleLocationsInfoEXT.__CreateInstance(new global::System.IntPtr(&((global::VkAttachmentSampleLocationsEXT.__Internal*) __Instance)->sampleLocationsInfo));
        }

        set
        {
            ((global::VkAttachmentSampleLocationsEXT.__Internal*)__Instance)->sampleLocationsInfo = ReferenceEquals(value, null) ? new global::VkSampleLocationsInfoEXT.__Internal() : *(global::VkSampleLocationsInfoEXT.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkSubpassSampleLocationsEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint subpassIndex;

        [FieldOffset(8)]
        internal global::VkSampleLocationsInfoEXT.__Internal sampleLocationsInfo;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkSubpassSampleLocationsEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassSampleLocationsEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkSubpassSampleLocationsEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkSubpassSampleLocationsEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkSubpassSampleLocationsEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkSubpassSampleLocationsEXT __CreateInstance(global::VkSubpassSampleLocationsEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkSubpassSampleLocationsEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkSubpassSampleLocationsEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkSubpassSampleLocationsEXT.__Internal));
        *(global::VkSubpassSampleLocationsEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkSubpassSampleLocationsEXT(global::VkSubpassSampleLocationsEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkSubpassSampleLocationsEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkSubpassSampleLocationsEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassSampleLocationsEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkSubpassSampleLocationsEXT(global::VkSubpassSampleLocationsEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkSubpassSampleLocationsEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkSubpassSampleLocationsEXT.__Internal*) __Instance) = *((global::VkSubpassSampleLocationsEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkSubpassSampleLocationsEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint SubpassIndex
    {
        get
        {
            return ((global::VkSubpassSampleLocationsEXT.__Internal*) __Instance)->subpassIndex;
        }

        set
        {
            ((global::VkSubpassSampleLocationsEXT.__Internal*)__Instance)->subpassIndex = value;
        }
    }

    public global::VkSampleLocationsInfoEXT SampleLocationsInfo
    {
        get
        {
            return global::VkSampleLocationsInfoEXT.__CreateInstance(new global::System.IntPtr(&((global::VkSubpassSampleLocationsEXT.__Internal*) __Instance)->sampleLocationsInfo));
        }

        set
        {
            ((global::VkSubpassSampleLocationsEXT.__Internal*)__Instance)->sampleLocationsInfo = ReferenceEquals(value, null) ? new global::VkSampleLocationsInfoEXT.__Internal() : *(global::VkSampleLocationsInfoEXT.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkRenderPassSampleLocationsBeginInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint attachmentInitialSampleLocationsCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pAttachmentInitialSampleLocations;

        [FieldOffset(32)]
        internal uint postSubpassSampleLocationsCount;

        [FieldOffset(40)]
        internal global::System.IntPtr pPostSubpassSampleLocations;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkRenderPassSampleLocationsBeginInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassSampleLocationsBeginInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkRenderPassSampleLocationsBeginInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkRenderPassSampleLocationsBeginInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkRenderPassSampleLocationsBeginInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkRenderPassSampleLocationsBeginInfoEXT __CreateInstance(global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkRenderPassSampleLocationsBeginInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal));
        *(global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkRenderPassSampleLocationsBeginInfoEXT(global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkRenderPassSampleLocationsBeginInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkRenderPassSampleLocationsBeginInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkRenderPassSampleLocationsBeginInfoEXT(global::VkRenderPassSampleLocationsBeginInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance) = *((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkRenderPassSampleLocationsBeginInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint AttachmentInitialSampleLocationsCount
    {
        get
        {
            return ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->attachmentInitialSampleLocationsCount;
        }

        set
        {
            ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*)__Instance)->attachmentInitialSampleLocationsCount = value;
        }
    }

    public global::VkAttachmentSampleLocationsEXT PAttachmentInitialSampleLocations
    {
        get
        {
            global::VkAttachmentSampleLocationsEXT __result0;
            if (((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->pAttachmentInitialSampleLocations == IntPtr.Zero) __result0 = null;
            else if (global::VkAttachmentSampleLocationsEXT.NativeToManagedMap.ContainsKey(((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->pAttachmentInitialSampleLocations))
                __result0 = (global::VkAttachmentSampleLocationsEXT) global::VkAttachmentSampleLocationsEXT.NativeToManagedMap[((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->pAttachmentInitialSampleLocations];
            else __result0 = global::VkAttachmentSampleLocationsEXT.__CreateInstance(((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->pAttachmentInitialSampleLocations);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*)__Instance)->pAttachmentInitialSampleLocations = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }

    public uint PostSubpassSampleLocationsCount
    {
        get
        {
            return ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->postSubpassSampleLocationsCount;
        }

        set
        {
            ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*)__Instance)->postSubpassSampleLocationsCount = value;
        }
    }

    public global::VkSubpassSampleLocationsEXT PPostSubpassSampleLocations
    {
        get
        {
            global::VkSubpassSampleLocationsEXT __result0;
            if (((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->pPostSubpassSampleLocations == IntPtr.Zero) __result0 = null;
            else if (global::VkSubpassSampleLocationsEXT.NativeToManagedMap.ContainsKey(((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->pPostSubpassSampleLocations))
                __result0 = (global::VkSubpassSampleLocationsEXT) global::VkSubpassSampleLocationsEXT.NativeToManagedMap[((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->pPostSubpassSampleLocations];
            else __result0 = global::VkSubpassSampleLocationsEXT.__CreateInstance(((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*) __Instance)->pPostSubpassSampleLocations);
            return __result0;
        }

        set
        {
            ((global::VkRenderPassSampleLocationsBeginInfoEXT.__Internal*)__Instance)->pPostSubpassSampleLocations = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkPipelineSampleLocationsStateCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint sampleLocationsEnable;

        [FieldOffset(24)]
        internal global::VkSampleLocationsInfoEXT.__Internal sampleLocationsInfo;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineSampleLocationsStateCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineSampleLocationsStateCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineSampleLocationsStateCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineSampleLocationsStateCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineSampleLocationsStateCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineSampleLocationsStateCreateInfoEXT __CreateInstance(global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineSampleLocationsStateCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal));
        *(global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineSampleLocationsStateCreateInfoEXT(global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineSampleLocationsStateCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineSampleLocationsStateCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineSampleLocationsStateCreateInfoEXT(global::VkPipelineSampleLocationsStateCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*) __Instance) = *((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineSampleLocationsStateCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SampleLocationsEnable
    {
        get
        {
            return ((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*) __Instance)->sampleLocationsEnable;
        }

        set
        {
            ((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*)__Instance)->sampleLocationsEnable = value;
        }
    }

    public global::VkSampleLocationsInfoEXT SampleLocationsInfo
    {
        get
        {
            return global::VkSampleLocationsInfoEXT.__CreateInstance(new global::System.IntPtr(&((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*) __Instance)->sampleLocationsInfo));
        }

        set
        {
            ((global::VkPipelineSampleLocationsStateCreateInfoEXT.__Internal*)__Instance)->sampleLocationsInfo = ReferenceEquals(value, null) ? new global::VkSampleLocationsInfoEXT.__Internal() : *(global::VkSampleLocationsInfoEXT.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceSampleLocationsPropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint sampleLocationSampleCounts;

        [FieldOffset(20)]
        internal global::VkExtent2D.__Internal maxSampleLocationGridSize;

        [FieldOffset(28)]
        internal fixed float sampleLocationCoordinateRange[2];

        [FieldOffset(36)]
        internal uint sampleLocationSubPixelBits;

        [FieldOffset(40)]
        internal uint variableSampleLocations;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceSampleLocationsPropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSampleLocationsPropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceSampleLocationsPropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceSampleLocationsPropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSampleLocationsPropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceSampleLocationsPropertiesEXT __CreateInstance(global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceSampleLocationsPropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal));
        *(global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceSampleLocationsPropertiesEXT(global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceSampleLocationsPropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceSampleLocationsPropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceSampleLocationsPropertiesEXT(global::VkPhysicalDeviceSampleLocationsPropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceSampleLocationsPropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SampleLocationSampleCounts
    {
        get
        {
            return ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) __Instance)->sampleLocationSampleCounts;
        }

        set
        {
            ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*)__Instance)->sampleLocationSampleCounts = value;
        }
    }

    public global::VkExtent2D MaxSampleLocationGridSize
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) __Instance)->maxSampleLocationGridSize));
        }

        set
        {
            ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*)__Instance)->maxSampleLocationGridSize = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }

    public float[] SampleLocationCoordinateRange
    {
        get
        {
            float[] __value = null;
            if (((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) __Instance)->sampleLocationCoordinateRange != null)
            {
                __value = new float[2];
                for (int i = 0; i < 2; i++)
                    __value[i] = ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) __Instance)->sampleLocationCoordinateRange[i];
            }
            return __value;
        }

        set
        {
            if (value != null)
            {
                for (int i = 0; i < 2; i++)
                    ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*)__Instance)->sampleLocationCoordinateRange[i] = value[i];
            }
        }
    }

    public uint SampleLocationSubPixelBits
    {
        get
        {
            return ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) __Instance)->sampleLocationSubPixelBits;
        }

        set
        {
            ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*)__Instance)->sampleLocationSubPixelBits = value;
        }
    }

    public uint VariableSampleLocations
    {
        get
        {
            return ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*) __Instance)->variableSampleLocations;
        }

        set
        {
            ((global::VkPhysicalDeviceSampleLocationsPropertiesEXT.__Internal*)__Instance)->variableSampleLocations = value;
        }
    }
}

public unsafe partial class VkMultisamplePropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkExtent2D.__Internal maxSampleLocationGridSize;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMultisamplePropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMultisamplePropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMultisamplePropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMultisamplePropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMultisamplePropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkMultisamplePropertiesEXT __CreateInstance(global::VkMultisamplePropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkMultisamplePropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMultisamplePropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMultisamplePropertiesEXT.__Internal));
        *(global::VkMultisamplePropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMultisamplePropertiesEXT(global::VkMultisamplePropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMultisamplePropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMultisamplePropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMultisamplePropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMultisamplePropertiesEXT(global::VkMultisamplePropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMultisamplePropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMultisamplePropertiesEXT.__Internal*) __Instance) = *((global::VkMultisamplePropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMultisamplePropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMultisamplePropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMultisamplePropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMultisamplePropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMultisamplePropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkExtent2D MaxSampleLocationGridSize
    {
        get
        {
            return global::VkExtent2D.__CreateInstance(new global::System.IntPtr(&((global::VkMultisamplePropertiesEXT.__Internal*) __Instance)->maxSampleLocationGridSize));
        }

        set
        {
            ((global::VkMultisamplePropertiesEXT.__Internal*)__Instance)->maxSampleLocationGridSize = ReferenceEquals(value, null) ? new global::VkExtent2D.__Internal() : *(global::VkExtent2D.__Internal*) value.__Instance;
        }
    }
}

public unsafe partial class VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint advancedBlendCoherentOperations;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT __CreateInstance(global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal));
        *(global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint AdvancedBlendCoherentOperations
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal*) __Instance)->advancedBlendCoherentOperations;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.__Internal*)__Instance)->advancedBlendCoherentOperations = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint advancedBlendMaxColorAttachments;

        [FieldOffset(20)]
        internal uint advancedBlendIndependentBlend;

        [FieldOffset(24)]
        internal uint advancedBlendNonPremultipliedSrcColor;

        [FieldOffset(28)]
        internal uint advancedBlendNonPremultipliedDstColor;

        [FieldOffset(32)]
        internal uint advancedBlendCorrelatedOverlap;

        [FieldOffset(36)]
        internal uint advancedBlendAllOperations;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT __CreateInstance(global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal));
        *(global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint AdvancedBlendMaxColorAttachments
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) __Instance)->advancedBlendMaxColorAttachments;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*)__Instance)->advancedBlendMaxColorAttachments = value;
        }
    }

    public uint AdvancedBlendIndependentBlend
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) __Instance)->advancedBlendIndependentBlend;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*)__Instance)->advancedBlendIndependentBlend = value;
        }
    }

    public uint AdvancedBlendNonPremultipliedSrcColor
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) __Instance)->advancedBlendNonPremultipliedSrcColor;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*)__Instance)->advancedBlendNonPremultipliedSrcColor = value;
        }
    }

    public uint AdvancedBlendNonPremultipliedDstColor
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) __Instance)->advancedBlendNonPremultipliedDstColor;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*)__Instance)->advancedBlendNonPremultipliedDstColor = value;
        }
    }

    public uint AdvancedBlendCorrelatedOverlap
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) __Instance)->advancedBlendCorrelatedOverlap;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*)__Instance)->advancedBlendCorrelatedOverlap = value;
        }
    }

    public uint AdvancedBlendAllOperations
    {
        get
        {
            return ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*) __Instance)->advancedBlendAllOperations;
        }

        set
        {
            ((global::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.__Internal*)__Instance)->advancedBlendAllOperations = value;
        }
    }
}

public unsafe partial class VkPipelineColorBlendAdvancedStateCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint srcPremultiplied;

        [FieldOffset(20)]
        internal uint dstPremultiplied;

        [FieldOffset(24)]
        internal global::VkBlendOverlapEXT blendOverlap;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineColorBlendAdvancedStateCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineColorBlendAdvancedStateCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineColorBlendAdvancedStateCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineColorBlendAdvancedStateCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineColorBlendAdvancedStateCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineColorBlendAdvancedStateCreateInfoEXT __CreateInstance(global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineColorBlendAdvancedStateCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal));
        *(global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineColorBlendAdvancedStateCreateInfoEXT(global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineColorBlendAdvancedStateCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineColorBlendAdvancedStateCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineColorBlendAdvancedStateCreateInfoEXT(global::VkPipelineColorBlendAdvancedStateCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*) __Instance) = *((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineColorBlendAdvancedStateCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint SrcPremultiplied
    {
        get
        {
            return ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*) __Instance)->srcPremultiplied;
        }

        set
        {
            ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*)__Instance)->srcPremultiplied = value;
        }
    }

    public uint DstPremultiplied
    {
        get
        {
            return ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*) __Instance)->dstPremultiplied;
        }

        set
        {
            ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*)__Instance)->dstPremultiplied = value;
        }
    }

    public global::VkBlendOverlapEXT BlendOverlap
    {
        get
        {
            return ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*) __Instance)->blendOverlap;
        }

        set
        {
            ((global::VkPipelineColorBlendAdvancedStateCreateInfoEXT.__Internal*)__Instance)->blendOverlap = value;
        }
    }
}

public unsafe partial class VkPipelineCoverageToColorStateCreateInfoNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal uint coverageToColorEnable;

        [FieldOffset(24)]
        internal uint coverageToColorLocation;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineCoverageToColorStateCreateInfoNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineCoverageToColorStateCreateInfoNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineCoverageToColorStateCreateInfoNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineCoverageToColorStateCreateInfoNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineCoverageToColorStateCreateInfoNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineCoverageToColorStateCreateInfoNV __CreateInstance(global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineCoverageToColorStateCreateInfoNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal));
        *(global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineCoverageToColorStateCreateInfoNV(global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineCoverageToColorStateCreateInfoNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineCoverageToColorStateCreateInfoNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineCoverageToColorStateCreateInfoNV(global::VkPipelineCoverageToColorStateCreateInfoNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*) __Instance) = *((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineCoverageToColorStateCreateInfoNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*)__Instance)->flags = value;
        }
    }

    public uint CoverageToColorEnable
    {
        get
        {
            return ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*) __Instance)->coverageToColorEnable;
        }

        set
        {
            ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*)__Instance)->coverageToColorEnable = value;
        }
    }

    public uint CoverageToColorLocation
    {
        get
        {
            return ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*) __Instance)->coverageToColorLocation;
        }

        set
        {
            ((global::VkPipelineCoverageToColorStateCreateInfoNV.__Internal*)__Instance)->coverageToColorLocation = value;
        }
    }
}

public unsafe partial class VkPipelineCoverageModulationStateCreateInfoNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(20)]
        internal global::VkCoverageModulationModeNV coverageModulationMode;

        [FieldOffset(24)]
        internal uint coverageModulationTableEnable;

        [FieldOffset(28)]
        internal uint coverageModulationTableCount;

        [FieldOffset(32)]
        internal global::System.IntPtr pCoverageModulationTable;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineCoverageModulationStateCreateInfoNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineCoverageModulationStateCreateInfoNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineCoverageModulationStateCreateInfoNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineCoverageModulationStateCreateInfoNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineCoverageModulationStateCreateInfoNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineCoverageModulationStateCreateInfoNV __CreateInstance(global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineCoverageModulationStateCreateInfoNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal));
        *(global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineCoverageModulationStateCreateInfoNV(global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineCoverageModulationStateCreateInfoNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineCoverageModulationStateCreateInfoNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineCoverageModulationStateCreateInfoNV(global::VkPipelineCoverageModulationStateCreateInfoNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) __Instance) = *((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineCoverageModulationStateCreateInfoNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*)__Instance)->flags = value;
        }
    }

    public global::VkCoverageModulationModeNV CoverageModulationMode
    {
        get
        {
            return ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) __Instance)->coverageModulationMode;
        }

        set
        {
            ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*)__Instance)->coverageModulationMode = value;
        }
    }

    public uint CoverageModulationTableEnable
    {
        get
        {
            return ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) __Instance)->coverageModulationTableEnable;
        }

        set
        {
            ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*)__Instance)->coverageModulationTableEnable = value;
        }
    }

    public uint CoverageModulationTableCount
    {
        get
        {
            return ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) __Instance)->coverageModulationTableCount;
        }

        set
        {
            ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*)__Instance)->coverageModulationTableCount = value;
        }
    }

    public float* PCoverageModulationTable
    {
        get
        {
            return (float*) ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*) __Instance)->pCoverageModulationTable;
        }

        set
        {
            ((global::VkPipelineCoverageModulationStateCreateInfoNV.__Internal*)__Instance)->pCoverageModulationTable = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkValidationCacheEXT_T
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkValidationCacheEXT_T> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkValidationCacheEXT_T>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkValidationCacheEXT_T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkValidationCacheEXT_T(native.ToPointer(), skipVTables);
    }

    internal static global::VkValidationCacheEXT_T __CreateInstance(global::VkValidationCacheEXT_T.__Internal native, bool skipVTables = false)
    {
        return new global::VkValidationCacheEXT_T(native, skipVTables);
    }

    private static void* __CopyValue(global::VkValidationCacheEXT_T.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkValidationCacheEXT_T.__Internal));
        *(global::VkValidationCacheEXT_T.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkValidationCacheEXT_T(global::VkValidationCacheEXT_T.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkValidationCacheEXT_T(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class VkValidationCacheCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint flags;

        [FieldOffset(24)]
        internal ulong initialDataSize;

        [FieldOffset(32)]
        internal global::System.IntPtr pInitialData;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkValidationCacheCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkValidationCacheCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkValidationCacheCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkValidationCacheCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkValidationCacheCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkValidationCacheCreateInfoEXT __CreateInstance(global::VkValidationCacheCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkValidationCacheCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkValidationCacheCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkValidationCacheCreateInfoEXT.__Internal));
        *(global::VkValidationCacheCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkValidationCacheCreateInfoEXT(global::VkValidationCacheCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkValidationCacheCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkValidationCacheCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkValidationCacheCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkValidationCacheCreateInfoEXT(global::VkValidationCacheCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkValidationCacheCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkValidationCacheCreateInfoEXT.__Internal*) __Instance) = *((global::VkValidationCacheCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkValidationCacheCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkValidationCacheCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkValidationCacheCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkValidationCacheCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkValidationCacheCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint Flags
    {
        get
        {
            return ((global::VkValidationCacheCreateInfoEXT.__Internal*) __Instance)->flags;
        }

        set
        {
            ((global::VkValidationCacheCreateInfoEXT.__Internal*)__Instance)->flags = value;
        }
    }

    public ulong InitialDataSize
    {
        get
        {
            return ((global::VkValidationCacheCreateInfoEXT.__Internal*) __Instance)->initialDataSize;
        }

        set
        {
            ((global::VkValidationCacheCreateInfoEXT.__Internal*)__Instance)->initialDataSize = value;
        }
    }

    public global::System.IntPtr PInitialData
    {
        get
        {
            return ((global::VkValidationCacheCreateInfoEXT.__Internal*) __Instance)->pInitialData;
        }

        set
        {
            ((global::VkValidationCacheCreateInfoEXT.__Internal*)__Instance)->pInitialData = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkShaderModuleValidationCacheCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::System.IntPtr validationCache;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkShaderModuleValidationCacheCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderModuleValidationCacheCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkShaderModuleValidationCacheCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkShaderModuleValidationCacheCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkShaderModuleValidationCacheCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkShaderModuleValidationCacheCreateInfoEXT __CreateInstance(global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkShaderModuleValidationCacheCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal));
        *(global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkShaderModuleValidationCacheCreateInfoEXT(global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkShaderModuleValidationCacheCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkShaderModuleValidationCacheCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkShaderModuleValidationCacheCreateInfoEXT(global::VkShaderModuleValidationCacheCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*) __Instance) = *((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkShaderModuleValidationCacheCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkValidationCacheEXT_T ValidationCache
    {
        get
        {
            global::VkValidationCacheEXT_T __result0;
            if (((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*) __Instance)->validationCache == IntPtr.Zero) __result0 = null;
            else if (global::VkValidationCacheEXT_T.NativeToManagedMap.ContainsKey(((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*) __Instance)->validationCache))
                __result0 = (global::VkValidationCacheEXT_T) global::VkValidationCacheEXT_T.NativeToManagedMap[((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*) __Instance)->validationCache];
            else __result0 = global::VkValidationCacheEXT_T.__CreateInstance(((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*) __Instance)->validationCache);
            return __result0;
        }

        set
        {
            ((global::VkShaderModuleValidationCacheCreateInfoEXT.__Internal*)__Instance)->validationCache = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkDescriptorSetLayoutBindingFlagsCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint bindingCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pBindingFlags;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorSetLayoutBindingFlagsCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT __CreateInstance(global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal));
        *(global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorSetLayoutBindingFlagsCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*) __Instance) = *((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint BindingCount
    {
        get
        {
            return ((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*) __Instance)->bindingCount;
        }

        set
        {
            ((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*)__Instance)->bindingCount = value;
        }
    }

    public uint* PBindingFlags
    {
        get
        {
            return (uint*) ((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*) __Instance)->pBindingFlags;
        }

        set
        {
            ((global::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.__Internal*)__Instance)->pBindingFlags = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceDescriptorIndexingFeaturesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 96)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint shaderInputAttachmentArrayDynamicIndexing;

        [FieldOffset(20)]
        internal uint shaderUniformTexelBufferArrayDynamicIndexing;

        [FieldOffset(24)]
        internal uint shaderStorageTexelBufferArrayDynamicIndexing;

        [FieldOffset(28)]
        internal uint shaderUniformBufferArrayNonUniformIndexing;

        [FieldOffset(32)]
        internal uint shaderSampledImageArrayNonUniformIndexing;

        [FieldOffset(36)]
        internal uint shaderStorageBufferArrayNonUniformIndexing;

        [FieldOffset(40)]
        internal uint shaderStorageImageArrayNonUniformIndexing;

        [FieldOffset(44)]
        internal uint shaderInputAttachmentArrayNonUniformIndexing;

        [FieldOffset(48)]
        internal uint shaderUniformTexelBufferArrayNonUniformIndexing;

        [FieldOffset(52)]
        internal uint shaderStorageTexelBufferArrayNonUniformIndexing;

        [FieldOffset(56)]
        internal uint descriptorBindingUniformBufferUpdateAfterBind;

        [FieldOffset(60)]
        internal uint descriptorBindingSampledImageUpdateAfterBind;

        [FieldOffset(64)]
        internal uint descriptorBindingStorageImageUpdateAfterBind;

        [FieldOffset(68)]
        internal uint descriptorBindingStorageBufferUpdateAfterBind;

        [FieldOffset(72)]
        internal uint descriptorBindingUniformTexelBufferUpdateAfterBind;

        [FieldOffset(76)]
        internal uint descriptorBindingStorageTexelBufferUpdateAfterBind;

        [FieldOffset(80)]
        internal uint descriptorBindingUpdateUnusedWhilePending;

        [FieldOffset(84)]
        internal uint descriptorBindingPartiallyBound;

        [FieldOffset(88)]
        internal uint descriptorBindingVariableDescriptorCount;

        [FieldOffset(92)]
        internal uint runtimeDescriptorArray;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceDescriptorIndexingFeaturesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT __CreateInstance(global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal));
        *(global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceDescriptorIndexingFeaturesEXT(global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceDescriptorIndexingFeaturesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceDescriptorIndexingFeaturesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceDescriptorIndexingFeaturesEXT(global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ShaderInputAttachmentArrayDynamicIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderInputAttachmentArrayDynamicIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderInputAttachmentArrayDynamicIndexing = value;
        }
    }

    public uint ShaderUniformTexelBufferArrayDynamicIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderUniformTexelBufferArrayDynamicIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderUniformTexelBufferArrayDynamicIndexing = value;
        }
    }

    public uint ShaderStorageTexelBufferArrayDynamicIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderStorageTexelBufferArrayDynamicIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderStorageTexelBufferArrayDynamicIndexing = value;
        }
    }

    public uint ShaderUniformBufferArrayNonUniformIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderUniformBufferArrayNonUniformIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderUniformBufferArrayNonUniformIndexing = value;
        }
    }

    public uint ShaderSampledImageArrayNonUniformIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderSampledImageArrayNonUniformIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderSampledImageArrayNonUniformIndexing = value;
        }
    }

    public uint ShaderStorageBufferArrayNonUniformIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderStorageBufferArrayNonUniformIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderStorageBufferArrayNonUniformIndexing = value;
        }
    }

    public uint ShaderStorageImageArrayNonUniformIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderStorageImageArrayNonUniformIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderStorageImageArrayNonUniformIndexing = value;
        }
    }

    public uint ShaderInputAttachmentArrayNonUniformIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderInputAttachmentArrayNonUniformIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderInputAttachmentArrayNonUniformIndexing = value;
        }
    }

    public uint ShaderUniformTexelBufferArrayNonUniformIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderUniformTexelBufferArrayNonUniformIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderUniformTexelBufferArrayNonUniformIndexing = value;
        }
    }

    public uint ShaderStorageTexelBufferArrayNonUniformIndexing
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->shaderStorageTexelBufferArrayNonUniformIndexing;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->shaderStorageTexelBufferArrayNonUniformIndexing = value;
        }
    }

    public uint DescriptorBindingUniformBufferUpdateAfterBind
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->descriptorBindingUniformBufferUpdateAfterBind;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->descriptorBindingUniformBufferUpdateAfterBind = value;
        }
    }

    public uint DescriptorBindingSampledImageUpdateAfterBind
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->descriptorBindingSampledImageUpdateAfterBind;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->descriptorBindingSampledImageUpdateAfterBind = value;
        }
    }

    public uint DescriptorBindingStorageImageUpdateAfterBind
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->descriptorBindingStorageImageUpdateAfterBind;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->descriptorBindingStorageImageUpdateAfterBind = value;
        }
    }

    public uint DescriptorBindingStorageBufferUpdateAfterBind
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->descriptorBindingStorageBufferUpdateAfterBind;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->descriptorBindingStorageBufferUpdateAfterBind = value;
        }
    }

    public uint DescriptorBindingUniformTexelBufferUpdateAfterBind
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->descriptorBindingUniformTexelBufferUpdateAfterBind;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->descriptorBindingUniformTexelBufferUpdateAfterBind = value;
        }
    }

    public uint DescriptorBindingStorageTexelBufferUpdateAfterBind
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->descriptorBindingStorageTexelBufferUpdateAfterBind;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->descriptorBindingStorageTexelBufferUpdateAfterBind = value;
        }
    }

    public uint DescriptorBindingUpdateUnusedWhilePending
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->descriptorBindingUpdateUnusedWhilePending;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->descriptorBindingUpdateUnusedWhilePending = value;
        }
    }

    public uint DescriptorBindingPartiallyBound
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->descriptorBindingPartiallyBound;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->descriptorBindingPartiallyBound = value;
        }
    }

    public uint DescriptorBindingVariableDescriptorCount
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->descriptorBindingVariableDescriptorCount;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->descriptorBindingVariableDescriptorCount = value;
        }
    }

    public uint RuntimeDescriptorArray
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*) __Instance)->runtimeDescriptorArray;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingFeaturesEXT.__Internal*)__Instance)->runtimeDescriptorArray = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceDescriptorIndexingPropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 112)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint maxUpdateAfterBindDescriptorsInAllPools;

        [FieldOffset(20)]
        internal uint shaderUniformBufferArrayNonUniformIndexingNative;

        [FieldOffset(24)]
        internal uint shaderSampledImageArrayNonUniformIndexingNative;

        [FieldOffset(28)]
        internal uint shaderStorageBufferArrayNonUniformIndexingNative;

        [FieldOffset(32)]
        internal uint shaderStorageImageArrayNonUniformIndexingNative;

        [FieldOffset(36)]
        internal uint shaderInputAttachmentArrayNonUniformIndexingNative;

        [FieldOffset(40)]
        internal uint robustBufferAccessUpdateAfterBind;

        [FieldOffset(44)]
        internal uint quadDivergentImplicitLod;

        [FieldOffset(48)]
        internal uint maxPerStageDescriptorUpdateAfterBindSamplers;

        [FieldOffset(52)]
        internal uint maxPerStageDescriptorUpdateAfterBindUniformBuffers;

        [FieldOffset(56)]
        internal uint maxPerStageDescriptorUpdateAfterBindStorageBuffers;

        [FieldOffset(60)]
        internal uint maxPerStageDescriptorUpdateAfterBindSampledImages;

        [FieldOffset(64)]
        internal uint maxPerStageDescriptorUpdateAfterBindStorageImages;

        [FieldOffset(68)]
        internal uint maxPerStageDescriptorUpdateAfterBindInputAttachments;

        [FieldOffset(72)]
        internal uint maxPerStageUpdateAfterBindResources;

        [FieldOffset(76)]
        internal uint maxDescriptorSetUpdateAfterBindSamplers;

        [FieldOffset(80)]
        internal uint maxDescriptorSetUpdateAfterBindUniformBuffers;

        [FieldOffset(84)]
        internal uint maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;

        [FieldOffset(88)]
        internal uint maxDescriptorSetUpdateAfterBindStorageBuffers;

        [FieldOffset(92)]
        internal uint maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;

        [FieldOffset(96)]
        internal uint maxDescriptorSetUpdateAfterBindSampledImages;

        [FieldOffset(100)]
        internal uint maxDescriptorSetUpdateAfterBindStorageImages;

        [FieldOffset(104)]
        internal uint maxDescriptorSetUpdateAfterBindInputAttachments;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceDescriptorIndexingPropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT __CreateInstance(global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal));
        *(global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceDescriptorIndexingPropertiesEXT(global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceDescriptorIndexingPropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceDescriptorIndexingPropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceDescriptorIndexingPropertiesEXT(global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MaxUpdateAfterBindDescriptorsInAllPools
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxUpdateAfterBindDescriptorsInAllPools;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxUpdateAfterBindDescriptorsInAllPools = value;
        }
    }

    public uint ShaderUniformBufferArrayNonUniformIndexingNative
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->shaderUniformBufferArrayNonUniformIndexingNative;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->shaderUniformBufferArrayNonUniformIndexingNative = value;
        }
    }

    public uint ShaderSampledImageArrayNonUniformIndexingNative
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->shaderSampledImageArrayNonUniformIndexingNative;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->shaderSampledImageArrayNonUniformIndexingNative = value;
        }
    }

    public uint ShaderStorageBufferArrayNonUniformIndexingNative
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->shaderStorageBufferArrayNonUniformIndexingNative;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->shaderStorageBufferArrayNonUniformIndexingNative = value;
        }
    }

    public uint ShaderStorageImageArrayNonUniformIndexingNative
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->shaderStorageImageArrayNonUniformIndexingNative;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->shaderStorageImageArrayNonUniformIndexingNative = value;
        }
    }

    public uint ShaderInputAttachmentArrayNonUniformIndexingNative
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->shaderInputAttachmentArrayNonUniformIndexingNative;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->shaderInputAttachmentArrayNonUniformIndexingNative = value;
        }
    }

    public uint RobustBufferAccessUpdateAfterBind
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->robustBufferAccessUpdateAfterBind;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->robustBufferAccessUpdateAfterBind = value;
        }
    }

    public uint QuadDivergentImplicitLod
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->quadDivergentImplicitLod;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->quadDivergentImplicitLod = value;
        }
    }

    public uint MaxPerStageDescriptorUpdateAfterBindSamplers
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxPerStageDescriptorUpdateAfterBindSamplers;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxPerStageDescriptorUpdateAfterBindSamplers = value;
        }
    }

    public uint MaxPerStageDescriptorUpdateAfterBindUniformBuffers
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxPerStageDescriptorUpdateAfterBindUniformBuffers;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxPerStageDescriptorUpdateAfterBindUniformBuffers = value;
        }
    }

    public uint MaxPerStageDescriptorUpdateAfterBindStorageBuffers
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxPerStageDescriptorUpdateAfterBindStorageBuffers;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxPerStageDescriptorUpdateAfterBindStorageBuffers = value;
        }
    }

    public uint MaxPerStageDescriptorUpdateAfterBindSampledImages
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxPerStageDescriptorUpdateAfterBindSampledImages;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxPerStageDescriptorUpdateAfterBindSampledImages = value;
        }
    }

    public uint MaxPerStageDescriptorUpdateAfterBindStorageImages
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxPerStageDescriptorUpdateAfterBindStorageImages;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxPerStageDescriptorUpdateAfterBindStorageImages = value;
        }
    }

    public uint MaxPerStageDescriptorUpdateAfterBindInputAttachments
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxPerStageDescriptorUpdateAfterBindInputAttachments;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxPerStageDescriptorUpdateAfterBindInputAttachments = value;
        }
    }

    public uint MaxPerStageUpdateAfterBindResources
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxPerStageUpdateAfterBindResources;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxPerStageUpdateAfterBindResources = value;
        }
    }

    public uint MaxDescriptorSetUpdateAfterBindSamplers
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxDescriptorSetUpdateAfterBindSamplers;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxDescriptorSetUpdateAfterBindSamplers = value;
        }
    }

    public uint MaxDescriptorSetUpdateAfterBindUniformBuffers
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxDescriptorSetUpdateAfterBindUniformBuffers;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxDescriptorSetUpdateAfterBindUniformBuffers = value;
        }
    }

    public uint MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = value;
        }
    }

    public uint MaxDescriptorSetUpdateAfterBindStorageBuffers
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxDescriptorSetUpdateAfterBindStorageBuffers;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxDescriptorSetUpdateAfterBindStorageBuffers = value;
        }
    }

    public uint MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = value;
        }
    }

    public uint MaxDescriptorSetUpdateAfterBindSampledImages
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxDescriptorSetUpdateAfterBindSampledImages;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxDescriptorSetUpdateAfterBindSampledImages = value;
        }
    }

    public uint MaxDescriptorSetUpdateAfterBindStorageImages
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxDescriptorSetUpdateAfterBindStorageImages;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxDescriptorSetUpdateAfterBindStorageImages = value;
        }
    }

    public uint MaxDescriptorSetUpdateAfterBindInputAttachments
    {
        get
        {
            return ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*) __Instance)->maxDescriptorSetUpdateAfterBindInputAttachments;
        }

        set
        {
            ((global::VkPhysicalDeviceDescriptorIndexingPropertiesEXT.__Internal*)__Instance)->maxDescriptorSetUpdateAfterBindInputAttachments = value;
        }
    }
}

public unsafe partial class VkDescriptorSetVariableDescriptorCountAllocateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint descriptorSetCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pDescriptorCounts;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorSetVariableDescriptorCountAllocateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT __CreateInstance(global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal));
        *(global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorSetVariableDescriptorCountAllocateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*) __Instance) = *((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint DescriptorSetCount
    {
        get
        {
            return ((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*) __Instance)->descriptorSetCount;
        }

        set
        {
            ((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*)__Instance)->descriptorSetCount = value;
        }
    }

    public uint* PDescriptorCounts
    {
        get
        {
            return (uint*) ((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*) __Instance)->pDescriptorCounts;
        }

        set
        {
            ((global::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.__Internal*)__Instance)->pDescriptorCounts = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkDescriptorSetVariableDescriptorCountLayoutSupportEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint maxVariableDescriptorCount;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDescriptorSetVariableDescriptorCountLayoutSupportEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT __CreateInstance(global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal));
        *(global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDescriptorSetVariableDescriptorCountLayoutSupportEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal*) __Instance) = *((global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MaxVariableDescriptorCount
    {
        get
        {
            return ((global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal*) __Instance)->maxVariableDescriptorCount;
        }

        set
        {
            ((global::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.__Internal*)__Instance)->maxVariableDescriptorCount = value;
        }
    }
}

public unsafe partial class VkDeviceQueueGlobalPriorityCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkQueueGlobalPriorityEXT globalPriority;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkDeviceQueueGlobalPriorityCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceQueueGlobalPriorityCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkDeviceQueueGlobalPriorityCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkDeviceQueueGlobalPriorityCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkDeviceQueueGlobalPriorityCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkDeviceQueueGlobalPriorityCreateInfoEXT __CreateInstance(global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkDeviceQueueGlobalPriorityCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal));
        *(global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkDeviceQueueGlobalPriorityCreateInfoEXT(global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkDeviceQueueGlobalPriorityCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkDeviceQueueGlobalPriorityCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkDeviceQueueGlobalPriorityCreateInfoEXT(global::VkDeviceQueueGlobalPriorityCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal*) __Instance) = *((global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkDeviceQueueGlobalPriorityCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkQueueGlobalPriorityEXT GlobalPriority
    {
        get
        {
            return ((global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal*) __Instance)->globalPriority;
        }

        set
        {
            ((global::VkDeviceQueueGlobalPriorityCreateInfoEXT.__Internal*)__Instance)->globalPriority = value;
        }
    }
}

public unsafe partial class VkImportMemoryHostPointerInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkExternalMemoryHandleTypeFlagBits handleType;

        [FieldOffset(24)]
        internal global::System.IntPtr pHostPointer;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkImportMemoryHostPointerInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImportMemoryHostPointerInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkImportMemoryHostPointerInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkImportMemoryHostPointerInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkImportMemoryHostPointerInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkImportMemoryHostPointerInfoEXT __CreateInstance(global::VkImportMemoryHostPointerInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkImportMemoryHostPointerInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkImportMemoryHostPointerInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkImportMemoryHostPointerInfoEXT.__Internal));
        *(global::VkImportMemoryHostPointerInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkImportMemoryHostPointerInfoEXT(global::VkImportMemoryHostPointerInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkImportMemoryHostPointerInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkImportMemoryHostPointerInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImportMemoryHostPointerInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkImportMemoryHostPointerInfoEXT(global::VkImportMemoryHostPointerInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkImportMemoryHostPointerInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkImportMemoryHostPointerInfoEXT.__Internal*) __Instance) = *((global::VkImportMemoryHostPointerInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkImportMemoryHostPointerInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkImportMemoryHostPointerInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkImportMemoryHostPointerInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkImportMemoryHostPointerInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkImportMemoryHostPointerInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkExternalMemoryHandleTypeFlagBits HandleType
    {
        get
        {
            return ((global::VkImportMemoryHostPointerInfoEXT.__Internal*) __Instance)->handleType;
        }

        set
        {
            ((global::VkImportMemoryHostPointerInfoEXT.__Internal*)__Instance)->handleType = value;
        }
    }

    public global::System.IntPtr PHostPointer
    {
        get
        {
            return ((global::VkImportMemoryHostPointerInfoEXT.__Internal*) __Instance)->pHostPointer;
        }

        set
        {
            ((global::VkImportMemoryHostPointerInfoEXT.__Internal*)__Instance)->pHostPointer = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class VkMemoryHostPointerPropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint memoryTypeBits;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkMemoryHostPointerPropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryHostPointerPropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkMemoryHostPointerPropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkMemoryHostPointerPropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkMemoryHostPointerPropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkMemoryHostPointerPropertiesEXT __CreateInstance(global::VkMemoryHostPointerPropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkMemoryHostPointerPropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkMemoryHostPointerPropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkMemoryHostPointerPropertiesEXT.__Internal));
        *(global::VkMemoryHostPointerPropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkMemoryHostPointerPropertiesEXT(global::VkMemoryHostPointerPropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkMemoryHostPointerPropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkMemoryHostPointerPropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryHostPointerPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkMemoryHostPointerPropertiesEXT(global::VkMemoryHostPointerPropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkMemoryHostPointerPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkMemoryHostPointerPropertiesEXT.__Internal*) __Instance) = *((global::VkMemoryHostPointerPropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkMemoryHostPointerPropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkMemoryHostPointerPropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkMemoryHostPointerPropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkMemoryHostPointerPropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkMemoryHostPointerPropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MemoryTypeBits
    {
        get
        {
            return ((global::VkMemoryHostPointerPropertiesEXT.__Internal*) __Instance)->memoryTypeBits;
        }

        set
        {
            ((global::VkMemoryHostPointerPropertiesEXT.__Internal*)__Instance)->memoryTypeBits = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceExternalMemoryHostPropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal ulong minImportedHostPointerAlignment;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceExternalMemoryHostPropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT __CreateInstance(global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal));
        *(global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceExternalMemoryHostPropertiesEXT(global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceExternalMemoryHostPropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceExternalMemoryHostPropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceExternalMemoryHostPropertiesEXT(global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public ulong MinImportedHostPointerAlignment
    {
        get
        {
            return ((global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal*) __Instance)->minImportedHostPointerAlignment;
        }

        set
        {
            ((global::VkPhysicalDeviceExternalMemoryHostPropertiesEXT.__Internal*)__Instance)->minImportedHostPointerAlignment = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceShaderCorePropertiesAMD : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint shaderEngineCount;

        [FieldOffset(20)]
        internal uint shaderArraysPerEngineCount;

        [FieldOffset(24)]
        internal uint computeUnitsPerShaderArray;

        [FieldOffset(28)]
        internal uint simdPerComputeUnit;

        [FieldOffset(32)]
        internal uint wavefrontsPerSimd;

        [FieldOffset(36)]
        internal uint wavefrontSize;

        [FieldOffset(40)]
        internal uint sgprsPerSimd;

        [FieldOffset(44)]
        internal uint minSgprAllocation;

        [FieldOffset(48)]
        internal uint maxSgprAllocation;

        [FieldOffset(52)]
        internal uint sgprAllocationGranularity;

        [FieldOffset(56)]
        internal uint vgprsPerSimd;

        [FieldOffset(60)]
        internal uint minVgprAllocation;

        [FieldOffset(64)]
        internal uint maxVgprAllocation;

        [FieldOffset(68)]
        internal uint vgprAllocationGranularity;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceShaderCorePropertiesAMD@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceShaderCorePropertiesAMD> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceShaderCorePropertiesAMD>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceShaderCorePropertiesAMD __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceShaderCorePropertiesAMD(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceShaderCorePropertiesAMD __CreateInstance(global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceShaderCorePropertiesAMD(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal));
        *(global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceShaderCorePropertiesAMD(global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceShaderCorePropertiesAMD(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceShaderCorePropertiesAMD()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceShaderCorePropertiesAMD(global::VkPhysicalDeviceShaderCorePropertiesAMD _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance) = *((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceShaderCorePropertiesAMD __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint ShaderEngineCount
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->shaderEngineCount;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->shaderEngineCount = value;
        }
    }

    public uint ShaderArraysPerEngineCount
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->shaderArraysPerEngineCount;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->shaderArraysPerEngineCount = value;
        }
    }

    public uint ComputeUnitsPerShaderArray
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->computeUnitsPerShaderArray;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->computeUnitsPerShaderArray = value;
        }
    }

    public uint SimdPerComputeUnit
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->simdPerComputeUnit;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->simdPerComputeUnit = value;
        }
    }

    public uint WavefrontsPerSimd
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->wavefrontsPerSimd;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->wavefrontsPerSimd = value;
        }
    }

    public uint WavefrontSize
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->wavefrontSize;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->wavefrontSize = value;
        }
    }

    public uint SgprsPerSimd
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->sgprsPerSimd;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->sgprsPerSimd = value;
        }
    }

    public uint MinSgprAllocation
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->minSgprAllocation;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->minSgprAllocation = value;
        }
    }

    public uint MaxSgprAllocation
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->maxSgprAllocation;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->maxSgprAllocation = value;
        }
    }

    public uint SgprAllocationGranularity
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->sgprAllocationGranularity;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->sgprAllocationGranularity = value;
        }
    }

    public uint VgprsPerSimd
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->vgprsPerSimd;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->vgprsPerSimd = value;
        }
    }

    public uint MinVgprAllocation
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->minVgprAllocation;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->minVgprAllocation = value;
        }
    }

    public uint MaxVgprAllocation
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->maxVgprAllocation;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->maxVgprAllocation = value;
        }
    }

    public uint VgprAllocationGranularity
    {
        get
        {
            return ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*) __Instance)->vgprAllocationGranularity;
        }

        set
        {
            ((global::VkPhysicalDeviceShaderCorePropertiesAMD.__Internal*)__Instance)->vgprAllocationGranularity = value;
        }
    }
}

public unsafe partial class VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint maxVertexAttribDivisor;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT __CreateInstance(global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal));
        *(global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal*) __Instance) = *((global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint MaxVertexAttribDivisor
    {
        get
        {
            return ((global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal*) __Instance)->maxVertexAttribDivisor;
        }

        set
        {
            ((global::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.__Internal*)__Instance)->maxVertexAttribDivisor = value;
        }
    }
}

public unsafe partial class VkVertexInputBindingDivisorDescriptionEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint binding;

        [FieldOffset(4)]
        internal uint divisor;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkVertexInputBindingDivisorDescriptionEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkVertexInputBindingDivisorDescriptionEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkVertexInputBindingDivisorDescriptionEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkVertexInputBindingDivisorDescriptionEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkVertexInputBindingDivisorDescriptionEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkVertexInputBindingDivisorDescriptionEXT __CreateInstance(global::VkVertexInputBindingDivisorDescriptionEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkVertexInputBindingDivisorDescriptionEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkVertexInputBindingDivisorDescriptionEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkVertexInputBindingDivisorDescriptionEXT.__Internal));
        *(global::VkVertexInputBindingDivisorDescriptionEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkVertexInputBindingDivisorDescriptionEXT(global::VkVertexInputBindingDivisorDescriptionEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkVertexInputBindingDivisorDescriptionEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkVertexInputBindingDivisorDescriptionEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkVertexInputBindingDivisorDescriptionEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkVertexInputBindingDivisorDescriptionEXT(global::VkVertexInputBindingDivisorDescriptionEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkVertexInputBindingDivisorDescriptionEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkVertexInputBindingDivisorDescriptionEXT.__Internal*) __Instance) = *((global::VkVertexInputBindingDivisorDescriptionEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkVertexInputBindingDivisorDescriptionEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint Binding
    {
        get
        {
            return ((global::VkVertexInputBindingDivisorDescriptionEXT.__Internal*) __Instance)->binding;
        }

        set
        {
            ((global::VkVertexInputBindingDivisorDescriptionEXT.__Internal*)__Instance)->binding = value;
        }
    }

    public uint Divisor
    {
        get
        {
            return ((global::VkVertexInputBindingDivisorDescriptionEXT.__Internal*) __Instance)->divisor;
        }

        set
        {
            ((global::VkVertexInputBindingDivisorDescriptionEXT.__Internal*)__Instance)->divisor = value;
        }
    }
}

public unsafe partial class VkPipelineVertexInputDivisorStateCreateInfoEXT : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint vertexBindingDivisorCount;

        [FieldOffset(24)]
        internal global::System.IntPtr pVertexBindingDivisors;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkPipelineVertexInputDivisorStateCreateInfoEXT@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineVertexInputDivisorStateCreateInfoEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkPipelineVertexInputDivisorStateCreateInfoEXT>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkPipelineVertexInputDivisorStateCreateInfoEXT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkPipelineVertexInputDivisorStateCreateInfoEXT(native.ToPointer(), skipVTables);
    }

    internal static global::VkPipelineVertexInputDivisorStateCreateInfoEXT __CreateInstance(global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal native, bool skipVTables = false)
    {
        return new global::VkPipelineVertexInputDivisorStateCreateInfoEXT(native, skipVTables);
    }

    private static void* __CopyValue(global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal));
        *(global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkPipelineVertexInputDivisorStateCreateInfoEXT(global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkPipelineVertexInputDivisorStateCreateInfoEXT(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkPipelineVertexInputDivisorStateCreateInfoEXT()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkPipelineVertexInputDivisorStateCreateInfoEXT(global::VkPipelineVertexInputDivisorStateCreateInfoEXT _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) __Instance) = *((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkPipelineVertexInputDivisorStateCreateInfoEXT __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint VertexBindingDivisorCount
    {
        get
        {
            return ((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) __Instance)->vertexBindingDivisorCount;
        }

        set
        {
            ((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*)__Instance)->vertexBindingDivisorCount = value;
        }
    }

    public global::VkVertexInputBindingDivisorDescriptionEXT PVertexBindingDivisors
    {
        get
        {
            global::VkVertexInputBindingDivisorDescriptionEXT __result0;
            if (((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) __Instance)->pVertexBindingDivisors == IntPtr.Zero) __result0 = null;
            else if (global::VkVertexInputBindingDivisorDescriptionEXT.NativeToManagedMap.ContainsKey(((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) __Instance)->pVertexBindingDivisors))
                __result0 = (global::VkVertexInputBindingDivisorDescriptionEXT) global::VkVertexInputBindingDivisorDescriptionEXT.NativeToManagedMap[((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) __Instance)->pVertexBindingDivisors];
            else __result0 = global::VkVertexInputBindingDivisorDescriptionEXT.__CreateInstance(((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*) __Instance)->pVertexBindingDivisors);
            return __result0;
        }

        set
        {
            ((global::VkPipelineVertexInputDivisorStateCreateInfoEXT.__Internal*)__Instance)->pVertexBindingDivisors = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
        }
    }
}

public unsafe partial class VkQueueFamilyCheckpointPropertiesNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal uint checkpointExecutionStageMask;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkQueueFamilyCheckpointPropertiesNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueueFamilyCheckpointPropertiesNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkQueueFamilyCheckpointPropertiesNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkQueueFamilyCheckpointPropertiesNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkQueueFamilyCheckpointPropertiesNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkQueueFamilyCheckpointPropertiesNV __CreateInstance(global::VkQueueFamilyCheckpointPropertiesNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkQueueFamilyCheckpointPropertiesNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkQueueFamilyCheckpointPropertiesNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkQueueFamilyCheckpointPropertiesNV.__Internal));
        *(global::VkQueueFamilyCheckpointPropertiesNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkQueueFamilyCheckpointPropertiesNV(global::VkQueueFamilyCheckpointPropertiesNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkQueueFamilyCheckpointPropertiesNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkQueueFamilyCheckpointPropertiesNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkQueueFamilyCheckpointPropertiesNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkQueueFamilyCheckpointPropertiesNV(global::VkQueueFamilyCheckpointPropertiesNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkQueueFamilyCheckpointPropertiesNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkQueueFamilyCheckpointPropertiesNV.__Internal*) __Instance) = *((global::VkQueueFamilyCheckpointPropertiesNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkQueueFamilyCheckpointPropertiesNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkQueueFamilyCheckpointPropertiesNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkQueueFamilyCheckpointPropertiesNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkQueueFamilyCheckpointPropertiesNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkQueueFamilyCheckpointPropertiesNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public uint CheckpointExecutionStageMask
    {
        get
        {
            return ((global::VkQueueFamilyCheckpointPropertiesNV.__Internal*) __Instance)->checkpointExecutionStageMask;
        }

        set
        {
            ((global::VkQueueFamilyCheckpointPropertiesNV.__Internal*)__Instance)->checkpointExecutionStageMask = value;
        }
    }
}

public unsafe partial class VkCheckpointDataNV : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::VkStructureType sType;

        [FieldOffset(8)]
        internal global::System.IntPtr pNext;

        [FieldOffset(16)]
        internal global::VkPipelineStageFlagBits stage;

        [FieldOffset(24)]
        internal global::System.IntPtr pCheckpointMarker;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0VkCheckpointDataNV@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCheckpointDataNV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VkCheckpointDataNV>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::VkCheckpointDataNV __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::VkCheckpointDataNV(native.ToPointer(), skipVTables);
    }

    internal static global::VkCheckpointDataNV __CreateInstance(global::VkCheckpointDataNV.__Internal native, bool skipVTables = false)
    {
        return new global::VkCheckpointDataNV(native, skipVTables);
    }

    private static void* __CopyValue(global::VkCheckpointDataNV.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::VkCheckpointDataNV.__Internal));
        *(global::VkCheckpointDataNV.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private VkCheckpointDataNV(global::VkCheckpointDataNV.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected VkCheckpointDataNV(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public VkCheckpointDataNV()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCheckpointDataNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public VkCheckpointDataNV(global::VkCheckpointDataNV _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::VkCheckpointDataNV.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::VkCheckpointDataNV.__Internal*) __Instance) = *((global::VkCheckpointDataNV.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::VkCheckpointDataNV __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public global::VkStructureType SType
    {
        get
        {
            return ((global::VkCheckpointDataNV.__Internal*) __Instance)->sType;
        }

        set
        {
            ((global::VkCheckpointDataNV.__Internal*)__Instance)->sType = value;
        }
    }

    public global::System.IntPtr PNext
    {
        get
        {
            return ((global::VkCheckpointDataNV.__Internal*) __Instance)->pNext;
        }

        set
        {
            ((global::VkCheckpointDataNV.__Internal*)__Instance)->pNext = (global::System.IntPtr) value;
        }
    }

    public global::VkPipelineStageFlagBits Stage
    {
        get
        {
            return ((global::VkCheckpointDataNV.__Internal*) __Instance)->stage;
        }

        set
        {
            ((global::VkCheckpointDataNV.__Internal*)__Instance)->stage = value;
        }
    }

    public global::System.IntPtr PCheckpointMarker
    {
        get
        {
            return ((global::VkCheckpointDataNV.__Internal*) __Instance)->pCheckpointMarker;
        }

        set
        {
            ((global::VkCheckpointDataNV.__Internal*)__Instance)->pCheckpointMarker = (global::System.IntPtr) value;
        }
    }
}

public unsafe partial class vulkan_core
{
    public partial struct __Internal
    {
        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateInstance")]
        internal static extern global::VkResult VkCreateInstance(global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pInstance);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyInstance")]
        internal static extern void VkDestroyInstance(global::System.IntPtr instance, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkEnumeratePhysicalDevices")]
        internal static extern global::VkResult VkEnumeratePhysicalDevices(global::System.IntPtr instance, uint* pPhysicalDeviceCount, global::System.IntPtr pPhysicalDevices);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceFeatures")]
        internal static extern void VkGetPhysicalDeviceFeatures(global::System.IntPtr physicalDevice, global::System.IntPtr pFeatures);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceFormatProperties")]
        internal static extern void VkGetPhysicalDeviceFormatProperties(global::System.IntPtr physicalDevice, global::VkFormat format, global::System.IntPtr pFormatProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceImageFormatProperties")]
        internal static extern global::VkResult VkGetPhysicalDeviceImageFormatProperties(global::System.IntPtr physicalDevice, global::VkFormat format, global::VkImageType type, global::VkImageTiling tiling, uint usage, uint flags, global::System.IntPtr pImageFormatProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceProperties")]
        internal static extern void VkGetPhysicalDeviceProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceQueueFamilyProperties")]
        internal static extern void VkGetPhysicalDeviceQueueFamilyProperties(global::System.IntPtr physicalDevice, uint* pQueueFamilyPropertyCount, global::System.IntPtr pQueueFamilyProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceMemoryProperties")]
        internal static extern void VkGetPhysicalDeviceMemoryProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pMemoryProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetInstanceProcAddr")]
        internal static extern global::System.IntPtr VkGetInstanceProcAddr(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string pName);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDeviceProcAddr")]
        internal static extern global::System.IntPtr VkGetDeviceProcAddr(global::System.IntPtr device, [MarshalAs(UnmanagedType.LPStr)] string pName);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateDevice")]
        internal static extern global::VkResult VkCreateDevice(global::System.IntPtr physicalDevice, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pDevice);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyDevice")]
        internal static extern void VkDestroyDevice(global::System.IntPtr device, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkEnumerateInstanceExtensionProperties")]
        internal static extern global::VkResult VkEnumerateInstanceExtensionProperties([MarshalAs(UnmanagedType.LPStr)] string pLayerName, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkEnumerateDeviceExtensionProperties")]
        internal static extern global::VkResult VkEnumerateDeviceExtensionProperties(global::System.IntPtr physicalDevice, [MarshalAs(UnmanagedType.LPStr)] string pLayerName, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkEnumerateInstanceLayerProperties")]
        internal static extern global::VkResult VkEnumerateInstanceLayerProperties(uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkEnumerateDeviceLayerProperties")]
        internal static extern global::VkResult VkEnumerateDeviceLayerProperties(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDeviceQueue")]
        internal static extern void VkGetDeviceQueue(global::System.IntPtr device, uint queueFamilyIndex, uint queueIndex, global::System.IntPtr pQueue);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkQueueSubmit")]
        internal static extern global::VkResult VkQueueSubmit(global::System.IntPtr queue, uint submitCount, global::System.IntPtr pSubmits, global::System.IntPtr fence);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkQueueWaitIdle")]
        internal static extern global::VkResult VkQueueWaitIdle(global::System.IntPtr queue);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDeviceWaitIdle")]
        internal static extern global::VkResult VkDeviceWaitIdle(global::System.IntPtr device);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkAllocateMemory")]
        internal static extern global::VkResult VkAllocateMemory(global::System.IntPtr device, global::System.IntPtr pAllocateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pMemory);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkFreeMemory")]
        internal static extern void VkFreeMemory(global::System.IntPtr device, global::System.IntPtr memory, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkMapMemory")]
        internal static extern global::VkResult VkMapMemory(global::System.IntPtr device, global::System.IntPtr memory, ulong offset, ulong size, uint flags, void** ppData);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkUnmapMemory")]
        internal static extern void VkUnmapMemory(global::System.IntPtr device, global::System.IntPtr memory);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkFlushMappedMemoryRanges")]
        internal static extern global::VkResult VkFlushMappedMemoryRanges(global::System.IntPtr device, uint memoryRangeCount, global::System.IntPtr pMemoryRanges);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkInvalidateMappedMemoryRanges")]
        internal static extern global::VkResult VkInvalidateMappedMemoryRanges(global::System.IntPtr device, uint memoryRangeCount, global::System.IntPtr pMemoryRanges);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDeviceMemoryCommitment")]
        internal static extern void VkGetDeviceMemoryCommitment(global::System.IntPtr device, global::System.IntPtr memory, ulong* pCommittedMemoryInBytes);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkBindBufferMemory")]
        internal static extern global::VkResult VkBindBufferMemory(global::System.IntPtr device, global::System.IntPtr buffer, global::System.IntPtr memory, ulong memoryOffset);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkBindImageMemory")]
        internal static extern global::VkResult VkBindImageMemory(global::System.IntPtr device, global::System.IntPtr image, global::System.IntPtr memory, ulong memoryOffset);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetBufferMemoryRequirements")]
        internal static extern void VkGetBufferMemoryRequirements(global::System.IntPtr device, global::System.IntPtr buffer, global::System.IntPtr pMemoryRequirements);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetImageMemoryRequirements")]
        internal static extern void VkGetImageMemoryRequirements(global::System.IntPtr device, global::System.IntPtr image, global::System.IntPtr pMemoryRequirements);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetImageSparseMemoryRequirements")]
        internal static extern void VkGetImageSparseMemoryRequirements(global::System.IntPtr device, global::System.IntPtr image, uint* pSparseMemoryRequirementCount, global::System.IntPtr pSparseMemoryRequirements);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSparseImageFormatProperties")]
        internal static extern void VkGetPhysicalDeviceSparseImageFormatProperties(global::System.IntPtr physicalDevice, global::VkFormat format, global::VkImageType type, global::VkSampleCountFlagBits samples, uint usage, global::VkImageTiling tiling, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkQueueBindSparse")]
        internal static extern global::VkResult VkQueueBindSparse(global::System.IntPtr queue, uint bindInfoCount, global::System.IntPtr pBindInfo, global::System.IntPtr fence);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateFence")]
        internal static extern global::VkResult VkCreateFence(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pFence);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyFence")]
        internal static extern void VkDestroyFence(global::System.IntPtr device, global::System.IntPtr fence, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkResetFences")]
        internal static extern global::VkResult VkResetFences(global::System.IntPtr device, uint fenceCount, global::System.IntPtr pFences);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetFenceStatus")]
        internal static extern global::VkResult VkGetFenceStatus(global::System.IntPtr device, global::System.IntPtr fence);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkWaitForFences")]
        internal static extern global::VkResult VkWaitForFences(global::System.IntPtr device, uint fenceCount, global::System.IntPtr pFences, uint waitAll, ulong timeout);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateSemaphore")]
        internal static extern global::VkResult VkCreateSemaphore(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSemaphore);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroySemaphore")]
        internal static extern void VkDestroySemaphore(global::System.IntPtr device, global::System.IntPtr semaphore, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateEvent")]
        internal static extern global::VkResult VkCreateEvent(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pEvent);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyEvent")]
        internal static extern void VkDestroyEvent(global::System.IntPtr device, global::System.IntPtr @event, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetEventStatus")]
        internal static extern global::VkResult VkGetEventStatus(global::System.IntPtr device, global::System.IntPtr @event);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkSetEvent")]
        internal static extern global::VkResult VkSetEvent(global::System.IntPtr device, global::System.IntPtr @event);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkResetEvent")]
        internal static extern global::VkResult VkResetEvent(global::System.IntPtr device, global::System.IntPtr @event);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateQueryPool")]
        internal static extern global::VkResult VkCreateQueryPool(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pQueryPool);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyQueryPool")]
        internal static extern void VkDestroyQueryPool(global::System.IntPtr device, global::System.IntPtr queryPool, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetQueryPoolResults")]
        internal static extern global::VkResult VkGetQueryPoolResults(global::System.IntPtr device, global::System.IntPtr queryPool, uint firstQuery, uint queryCount, ulong dataSize, global::System.IntPtr pData, ulong stride, uint flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateBuffer")]
        internal static extern global::VkResult VkCreateBuffer(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pBuffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyBuffer")]
        internal static extern void VkDestroyBuffer(global::System.IntPtr device, global::System.IntPtr buffer, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateBufferView")]
        internal static extern global::VkResult VkCreateBufferView(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pView);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyBufferView")]
        internal static extern void VkDestroyBufferView(global::System.IntPtr device, global::System.IntPtr bufferView, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateImage")]
        internal static extern global::VkResult VkCreateImage(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pImage);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyImage")]
        internal static extern void VkDestroyImage(global::System.IntPtr device, global::System.IntPtr image, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetImageSubresourceLayout")]
        internal static extern void VkGetImageSubresourceLayout(global::System.IntPtr device, global::System.IntPtr image, global::System.IntPtr pSubresource, global::System.IntPtr pLayout);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateImageView")]
        internal static extern global::VkResult VkCreateImageView(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pView);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyImageView")]
        internal static extern void VkDestroyImageView(global::System.IntPtr device, global::System.IntPtr imageView, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateShaderModule")]
        internal static extern global::VkResult VkCreateShaderModule(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pShaderModule);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyShaderModule")]
        internal static extern void VkDestroyShaderModule(global::System.IntPtr device, global::System.IntPtr shaderModule, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreatePipelineCache")]
        internal static extern global::VkResult VkCreatePipelineCache(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pPipelineCache);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyPipelineCache")]
        internal static extern void VkDestroyPipelineCache(global::System.IntPtr device, global::System.IntPtr pipelineCache, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPipelineCacheData")]
        internal static extern global::VkResult VkGetPipelineCacheData(global::System.IntPtr device, global::System.IntPtr pipelineCache, ulong* pDataSize, global::System.IntPtr pData);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkMergePipelineCaches")]
        internal static extern global::VkResult VkMergePipelineCaches(global::System.IntPtr device, global::System.IntPtr dstCache, uint srcCacheCount, global::System.IntPtr pSrcCaches);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateGraphicsPipelines")]
        internal static extern global::VkResult VkCreateGraphicsPipelines(global::System.IntPtr device, global::System.IntPtr pipelineCache, uint createInfoCount, global::System.IntPtr pCreateInfos, global::System.IntPtr pAllocator, global::System.IntPtr pPipelines);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateComputePipelines")]
        internal static extern global::VkResult VkCreateComputePipelines(global::System.IntPtr device, global::System.IntPtr pipelineCache, uint createInfoCount, global::System.IntPtr pCreateInfos, global::System.IntPtr pAllocator, global::System.IntPtr pPipelines);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyPipeline")]
        internal static extern void VkDestroyPipeline(global::System.IntPtr device, global::System.IntPtr pipeline, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreatePipelineLayout")]
        internal static extern global::VkResult VkCreatePipelineLayout(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pPipelineLayout);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyPipelineLayout")]
        internal static extern void VkDestroyPipelineLayout(global::System.IntPtr device, global::System.IntPtr pipelineLayout, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateSampler")]
        internal static extern global::VkResult VkCreateSampler(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSampler);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroySampler")]
        internal static extern void VkDestroySampler(global::System.IntPtr device, global::System.IntPtr sampler, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateDescriptorSetLayout")]
        internal static extern global::VkResult VkCreateDescriptorSetLayout(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSetLayout);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyDescriptorSetLayout")]
        internal static extern void VkDestroyDescriptorSetLayout(global::System.IntPtr device, global::System.IntPtr descriptorSetLayout, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateDescriptorPool")]
        internal static extern global::VkResult VkCreateDescriptorPool(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pDescriptorPool);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyDescriptorPool")]
        internal static extern void VkDestroyDescriptorPool(global::System.IntPtr device, global::System.IntPtr descriptorPool, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkResetDescriptorPool")]
        internal static extern global::VkResult VkResetDescriptorPool(global::System.IntPtr device, global::System.IntPtr descriptorPool, uint flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkAllocateDescriptorSets")]
        internal static extern global::VkResult VkAllocateDescriptorSets(global::System.IntPtr device, global::System.IntPtr pAllocateInfo, global::System.IntPtr pDescriptorSets);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkFreeDescriptorSets")]
        internal static extern global::VkResult VkFreeDescriptorSets(global::System.IntPtr device, global::System.IntPtr descriptorPool, uint descriptorSetCount, global::System.IntPtr pDescriptorSets);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkUpdateDescriptorSets")]
        internal static extern void VkUpdateDescriptorSets(global::System.IntPtr device, uint descriptorWriteCount, global::System.IntPtr pDescriptorWrites, uint descriptorCopyCount, global::System.IntPtr pDescriptorCopies);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateFramebuffer")]
        internal static extern global::VkResult VkCreateFramebuffer(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pFramebuffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyFramebuffer")]
        internal static extern void VkDestroyFramebuffer(global::System.IntPtr device, global::System.IntPtr framebuffer, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateRenderPass")]
        internal static extern global::VkResult VkCreateRenderPass(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pRenderPass);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyRenderPass")]
        internal static extern void VkDestroyRenderPass(global::System.IntPtr device, global::System.IntPtr renderPass, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetRenderAreaGranularity")]
        internal static extern void VkGetRenderAreaGranularity(global::System.IntPtr device, global::System.IntPtr renderPass, global::System.IntPtr pGranularity);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateCommandPool")]
        internal static extern global::VkResult VkCreateCommandPool(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pCommandPool);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyCommandPool")]
        internal static extern void VkDestroyCommandPool(global::System.IntPtr device, global::System.IntPtr commandPool, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkResetCommandPool")]
        internal static extern global::VkResult VkResetCommandPool(global::System.IntPtr device, global::System.IntPtr commandPool, uint flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkAllocateCommandBuffers")]
        internal static extern global::VkResult VkAllocateCommandBuffers(global::System.IntPtr device, global::System.IntPtr pAllocateInfo, global::System.IntPtr pCommandBuffers);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkFreeCommandBuffers")]
        internal static extern void VkFreeCommandBuffers(global::System.IntPtr device, global::System.IntPtr commandPool, uint commandBufferCount, global::System.IntPtr pCommandBuffers);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkBeginCommandBuffer")]
        internal static extern global::VkResult VkBeginCommandBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr pBeginInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkEndCommandBuffer")]
        internal static extern global::VkResult VkEndCommandBuffer(global::System.IntPtr commandBuffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkResetCommandBuffer")]
        internal static extern global::VkResult VkResetCommandBuffer(global::System.IntPtr commandBuffer, uint flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBindPipeline")]
        internal static extern void VkCmdBindPipeline(global::System.IntPtr commandBuffer, global::VkPipelineBindPoint pipelineBindPoint, global::System.IntPtr pipeline);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetViewport")]
        internal static extern void VkCmdSetViewport(global::System.IntPtr commandBuffer, uint firstViewport, uint viewportCount, global::System.IntPtr pViewports);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetScissor")]
        internal static extern void VkCmdSetScissor(global::System.IntPtr commandBuffer, uint firstScissor, uint scissorCount, global::System.IntPtr pScissors);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetLineWidth")]
        internal static extern void VkCmdSetLineWidth(global::System.IntPtr commandBuffer, float lineWidth);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetDepthBias")]
        internal static extern void VkCmdSetDepthBias(global::System.IntPtr commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetBlendConstants")]
        internal static extern void VkCmdSetBlendConstants(global::System.IntPtr commandBuffer, float[] blendConstants);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetDepthBounds")]
        internal static extern void VkCmdSetDepthBounds(global::System.IntPtr commandBuffer, float minDepthBounds, float maxDepthBounds);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetStencilCompareMask")]
        internal static extern void VkCmdSetStencilCompareMask(global::System.IntPtr commandBuffer, uint faceMask, uint compareMask);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetStencilWriteMask")]
        internal static extern void VkCmdSetStencilWriteMask(global::System.IntPtr commandBuffer, uint faceMask, uint writeMask);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetStencilReference")]
        internal static extern void VkCmdSetStencilReference(global::System.IntPtr commandBuffer, uint faceMask, uint reference);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBindDescriptorSets")]
        internal static extern void VkCmdBindDescriptorSets(global::System.IntPtr commandBuffer, global::VkPipelineBindPoint pipelineBindPoint, global::System.IntPtr layout, uint firstSet, uint descriptorSetCount, global::System.IntPtr pDescriptorSets, uint dynamicOffsetCount, uint* pDynamicOffsets);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBindIndexBuffer")]
        internal static extern void VkCmdBindIndexBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::VkIndexType indexType);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBindVertexBuffers")]
        internal static extern void VkCmdBindVertexBuffers(global::System.IntPtr commandBuffer, uint firstBinding, uint bindingCount, global::System.IntPtr pBuffers, ulong* pOffsets);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDraw")]
        internal static extern void VkCmdDraw(global::System.IntPtr commandBuffer, uint vertexCount, uint instanceCount, uint firstVertex, uint firstInstance);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDrawIndexed")]
        internal static extern void VkCmdDrawIndexed(global::System.IntPtr commandBuffer, uint indexCount, uint instanceCount, uint firstIndex, int vertexOffset, uint firstInstance);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDrawIndirect")]
        internal static extern void VkCmdDrawIndirect(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, uint drawCount, uint stride);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDrawIndexedIndirect")]
        internal static extern void VkCmdDrawIndexedIndirect(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, uint drawCount, uint stride);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDispatch")]
        internal static extern void VkCmdDispatch(global::System.IntPtr commandBuffer, uint groupCountX, uint groupCountY, uint groupCountZ);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDispatchIndirect")]
        internal static extern void VkCmdDispatchIndirect(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdCopyBuffer")]
        internal static extern void VkCmdCopyBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr srcBuffer, global::System.IntPtr dstBuffer, uint regionCount, global::System.IntPtr pRegions);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdCopyImage")]
        internal static extern void VkCmdCopyImage(global::System.IntPtr commandBuffer, global::System.IntPtr srcImage, global::VkImageLayout srcImageLayout, global::System.IntPtr dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::System.IntPtr pRegions);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBlitImage")]
        internal static extern void VkCmdBlitImage(global::System.IntPtr commandBuffer, global::System.IntPtr srcImage, global::VkImageLayout srcImageLayout, global::System.IntPtr dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::System.IntPtr pRegions, global::VkFilter filter);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdCopyBufferToImage")]
        internal static extern void VkCmdCopyBufferToImage(global::System.IntPtr commandBuffer, global::System.IntPtr srcBuffer, global::System.IntPtr dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::System.IntPtr pRegions);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdCopyImageToBuffer")]
        internal static extern void VkCmdCopyImageToBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr srcImage, global::VkImageLayout srcImageLayout, global::System.IntPtr dstBuffer, uint regionCount, global::System.IntPtr pRegions);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdUpdateBuffer")]
        internal static extern void VkCmdUpdateBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr dstBuffer, ulong dstOffset, ulong dataSize, global::System.IntPtr pData);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdFillBuffer")]
        internal static extern void VkCmdFillBuffer(global::System.IntPtr commandBuffer, global::System.IntPtr dstBuffer, ulong dstOffset, ulong size, uint data);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdClearColorImage")]
        internal static extern void VkCmdClearColorImage(global::System.IntPtr commandBuffer, global::System.IntPtr image, global::VkImageLayout imageLayout, global::System.IntPtr pColor, uint rangeCount, global::System.IntPtr pRanges);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdClearDepthStencilImage")]
        internal static extern void VkCmdClearDepthStencilImage(global::System.IntPtr commandBuffer, global::System.IntPtr image, global::VkImageLayout imageLayout, global::System.IntPtr pDepthStencil, uint rangeCount, global::System.IntPtr pRanges);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdClearAttachments")]
        internal static extern void VkCmdClearAttachments(global::System.IntPtr commandBuffer, uint attachmentCount, global::System.IntPtr pAttachments, uint rectCount, global::System.IntPtr pRects);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdResolveImage")]
        internal static extern void VkCmdResolveImage(global::System.IntPtr commandBuffer, global::System.IntPtr srcImage, global::VkImageLayout srcImageLayout, global::System.IntPtr dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::System.IntPtr pRegions);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetEvent")]
        internal static extern void VkCmdSetEvent(global::System.IntPtr commandBuffer, global::System.IntPtr @event, uint stageMask);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdResetEvent")]
        internal static extern void VkCmdResetEvent(global::System.IntPtr commandBuffer, global::System.IntPtr @event, uint stageMask);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdWaitEvents")]
        internal static extern void VkCmdWaitEvents(global::System.IntPtr commandBuffer, uint eventCount, global::System.IntPtr pEvents, uint srcStageMask, uint dstStageMask, uint memoryBarrierCount, global::System.IntPtr pMemoryBarriers, uint bufferMemoryBarrierCount, global::System.IntPtr pBufferMemoryBarriers, uint imageMemoryBarrierCount, global::System.IntPtr pImageMemoryBarriers);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdPipelineBarrier")]
        internal static extern void VkCmdPipelineBarrier(global::System.IntPtr commandBuffer, uint srcStageMask, uint dstStageMask, uint dependencyFlags, uint memoryBarrierCount, global::System.IntPtr pMemoryBarriers, uint bufferMemoryBarrierCount, global::System.IntPtr pBufferMemoryBarriers, uint imageMemoryBarrierCount, global::System.IntPtr pImageMemoryBarriers);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBeginQuery")]
        internal static extern void VkCmdBeginQuery(global::System.IntPtr commandBuffer, global::System.IntPtr queryPool, uint query, uint flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdEndQuery")]
        internal static extern void VkCmdEndQuery(global::System.IntPtr commandBuffer, global::System.IntPtr queryPool, uint query);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdResetQueryPool")]
        internal static extern void VkCmdResetQueryPool(global::System.IntPtr commandBuffer, global::System.IntPtr queryPool, uint firstQuery, uint queryCount);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdWriteTimestamp")]
        internal static extern void VkCmdWriteTimestamp(global::System.IntPtr commandBuffer, global::VkPipelineStageFlagBits pipelineStage, global::System.IntPtr queryPool, uint query);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdCopyQueryPoolResults")]
        internal static extern void VkCmdCopyQueryPoolResults(global::System.IntPtr commandBuffer, global::System.IntPtr queryPool, uint firstQuery, uint queryCount, global::System.IntPtr dstBuffer, ulong dstOffset, ulong stride, uint flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdPushConstants")]
        internal static extern void VkCmdPushConstants(global::System.IntPtr commandBuffer, global::System.IntPtr layout, uint stageFlags, uint offset, uint size, global::System.IntPtr pValues);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBeginRenderPass")]
        internal static extern void VkCmdBeginRenderPass(global::System.IntPtr commandBuffer, global::System.IntPtr pRenderPassBegin, global::VkSubpassContents contents);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdNextSubpass")]
        internal static extern void VkCmdNextSubpass(global::System.IntPtr commandBuffer, global::VkSubpassContents contents);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdEndRenderPass")]
        internal static extern void VkCmdEndRenderPass(global::System.IntPtr commandBuffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdExecuteCommands")]
        internal static extern void VkCmdExecuteCommands(global::System.IntPtr commandBuffer, uint commandBufferCount, global::System.IntPtr pCommandBuffers);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkEnumerateInstanceVersion")]
        internal static extern global::VkResult VkEnumerateInstanceVersion(uint* pApiVersion);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkBindBufferMemory2")]
        internal static extern global::VkResult VkBindBufferMemory2(global::System.IntPtr device, uint bindInfoCount, global::System.IntPtr pBindInfos);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkBindImageMemory2")]
        internal static extern global::VkResult VkBindImageMemory2(global::System.IntPtr device, uint bindInfoCount, global::System.IntPtr pBindInfos);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDeviceGroupPeerMemoryFeatures")]
        internal static extern void VkGetDeviceGroupPeerMemoryFeatures(global::System.IntPtr device, uint heapIndex, uint localDeviceIndex, uint remoteDeviceIndex, uint* pPeerMemoryFeatures);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetDeviceMask")]
        internal static extern void VkCmdSetDeviceMask(global::System.IntPtr commandBuffer, uint deviceMask);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDispatchBase")]
        internal static extern void VkCmdDispatchBase(global::System.IntPtr commandBuffer, uint baseGroupX, uint baseGroupY, uint baseGroupZ, uint groupCountX, uint groupCountY, uint groupCountZ);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkEnumeratePhysicalDeviceGroups")]
        internal static extern global::VkResult VkEnumeratePhysicalDeviceGroups(global::System.IntPtr instance, uint* pPhysicalDeviceGroupCount, global::System.IntPtr pPhysicalDeviceGroupProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetImageMemoryRequirements2")]
        internal static extern void VkGetImageMemoryRequirements2(global::System.IntPtr device, global::System.IntPtr pInfo, global::System.IntPtr pMemoryRequirements);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetBufferMemoryRequirements2")]
        internal static extern void VkGetBufferMemoryRequirements2(global::System.IntPtr device, global::System.IntPtr pInfo, global::System.IntPtr pMemoryRequirements);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetImageSparseMemoryRequirements2")]
        internal static extern void VkGetImageSparseMemoryRequirements2(global::System.IntPtr device, global::System.IntPtr pInfo, uint* pSparseMemoryRequirementCount, global::System.IntPtr pSparseMemoryRequirements);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceFeatures2")]
        internal static extern void VkGetPhysicalDeviceFeatures2(global::System.IntPtr physicalDevice, global::System.IntPtr pFeatures);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceProperties2")]
        internal static extern void VkGetPhysicalDeviceProperties2(global::System.IntPtr physicalDevice, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceFormatProperties2")]
        internal static extern void VkGetPhysicalDeviceFormatProperties2(global::System.IntPtr physicalDevice, global::VkFormat format, global::System.IntPtr pFormatProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceImageFormatProperties2")]
        internal static extern global::VkResult VkGetPhysicalDeviceImageFormatProperties2(global::System.IntPtr physicalDevice, global::System.IntPtr pImageFormatInfo, global::System.IntPtr pImageFormatProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceQueueFamilyProperties2")]
        internal static extern void VkGetPhysicalDeviceQueueFamilyProperties2(global::System.IntPtr physicalDevice, uint* pQueueFamilyPropertyCount, global::System.IntPtr pQueueFamilyProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceMemoryProperties2")]
        internal static extern void VkGetPhysicalDeviceMemoryProperties2(global::System.IntPtr physicalDevice, global::System.IntPtr pMemoryProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSparseImageFormatProperties2")]
        internal static extern void VkGetPhysicalDeviceSparseImageFormatProperties2(global::System.IntPtr physicalDevice, global::System.IntPtr pFormatInfo, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkTrimCommandPool")]
        internal static extern void VkTrimCommandPool(global::System.IntPtr device, global::System.IntPtr commandPool, uint flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDeviceQueue2")]
        internal static extern void VkGetDeviceQueue2(global::System.IntPtr device, global::System.IntPtr pQueueInfo, global::System.IntPtr pQueue);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateSamplerYcbcrConversion")]
        internal static extern global::VkResult VkCreateSamplerYcbcrConversion(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pYcbcrConversion);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroySamplerYcbcrConversion")]
        internal static extern void VkDestroySamplerYcbcrConversion(global::System.IntPtr device, global::System.IntPtr ycbcrConversion, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateDescriptorUpdateTemplate")]
        internal static extern global::VkResult VkCreateDescriptorUpdateTemplate(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pDescriptorUpdateTemplate);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyDescriptorUpdateTemplate")]
        internal static extern void VkDestroyDescriptorUpdateTemplate(global::System.IntPtr device, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkUpdateDescriptorSetWithTemplate")]
        internal static extern void VkUpdateDescriptorSetWithTemplate(global::System.IntPtr device, global::System.IntPtr descriptorSet, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr pData);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceExternalBufferProperties")]
        internal static extern void VkGetPhysicalDeviceExternalBufferProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalBufferInfo, global::System.IntPtr pExternalBufferProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceExternalFenceProperties")]
        internal static extern void VkGetPhysicalDeviceExternalFenceProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalFenceInfo, global::System.IntPtr pExternalFenceProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceExternalSemaphoreProperties")]
        internal static extern void VkGetPhysicalDeviceExternalSemaphoreProperties(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalSemaphoreInfo, global::System.IntPtr pExternalSemaphoreProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDescriptorSetLayoutSupport")]
        internal static extern void VkGetDescriptorSetLayoutSupport(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pSupport);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroySurfaceKHR")]
        internal static extern void VkDestroySurfaceKHR(global::System.IntPtr instance, global::System.IntPtr surface, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSurfaceSupportKHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceSurfaceSupportKHR(global::System.IntPtr physicalDevice, uint queueFamilyIndex, global::System.IntPtr surface, uint* pSupported);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSurfaceCapabilitiesKHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceSurfaceCapabilitiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr surface, global::System.IntPtr pSurfaceCapabilities);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSurfaceFormatsKHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceSurfaceFormatsKHR(global::System.IntPtr physicalDevice, global::System.IntPtr surface, uint* pSurfaceFormatCount, global::System.IntPtr pSurfaceFormats);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSurfacePresentModesKHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceSurfacePresentModesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr surface, uint* pPresentModeCount, global::VkPresentModeKHR* pPresentModes);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateSwapchainKHR")]
        internal static extern global::VkResult VkCreateSwapchainKHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSwapchain);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroySwapchainKHR")]
        internal static extern void VkDestroySwapchainKHR(global::System.IntPtr device, global::System.IntPtr swapchain, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetSwapchainImagesKHR")]
        internal static extern global::VkResult VkGetSwapchainImagesKHR(global::System.IntPtr device, global::System.IntPtr swapchain, uint* pSwapchainImageCount, global::System.IntPtr pSwapchainImages);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkAcquireNextImageKHR")]
        internal static extern global::VkResult VkAcquireNextImageKHR(global::System.IntPtr device, global::System.IntPtr swapchain, ulong timeout, global::System.IntPtr semaphore, global::System.IntPtr fence, uint* pImageIndex);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkQueuePresentKHR")]
        internal static extern global::VkResult VkQueuePresentKHR(global::System.IntPtr queue, global::System.IntPtr pPresentInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDeviceGroupPresentCapabilitiesKHR")]
        internal static extern global::VkResult VkGetDeviceGroupPresentCapabilitiesKHR(global::System.IntPtr device, global::System.IntPtr pDeviceGroupPresentCapabilities);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDeviceGroupSurfacePresentModesKHR")]
        internal static extern global::VkResult VkGetDeviceGroupSurfacePresentModesKHR(global::System.IntPtr device, global::System.IntPtr surface, uint* pModes);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDevicePresentRectanglesKHR")]
        internal static extern global::VkResult VkGetPhysicalDevicePresentRectanglesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr surface, uint* pRectCount, global::System.IntPtr pRects);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkAcquireNextImage2KHR")]
        internal static extern global::VkResult VkAcquireNextImage2KHR(global::System.IntPtr device, global::System.IntPtr pAcquireInfo, uint* pImageIndex);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceDisplayPropertiesKHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceDisplayPropertiesKHR(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceDisplayPlanePropertiesKHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceDisplayPlanePropertiesKHR(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDisplayPlaneSupportedDisplaysKHR")]
        internal static extern global::VkResult VkGetDisplayPlaneSupportedDisplaysKHR(global::System.IntPtr physicalDevice, uint planeIndex, uint* pDisplayCount, global::System.IntPtr pDisplays);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDisplayModePropertiesKHR")]
        internal static extern global::VkResult VkGetDisplayModePropertiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr display, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateDisplayModeKHR")]
        internal static extern global::VkResult VkCreateDisplayModeKHR(global::System.IntPtr physicalDevice, global::System.IntPtr display, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pMode);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDisplayPlaneCapabilitiesKHR")]
        internal static extern global::VkResult VkGetDisplayPlaneCapabilitiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr mode, uint planeIndex, global::System.IntPtr pCapabilities);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateDisplayPlaneSurfaceKHR")]
        internal static extern global::VkResult VkCreateDisplayPlaneSurfaceKHR(global::System.IntPtr instance, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pSurface);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateSharedSwapchainsKHR")]
        internal static extern global::VkResult VkCreateSharedSwapchainsKHR(global::System.IntPtr device, uint swapchainCount, global::System.IntPtr pCreateInfos, global::System.IntPtr pAllocator, global::System.IntPtr pSwapchains);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceFeatures2KHR")]
        internal static extern void VkGetPhysicalDeviceFeatures2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pFeatures);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceProperties2KHR")]
        internal static extern void VkGetPhysicalDeviceProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceFormatProperties2KHR")]
        internal static extern void VkGetPhysicalDeviceFormatProperties2KHR(global::System.IntPtr physicalDevice, global::VkFormat format, global::System.IntPtr pFormatProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceImageFormatProperties2KHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceImageFormatProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pImageFormatInfo, global::System.IntPtr pImageFormatProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceQueueFamilyProperties2KHR")]
        internal static extern void VkGetPhysicalDeviceQueueFamilyProperties2KHR(global::System.IntPtr physicalDevice, uint* pQueueFamilyPropertyCount, global::System.IntPtr pQueueFamilyProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceMemoryProperties2KHR")]
        internal static extern void VkGetPhysicalDeviceMemoryProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pMemoryProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSparseImageFormatProperties2KHR")]
        internal static extern void VkGetPhysicalDeviceSparseImageFormatProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pFormatInfo, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDeviceGroupPeerMemoryFeaturesKHR")]
        internal static extern void VkGetDeviceGroupPeerMemoryFeaturesKHR(global::System.IntPtr device, uint heapIndex, uint localDeviceIndex, uint remoteDeviceIndex, uint* pPeerMemoryFeatures);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetDeviceMaskKHR")]
        internal static extern void VkCmdSetDeviceMaskKHR(global::System.IntPtr commandBuffer, uint deviceMask);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDispatchBaseKHR")]
        internal static extern void VkCmdDispatchBaseKHR(global::System.IntPtr commandBuffer, uint baseGroupX, uint baseGroupY, uint baseGroupZ, uint groupCountX, uint groupCountY, uint groupCountZ);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkTrimCommandPoolKHR")]
        internal static extern void VkTrimCommandPoolKHR(global::System.IntPtr device, global::System.IntPtr commandPool, uint flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkEnumeratePhysicalDeviceGroupsKHR")]
        internal static extern global::VkResult VkEnumeratePhysicalDeviceGroupsKHR(global::System.IntPtr instance, uint* pPhysicalDeviceGroupCount, global::System.IntPtr pPhysicalDeviceGroupProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceExternalBufferPropertiesKHR")]
        internal static extern void VkGetPhysicalDeviceExternalBufferPropertiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalBufferInfo, global::System.IntPtr pExternalBufferProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetMemoryFdKHR")]
        internal static extern global::VkResult VkGetMemoryFdKHR(global::System.IntPtr device, global::System.IntPtr pGetFdInfo, int* pFd);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetMemoryFdPropertiesKHR")]
        internal static extern global::VkResult VkGetMemoryFdPropertiesKHR(global::System.IntPtr device, global::VkExternalMemoryHandleTypeFlagBits handleType, int fd, global::System.IntPtr pMemoryFdProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceExternalSemaphorePropertiesKHR")]
        internal static extern void VkGetPhysicalDeviceExternalSemaphorePropertiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalSemaphoreInfo, global::System.IntPtr pExternalSemaphoreProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkImportSemaphoreFdKHR")]
        internal static extern global::VkResult VkImportSemaphoreFdKHR(global::System.IntPtr device, global::System.IntPtr pImportSemaphoreFdInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetSemaphoreFdKHR")]
        internal static extern global::VkResult VkGetSemaphoreFdKHR(global::System.IntPtr device, global::System.IntPtr pGetFdInfo, int* pFd);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdPushDescriptorSetKHR")]
        internal static extern void VkCmdPushDescriptorSetKHR(global::System.IntPtr commandBuffer, global::VkPipelineBindPoint pipelineBindPoint, global::System.IntPtr layout, uint set, uint descriptorWriteCount, global::System.IntPtr pDescriptorWrites);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdPushDescriptorSetWithTemplateKHR")]
        internal static extern void VkCmdPushDescriptorSetWithTemplateKHR(global::System.IntPtr commandBuffer, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr layout, uint set, global::System.IntPtr pData);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateDescriptorUpdateTemplateKHR")]
        internal static extern global::VkResult VkCreateDescriptorUpdateTemplateKHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pDescriptorUpdateTemplate);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyDescriptorUpdateTemplateKHR")]
        internal static extern void VkDestroyDescriptorUpdateTemplateKHR(global::System.IntPtr device, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkUpdateDescriptorSetWithTemplateKHR")]
        internal static extern void VkUpdateDescriptorSetWithTemplateKHR(global::System.IntPtr device, global::System.IntPtr descriptorSet, global::System.IntPtr descriptorUpdateTemplate, global::System.IntPtr pData);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateRenderPass2KHR")]
        internal static extern global::VkResult VkCreateRenderPass2KHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pRenderPass);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBeginRenderPass2KHR")]
        internal static extern void VkCmdBeginRenderPass2KHR(global::System.IntPtr commandBuffer, global::System.IntPtr pRenderPassBegin, global::System.IntPtr pSubpassBeginInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdNextSubpass2KHR")]
        internal static extern void VkCmdNextSubpass2KHR(global::System.IntPtr commandBuffer, global::System.IntPtr pSubpassBeginInfo, global::System.IntPtr pSubpassEndInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdEndRenderPass2KHR")]
        internal static extern void VkCmdEndRenderPass2KHR(global::System.IntPtr commandBuffer, global::System.IntPtr pSubpassEndInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetSwapchainStatusKHR")]
        internal static extern global::VkResult VkGetSwapchainStatusKHR(global::System.IntPtr device, global::System.IntPtr swapchain);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceExternalFencePropertiesKHR")]
        internal static extern void VkGetPhysicalDeviceExternalFencePropertiesKHR(global::System.IntPtr physicalDevice, global::System.IntPtr pExternalFenceInfo, global::System.IntPtr pExternalFenceProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkImportFenceFdKHR")]
        internal static extern global::VkResult VkImportFenceFdKHR(global::System.IntPtr device, global::System.IntPtr pImportFenceFdInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetFenceFdKHR")]
        internal static extern global::VkResult VkGetFenceFdKHR(global::System.IntPtr device, global::System.IntPtr pGetFdInfo, int* pFd);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSurfaceCapabilities2KHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceSurfaceCapabilities2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pSurfaceInfo, global::System.IntPtr pSurfaceCapabilities);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSurfaceFormats2KHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceSurfaceFormats2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pSurfaceInfo, uint* pSurfaceFormatCount, global::System.IntPtr pSurfaceFormats);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceDisplayProperties2KHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceDisplayProperties2KHR(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceDisplayPlaneProperties2KHR")]
        internal static extern global::VkResult VkGetPhysicalDeviceDisplayPlaneProperties2KHR(global::System.IntPtr physicalDevice, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDisplayModeProperties2KHR")]
        internal static extern global::VkResult VkGetDisplayModeProperties2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr display, uint* pPropertyCount, global::System.IntPtr pProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("vulkan-1", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDisplayPlaneCapabilities2KHR")]
        internal static extern global::VkResult VkGetDisplayPlaneCapabilities2KHR(global::System.IntPtr physicalDevice, global::System.IntPtr pDisplayPlaneInfo, global::System.IntPtr pCapabilities);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetImageMemoryRequirements2KHR")]
        internal static extern void VkGetImageMemoryRequirements2KHR(global::System.IntPtr device, global::System.IntPtr pInfo, global::System.IntPtr pMemoryRequirements);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetBufferMemoryRequirements2KHR")]
        internal static extern void VkGetBufferMemoryRequirements2KHR(global::System.IntPtr device, global::System.IntPtr pInfo, global::System.IntPtr pMemoryRequirements);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetImageSparseMemoryRequirements2KHR")]
        internal static extern void VkGetImageSparseMemoryRequirements2KHR(global::System.IntPtr device, global::System.IntPtr pInfo, uint* pSparseMemoryRequirementCount, global::System.IntPtr pSparseMemoryRequirements);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateSamplerYcbcrConversionKHR")]
        internal static extern global::VkResult VkCreateSamplerYcbcrConversionKHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pYcbcrConversion);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroySamplerYcbcrConversionKHR")]
        internal static extern void VkDestroySamplerYcbcrConversionKHR(global::System.IntPtr device, global::System.IntPtr ycbcrConversion, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkBindBufferMemory2KHR")]
        internal static extern global::VkResult VkBindBufferMemory2KHR(global::System.IntPtr device, uint bindInfoCount, global::System.IntPtr pBindInfos);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkBindImageMemory2KHR")]
        internal static extern global::VkResult VkBindImageMemory2KHR(global::System.IntPtr device, uint bindInfoCount, global::System.IntPtr pBindInfos);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetDescriptorSetLayoutSupportKHR")]
        internal static extern void VkGetDescriptorSetLayoutSupportKHR(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pSupport);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDrawIndirectCountKHR")]
        internal static extern void VkCmdDrawIndirectCountKHR(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::System.IntPtr countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDrawIndexedIndirectCountKHR")]
        internal static extern void VkCmdDrawIndexedIndirectCountKHR(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::System.IntPtr countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateDebugReportCallbackEXT")]
        internal static extern global::VkResult VkCreateDebugReportCallbackEXT(global::System.IntPtr instance, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pCallback);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyDebugReportCallbackEXT")]
        internal static extern void VkDestroyDebugReportCallbackEXT(global::System.IntPtr instance, global::System.IntPtr callback, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDebugReportMessageEXT")]
        internal static extern void VkDebugReportMessageEXT(global::System.IntPtr instance, uint flags, global::VkDebugReportObjectTypeEXT objectType, ulong targetObject, ulong location, int messageCode, [MarshalAs(UnmanagedType.LPStr)] string pLayerPrefix, [MarshalAs(UnmanagedType.LPStr)] string pMessage);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDebugMarkerSetObjectTagEXT")]
        internal static extern global::VkResult VkDebugMarkerSetObjectTagEXT(global::System.IntPtr device, global::System.IntPtr pTagInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDebugMarkerSetObjectNameEXT")]
        internal static extern global::VkResult VkDebugMarkerSetObjectNameEXT(global::System.IntPtr device, global::System.IntPtr pNameInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDebugMarkerBeginEXT")]
        internal static extern void VkCmdDebugMarkerBeginEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pMarkerInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDebugMarkerEndEXT")]
        internal static extern void VkCmdDebugMarkerEndEXT(global::System.IntPtr commandBuffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDebugMarkerInsertEXT")]
        internal static extern void VkCmdDebugMarkerInsertEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pMarkerInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDrawIndirectCountAMD")]
        internal static extern void VkCmdDrawIndirectCountAMD(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::System.IntPtr countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdDrawIndexedIndirectCountAMD")]
        internal static extern void VkCmdDrawIndexedIndirectCountAMD(global::System.IntPtr commandBuffer, global::System.IntPtr buffer, ulong offset, global::System.IntPtr countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetShaderInfoAMD")]
        internal static extern global::VkResult VkGetShaderInfoAMD(global::System.IntPtr device, global::System.IntPtr pipeline, global::VkShaderStageFlagBits shaderStage, global::VkShaderInfoTypeAMD infoType, ulong* pInfoSize, global::System.IntPtr pInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceExternalImageFormatPropertiesNV")]
        internal static extern global::VkResult VkGetPhysicalDeviceExternalImageFormatPropertiesNV(global::System.IntPtr physicalDevice, global::VkFormat format, global::VkImageType type, global::VkImageTiling tiling, uint usage, uint flags, uint externalHandleType, global::System.IntPtr pExternalImageFormatProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBeginConditionalRenderingEXT")]
        internal static extern void VkCmdBeginConditionalRenderingEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pConditionalRenderingBegin);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdEndConditionalRenderingEXT")]
        internal static extern void VkCmdEndConditionalRenderingEXT(global::System.IntPtr commandBuffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdProcessCommandsNVX")]
        internal static extern void VkCmdProcessCommandsNVX(global::System.IntPtr commandBuffer, global::System.IntPtr pProcessCommandsInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdReserveSpaceForCommandsNVX")]
        internal static extern void VkCmdReserveSpaceForCommandsNVX(global::System.IntPtr commandBuffer, global::System.IntPtr pReserveSpaceInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateIndirectCommandsLayoutNVX")]
        internal static extern global::VkResult VkCreateIndirectCommandsLayoutNVX(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pIndirectCommandsLayout);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyIndirectCommandsLayoutNVX")]
        internal static extern void VkDestroyIndirectCommandsLayoutNVX(global::System.IntPtr device, global::System.IntPtr indirectCommandsLayout, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateObjectTableNVX")]
        internal static extern global::VkResult VkCreateObjectTableNVX(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pObjectTable);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyObjectTableNVX")]
        internal static extern void VkDestroyObjectTableNVX(global::System.IntPtr device, global::System.IntPtr objectTable, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkRegisterObjectsNVX")]
        internal static extern global::VkResult VkRegisterObjectsNVX(global::System.IntPtr device, global::System.IntPtr objectTable, uint objectCount, global::System.IntPtr ppObjectTableEntries, uint* pObjectIndices);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkUnregisterObjectsNVX")]
        internal static extern global::VkResult VkUnregisterObjectsNVX(global::System.IntPtr device, global::System.IntPtr objectTable, uint objectCount, global::VkObjectEntryTypeNVX* pObjectEntryTypes, uint* pObjectIndices);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX")]
        internal static extern void VkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(global::System.IntPtr physicalDevice, global::System.IntPtr pFeatures, global::System.IntPtr pLimits);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetViewportWScalingNV")]
        internal static extern void VkCmdSetViewportWScalingNV(global::System.IntPtr commandBuffer, uint firstViewport, uint viewportCount, global::System.IntPtr pViewportWScalings);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkReleaseDisplayEXT")]
        internal static extern global::VkResult VkReleaseDisplayEXT(global::System.IntPtr physicalDevice, global::System.IntPtr display);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceSurfaceCapabilities2EXT")]
        internal static extern global::VkResult VkGetPhysicalDeviceSurfaceCapabilities2EXT(global::System.IntPtr physicalDevice, global::System.IntPtr surface, global::System.IntPtr pSurfaceCapabilities);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDisplayPowerControlEXT")]
        internal static extern global::VkResult VkDisplayPowerControlEXT(global::System.IntPtr device, global::System.IntPtr display, global::System.IntPtr pDisplayPowerInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkRegisterDeviceEventEXT")]
        internal static extern global::VkResult VkRegisterDeviceEventEXT(global::System.IntPtr device, global::System.IntPtr pDeviceEventInfo, global::System.IntPtr pAllocator, global::System.IntPtr pFence);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkRegisterDisplayEventEXT")]
        internal static extern global::VkResult VkRegisterDisplayEventEXT(global::System.IntPtr device, global::System.IntPtr display, global::System.IntPtr pDisplayEventInfo, global::System.IntPtr pAllocator, global::System.IntPtr pFence);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetSwapchainCounterEXT")]
        internal static extern global::VkResult VkGetSwapchainCounterEXT(global::System.IntPtr device, global::System.IntPtr swapchain, global::VkSurfaceCounterFlagBitsEXT counter, ulong* pCounterValue);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetRefreshCycleDurationGOOGLE")]
        internal static extern global::VkResult VkGetRefreshCycleDurationGOOGLE(global::System.IntPtr device, global::System.IntPtr swapchain, global::System.IntPtr pDisplayTimingProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPastPresentationTimingGOOGLE")]
        internal static extern global::VkResult VkGetPastPresentationTimingGOOGLE(global::System.IntPtr device, global::System.IntPtr swapchain, uint* pPresentationTimingCount, global::System.IntPtr pPresentationTimings);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetDiscardRectangleEXT")]
        internal static extern void VkCmdSetDiscardRectangleEXT(global::System.IntPtr commandBuffer, uint firstDiscardRectangle, uint discardRectangleCount, global::System.IntPtr pDiscardRectangles);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkSetHdrMetadataEXT")]
        internal static extern void VkSetHdrMetadataEXT(global::System.IntPtr device, uint swapchainCount, global::System.IntPtr pSwapchains, global::System.IntPtr pMetadata);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkSetDebugUtilsObjectNameEXT")]
        internal static extern global::VkResult VkSetDebugUtilsObjectNameEXT(global::System.IntPtr device, global::System.IntPtr pNameInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkSetDebugUtilsObjectTagEXT")]
        internal static extern global::VkResult VkSetDebugUtilsObjectTagEXT(global::System.IntPtr device, global::System.IntPtr pTagInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkQueueBeginDebugUtilsLabelEXT")]
        internal static extern void VkQueueBeginDebugUtilsLabelEXT(global::System.IntPtr queue, global::System.IntPtr pLabelInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkQueueEndDebugUtilsLabelEXT")]
        internal static extern void VkQueueEndDebugUtilsLabelEXT(global::System.IntPtr queue);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkQueueInsertDebugUtilsLabelEXT")]
        internal static extern void VkQueueInsertDebugUtilsLabelEXT(global::System.IntPtr queue, global::System.IntPtr pLabelInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdBeginDebugUtilsLabelEXT")]
        internal static extern void VkCmdBeginDebugUtilsLabelEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pLabelInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdEndDebugUtilsLabelEXT")]
        internal static extern void VkCmdEndDebugUtilsLabelEXT(global::System.IntPtr commandBuffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdInsertDebugUtilsLabelEXT")]
        internal static extern void VkCmdInsertDebugUtilsLabelEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pLabelInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateDebugUtilsMessengerEXT")]
        internal static extern global::VkResult VkCreateDebugUtilsMessengerEXT(global::System.IntPtr instance, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pMessenger);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyDebugUtilsMessengerEXT")]
        internal static extern void VkDestroyDebugUtilsMessengerEXT(global::System.IntPtr instance, global::System.IntPtr messenger, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkSubmitDebugUtilsMessageEXT")]
        internal static extern void VkSubmitDebugUtilsMessageEXT(global::System.IntPtr instance, global::VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, uint messageTypes, global::System.IntPtr pCallbackData);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetSampleLocationsEXT")]
        internal static extern void VkCmdSetSampleLocationsEXT(global::System.IntPtr commandBuffer, global::System.IntPtr pSampleLocationsInfo);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetPhysicalDeviceMultisamplePropertiesEXT")]
        internal static extern void VkGetPhysicalDeviceMultisamplePropertiesEXT(global::System.IntPtr physicalDevice, global::VkSampleCountFlagBits samples, global::System.IntPtr pMultisampleProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCreateValidationCacheEXT")]
        internal static extern global::VkResult VkCreateValidationCacheEXT(global::System.IntPtr device, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pValidationCache);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkDestroyValidationCacheEXT")]
        internal static extern void VkDestroyValidationCacheEXT(global::System.IntPtr device, global::System.IntPtr validationCache, global::System.IntPtr pAllocator);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkMergeValidationCachesEXT")]
        internal static extern global::VkResult VkMergeValidationCachesEXT(global::System.IntPtr device, global::System.IntPtr dstCache, uint srcCacheCount, global::System.IntPtr pSrcCaches);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetValidationCacheDataEXT")]
        internal static extern global::VkResult VkGetValidationCacheDataEXT(global::System.IntPtr device, global::System.IntPtr validationCache, ulong* pDataSize, global::System.IntPtr pData);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetMemoryHostPointerPropertiesEXT")]
        internal static extern global::VkResult VkGetMemoryHostPointerPropertiesEXT(global::System.IntPtr device, global::VkExternalMemoryHandleTypeFlagBits handleType, global::System.IntPtr pHostPointer, global::System.IntPtr pMemoryHostPointerProperties);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdWriteBufferMarkerAMD")]
        internal static extern void VkCmdWriteBufferMarkerAMD(global::System.IntPtr commandBuffer, global::VkPipelineStageFlagBits pipelineStage, global::System.IntPtr dstBuffer, ulong dstOffset, uint marker);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkCmdSetCheckpointNV")]
        internal static extern void VkCmdSetCheckpointNV(global::System.IntPtr commandBuffer, global::System.IntPtr pCheckpointMarker);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="vkGetQueueCheckpointDataNV")]
        internal static extern void VkGetQueueCheckpointDataNV(global::System.IntPtr queue, uint* pCheckpointDataCount, global::System.IntPtr pCheckpointData);
    }

    public static global::VkResult VkCreateInstance(global::VkInstanceCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkInstanceT pInstance)
    {
        var __arg0 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg1 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg2 = ReferenceEquals(pInstance, null) ? global::System.IntPtr.Zero : pInstance.__Instance;
        var __ret = __Internal.VkCreateInstance(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static void VkDestroyInstance(global::VkInstanceT instance, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        var __arg1 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyInstance(__arg0, __arg1);
    }

    public static global::VkResult VkEnumeratePhysicalDevices(global::VkInstanceT instance, ref uint pPhysicalDeviceCount, global::VkPhysicalDeviceT pPhysicalDevices)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        fixed (uint* __refParamPtr1 = &pPhysicalDeviceCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pPhysicalDevices, null) ? global::System.IntPtr.Zero : pPhysicalDevices.__Instance;
            var __ret = __Internal.VkEnumeratePhysicalDevices(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static void VkGetPhysicalDeviceFeatures(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceFeatures pFeatures)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pFeatures, null) ? global::System.IntPtr.Zero : pFeatures.__Instance;
        __Internal.VkGetPhysicalDeviceFeatures(__arg0, __arg1);
    }

    public static void VkGetPhysicalDeviceFormatProperties(global::VkPhysicalDeviceT physicalDevice, global::VkFormat format, global::VkFormatProperties pFormatProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg2 = ReferenceEquals(pFormatProperties, null) ? global::System.IntPtr.Zero : pFormatProperties.__Instance;
        __Internal.VkGetPhysicalDeviceFormatProperties(__arg0, format, __arg2);
    }

    public static global::VkResult VkGetPhysicalDeviceImageFormatProperties(global::VkPhysicalDeviceT physicalDevice, global::VkFormat format, global::VkImageType type, global::VkImageTiling tiling, uint usage, uint flags, global::VkImageFormatProperties pImageFormatProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg6 = ReferenceEquals(pImageFormatProperties, null) ? global::System.IntPtr.Zero : pImageFormatProperties.__Instance;
        var __ret = __Internal.VkGetPhysicalDeviceImageFormatProperties(__arg0, format, type, tiling, usage, flags, __arg6);
        return __ret;
    }

    public static void VkGetPhysicalDeviceProperties(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceProperties pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
        __Internal.VkGetPhysicalDeviceProperties(__arg0, __arg1);
    }

    public static void VkGetPhysicalDeviceQueueFamilyProperties(global::VkPhysicalDeviceT physicalDevice, ref uint pQueueFamilyPropertyCount, global::VkQueueFamilyProperties pQueueFamilyProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr1 = &pQueueFamilyPropertyCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pQueueFamilyProperties, null) ? global::System.IntPtr.Zero : pQueueFamilyProperties.__Instance;
            __Internal.VkGetPhysicalDeviceQueueFamilyProperties(__arg0, __arg1, __arg2);
        }
    }

    public static void VkGetPhysicalDeviceMemoryProperties(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceMemoryProperties pMemoryProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pMemoryProperties, null) ? global::System.IntPtr.Zero : pMemoryProperties.__Instance;
        __Internal.VkGetPhysicalDeviceMemoryProperties(__arg0, __arg1);
    }

    public static global::PFN_vkVoidFunction VkGetInstanceProcAddr(global::VkInstanceT instance, string pName)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        var __ret = __Internal.VkGetInstanceProcAddr(__arg0, pName);
        var __ptr0 = __ret;
        return __ptr0 == IntPtr.Zero? null : (global::PFN_vkVoidFunction) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PFN_vkVoidFunction));
    }

    public static global::PFN_vkVoidFunction VkGetDeviceProcAddr(global::VkDeviceT device, string pName)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __ret = __Internal.VkGetDeviceProcAddr(__arg0, pName);
        var __ptr0 = __ret;
        return __ptr0 == IntPtr.Zero? null : (global::PFN_vkVoidFunction) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PFN_vkVoidFunction));
    }

    public static global::VkResult VkCreateDevice(global::VkPhysicalDeviceT physicalDevice, global::VkDeviceCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkDeviceT pDevice)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pDevice, null) ? global::System.IntPtr.Zero : pDevice.__Instance;
        var __ret = __Internal.VkCreateDevice(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyDevice(global::VkDeviceT device, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyDevice(__arg0, __arg1);
    }

    public static global::VkResult VkEnumerateInstanceExtensionProperties(string pLayerName, ref uint pPropertyCount, global::VkExtensionProperties pProperties)
    {
        fixed (uint* __refParamPtr1 = &pPropertyCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkEnumerateInstanceExtensionProperties(pLayerName, __arg1, __arg2);
            return __ret;
        }
    }

    public static global::VkResult VkEnumerateDeviceExtensionProperties(global::VkPhysicalDeviceT physicalDevice, string pLayerName, ref uint pPropertyCount, global::VkExtensionProperties pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr2 = &pPropertyCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkEnumerateDeviceExtensionProperties(__arg0, pLayerName, __arg2, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkEnumerateInstanceLayerProperties(ref uint pPropertyCount, global::VkLayerProperties pProperties)
    {
        fixed (uint* __refParamPtr0 = &pPropertyCount)
        {
            var __arg0 = __refParamPtr0;
            var __arg1 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkEnumerateInstanceLayerProperties(__arg0, __arg1);
            return __ret;
        }
    }

    public static global::VkResult VkEnumerateDeviceLayerProperties(global::VkPhysicalDeviceT physicalDevice, ref uint pPropertyCount, global::VkLayerProperties pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr1 = &pPropertyCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkEnumerateDeviceLayerProperties(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static void VkGetDeviceQueue(global::VkDeviceT device, uint queueFamilyIndex, uint queueIndex, global::VkQueueT pQueue)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg3 = ReferenceEquals(pQueue, null) ? global::System.IntPtr.Zero : pQueue.__Instance;
        __Internal.VkGetDeviceQueue(__arg0, queueFamilyIndex, queueIndex, __arg3);
    }

    public static global::VkResult VkQueueSubmit(global::VkQueueT queue, uint submitCount, global::VkSubmitInfo pSubmits, global::VkFenceT fence)
    {
        var __arg0 = ReferenceEquals(queue, null) ? global::System.IntPtr.Zero : queue.__Instance;
        var __arg2 = ReferenceEquals(pSubmits, null) ? global::System.IntPtr.Zero : pSubmits.__Instance;
        var __arg3 = ReferenceEquals(fence, null) ? global::System.IntPtr.Zero : fence.__Instance;
        var __ret = __Internal.VkQueueSubmit(__arg0, submitCount, __arg2, __arg3);
        return __ret;
    }

    public static global::VkResult VkQueueWaitIdle(global::VkQueueT queue)
    {
        var __arg0 = ReferenceEquals(queue, null) ? global::System.IntPtr.Zero : queue.__Instance;
        var __ret = __Internal.VkQueueWaitIdle(__arg0);
        return __ret;
    }

    public static global::VkResult VkDeviceWaitIdle(global::VkDeviceT device)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __ret = __Internal.VkDeviceWaitIdle(__arg0);
        return __ret;
    }

    public static global::VkResult VkAllocateMemory(global::VkDeviceT device, global::VkMemoryAllocateInfo pAllocateInfo, global::VkAllocationCallbacks pAllocator, global::VkDeviceMemoryT pMemory)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pAllocateInfo, null) ? global::System.IntPtr.Zero : pAllocateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pMemory, null) ? global::System.IntPtr.Zero : pMemory.__Instance;
        var __ret = __Internal.VkAllocateMemory(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkFreeMemory(global::VkDeviceT device, global::VkDeviceMemoryT memory, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(memory, null) ? global::System.IntPtr.Zero : memory.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkFreeMemory(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkMapMemory(global::VkDeviceT device, global::VkDeviceMemoryT memory, ulong offset, ulong size, uint flags, void** ppData)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(memory, null) ? global::System.IntPtr.Zero : memory.__Instance;
        var __ret = __Internal.VkMapMemory(__arg0, __arg1, offset, size, flags, ppData);
        return __ret;
    }

    public static void VkUnmapMemory(global::VkDeviceT device, global::VkDeviceMemoryT memory)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(memory, null) ? global::System.IntPtr.Zero : memory.__Instance;
        __Internal.VkUnmapMemory(__arg0, __arg1);
    }

    public static global::VkResult VkFlushMappedMemoryRanges(global::VkDeviceT device, uint memoryRangeCount, global::VkMappedMemoryRange pMemoryRanges)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pMemoryRanges, null) ? global::System.IntPtr.Zero : pMemoryRanges.__Instance;
        var __ret = __Internal.VkFlushMappedMemoryRanges(__arg0, memoryRangeCount, __arg2);
        return __ret;
    }

    public static global::VkResult VkInvalidateMappedMemoryRanges(global::VkDeviceT device, uint memoryRangeCount, global::VkMappedMemoryRange pMemoryRanges)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pMemoryRanges, null) ? global::System.IntPtr.Zero : pMemoryRanges.__Instance;
        var __ret = __Internal.VkInvalidateMappedMemoryRanges(__arg0, memoryRangeCount, __arg2);
        return __ret;
    }

    public static void VkGetDeviceMemoryCommitment(global::VkDeviceT device, global::VkDeviceMemoryT memory, ref ulong pCommittedMemoryInBytes)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(memory, null) ? global::System.IntPtr.Zero : memory.__Instance;
        fixed (ulong* __refParamPtr2 = &pCommittedMemoryInBytes)
        {
            var __arg2 = __refParamPtr2;
            __Internal.VkGetDeviceMemoryCommitment(__arg0, __arg1, __arg2);
        }
    }

    public static global::VkResult VkBindBufferMemory(global::VkDeviceT device, global::VkBufferT buffer, global::VkDeviceMemoryT memory, ulong memoryOffset)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        var __arg2 = ReferenceEquals(memory, null) ? global::System.IntPtr.Zero : memory.__Instance;
        var __ret = __Internal.VkBindBufferMemory(__arg0, __arg1, __arg2, memoryOffset);
        return __ret;
    }

    public static global::VkResult VkBindImageMemory(global::VkDeviceT device, global::VkImageT image, global::VkDeviceMemoryT memory, ulong memoryOffset)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
        var __arg2 = ReferenceEquals(memory, null) ? global::System.IntPtr.Zero : memory.__Instance;
        var __ret = __Internal.VkBindImageMemory(__arg0, __arg1, __arg2, memoryOffset);
        return __ret;
    }

    public static void VkGetBufferMemoryRequirements(global::VkDeviceT device, global::VkBufferT buffer, global::VkMemoryRequirements pMemoryRequirements)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        var __arg2 = ReferenceEquals(pMemoryRequirements, null) ? global::System.IntPtr.Zero : pMemoryRequirements.__Instance;
        __Internal.VkGetBufferMemoryRequirements(__arg0, __arg1, __arg2);
    }

    public static void VkGetImageMemoryRequirements(global::VkDeviceT device, global::VkImageT image, global::VkMemoryRequirements pMemoryRequirements)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
        var __arg2 = ReferenceEquals(pMemoryRequirements, null) ? global::System.IntPtr.Zero : pMemoryRequirements.__Instance;
        __Internal.VkGetImageMemoryRequirements(__arg0, __arg1, __arg2);
    }

    public static void VkGetImageSparseMemoryRequirements(global::VkDeviceT device, global::VkImageT image, ref uint pSparseMemoryRequirementCount, global::VkSparseImageMemoryRequirements pSparseMemoryRequirements)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
        fixed (uint* __refParamPtr2 = &pSparseMemoryRequirementCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pSparseMemoryRequirements, null) ? global::System.IntPtr.Zero : pSparseMemoryRequirements.__Instance;
            __Internal.VkGetImageSparseMemoryRequirements(__arg0, __arg1, __arg2, __arg3);
        }
    }

    public static void VkGetPhysicalDeviceSparseImageFormatProperties(global::VkPhysicalDeviceT physicalDevice, global::VkFormat format, global::VkImageType type, global::VkSampleCountFlagBits samples, uint usage, global::VkImageTiling tiling, ref uint pPropertyCount, global::VkSparseImageFormatProperties pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr6 = &pPropertyCount)
        {
            var __arg6 = __refParamPtr6;
            var __arg7 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            __Internal.VkGetPhysicalDeviceSparseImageFormatProperties(__arg0, format, type, samples, usage, tiling, __arg6, __arg7);
        }
    }

    public static global::VkResult VkQueueBindSparse(global::VkQueueT queue, uint bindInfoCount, global::VkBindSparseInfo pBindInfo, global::VkFenceT fence)
    {
        var __arg0 = ReferenceEquals(queue, null) ? global::System.IntPtr.Zero : queue.__Instance;
        var __arg2 = ReferenceEquals(pBindInfo, null) ? global::System.IntPtr.Zero : pBindInfo.__Instance;
        var __arg3 = ReferenceEquals(fence, null) ? global::System.IntPtr.Zero : fence.__Instance;
        var __ret = __Internal.VkQueueBindSparse(__arg0, bindInfoCount, __arg2, __arg3);
        return __ret;
    }

    public static global::VkResult VkCreateFence(global::VkDeviceT device, global::VkFenceCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkFenceT pFence)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pFence, null) ? global::System.IntPtr.Zero : pFence.__Instance;
        var __ret = __Internal.VkCreateFence(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyFence(global::VkDeviceT device, global::VkFenceT fence, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(fence, null) ? global::System.IntPtr.Zero : fence.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyFence(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkResetFences(global::VkDeviceT device, uint fenceCount, global::VkFenceT pFences)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pFences, null) ? global::System.IntPtr.Zero : pFences.__Instance;
        var __ret = __Internal.VkResetFences(__arg0, fenceCount, __arg2);
        return __ret;
    }

    public static global::VkResult VkGetFenceStatus(global::VkDeviceT device, global::VkFenceT fence)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(fence, null) ? global::System.IntPtr.Zero : fence.__Instance;
        var __ret = __Internal.VkGetFenceStatus(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkWaitForFences(global::VkDeviceT device, uint fenceCount, global::VkFenceT pFences, uint waitAll, ulong timeout)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pFences, null) ? global::System.IntPtr.Zero : pFences.__Instance;
        var __ret = __Internal.VkWaitForFences(__arg0, fenceCount, __arg2, waitAll, timeout);
        return __ret;
    }

    public static global::VkResult VkCreateSemaphore(global::VkDeviceT device, global::VkSemaphoreCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkSemaphoreT pSemaphore)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pSemaphore, null) ? global::System.IntPtr.Zero : pSemaphore.__Instance;
        var __ret = __Internal.VkCreateSemaphore(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroySemaphore(global::VkDeviceT device, global::VkSemaphoreT semaphore, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(semaphore, null) ? global::System.IntPtr.Zero : semaphore.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroySemaphore(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateEvent(global::VkDeviceT device, global::VkEventCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkEventT pEvent)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pEvent, null) ? global::System.IntPtr.Zero : pEvent.__Instance;
        var __ret = __Internal.VkCreateEvent(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyEvent(global::VkDeviceT device, global::VkEventT @event, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyEvent(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkGetEventStatus(global::VkDeviceT device, global::VkEventT @event)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
        var __ret = __Internal.VkGetEventStatus(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkSetEvent(global::VkDeviceT device, global::VkEventT @event)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
        var __ret = __Internal.VkSetEvent(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkResetEvent(global::VkDeviceT device, global::VkEventT @event)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
        var __ret = __Internal.VkResetEvent(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkCreateQueryPool(global::VkDeviceT device, global::VkQueryPoolCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkQueryPoolT pQueryPool)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pQueryPool, null) ? global::System.IntPtr.Zero : pQueryPool.__Instance;
        var __ret = __Internal.VkCreateQueryPool(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyQueryPool(global::VkDeviceT device, global::VkQueryPoolT queryPool, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(queryPool, null) ? global::System.IntPtr.Zero : queryPool.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyQueryPool(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkGetQueryPoolResults(global::VkDeviceT device, global::VkQueryPoolT queryPool, uint firstQuery, uint queryCount, ulong dataSize, global::System.IntPtr pData, ulong stride, uint flags)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(queryPool, null) ? global::System.IntPtr.Zero : queryPool.__Instance;
        var __ret = __Internal.VkGetQueryPoolResults(__arg0, __arg1, firstQuery, queryCount, dataSize, pData, stride, flags);
        return __ret;
    }

    public static global::VkResult VkCreateBuffer(global::VkDeviceT device, global::VkBufferCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkBufferT pBuffer)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pBuffer, null) ? global::System.IntPtr.Zero : pBuffer.__Instance;
        var __ret = __Internal.VkCreateBuffer(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyBuffer(global::VkDeviceT device, global::VkBufferT buffer, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyBuffer(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateBufferView(global::VkDeviceT device, global::VkBufferViewCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkBufferViewT pView)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pView, null) ? global::System.IntPtr.Zero : pView.__Instance;
        var __ret = __Internal.VkCreateBufferView(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyBufferView(global::VkDeviceT device, global::VkBufferViewT bufferView, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(bufferView, null) ? global::System.IntPtr.Zero : bufferView.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyBufferView(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateImage(global::VkDeviceT device, global::VkImageCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkImageT pImage)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pImage, null) ? global::System.IntPtr.Zero : pImage.__Instance;
        var __ret = __Internal.VkCreateImage(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyImage(global::VkDeviceT device, global::VkImageT image, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyImage(__arg0, __arg1, __arg2);
    }

    public static void VkGetImageSubresourceLayout(global::VkDeviceT device, global::VkImageT image, global::VkImageSubresource pSubresource, global::VkSubresourceLayout pLayout)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
        var __arg2 = ReferenceEquals(pSubresource, null) ? global::System.IntPtr.Zero : pSubresource.__Instance;
        var __arg3 = ReferenceEquals(pLayout, null) ? global::System.IntPtr.Zero : pLayout.__Instance;
        __Internal.VkGetImageSubresourceLayout(__arg0, __arg1, __arg2, __arg3);
    }

    public static global::VkResult VkCreateImageView(global::VkDeviceT device, global::VkImageViewCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkImageViewT pView)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pView, null) ? global::System.IntPtr.Zero : pView.__Instance;
        var __ret = __Internal.VkCreateImageView(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyImageView(global::VkDeviceT device, global::VkImageViewT imageView, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(imageView, null) ? global::System.IntPtr.Zero : imageView.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyImageView(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateShaderModule(global::VkDeviceT device, global::VkShaderModuleCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkShaderModuleT pShaderModule)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pShaderModule, null) ? global::System.IntPtr.Zero : pShaderModule.__Instance;
        var __ret = __Internal.VkCreateShaderModule(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyShaderModule(global::VkDeviceT device, global::VkShaderModuleT shaderModule, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(shaderModule, null) ? global::System.IntPtr.Zero : shaderModule.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyShaderModule(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreatePipelineCache(global::VkDeviceT device, global::VkPipelineCacheCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkPipelineCacheT pPipelineCache)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pPipelineCache, null) ? global::System.IntPtr.Zero : pPipelineCache.__Instance;
        var __ret = __Internal.VkCreatePipelineCache(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyPipelineCache(global::VkDeviceT device, global::VkPipelineCacheT pipelineCache, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pipelineCache, null) ? global::System.IntPtr.Zero : pipelineCache.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyPipelineCache(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkGetPipelineCacheData(global::VkDeviceT device, global::VkPipelineCacheT pipelineCache, ref ulong pDataSize, global::System.IntPtr pData)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pipelineCache, null) ? global::System.IntPtr.Zero : pipelineCache.__Instance;
        fixed (ulong* __refParamPtr2 = &pDataSize)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.VkGetPipelineCacheData(__arg0, __arg1, __arg2, pData);
            return __ret;
        }
    }

    public static global::VkResult VkMergePipelineCaches(global::VkDeviceT device, global::VkPipelineCacheT dstCache, uint srcCacheCount, global::VkPipelineCacheT pSrcCaches)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(dstCache, null) ? global::System.IntPtr.Zero : dstCache.__Instance;
        var __arg3 = ReferenceEquals(pSrcCaches, null) ? global::System.IntPtr.Zero : pSrcCaches.__Instance;
        var __ret = __Internal.VkMergePipelineCaches(__arg0, __arg1, srcCacheCount, __arg3);
        return __ret;
    }

    public static global::VkResult VkCreateGraphicsPipelines(global::VkDeviceT device, global::VkPipelineCacheT pipelineCache, uint createInfoCount, global::VkGraphicsPipelineCreateInfo pCreateInfos, global::VkAllocationCallbacks pAllocator, global::VkPipelineT pPipelines)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pipelineCache, null) ? global::System.IntPtr.Zero : pipelineCache.__Instance;
        var __arg3 = ReferenceEquals(pCreateInfos, null) ? global::System.IntPtr.Zero : pCreateInfos.__Instance;
        var __arg4 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg5 = ReferenceEquals(pPipelines, null) ? global::System.IntPtr.Zero : pPipelines.__Instance;
        var __ret = __Internal.VkCreateGraphicsPipelines(__arg0, __arg1, createInfoCount, __arg3, __arg4, __arg5);
        return __ret;
    }

    public static global::VkResult VkCreateComputePipelines(global::VkDeviceT device, global::VkPipelineCacheT pipelineCache, uint createInfoCount, global::VkComputePipelineCreateInfo pCreateInfos, global::VkAllocationCallbacks pAllocator, global::VkPipelineT pPipelines)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pipelineCache, null) ? global::System.IntPtr.Zero : pipelineCache.__Instance;
        var __arg3 = ReferenceEquals(pCreateInfos, null) ? global::System.IntPtr.Zero : pCreateInfos.__Instance;
        var __arg4 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg5 = ReferenceEquals(pPipelines, null) ? global::System.IntPtr.Zero : pPipelines.__Instance;
        var __ret = __Internal.VkCreateComputePipelines(__arg0, __arg1, createInfoCount, __arg3, __arg4, __arg5);
        return __ret;
    }

    public static void VkDestroyPipeline(global::VkDeviceT device, global::VkPipelineT pipeline, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pipeline, null) ? global::System.IntPtr.Zero : pipeline.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyPipeline(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreatePipelineLayout(global::VkDeviceT device, global::VkPipelineLayoutCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkPipelineLayoutT pPipelineLayout)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pPipelineLayout, null) ? global::System.IntPtr.Zero : pPipelineLayout.__Instance;
        var __ret = __Internal.VkCreatePipelineLayout(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyPipelineLayout(global::VkDeviceT device, global::VkPipelineLayoutT pipelineLayout, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pipelineLayout, null) ? global::System.IntPtr.Zero : pipelineLayout.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyPipelineLayout(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateSampler(global::VkDeviceT device, global::VkSamplerCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkSamplerT pSampler)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pSampler, null) ? global::System.IntPtr.Zero : pSampler.__Instance;
        var __ret = __Internal.VkCreateSampler(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroySampler(global::VkDeviceT device, global::VkSamplerT sampler, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(sampler, null) ? global::System.IntPtr.Zero : sampler.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroySampler(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateDescriptorSetLayout(global::VkDeviceT device, global::VkDescriptorSetLayoutCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkDescriptorSetLayoutT pSetLayout)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pSetLayout, null) ? global::System.IntPtr.Zero : pSetLayout.__Instance;
        var __ret = __Internal.VkCreateDescriptorSetLayout(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyDescriptorSetLayout(global::VkDeviceT device, global::VkDescriptorSetLayoutT descriptorSetLayout, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(descriptorSetLayout, null) ? global::System.IntPtr.Zero : descriptorSetLayout.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyDescriptorSetLayout(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateDescriptorPool(global::VkDeviceT device, global::VkDescriptorPoolCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkDescriptorPoolT pDescriptorPool)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pDescriptorPool, null) ? global::System.IntPtr.Zero : pDescriptorPool.__Instance;
        var __ret = __Internal.VkCreateDescriptorPool(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyDescriptorPool(global::VkDeviceT device, global::VkDescriptorPoolT descriptorPool, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(descriptorPool, null) ? global::System.IntPtr.Zero : descriptorPool.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyDescriptorPool(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkResetDescriptorPool(global::VkDeviceT device, global::VkDescriptorPoolT descriptorPool, uint flags)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(descriptorPool, null) ? global::System.IntPtr.Zero : descriptorPool.__Instance;
        var __ret = __Internal.VkResetDescriptorPool(__arg0, __arg1, flags);
        return __ret;
    }

    public static global::VkResult VkAllocateDescriptorSets(global::VkDeviceT device, global::VkDescriptorSetAllocateInfo pAllocateInfo, global::VkDescriptorSetT pDescriptorSets)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pAllocateInfo, null) ? global::System.IntPtr.Zero : pAllocateInfo.__Instance;
        var __arg2 = ReferenceEquals(pDescriptorSets, null) ? global::System.IntPtr.Zero : pDescriptorSets.__Instance;
        var __ret = __Internal.VkAllocateDescriptorSets(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static global::VkResult VkFreeDescriptorSets(global::VkDeviceT device, global::VkDescriptorPoolT descriptorPool, uint descriptorSetCount, global::VkDescriptorSetT pDescriptorSets)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(descriptorPool, null) ? global::System.IntPtr.Zero : descriptorPool.__Instance;
        var __arg3 = ReferenceEquals(pDescriptorSets, null) ? global::System.IntPtr.Zero : pDescriptorSets.__Instance;
        var __ret = __Internal.VkFreeDescriptorSets(__arg0, __arg1, descriptorSetCount, __arg3);
        return __ret;
    }

    public static void VkUpdateDescriptorSets(global::VkDeviceT device, uint descriptorWriteCount, global::VkWriteDescriptorSet pDescriptorWrites, uint descriptorCopyCount, global::VkCopyDescriptorSet pDescriptorCopies)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pDescriptorWrites, null) ? global::System.IntPtr.Zero : pDescriptorWrites.__Instance;
        var __arg4 = ReferenceEquals(pDescriptorCopies, null) ? global::System.IntPtr.Zero : pDescriptorCopies.__Instance;
        __Internal.VkUpdateDescriptorSets(__arg0, descriptorWriteCount, __arg2, descriptorCopyCount, __arg4);
    }

    public static global::VkResult VkCreateFramebuffer(global::VkDeviceT device, global::VkFramebufferCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkFramebufferT pFramebuffer)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pFramebuffer, null) ? global::System.IntPtr.Zero : pFramebuffer.__Instance;
        var __ret = __Internal.VkCreateFramebuffer(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyFramebuffer(global::VkDeviceT device, global::VkFramebufferT framebuffer, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(framebuffer, null) ? global::System.IntPtr.Zero : framebuffer.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyFramebuffer(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateRenderPass(global::VkDeviceT device, global::VkRenderPassCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkRenderPassT pRenderPass)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pRenderPass, null) ? global::System.IntPtr.Zero : pRenderPass.__Instance;
        var __ret = __Internal.VkCreateRenderPass(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyRenderPass(global::VkDeviceT device, global::VkRenderPassT renderPass, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(renderPass, null) ? global::System.IntPtr.Zero : renderPass.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyRenderPass(__arg0, __arg1, __arg2);
    }

    public static void VkGetRenderAreaGranularity(global::VkDeviceT device, global::VkRenderPassT renderPass, global::VkExtent2D pGranularity)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(renderPass, null) ? global::System.IntPtr.Zero : renderPass.__Instance;
        var __arg2 = ReferenceEquals(pGranularity, null) ? global::System.IntPtr.Zero : pGranularity.__Instance;
        __Internal.VkGetRenderAreaGranularity(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateCommandPool(global::VkDeviceT device, global::VkCommandPoolCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkCommandPoolT pCommandPool)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pCommandPool, null) ? global::System.IntPtr.Zero : pCommandPool.__Instance;
        var __ret = __Internal.VkCreateCommandPool(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyCommandPool(global::VkDeviceT device, global::VkCommandPoolT commandPool, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(commandPool, null) ? global::System.IntPtr.Zero : commandPool.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyCommandPool(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkResetCommandPool(global::VkDeviceT device, global::VkCommandPoolT commandPool, uint flags)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(commandPool, null) ? global::System.IntPtr.Zero : commandPool.__Instance;
        var __ret = __Internal.VkResetCommandPool(__arg0, __arg1, flags);
        return __ret;
    }

    public static global::VkResult VkAllocateCommandBuffers(global::VkDeviceT device, global::VkCommandBufferAllocateInfo pAllocateInfo, global::VkCommandBufferT pCommandBuffers)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pAllocateInfo, null) ? global::System.IntPtr.Zero : pAllocateInfo.__Instance;
        var __arg2 = ReferenceEquals(pCommandBuffers, null) ? global::System.IntPtr.Zero : pCommandBuffers.__Instance;
        var __ret = __Internal.VkAllocateCommandBuffers(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static void VkFreeCommandBuffers(global::VkDeviceT device, global::VkCommandPoolT commandPool, uint commandBufferCount, global::VkCommandBufferT pCommandBuffers)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(commandPool, null) ? global::System.IntPtr.Zero : commandPool.__Instance;
        var __arg3 = ReferenceEquals(pCommandBuffers, null) ? global::System.IntPtr.Zero : pCommandBuffers.__Instance;
        __Internal.VkFreeCommandBuffers(__arg0, __arg1, commandBufferCount, __arg3);
    }

    public static global::VkResult VkBeginCommandBuffer(global::VkCommandBufferT commandBuffer, global::VkCommandBufferBeginInfo pBeginInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pBeginInfo, null) ? global::System.IntPtr.Zero : pBeginInfo.__Instance;
        var __ret = __Internal.VkBeginCommandBuffer(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkEndCommandBuffer(global::VkCommandBufferT commandBuffer)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __ret = __Internal.VkEndCommandBuffer(__arg0);
        return __ret;
    }

    public static global::VkResult VkResetCommandBuffer(global::VkCommandBufferT commandBuffer, uint flags)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __ret = __Internal.VkResetCommandBuffer(__arg0, flags);
        return __ret;
    }

    public static void VkCmdBindPipeline(global::VkCommandBufferT commandBuffer, global::VkPipelineBindPoint pipelineBindPoint, global::VkPipelineT pipeline)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg2 = ReferenceEquals(pipeline, null) ? global::System.IntPtr.Zero : pipeline.__Instance;
        __Internal.VkCmdBindPipeline(__arg0, pipelineBindPoint, __arg2);
    }

    public static void VkCmdSetViewport(global::VkCommandBufferT commandBuffer, uint firstViewport, uint viewportCount, global::VkViewport pViewports)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg3 = ReferenceEquals(pViewports, null) ? global::System.IntPtr.Zero : pViewports.__Instance;
        __Internal.VkCmdSetViewport(__arg0, firstViewport, viewportCount, __arg3);
    }

    public static void VkCmdSetScissor(global::VkCommandBufferT commandBuffer, uint firstScissor, uint scissorCount, global::VkRect2D pScissors)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg3 = ReferenceEquals(pScissors, null) ? global::System.IntPtr.Zero : pScissors.__Instance;
        __Internal.VkCmdSetScissor(__arg0, firstScissor, scissorCount, __arg3);
    }

    public static void VkCmdSetLineWidth(global::VkCommandBufferT commandBuffer, float lineWidth)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdSetLineWidth(__arg0, lineWidth);
    }

    public static void VkCmdSetDepthBias(global::VkCommandBufferT commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdSetDepthBias(__arg0, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
    }

    public static void VkCmdSetBlendConstants(global::VkCommandBufferT commandBuffer, float[] blendConstants)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        if (blendConstants == null || blendConstants.Length != 4)
            throw new ArgumentOutOfRangeException("blendConstants", "The dimensions of the provided array don't match the required size.");
        __Internal.VkCmdSetBlendConstants(__arg0, blendConstants);
    }

    public static void VkCmdSetDepthBounds(global::VkCommandBufferT commandBuffer, float minDepthBounds, float maxDepthBounds)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdSetDepthBounds(__arg0, minDepthBounds, maxDepthBounds);
    }

    public static void VkCmdSetStencilCompareMask(global::VkCommandBufferT commandBuffer, uint faceMask, uint compareMask)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdSetStencilCompareMask(__arg0, faceMask, compareMask);
    }

    public static void VkCmdSetStencilWriteMask(global::VkCommandBufferT commandBuffer, uint faceMask, uint writeMask)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdSetStencilWriteMask(__arg0, faceMask, writeMask);
    }

    public static void VkCmdSetStencilReference(global::VkCommandBufferT commandBuffer, uint faceMask, uint reference)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdSetStencilReference(__arg0, faceMask, reference);
    }

    public static void VkCmdBindDescriptorSets(global::VkCommandBufferT commandBuffer, global::VkPipelineBindPoint pipelineBindPoint, global::VkPipelineLayoutT layout, uint firstSet, uint descriptorSetCount, global::VkDescriptorSetT pDescriptorSets, uint dynamicOffsetCount, ref uint pDynamicOffsets)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg2 = ReferenceEquals(layout, null) ? global::System.IntPtr.Zero : layout.__Instance;
        var __arg5 = ReferenceEquals(pDescriptorSets, null) ? global::System.IntPtr.Zero : pDescriptorSets.__Instance;
        fixed (uint* __refParamPtr7 = &pDynamicOffsets)
        {
            var __arg7 = __refParamPtr7;
            __Internal.VkCmdBindDescriptorSets(__arg0, pipelineBindPoint, __arg2, firstSet, descriptorSetCount, __arg5, dynamicOffsetCount, __arg7);
        }
    }

    public static void VkCmdBindIndexBuffer(global::VkCommandBufferT commandBuffer, global::VkBufferT buffer, ulong offset, global::VkIndexType indexType)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        __Internal.VkCmdBindIndexBuffer(__arg0, __arg1, offset, indexType);
    }

    public static void VkCmdBindVertexBuffers(global::VkCommandBufferT commandBuffer, uint firstBinding, uint bindingCount, global::VkBufferT pBuffers, ref ulong pOffsets)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg3 = ReferenceEquals(pBuffers, null) ? global::System.IntPtr.Zero : pBuffers.__Instance;
        fixed (ulong* __refParamPtr4 = &pOffsets)
        {
            var __arg4 = __refParamPtr4;
            __Internal.VkCmdBindVertexBuffers(__arg0, firstBinding, bindingCount, __arg3, __arg4);
        }
    }

    public static void VkCmdDraw(global::VkCommandBufferT commandBuffer, uint vertexCount, uint instanceCount, uint firstVertex, uint firstInstance)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdDraw(__arg0, vertexCount, instanceCount, firstVertex, firstInstance);
    }

    public static void VkCmdDrawIndexed(global::VkCommandBufferT commandBuffer, uint indexCount, uint instanceCount, uint firstIndex, int vertexOffset, uint firstInstance)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdDrawIndexed(__arg0, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
    }

    public static void VkCmdDrawIndirect(global::VkCommandBufferT commandBuffer, global::VkBufferT buffer, ulong offset, uint drawCount, uint stride)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        __Internal.VkCmdDrawIndirect(__arg0, __arg1, offset, drawCount, stride);
    }

    public static void VkCmdDrawIndexedIndirect(global::VkCommandBufferT commandBuffer, global::VkBufferT buffer, ulong offset, uint drawCount, uint stride)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        __Internal.VkCmdDrawIndexedIndirect(__arg0, __arg1, offset, drawCount, stride);
    }

    public static void VkCmdDispatch(global::VkCommandBufferT commandBuffer, uint groupCountX, uint groupCountY, uint groupCountZ)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdDispatch(__arg0, groupCountX, groupCountY, groupCountZ);
    }

    public static void VkCmdDispatchIndirect(global::VkCommandBufferT commandBuffer, global::VkBufferT buffer, ulong offset)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        __Internal.VkCmdDispatchIndirect(__arg0, __arg1, offset);
    }

    public static void VkCmdCopyBuffer(global::VkCommandBufferT commandBuffer, global::VkBufferT srcBuffer, global::VkBufferT dstBuffer, uint regionCount, global::VkBufferCopy pRegions)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(srcBuffer, null) ? global::System.IntPtr.Zero : srcBuffer.__Instance;
        var __arg2 = ReferenceEquals(dstBuffer, null) ? global::System.IntPtr.Zero : dstBuffer.__Instance;
        var __arg4 = ReferenceEquals(pRegions, null) ? global::System.IntPtr.Zero : pRegions.__Instance;
        __Internal.VkCmdCopyBuffer(__arg0, __arg1, __arg2, regionCount, __arg4);
    }

    public static void VkCmdCopyImage(global::VkCommandBufferT commandBuffer, global::VkImageT srcImage, global::VkImageLayout srcImageLayout, global::VkImageT dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::VkImageCopy pRegions)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(srcImage, null) ? global::System.IntPtr.Zero : srcImage.__Instance;
        var __arg3 = ReferenceEquals(dstImage, null) ? global::System.IntPtr.Zero : dstImage.__Instance;
        var __arg6 = ReferenceEquals(pRegions, null) ? global::System.IntPtr.Zero : pRegions.__Instance;
        __Internal.VkCmdCopyImage(__arg0, __arg1, srcImageLayout, __arg3, dstImageLayout, regionCount, __arg6);
    }

    public static void VkCmdBlitImage(global::VkCommandBufferT commandBuffer, global::VkImageT srcImage, global::VkImageLayout srcImageLayout, global::VkImageT dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::VkImageBlit pRegions, global::VkFilter filter)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(srcImage, null) ? global::System.IntPtr.Zero : srcImage.__Instance;
        var __arg3 = ReferenceEquals(dstImage, null) ? global::System.IntPtr.Zero : dstImage.__Instance;
        var __arg6 = ReferenceEquals(pRegions, null) ? global::System.IntPtr.Zero : pRegions.__Instance;
        __Internal.VkCmdBlitImage(__arg0, __arg1, srcImageLayout, __arg3, dstImageLayout, regionCount, __arg6, filter);
    }

    public static void VkCmdCopyBufferToImage(global::VkCommandBufferT commandBuffer, global::VkBufferT srcBuffer, global::VkImageT dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::VkBufferImageCopy pRegions)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(srcBuffer, null) ? global::System.IntPtr.Zero : srcBuffer.__Instance;
        var __arg2 = ReferenceEquals(dstImage, null) ? global::System.IntPtr.Zero : dstImage.__Instance;
        var __arg5 = ReferenceEquals(pRegions, null) ? global::System.IntPtr.Zero : pRegions.__Instance;
        __Internal.VkCmdCopyBufferToImage(__arg0, __arg1, __arg2, dstImageLayout, regionCount, __arg5);
    }

    public static void VkCmdCopyImageToBuffer(global::VkCommandBufferT commandBuffer, global::VkImageT srcImage, global::VkImageLayout srcImageLayout, global::VkBufferT dstBuffer, uint regionCount, global::VkBufferImageCopy pRegions)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(srcImage, null) ? global::System.IntPtr.Zero : srcImage.__Instance;
        var __arg3 = ReferenceEquals(dstBuffer, null) ? global::System.IntPtr.Zero : dstBuffer.__Instance;
        var __arg5 = ReferenceEquals(pRegions, null) ? global::System.IntPtr.Zero : pRegions.__Instance;
        __Internal.VkCmdCopyImageToBuffer(__arg0, __arg1, srcImageLayout, __arg3, regionCount, __arg5);
    }

    public static void VkCmdUpdateBuffer(global::VkCommandBufferT commandBuffer, global::VkBufferT dstBuffer, ulong dstOffset, ulong dataSize, global::System.IntPtr pData)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(dstBuffer, null) ? global::System.IntPtr.Zero : dstBuffer.__Instance;
        __Internal.VkCmdUpdateBuffer(__arg0, __arg1, dstOffset, dataSize, pData);
    }

    public static void VkCmdFillBuffer(global::VkCommandBufferT commandBuffer, global::VkBufferT dstBuffer, ulong dstOffset, ulong size, uint data)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(dstBuffer, null) ? global::System.IntPtr.Zero : dstBuffer.__Instance;
        __Internal.VkCmdFillBuffer(__arg0, __arg1, dstOffset, size, data);
    }

    public static void VkCmdClearColorImage(global::VkCommandBufferT commandBuffer, global::VkImageT image, global::VkImageLayout imageLayout, global::VkClearColorValue pColor, uint rangeCount, global::VkImageSubresourceRange pRanges)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
        var ____arg3 = pColor.__Instance;
        var __arg3 = new global::System.IntPtr(&____arg3);
        var __arg5 = ReferenceEquals(pRanges, null) ? global::System.IntPtr.Zero : pRanges.__Instance;
        __Internal.VkCmdClearColorImage(__arg0, __arg1, imageLayout, __arg3, rangeCount, __arg5);
    }

    public static void VkCmdClearDepthStencilImage(global::VkCommandBufferT commandBuffer, global::VkImageT image, global::VkImageLayout imageLayout, global::VkClearDepthStencilValue pDepthStencil, uint rangeCount, global::VkImageSubresourceRange pRanges)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
        var __arg3 = ReferenceEquals(pDepthStencil, null) ? global::System.IntPtr.Zero : pDepthStencil.__Instance;
        var __arg5 = ReferenceEquals(pRanges, null) ? global::System.IntPtr.Zero : pRanges.__Instance;
        __Internal.VkCmdClearDepthStencilImage(__arg0, __arg1, imageLayout, __arg3, rangeCount, __arg5);
    }

    public static void VkCmdClearAttachments(global::VkCommandBufferT commandBuffer, uint attachmentCount, global::VkClearAttachment pAttachments, uint rectCount, global::VkClearRect pRects)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg2 = ReferenceEquals(pAttachments, null) ? global::System.IntPtr.Zero : pAttachments.__Instance;
        var __arg4 = ReferenceEquals(pRects, null) ? global::System.IntPtr.Zero : pRects.__Instance;
        __Internal.VkCmdClearAttachments(__arg0, attachmentCount, __arg2, rectCount, __arg4);
    }

    public static void VkCmdResolveImage(global::VkCommandBufferT commandBuffer, global::VkImageT srcImage, global::VkImageLayout srcImageLayout, global::VkImageT dstImage, global::VkImageLayout dstImageLayout, uint regionCount, global::VkImageResolve pRegions)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(srcImage, null) ? global::System.IntPtr.Zero : srcImage.__Instance;
        var __arg3 = ReferenceEquals(dstImage, null) ? global::System.IntPtr.Zero : dstImage.__Instance;
        var __arg6 = ReferenceEquals(pRegions, null) ? global::System.IntPtr.Zero : pRegions.__Instance;
        __Internal.VkCmdResolveImage(__arg0, __arg1, srcImageLayout, __arg3, dstImageLayout, regionCount, __arg6);
    }

    public static void VkCmdSetEvent(global::VkCommandBufferT commandBuffer, global::VkEventT @event, uint stageMask)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
        __Internal.VkCmdSetEvent(__arg0, __arg1, stageMask);
    }

    public static void VkCmdResetEvent(global::VkCommandBufferT commandBuffer, global::VkEventT @event, uint stageMask)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
        __Internal.VkCmdResetEvent(__arg0, __arg1, stageMask);
    }

    public static void VkCmdWaitEvents(global::VkCommandBufferT commandBuffer, uint eventCount, global::VkEventT pEvents, uint srcStageMask, uint dstStageMask, uint memoryBarrierCount, global::VkMemoryBarrier pMemoryBarriers, uint bufferMemoryBarrierCount, global::VkBufferMemoryBarrier pBufferMemoryBarriers, uint imageMemoryBarrierCount, global::VkImageMemoryBarrier pImageMemoryBarriers)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg2 = ReferenceEquals(pEvents, null) ? global::System.IntPtr.Zero : pEvents.__Instance;
        var __arg6 = ReferenceEquals(pMemoryBarriers, null) ? global::System.IntPtr.Zero : pMemoryBarriers.__Instance;
        var __arg8 = ReferenceEquals(pBufferMemoryBarriers, null) ? global::System.IntPtr.Zero : pBufferMemoryBarriers.__Instance;
        var __arg10 = ReferenceEquals(pImageMemoryBarriers, null) ? global::System.IntPtr.Zero : pImageMemoryBarriers.__Instance;
        __Internal.VkCmdWaitEvents(__arg0, eventCount, __arg2, srcStageMask, dstStageMask, memoryBarrierCount, __arg6, bufferMemoryBarrierCount, __arg8, imageMemoryBarrierCount, __arg10);
    }

    public static void VkCmdPipelineBarrier(global::VkCommandBufferT commandBuffer, uint srcStageMask, uint dstStageMask, uint dependencyFlags, uint memoryBarrierCount, global::VkMemoryBarrier pMemoryBarriers, uint bufferMemoryBarrierCount, global::VkBufferMemoryBarrier pBufferMemoryBarriers, uint imageMemoryBarrierCount, global::VkImageMemoryBarrier pImageMemoryBarriers)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg5 = ReferenceEquals(pMemoryBarriers, null) ? global::System.IntPtr.Zero : pMemoryBarriers.__Instance;
        var __arg7 = ReferenceEquals(pBufferMemoryBarriers, null) ? global::System.IntPtr.Zero : pBufferMemoryBarriers.__Instance;
        var __arg9 = ReferenceEquals(pImageMemoryBarriers, null) ? global::System.IntPtr.Zero : pImageMemoryBarriers.__Instance;
        __Internal.VkCmdPipelineBarrier(__arg0, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, __arg5, bufferMemoryBarrierCount, __arg7, imageMemoryBarrierCount, __arg9);
    }

    public static void VkCmdBeginQuery(global::VkCommandBufferT commandBuffer, global::VkQueryPoolT queryPool, uint query, uint flags)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(queryPool, null) ? global::System.IntPtr.Zero : queryPool.__Instance;
        __Internal.VkCmdBeginQuery(__arg0, __arg1, query, flags);
    }

    public static void VkCmdEndQuery(global::VkCommandBufferT commandBuffer, global::VkQueryPoolT queryPool, uint query)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(queryPool, null) ? global::System.IntPtr.Zero : queryPool.__Instance;
        __Internal.VkCmdEndQuery(__arg0, __arg1, query);
    }

    public static void VkCmdResetQueryPool(global::VkCommandBufferT commandBuffer, global::VkQueryPoolT queryPool, uint firstQuery, uint queryCount)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(queryPool, null) ? global::System.IntPtr.Zero : queryPool.__Instance;
        __Internal.VkCmdResetQueryPool(__arg0, __arg1, firstQuery, queryCount);
    }

    public static void VkCmdWriteTimestamp(global::VkCommandBufferT commandBuffer, global::VkPipelineStageFlagBits pipelineStage, global::VkQueryPoolT queryPool, uint query)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg2 = ReferenceEquals(queryPool, null) ? global::System.IntPtr.Zero : queryPool.__Instance;
        __Internal.VkCmdWriteTimestamp(__arg0, pipelineStage, __arg2, query);
    }

    public static void VkCmdCopyQueryPoolResults(global::VkCommandBufferT commandBuffer, global::VkQueryPoolT queryPool, uint firstQuery, uint queryCount, global::VkBufferT dstBuffer, ulong dstOffset, ulong stride, uint flags)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(queryPool, null) ? global::System.IntPtr.Zero : queryPool.__Instance;
        var __arg4 = ReferenceEquals(dstBuffer, null) ? global::System.IntPtr.Zero : dstBuffer.__Instance;
        __Internal.VkCmdCopyQueryPoolResults(__arg0, __arg1, firstQuery, queryCount, __arg4, dstOffset, stride, flags);
    }

    public static void VkCmdPushConstants(global::VkCommandBufferT commandBuffer, global::VkPipelineLayoutT layout, uint stageFlags, uint offset, uint size, global::System.IntPtr pValues)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(layout, null) ? global::System.IntPtr.Zero : layout.__Instance;
        __Internal.VkCmdPushConstants(__arg0, __arg1, stageFlags, offset, size, pValues);
    }

    public static void VkCmdBeginRenderPass(global::VkCommandBufferT commandBuffer, global::VkRenderPassBeginInfo pRenderPassBegin, global::VkSubpassContents contents)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pRenderPassBegin, null) ? global::System.IntPtr.Zero : pRenderPassBegin.__Instance;
        __Internal.VkCmdBeginRenderPass(__arg0, __arg1, contents);
    }

    public static void VkCmdNextSubpass(global::VkCommandBufferT commandBuffer, global::VkSubpassContents contents)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdNextSubpass(__arg0, contents);
    }

    public static void VkCmdEndRenderPass(global::VkCommandBufferT commandBuffer)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdEndRenderPass(__arg0);
    }

    public static void VkCmdExecuteCommands(global::VkCommandBufferT commandBuffer, uint commandBufferCount, global::VkCommandBufferT pCommandBuffers)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg2 = ReferenceEquals(pCommandBuffers, null) ? global::System.IntPtr.Zero : pCommandBuffers.__Instance;
        __Internal.VkCmdExecuteCommands(__arg0, commandBufferCount, __arg2);
    }

    public static global::VkResult VkEnumerateInstanceVersion(ref uint pApiVersion)
    {
        fixed (uint* __refParamPtr0 = &pApiVersion)
        {
            var __arg0 = __refParamPtr0;
            var __ret = __Internal.VkEnumerateInstanceVersion(__arg0);
            return __ret;
        }
    }

    public static global::VkResult VkBindBufferMemory2(global::VkDeviceT device, uint bindInfoCount, global::VkBindBufferMemoryInfo pBindInfos)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pBindInfos, null) ? global::System.IntPtr.Zero : pBindInfos.__Instance;
        var __ret = __Internal.VkBindBufferMemory2(__arg0, bindInfoCount, __arg2);
        return __ret;
    }

    public static global::VkResult VkBindImageMemory2(global::VkDeviceT device, uint bindInfoCount, global::VkBindImageMemoryInfo pBindInfos)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pBindInfos, null) ? global::System.IntPtr.Zero : pBindInfos.__Instance;
        var __ret = __Internal.VkBindImageMemory2(__arg0, bindInfoCount, __arg2);
        return __ret;
    }

    public static void VkGetDeviceGroupPeerMemoryFeatures(global::VkDeviceT device, uint heapIndex, uint localDeviceIndex, uint remoteDeviceIndex, ref uint pPeerMemoryFeatures)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        fixed (uint* __refParamPtr4 = &pPeerMemoryFeatures)
        {
            var __arg4 = __refParamPtr4;
            __Internal.VkGetDeviceGroupPeerMemoryFeatures(__arg0, heapIndex, localDeviceIndex, remoteDeviceIndex, __arg4);
        }
    }

    public static void VkCmdSetDeviceMask(global::VkCommandBufferT commandBuffer, uint deviceMask)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdSetDeviceMask(__arg0, deviceMask);
    }

    public static void VkCmdDispatchBase(global::VkCommandBufferT commandBuffer, uint baseGroupX, uint baseGroupY, uint baseGroupZ, uint groupCountX, uint groupCountY, uint groupCountZ)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdDispatchBase(__arg0, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
    }

    public static global::VkResult VkEnumeratePhysicalDeviceGroups(global::VkInstanceT instance, ref uint pPhysicalDeviceGroupCount, global::VkPhysicalDeviceGroupProperties pPhysicalDeviceGroupProperties)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        fixed (uint* __refParamPtr1 = &pPhysicalDeviceGroupCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pPhysicalDeviceGroupProperties, null) ? global::System.IntPtr.Zero : pPhysicalDeviceGroupProperties.__Instance;
            var __ret = __Internal.VkEnumeratePhysicalDeviceGroups(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static void VkGetImageMemoryRequirements2(global::VkDeviceT device, global::VkImageMemoryRequirementsInfo2 pInfo, global::VkMemoryRequirements2 pMemoryRequirements)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pInfo, null) ? global::System.IntPtr.Zero : pInfo.__Instance;
        var __arg2 = ReferenceEquals(pMemoryRequirements, null) ? global::System.IntPtr.Zero : pMemoryRequirements.__Instance;
        __Internal.VkGetImageMemoryRequirements2(__arg0, __arg1, __arg2);
    }

    public static void VkGetBufferMemoryRequirements2(global::VkDeviceT device, global::VkBufferMemoryRequirementsInfo2 pInfo, global::VkMemoryRequirements2 pMemoryRequirements)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pInfo, null) ? global::System.IntPtr.Zero : pInfo.__Instance;
        var __arg2 = ReferenceEquals(pMemoryRequirements, null) ? global::System.IntPtr.Zero : pMemoryRequirements.__Instance;
        __Internal.VkGetBufferMemoryRequirements2(__arg0, __arg1, __arg2);
    }

    public static void VkGetImageSparseMemoryRequirements2(global::VkDeviceT device, global::VkImageSparseMemoryRequirementsInfo2 pInfo, ref uint pSparseMemoryRequirementCount, global::VkSparseImageMemoryRequirements2 pSparseMemoryRequirements)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pInfo, null) ? global::System.IntPtr.Zero : pInfo.__Instance;
        fixed (uint* __refParamPtr2 = &pSparseMemoryRequirementCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pSparseMemoryRequirements, null) ? global::System.IntPtr.Zero : pSparseMemoryRequirements.__Instance;
            __Internal.VkGetImageSparseMemoryRequirements2(__arg0, __arg1, __arg2, __arg3);
        }
    }

    public static void VkGetPhysicalDeviceFeatures2(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceFeatures2 pFeatures)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pFeatures, null) ? global::System.IntPtr.Zero : pFeatures.__Instance;
        __Internal.VkGetPhysicalDeviceFeatures2(__arg0, __arg1);
    }

    public static void VkGetPhysicalDeviceProperties2(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceProperties2 pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
        __Internal.VkGetPhysicalDeviceProperties2(__arg0, __arg1);
    }

    public static void VkGetPhysicalDeviceFormatProperties2(global::VkPhysicalDeviceT physicalDevice, global::VkFormat format, global::VkFormatProperties2 pFormatProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg2 = ReferenceEquals(pFormatProperties, null) ? global::System.IntPtr.Zero : pFormatProperties.__Instance;
        __Internal.VkGetPhysicalDeviceFormatProperties2(__arg0, format, __arg2);
    }

    public static global::VkResult VkGetPhysicalDeviceImageFormatProperties2(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo, global::VkImageFormatProperties2 pImageFormatProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pImageFormatInfo, null) ? global::System.IntPtr.Zero : pImageFormatInfo.__Instance;
        var __arg2 = ReferenceEquals(pImageFormatProperties, null) ? global::System.IntPtr.Zero : pImageFormatProperties.__Instance;
        var __ret = __Internal.VkGetPhysicalDeviceImageFormatProperties2(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static void VkGetPhysicalDeviceQueueFamilyProperties2(global::VkPhysicalDeviceT physicalDevice, ref uint pQueueFamilyPropertyCount, global::VkQueueFamilyProperties2 pQueueFamilyProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr1 = &pQueueFamilyPropertyCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pQueueFamilyProperties, null) ? global::System.IntPtr.Zero : pQueueFamilyProperties.__Instance;
            __Internal.VkGetPhysicalDeviceQueueFamilyProperties2(__arg0, __arg1, __arg2);
        }
    }

    public static void VkGetPhysicalDeviceMemoryProperties2(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceMemoryProperties2 pMemoryProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pMemoryProperties, null) ? global::System.IntPtr.Zero : pMemoryProperties.__Instance;
        __Internal.VkGetPhysicalDeviceMemoryProperties2(__arg0, __arg1);
    }

    public static void VkGetPhysicalDeviceSparseImageFormatProperties2(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceSparseImageFormatInfo2 pFormatInfo, ref uint pPropertyCount, global::VkSparseImageFormatProperties2 pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pFormatInfo, null) ? global::System.IntPtr.Zero : pFormatInfo.__Instance;
        fixed (uint* __refParamPtr2 = &pPropertyCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            __Internal.VkGetPhysicalDeviceSparseImageFormatProperties2(__arg0, __arg1, __arg2, __arg3);
        }
    }

    public static void VkTrimCommandPool(global::VkDeviceT device, global::VkCommandPoolT commandPool, uint flags)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(commandPool, null) ? global::System.IntPtr.Zero : commandPool.__Instance;
        __Internal.VkTrimCommandPool(__arg0, __arg1, flags);
    }

    public static void VkGetDeviceQueue2(global::VkDeviceT device, global::VkDeviceQueueInfo2 pQueueInfo, global::VkQueueT pQueue)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pQueueInfo, null) ? global::System.IntPtr.Zero : pQueueInfo.__Instance;
        var __arg2 = ReferenceEquals(pQueue, null) ? global::System.IntPtr.Zero : pQueue.__Instance;
        __Internal.VkGetDeviceQueue2(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateSamplerYcbcrConversion(global::VkDeviceT device, global::VkSamplerYcbcrConversionCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkSamplerYcbcrConversionT pYcbcrConversion)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pYcbcrConversion, null) ? global::System.IntPtr.Zero : pYcbcrConversion.__Instance;
        var __ret = __Internal.VkCreateSamplerYcbcrConversion(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroySamplerYcbcrConversion(global::VkDeviceT device, global::VkSamplerYcbcrConversionT ycbcrConversion, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(ycbcrConversion, null) ? global::System.IntPtr.Zero : ycbcrConversion.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroySamplerYcbcrConversion(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateDescriptorUpdateTemplate(global::VkDeviceT device, global::VkDescriptorUpdateTemplateCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkDescriptorUpdateTemplateT pDescriptorUpdateTemplate)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pDescriptorUpdateTemplate, null) ? global::System.IntPtr.Zero : pDescriptorUpdateTemplate.__Instance;
        var __ret = __Internal.VkCreateDescriptorUpdateTemplate(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyDescriptorUpdateTemplate(global::VkDeviceT device, global::VkDescriptorUpdateTemplateT descriptorUpdateTemplate, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(descriptorUpdateTemplate, null) ? global::System.IntPtr.Zero : descriptorUpdateTemplate.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyDescriptorUpdateTemplate(__arg0, __arg1, __arg2);
    }

    public static void VkUpdateDescriptorSetWithTemplate(global::VkDeviceT device, global::VkDescriptorSetT descriptorSet, global::VkDescriptorUpdateTemplateT descriptorUpdateTemplate, global::System.IntPtr pData)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(descriptorSet, null) ? global::System.IntPtr.Zero : descriptorSet.__Instance;
        var __arg2 = ReferenceEquals(descriptorUpdateTemplate, null) ? global::System.IntPtr.Zero : descriptorUpdateTemplate.__Instance;
        __Internal.VkUpdateDescriptorSetWithTemplate(__arg0, __arg1, __arg2, pData);
    }

    public static void VkGetPhysicalDeviceExternalBufferProperties(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo, global::VkExternalBufferProperties pExternalBufferProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pExternalBufferInfo, null) ? global::System.IntPtr.Zero : pExternalBufferInfo.__Instance;
        var __arg2 = ReferenceEquals(pExternalBufferProperties, null) ? global::System.IntPtr.Zero : pExternalBufferProperties.__Instance;
        __Internal.VkGetPhysicalDeviceExternalBufferProperties(__arg0, __arg1, __arg2);
    }

    public static void VkGetPhysicalDeviceExternalFenceProperties(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceExternalFenceInfo pExternalFenceInfo, global::VkExternalFenceProperties pExternalFenceProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pExternalFenceInfo, null) ? global::System.IntPtr.Zero : pExternalFenceInfo.__Instance;
        var __arg2 = ReferenceEquals(pExternalFenceProperties, null) ? global::System.IntPtr.Zero : pExternalFenceProperties.__Instance;
        __Internal.VkGetPhysicalDeviceExternalFenceProperties(__arg0, __arg1, __arg2);
    }

    public static void VkGetPhysicalDeviceExternalSemaphoreProperties(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo, global::VkExternalSemaphoreProperties pExternalSemaphoreProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pExternalSemaphoreInfo, null) ? global::System.IntPtr.Zero : pExternalSemaphoreInfo.__Instance;
        var __arg2 = ReferenceEquals(pExternalSemaphoreProperties, null) ? global::System.IntPtr.Zero : pExternalSemaphoreProperties.__Instance;
        __Internal.VkGetPhysicalDeviceExternalSemaphoreProperties(__arg0, __arg1, __arg2);
    }

    public static void VkGetDescriptorSetLayoutSupport(global::VkDeviceT device, global::VkDescriptorSetLayoutCreateInfo pCreateInfo, global::VkDescriptorSetLayoutSupport pSupport)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pSupport, null) ? global::System.IntPtr.Zero : pSupport.__Instance;
        __Internal.VkGetDescriptorSetLayoutSupport(__arg0, __arg1, __arg2);
    }

    public static void VkDestroySurfaceKHR(global::VkInstanceT instance, global::VkSurfaceKHR_T surface, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        var __arg1 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroySurfaceKHR(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkGetPhysicalDeviceSurfaceSupportKHR(global::VkPhysicalDeviceT physicalDevice, uint queueFamilyIndex, global::VkSurfaceKHR_T surface, ref uint pSupported)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg2 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
        fixed (uint* __refParamPtr3 = &pSupported)
        {
            var __arg3 = __refParamPtr3;
            var __ret = __Internal.VkGetPhysicalDeviceSurfaceSupportKHR(__arg0, queueFamilyIndex, __arg2, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkGetPhysicalDeviceSurfaceCapabilitiesKHR(global::VkPhysicalDeviceT physicalDevice, global::VkSurfaceKHR_T surface, global::VkSurfaceCapabilitiesKHR pSurfaceCapabilities)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
        var __arg2 = ReferenceEquals(pSurfaceCapabilities, null) ? global::System.IntPtr.Zero : pSurfaceCapabilities.__Instance;
        var __ret = __Internal.VkGetPhysicalDeviceSurfaceCapabilitiesKHR(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static global::VkResult VkGetPhysicalDeviceSurfaceFormatsKHR(global::VkPhysicalDeviceT physicalDevice, global::VkSurfaceKHR_T surface, ref uint pSurfaceFormatCount, global::VkSurfaceFormatKHR pSurfaceFormats)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
        fixed (uint* __refParamPtr2 = &pSurfaceFormatCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pSurfaceFormats, null) ? global::System.IntPtr.Zero : pSurfaceFormats.__Instance;
            var __ret = __Internal.VkGetPhysicalDeviceSurfaceFormatsKHR(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkGetPhysicalDeviceSurfacePresentModesKHR(global::VkPhysicalDeviceT physicalDevice, global::VkSurfaceKHR_T surface, ref uint pPresentModeCount, global::VkPresentModeKHR* pPresentModes)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
        fixed (uint* __refParamPtr2 = &pPresentModeCount)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.VkGetPhysicalDeviceSurfacePresentModesKHR(__arg0, __arg1, __arg2, pPresentModes);
            return __ret;
        }
    }

    public static global::VkResult VkCreateSwapchainKHR(global::VkDeviceT device, global::VkSwapchainCreateInfoKHR pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkSwapchainKHR_T pSwapchain)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pSwapchain, null) ? global::System.IntPtr.Zero : pSwapchain.__Instance;
        var __ret = __Internal.VkCreateSwapchainKHR(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroySwapchainKHR(global::VkDeviceT device, global::VkSwapchainKHR_T swapchain, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(swapchain, null) ? global::System.IntPtr.Zero : swapchain.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroySwapchainKHR(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkGetSwapchainImagesKHR(global::VkDeviceT device, global::VkSwapchainKHR_T swapchain, ref uint pSwapchainImageCount, global::VkImageT pSwapchainImages)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(swapchain, null) ? global::System.IntPtr.Zero : swapchain.__Instance;
        fixed (uint* __refParamPtr2 = &pSwapchainImageCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pSwapchainImages, null) ? global::System.IntPtr.Zero : pSwapchainImages.__Instance;
            var __ret = __Internal.VkGetSwapchainImagesKHR(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkAcquireNextImageKHR(global::VkDeviceT device, global::VkSwapchainKHR_T swapchain, ulong timeout, global::VkSemaphoreT semaphore, global::VkFenceT fence, ref uint pImageIndex)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(swapchain, null) ? global::System.IntPtr.Zero : swapchain.__Instance;
        var __arg3 = ReferenceEquals(semaphore, null) ? global::System.IntPtr.Zero : semaphore.__Instance;
        var __arg4 = ReferenceEquals(fence, null) ? global::System.IntPtr.Zero : fence.__Instance;
        fixed (uint* __refParamPtr5 = &pImageIndex)
        {
            var __arg5 = __refParamPtr5;
            var __ret = __Internal.VkAcquireNextImageKHR(__arg0, __arg1, timeout, __arg3, __arg4, __arg5);
            return __ret;
        }
    }

    public static global::VkResult VkQueuePresentKHR(global::VkQueueT queue, global::VkPresentInfoKHR pPresentInfo)
    {
        var __arg0 = ReferenceEquals(queue, null) ? global::System.IntPtr.Zero : queue.__Instance;
        var __arg1 = ReferenceEquals(pPresentInfo, null) ? global::System.IntPtr.Zero : pPresentInfo.__Instance;
        var __ret = __Internal.VkQueuePresentKHR(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkGetDeviceGroupPresentCapabilitiesKHR(global::VkDeviceT device, global::VkDeviceGroupPresentCapabilitiesKHR pDeviceGroupPresentCapabilities)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pDeviceGroupPresentCapabilities, null) ? global::System.IntPtr.Zero : pDeviceGroupPresentCapabilities.__Instance;
        var __ret = __Internal.VkGetDeviceGroupPresentCapabilitiesKHR(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkGetDeviceGroupSurfacePresentModesKHR(global::VkDeviceT device, global::VkSurfaceKHR_T surface, ref uint pModes)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
        fixed (uint* __refParamPtr2 = &pModes)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.VkGetDeviceGroupSurfacePresentModesKHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static global::VkResult VkGetPhysicalDevicePresentRectanglesKHR(global::VkPhysicalDeviceT physicalDevice, global::VkSurfaceKHR_T surface, ref uint pRectCount, global::VkRect2D pRects)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
        fixed (uint* __refParamPtr2 = &pRectCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pRects, null) ? global::System.IntPtr.Zero : pRects.__Instance;
            var __ret = __Internal.VkGetPhysicalDevicePresentRectanglesKHR(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkAcquireNextImage2KHR(global::VkDeviceT device, global::VkAcquireNextImageInfoKHR pAcquireInfo, ref uint pImageIndex)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pAcquireInfo, null) ? global::System.IntPtr.Zero : pAcquireInfo.__Instance;
        fixed (uint* __refParamPtr2 = &pImageIndex)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.VkAcquireNextImage2KHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static global::VkResult VkGetPhysicalDeviceDisplayPropertiesKHR(global::VkPhysicalDeviceT physicalDevice, ref uint pPropertyCount, global::VkDisplayPropertiesKHR pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr1 = &pPropertyCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkGetPhysicalDeviceDisplayPropertiesKHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static global::VkResult VkGetPhysicalDeviceDisplayPlanePropertiesKHR(global::VkPhysicalDeviceT physicalDevice, ref uint pPropertyCount, global::VkDisplayPlanePropertiesKHR pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr1 = &pPropertyCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkGetPhysicalDeviceDisplayPlanePropertiesKHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static global::VkResult VkGetDisplayPlaneSupportedDisplaysKHR(global::VkPhysicalDeviceT physicalDevice, uint planeIndex, ref uint pDisplayCount, global::VkDisplayKHR_T pDisplays)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr2 = &pDisplayCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pDisplays, null) ? global::System.IntPtr.Zero : pDisplays.__Instance;
            var __ret = __Internal.VkGetDisplayPlaneSupportedDisplaysKHR(__arg0, planeIndex, __arg2, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkGetDisplayModePropertiesKHR(global::VkPhysicalDeviceT physicalDevice, global::VkDisplayKHR_T display, ref uint pPropertyCount, global::VkDisplayModePropertiesKHR pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(display, null) ? global::System.IntPtr.Zero : display.__Instance;
        fixed (uint* __refParamPtr2 = &pPropertyCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkGetDisplayModePropertiesKHR(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkCreateDisplayModeKHR(global::VkPhysicalDeviceT physicalDevice, global::VkDisplayKHR_T display, global::VkDisplayModeCreateInfoKHR pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkDisplayModeKHR_T pMode)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(display, null) ? global::System.IntPtr.Zero : display.__Instance;
        var __arg2 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg3 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg4 = ReferenceEquals(pMode, null) ? global::System.IntPtr.Zero : pMode.__Instance;
        var __ret = __Internal.VkCreateDisplayModeKHR(__arg0, __arg1, __arg2, __arg3, __arg4);
        return __ret;
    }

    public static global::VkResult VkGetDisplayPlaneCapabilitiesKHR(global::VkPhysicalDeviceT physicalDevice, global::VkDisplayModeKHR_T mode, uint planeIndex, global::VkDisplayPlaneCapabilitiesKHR pCapabilities)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(mode, null) ? global::System.IntPtr.Zero : mode.__Instance;
        var __arg3 = ReferenceEquals(pCapabilities, null) ? global::System.IntPtr.Zero : pCapabilities.__Instance;
        var __ret = __Internal.VkGetDisplayPlaneCapabilitiesKHR(__arg0, __arg1, planeIndex, __arg3);
        return __ret;
    }

    public static global::VkResult VkCreateDisplayPlaneSurfaceKHR(global::VkInstanceT instance, global::VkDisplaySurfaceCreateInfoKHR pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkSurfaceKHR_T pSurface)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pSurface, null) ? global::System.IntPtr.Zero : pSurface.__Instance;
        var __ret = __Internal.VkCreateDisplayPlaneSurfaceKHR(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static global::VkResult VkCreateSharedSwapchainsKHR(global::VkDeviceT device, uint swapchainCount, global::VkSwapchainCreateInfoKHR pCreateInfos, global::VkAllocationCallbacks pAllocator, global::VkSwapchainKHR_T pSwapchains)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pCreateInfos, null) ? global::System.IntPtr.Zero : pCreateInfos.__Instance;
        var __arg3 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg4 = ReferenceEquals(pSwapchains, null) ? global::System.IntPtr.Zero : pSwapchains.__Instance;
        var __ret = __Internal.VkCreateSharedSwapchainsKHR(__arg0, swapchainCount, __arg2, __arg3, __arg4);
        return __ret;
    }

    public static void VkGetPhysicalDeviceFeatures2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceFeatures2 pFeatures)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pFeatures, null) ? global::System.IntPtr.Zero : pFeatures.__Instance;
        __Internal.VkGetPhysicalDeviceFeatures2KHR(__arg0, __arg1);
    }

    public static void VkGetPhysicalDeviceProperties2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceProperties2 pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
        __Internal.VkGetPhysicalDeviceProperties2KHR(__arg0, __arg1);
    }

    public static void VkGetPhysicalDeviceFormatProperties2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkFormat format, global::VkFormatProperties2 pFormatProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg2 = ReferenceEquals(pFormatProperties, null) ? global::System.IntPtr.Zero : pFormatProperties.__Instance;
        __Internal.VkGetPhysicalDeviceFormatProperties2KHR(__arg0, format, __arg2);
    }

    public static global::VkResult VkGetPhysicalDeviceImageFormatProperties2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo, global::VkImageFormatProperties2 pImageFormatProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pImageFormatInfo, null) ? global::System.IntPtr.Zero : pImageFormatInfo.__Instance;
        var __arg2 = ReferenceEquals(pImageFormatProperties, null) ? global::System.IntPtr.Zero : pImageFormatProperties.__Instance;
        var __ret = __Internal.VkGetPhysicalDeviceImageFormatProperties2KHR(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static void VkGetPhysicalDeviceQueueFamilyProperties2KHR(global::VkPhysicalDeviceT physicalDevice, ref uint pQueueFamilyPropertyCount, global::VkQueueFamilyProperties2 pQueueFamilyProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr1 = &pQueueFamilyPropertyCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pQueueFamilyProperties, null) ? global::System.IntPtr.Zero : pQueueFamilyProperties.__Instance;
            __Internal.VkGetPhysicalDeviceQueueFamilyProperties2KHR(__arg0, __arg1, __arg2);
        }
    }

    public static void VkGetPhysicalDeviceMemoryProperties2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceMemoryProperties2 pMemoryProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pMemoryProperties, null) ? global::System.IntPtr.Zero : pMemoryProperties.__Instance;
        __Internal.VkGetPhysicalDeviceMemoryProperties2KHR(__arg0, __arg1);
    }

    public static void VkGetPhysicalDeviceSparseImageFormatProperties2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceSparseImageFormatInfo2 pFormatInfo, ref uint pPropertyCount, global::VkSparseImageFormatProperties2 pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pFormatInfo, null) ? global::System.IntPtr.Zero : pFormatInfo.__Instance;
        fixed (uint* __refParamPtr2 = &pPropertyCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            __Internal.VkGetPhysicalDeviceSparseImageFormatProperties2KHR(__arg0, __arg1, __arg2, __arg3);
        }
    }

    public static void VkGetDeviceGroupPeerMemoryFeaturesKHR(global::VkDeviceT device, uint heapIndex, uint localDeviceIndex, uint remoteDeviceIndex, ref uint pPeerMemoryFeatures)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        fixed (uint* __refParamPtr4 = &pPeerMemoryFeatures)
        {
            var __arg4 = __refParamPtr4;
            __Internal.VkGetDeviceGroupPeerMemoryFeaturesKHR(__arg0, heapIndex, localDeviceIndex, remoteDeviceIndex, __arg4);
        }
    }

    public static void VkCmdSetDeviceMaskKHR(global::VkCommandBufferT commandBuffer, uint deviceMask)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdSetDeviceMaskKHR(__arg0, deviceMask);
    }

    public static void VkCmdDispatchBaseKHR(global::VkCommandBufferT commandBuffer, uint baseGroupX, uint baseGroupY, uint baseGroupZ, uint groupCountX, uint groupCountY, uint groupCountZ)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdDispatchBaseKHR(__arg0, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
    }

    public static void VkTrimCommandPoolKHR(global::VkDeviceT device, global::VkCommandPoolT commandPool, uint flags)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(commandPool, null) ? global::System.IntPtr.Zero : commandPool.__Instance;
        __Internal.VkTrimCommandPoolKHR(__arg0, __arg1, flags);
    }

    public static global::VkResult VkEnumeratePhysicalDeviceGroupsKHR(global::VkInstanceT instance, ref uint pPhysicalDeviceGroupCount, global::VkPhysicalDeviceGroupProperties pPhysicalDeviceGroupProperties)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        fixed (uint* __refParamPtr1 = &pPhysicalDeviceGroupCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pPhysicalDeviceGroupProperties, null) ? global::System.IntPtr.Zero : pPhysicalDeviceGroupProperties.__Instance;
            var __ret = __Internal.VkEnumeratePhysicalDeviceGroupsKHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static void VkGetPhysicalDeviceExternalBufferPropertiesKHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo, global::VkExternalBufferProperties pExternalBufferProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pExternalBufferInfo, null) ? global::System.IntPtr.Zero : pExternalBufferInfo.__Instance;
        var __arg2 = ReferenceEquals(pExternalBufferProperties, null) ? global::System.IntPtr.Zero : pExternalBufferProperties.__Instance;
        __Internal.VkGetPhysicalDeviceExternalBufferPropertiesKHR(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkGetMemoryFdKHR(global::VkDeviceT device, global::VkMemoryGetFdInfoKHR pGetFdInfo, ref int pFd)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pGetFdInfo, null) ? global::System.IntPtr.Zero : pGetFdInfo.__Instance;
        fixed (int* __refParamPtr2 = &pFd)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.VkGetMemoryFdKHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static global::VkResult VkGetMemoryFdPropertiesKHR(global::VkDeviceT device, global::VkExternalMemoryHandleTypeFlagBits handleType, int fd, global::VkMemoryFdPropertiesKHR pMemoryFdProperties)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg3 = ReferenceEquals(pMemoryFdProperties, null) ? global::System.IntPtr.Zero : pMemoryFdProperties.__Instance;
        var __ret = __Internal.VkGetMemoryFdPropertiesKHR(__arg0, handleType, fd, __arg3);
        return __ret;
    }

    public static void VkGetPhysicalDeviceExternalSemaphorePropertiesKHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo, global::VkExternalSemaphoreProperties pExternalSemaphoreProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pExternalSemaphoreInfo, null) ? global::System.IntPtr.Zero : pExternalSemaphoreInfo.__Instance;
        var __arg2 = ReferenceEquals(pExternalSemaphoreProperties, null) ? global::System.IntPtr.Zero : pExternalSemaphoreProperties.__Instance;
        __Internal.VkGetPhysicalDeviceExternalSemaphorePropertiesKHR(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkImportSemaphoreFdKHR(global::VkDeviceT device, global::VkImportSemaphoreFdInfoKHR pImportSemaphoreFdInfo)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pImportSemaphoreFdInfo, null) ? global::System.IntPtr.Zero : pImportSemaphoreFdInfo.__Instance;
        var __ret = __Internal.VkImportSemaphoreFdKHR(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkGetSemaphoreFdKHR(global::VkDeviceT device, global::VkSemaphoreGetFdInfoKHR pGetFdInfo, ref int pFd)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pGetFdInfo, null) ? global::System.IntPtr.Zero : pGetFdInfo.__Instance;
        fixed (int* __refParamPtr2 = &pFd)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.VkGetSemaphoreFdKHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static void VkCmdPushDescriptorSetKHR(global::VkCommandBufferT commandBuffer, global::VkPipelineBindPoint pipelineBindPoint, global::VkPipelineLayoutT layout, uint set, uint descriptorWriteCount, global::VkWriteDescriptorSet pDescriptorWrites)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg2 = ReferenceEquals(layout, null) ? global::System.IntPtr.Zero : layout.__Instance;
        var __arg5 = ReferenceEquals(pDescriptorWrites, null) ? global::System.IntPtr.Zero : pDescriptorWrites.__Instance;
        __Internal.VkCmdPushDescriptorSetKHR(__arg0, pipelineBindPoint, __arg2, set, descriptorWriteCount, __arg5);
    }

    public static void VkCmdPushDescriptorSetWithTemplateKHR(global::VkCommandBufferT commandBuffer, global::VkDescriptorUpdateTemplateT descriptorUpdateTemplate, global::VkPipelineLayoutT layout, uint set, global::System.IntPtr pData)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(descriptorUpdateTemplate, null) ? global::System.IntPtr.Zero : descriptorUpdateTemplate.__Instance;
        var __arg2 = ReferenceEquals(layout, null) ? global::System.IntPtr.Zero : layout.__Instance;
        __Internal.VkCmdPushDescriptorSetWithTemplateKHR(__arg0, __arg1, __arg2, set, pData);
    }

    public static global::VkResult VkCreateDescriptorUpdateTemplateKHR(global::VkDeviceT device, global::VkDescriptorUpdateTemplateCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkDescriptorUpdateTemplateT pDescriptorUpdateTemplate)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pDescriptorUpdateTemplate, null) ? global::System.IntPtr.Zero : pDescriptorUpdateTemplate.__Instance;
        var __ret = __Internal.VkCreateDescriptorUpdateTemplateKHR(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyDescriptorUpdateTemplateKHR(global::VkDeviceT device, global::VkDescriptorUpdateTemplateT descriptorUpdateTemplate, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(descriptorUpdateTemplate, null) ? global::System.IntPtr.Zero : descriptorUpdateTemplate.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyDescriptorUpdateTemplateKHR(__arg0, __arg1, __arg2);
    }

    public static void VkUpdateDescriptorSetWithTemplateKHR(global::VkDeviceT device, global::VkDescriptorSetT descriptorSet, global::VkDescriptorUpdateTemplateT descriptorUpdateTemplate, global::System.IntPtr pData)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(descriptorSet, null) ? global::System.IntPtr.Zero : descriptorSet.__Instance;
        var __arg2 = ReferenceEquals(descriptorUpdateTemplate, null) ? global::System.IntPtr.Zero : descriptorUpdateTemplate.__Instance;
        __Internal.VkUpdateDescriptorSetWithTemplateKHR(__arg0, __arg1, __arg2, pData);
    }

    public static global::VkResult VkCreateRenderPass2KHR(global::VkDeviceT device, global::VkRenderPassCreateInfo2KHR pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkRenderPassT pRenderPass)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pRenderPass, null) ? global::System.IntPtr.Zero : pRenderPass.__Instance;
        var __ret = __Internal.VkCreateRenderPass2KHR(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkCmdBeginRenderPass2KHR(global::VkCommandBufferT commandBuffer, global::VkRenderPassBeginInfo pRenderPassBegin, global::VkSubpassBeginInfoKHR pSubpassBeginInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pRenderPassBegin, null) ? global::System.IntPtr.Zero : pRenderPassBegin.__Instance;
        var __arg2 = ReferenceEquals(pSubpassBeginInfo, null) ? global::System.IntPtr.Zero : pSubpassBeginInfo.__Instance;
        __Internal.VkCmdBeginRenderPass2KHR(__arg0, __arg1, __arg2);
    }

    public static void VkCmdNextSubpass2KHR(global::VkCommandBufferT commandBuffer, global::VkSubpassBeginInfoKHR pSubpassBeginInfo, global::VkSubpassEndInfoKHR pSubpassEndInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pSubpassBeginInfo, null) ? global::System.IntPtr.Zero : pSubpassBeginInfo.__Instance;
        var __arg2 = ReferenceEquals(pSubpassEndInfo, null) ? global::System.IntPtr.Zero : pSubpassEndInfo.__Instance;
        __Internal.VkCmdNextSubpass2KHR(__arg0, __arg1, __arg2);
    }

    public static void VkCmdEndRenderPass2KHR(global::VkCommandBufferT commandBuffer, global::VkSubpassEndInfoKHR pSubpassEndInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pSubpassEndInfo, null) ? global::System.IntPtr.Zero : pSubpassEndInfo.__Instance;
        __Internal.VkCmdEndRenderPass2KHR(__arg0, __arg1);
    }

    public static global::VkResult VkGetSwapchainStatusKHR(global::VkDeviceT device, global::VkSwapchainKHR_T swapchain)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(swapchain, null) ? global::System.IntPtr.Zero : swapchain.__Instance;
        var __ret = __Internal.VkGetSwapchainStatusKHR(__arg0, __arg1);
        return __ret;
    }

    public static void VkGetPhysicalDeviceExternalFencePropertiesKHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceExternalFenceInfo pExternalFenceInfo, global::VkExternalFenceProperties pExternalFenceProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pExternalFenceInfo, null) ? global::System.IntPtr.Zero : pExternalFenceInfo.__Instance;
        var __arg2 = ReferenceEquals(pExternalFenceProperties, null) ? global::System.IntPtr.Zero : pExternalFenceProperties.__Instance;
        __Internal.VkGetPhysicalDeviceExternalFencePropertiesKHR(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkImportFenceFdKHR(global::VkDeviceT device, global::VkImportFenceFdInfoKHR pImportFenceFdInfo)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pImportFenceFdInfo, null) ? global::System.IntPtr.Zero : pImportFenceFdInfo.__Instance;
        var __ret = __Internal.VkImportFenceFdKHR(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkGetFenceFdKHR(global::VkDeviceT device, global::VkFenceGetFdInfoKHR pGetFdInfo, ref int pFd)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pGetFdInfo, null) ? global::System.IntPtr.Zero : pGetFdInfo.__Instance;
        fixed (int* __refParamPtr2 = &pFd)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.VkGetFenceFdKHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static global::VkResult VkGetPhysicalDeviceSurfaceCapabilities2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo, global::VkSurfaceCapabilities2KHR pSurfaceCapabilities)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pSurfaceInfo, null) ? global::System.IntPtr.Zero : pSurfaceInfo.__Instance;
        var __arg2 = ReferenceEquals(pSurfaceCapabilities, null) ? global::System.IntPtr.Zero : pSurfaceCapabilities.__Instance;
        var __ret = __Internal.VkGetPhysicalDeviceSurfaceCapabilities2KHR(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static global::VkResult VkGetPhysicalDeviceSurfaceFormats2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo, ref uint pSurfaceFormatCount, global::VkSurfaceFormat2KHR pSurfaceFormats)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pSurfaceInfo, null) ? global::System.IntPtr.Zero : pSurfaceInfo.__Instance;
        fixed (uint* __refParamPtr2 = &pSurfaceFormatCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pSurfaceFormats, null) ? global::System.IntPtr.Zero : pSurfaceFormats.__Instance;
            var __ret = __Internal.VkGetPhysicalDeviceSurfaceFormats2KHR(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkGetPhysicalDeviceDisplayProperties2KHR(global::VkPhysicalDeviceT physicalDevice, ref uint pPropertyCount, global::VkDisplayProperties2KHR pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr1 = &pPropertyCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkGetPhysicalDeviceDisplayProperties2KHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static global::VkResult VkGetPhysicalDeviceDisplayPlaneProperties2KHR(global::VkPhysicalDeviceT physicalDevice, ref uint pPropertyCount, global::VkDisplayPlaneProperties2KHR pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        fixed (uint* __refParamPtr1 = &pPropertyCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkGetPhysicalDeviceDisplayPlaneProperties2KHR(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public static global::VkResult VkGetDisplayModeProperties2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkDisplayKHR_T display, ref uint pPropertyCount, global::VkDisplayModeProperties2KHR pProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(display, null) ? global::System.IntPtr.Zero : display.__Instance;
        fixed (uint* __refParamPtr2 = &pPropertyCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pProperties, null) ? global::System.IntPtr.Zero : pProperties.__Instance;
            var __ret = __Internal.VkGetDisplayModeProperties2KHR(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkGetDisplayPlaneCapabilities2KHR(global::VkPhysicalDeviceT physicalDevice, global::VkDisplayPlaneInfo2KHR pDisplayPlaneInfo, global::VkDisplayPlaneCapabilities2KHR pCapabilities)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pDisplayPlaneInfo, null) ? global::System.IntPtr.Zero : pDisplayPlaneInfo.__Instance;
        var __arg2 = ReferenceEquals(pCapabilities, null) ? global::System.IntPtr.Zero : pCapabilities.__Instance;
        var __ret = __Internal.VkGetDisplayPlaneCapabilities2KHR(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static void VkGetImageMemoryRequirements2KHR(global::VkDeviceT device, global::VkImageMemoryRequirementsInfo2 pInfo, global::VkMemoryRequirements2 pMemoryRequirements)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pInfo, null) ? global::System.IntPtr.Zero : pInfo.__Instance;
        var __arg2 = ReferenceEquals(pMemoryRequirements, null) ? global::System.IntPtr.Zero : pMemoryRequirements.__Instance;
        __Internal.VkGetImageMemoryRequirements2KHR(__arg0, __arg1, __arg2);
    }

    public static void VkGetBufferMemoryRequirements2KHR(global::VkDeviceT device, global::VkBufferMemoryRequirementsInfo2 pInfo, global::VkMemoryRequirements2 pMemoryRequirements)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pInfo, null) ? global::System.IntPtr.Zero : pInfo.__Instance;
        var __arg2 = ReferenceEquals(pMemoryRequirements, null) ? global::System.IntPtr.Zero : pMemoryRequirements.__Instance;
        __Internal.VkGetBufferMemoryRequirements2KHR(__arg0, __arg1, __arg2);
    }

    public static void VkGetImageSparseMemoryRequirements2KHR(global::VkDeviceT device, global::VkImageSparseMemoryRequirementsInfo2 pInfo, ref uint pSparseMemoryRequirementCount, global::VkSparseImageMemoryRequirements2 pSparseMemoryRequirements)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pInfo, null) ? global::System.IntPtr.Zero : pInfo.__Instance;
        fixed (uint* __refParamPtr2 = &pSparseMemoryRequirementCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pSparseMemoryRequirements, null) ? global::System.IntPtr.Zero : pSparseMemoryRequirements.__Instance;
            __Internal.VkGetImageSparseMemoryRequirements2KHR(__arg0, __arg1, __arg2, __arg3);
        }
    }

    public static global::VkResult VkCreateSamplerYcbcrConversionKHR(global::VkDeviceT device, global::VkSamplerYcbcrConversionCreateInfo pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkSamplerYcbcrConversionT pYcbcrConversion)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pYcbcrConversion, null) ? global::System.IntPtr.Zero : pYcbcrConversion.__Instance;
        var __ret = __Internal.VkCreateSamplerYcbcrConversionKHR(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroySamplerYcbcrConversionKHR(global::VkDeviceT device, global::VkSamplerYcbcrConversionT ycbcrConversion, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(ycbcrConversion, null) ? global::System.IntPtr.Zero : ycbcrConversion.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroySamplerYcbcrConversionKHR(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkBindBufferMemory2KHR(global::VkDeviceT device, uint bindInfoCount, global::VkBindBufferMemoryInfo pBindInfos)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pBindInfos, null) ? global::System.IntPtr.Zero : pBindInfos.__Instance;
        var __ret = __Internal.VkBindBufferMemory2KHR(__arg0, bindInfoCount, __arg2);
        return __ret;
    }

    public static global::VkResult VkBindImageMemory2KHR(global::VkDeviceT device, uint bindInfoCount, global::VkBindImageMemoryInfo pBindInfos)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pBindInfos, null) ? global::System.IntPtr.Zero : pBindInfos.__Instance;
        var __ret = __Internal.VkBindImageMemory2KHR(__arg0, bindInfoCount, __arg2);
        return __ret;
    }

    public static void VkGetDescriptorSetLayoutSupportKHR(global::VkDeviceT device, global::VkDescriptorSetLayoutCreateInfo pCreateInfo, global::VkDescriptorSetLayoutSupport pSupport)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pSupport, null) ? global::System.IntPtr.Zero : pSupport.__Instance;
        __Internal.VkGetDescriptorSetLayoutSupportKHR(__arg0, __arg1, __arg2);
    }

    public static void VkCmdDrawIndirectCountKHR(global::VkCommandBufferT commandBuffer, global::VkBufferT buffer, ulong offset, global::VkBufferT countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        var __arg3 = ReferenceEquals(countBuffer, null) ? global::System.IntPtr.Zero : countBuffer.__Instance;
        __Internal.VkCmdDrawIndirectCountKHR(__arg0, __arg1, offset, __arg3, countBufferOffset, maxDrawCount, stride);
    }

    public static void VkCmdDrawIndexedIndirectCountKHR(global::VkCommandBufferT commandBuffer, global::VkBufferT buffer, ulong offset, global::VkBufferT countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        var __arg3 = ReferenceEquals(countBuffer, null) ? global::System.IntPtr.Zero : countBuffer.__Instance;
        __Internal.VkCmdDrawIndexedIndirectCountKHR(__arg0, __arg1, offset, __arg3, countBufferOffset, maxDrawCount, stride);
    }

    public static global::VkResult VkCreateDebugReportCallbackEXT(global::VkInstanceT instance, global::VkDebugReportCallbackCreateInfoEXT pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkDebugReportCallbackEXT_T pCallback)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pCallback, null) ? global::System.IntPtr.Zero : pCallback.__Instance;
        var __ret = __Internal.VkCreateDebugReportCallbackEXT(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyDebugReportCallbackEXT(global::VkInstanceT instance, global::VkDebugReportCallbackEXT_T callback, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        var __arg1 = ReferenceEquals(callback, null) ? global::System.IntPtr.Zero : callback.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyDebugReportCallbackEXT(__arg0, __arg1, __arg2);
    }

    public static void VkDebugReportMessageEXT(global::VkInstanceT instance, uint flags, global::VkDebugReportObjectTypeEXT objectType, ulong targetObject, ulong location, int messageCode, string pLayerPrefix, string pMessage)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        __Internal.VkDebugReportMessageEXT(__arg0, flags, objectType, targetObject, location, messageCode, pLayerPrefix, pMessage);
    }

    public static global::VkResult VkDebugMarkerSetObjectTagEXT(global::VkDeviceT device, global::VkDebugMarkerObjectTagInfoEXT pTagInfo)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pTagInfo, null) ? global::System.IntPtr.Zero : pTagInfo.__Instance;
        var __ret = __Internal.VkDebugMarkerSetObjectTagEXT(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkDebugMarkerSetObjectNameEXT(global::VkDeviceT device, global::VkDebugMarkerObjectNameInfoEXT pNameInfo)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pNameInfo, null) ? global::System.IntPtr.Zero : pNameInfo.__Instance;
        var __ret = __Internal.VkDebugMarkerSetObjectNameEXT(__arg0, __arg1);
        return __ret;
    }

    public static void VkCmdDebugMarkerBeginEXT(global::VkCommandBufferT commandBuffer, global::VkDebugMarkerMarkerInfoEXT pMarkerInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pMarkerInfo, null) ? global::System.IntPtr.Zero : pMarkerInfo.__Instance;
        __Internal.VkCmdDebugMarkerBeginEXT(__arg0, __arg1);
    }

    public static void VkCmdDebugMarkerEndEXT(global::VkCommandBufferT commandBuffer)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdDebugMarkerEndEXT(__arg0);
    }

    public static void VkCmdDebugMarkerInsertEXT(global::VkCommandBufferT commandBuffer, global::VkDebugMarkerMarkerInfoEXT pMarkerInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pMarkerInfo, null) ? global::System.IntPtr.Zero : pMarkerInfo.__Instance;
        __Internal.VkCmdDebugMarkerInsertEXT(__arg0, __arg1);
    }

    public static void VkCmdDrawIndirectCountAMD(global::VkCommandBufferT commandBuffer, global::VkBufferT buffer, ulong offset, global::VkBufferT countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        var __arg3 = ReferenceEquals(countBuffer, null) ? global::System.IntPtr.Zero : countBuffer.__Instance;
        __Internal.VkCmdDrawIndirectCountAMD(__arg0, __arg1, offset, __arg3, countBufferOffset, maxDrawCount, stride);
    }

    public static void VkCmdDrawIndexedIndirectCountAMD(global::VkCommandBufferT commandBuffer, global::VkBufferT buffer, ulong offset, global::VkBufferT countBuffer, ulong countBufferOffset, uint maxDrawCount, uint stride)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
        var __arg3 = ReferenceEquals(countBuffer, null) ? global::System.IntPtr.Zero : countBuffer.__Instance;
        __Internal.VkCmdDrawIndexedIndirectCountAMD(__arg0, __arg1, offset, __arg3, countBufferOffset, maxDrawCount, stride);
    }

    public static global::VkResult VkGetShaderInfoAMD(global::VkDeviceT device, global::VkPipelineT pipeline, global::VkShaderStageFlagBits shaderStage, global::VkShaderInfoTypeAMD infoType, ref ulong pInfoSize, global::System.IntPtr pInfo)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pipeline, null) ? global::System.IntPtr.Zero : pipeline.__Instance;
        fixed (ulong* __refParamPtr4 = &pInfoSize)
        {
            var __arg4 = __refParamPtr4;
            var __ret = __Internal.VkGetShaderInfoAMD(__arg0, __arg1, shaderStage, infoType, __arg4, pInfo);
            return __ret;
        }
    }

    public static global::VkResult VkGetPhysicalDeviceExternalImageFormatPropertiesNV(global::VkPhysicalDeviceT physicalDevice, global::VkFormat format, global::VkImageType type, global::VkImageTiling tiling, uint usage, uint flags, uint externalHandleType, global::VkExternalImageFormatPropertiesNV pExternalImageFormatProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg7 = ReferenceEquals(pExternalImageFormatProperties, null) ? global::System.IntPtr.Zero : pExternalImageFormatProperties.__Instance;
        var __ret = __Internal.VkGetPhysicalDeviceExternalImageFormatPropertiesNV(__arg0, format, type, tiling, usage, flags, externalHandleType, __arg7);
        return __ret;
    }

    public static void VkCmdBeginConditionalRenderingEXT(global::VkCommandBufferT commandBuffer, global::VkConditionalRenderingBeginInfoEXT pConditionalRenderingBegin)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pConditionalRenderingBegin, null) ? global::System.IntPtr.Zero : pConditionalRenderingBegin.__Instance;
        __Internal.VkCmdBeginConditionalRenderingEXT(__arg0, __arg1);
    }

    public static void VkCmdEndConditionalRenderingEXT(global::VkCommandBufferT commandBuffer)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdEndConditionalRenderingEXT(__arg0);
    }

    public static void VkCmdProcessCommandsNVX(global::VkCommandBufferT commandBuffer, global::VkCmdProcessCommandsInfoNVX pProcessCommandsInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pProcessCommandsInfo, null) ? global::System.IntPtr.Zero : pProcessCommandsInfo.__Instance;
        __Internal.VkCmdProcessCommandsNVX(__arg0, __arg1);
    }

    public static void VkCmdReserveSpaceForCommandsNVX(global::VkCommandBufferT commandBuffer, global::VkCmdReserveSpaceForCommandsInfoNVX pReserveSpaceInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pReserveSpaceInfo, null) ? global::System.IntPtr.Zero : pReserveSpaceInfo.__Instance;
        __Internal.VkCmdReserveSpaceForCommandsNVX(__arg0, __arg1);
    }

    public static global::VkResult VkCreateIndirectCommandsLayoutNVX(global::VkDeviceT device, global::VkIndirectCommandsLayoutCreateInfoNVX pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkIndirectCommandsLayoutNVX_T pIndirectCommandsLayout)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pIndirectCommandsLayout, null) ? global::System.IntPtr.Zero : pIndirectCommandsLayout.__Instance;
        var __ret = __Internal.VkCreateIndirectCommandsLayoutNVX(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyIndirectCommandsLayoutNVX(global::VkDeviceT device, global::VkIndirectCommandsLayoutNVX_T indirectCommandsLayout, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(indirectCommandsLayout, null) ? global::System.IntPtr.Zero : indirectCommandsLayout.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyIndirectCommandsLayoutNVX(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkCreateObjectTableNVX(global::VkDeviceT device, global::VkObjectTableCreateInfoNVX pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkObjectTableNVX_T pObjectTable)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pObjectTable, null) ? global::System.IntPtr.Zero : pObjectTable.__Instance;
        var __ret = __Internal.VkCreateObjectTableNVX(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyObjectTableNVX(global::VkDeviceT device, global::VkObjectTableNVX_T objectTable, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(objectTable, null) ? global::System.IntPtr.Zero : objectTable.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyObjectTableNVX(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkRegisterObjectsNVX(global::VkDeviceT device, global::VkObjectTableNVX_T objectTable, uint objectCount, global::VkObjectTableEntryNVX ppObjectTableEntries, ref uint pObjectIndices)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(objectTable, null) ? global::System.IntPtr.Zero : objectTable.__Instance;
        var __arg3 = ReferenceEquals(ppObjectTableEntries, null) ? global::System.IntPtr.Zero : ppObjectTableEntries.__Instance;
        fixed (uint* __refParamPtr4 = &pObjectIndices)
        {
            var __arg4 = __refParamPtr4;
            var __ret = __Internal.VkRegisterObjectsNVX(__arg0, __arg1, objectCount, __arg3, __arg4);
            return __ret;
        }
    }

    public static global::VkResult VkUnregisterObjectsNVX(global::VkDeviceT device, global::VkObjectTableNVX_T objectTable, uint objectCount, global::VkObjectEntryTypeNVX* pObjectEntryTypes, ref uint pObjectIndices)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(objectTable, null) ? global::System.IntPtr.Zero : objectTable.__Instance;
        fixed (uint* __refParamPtr4 = &pObjectIndices)
        {
            var __arg4 = __refParamPtr4;
            var __ret = __Internal.VkUnregisterObjectsNVX(__arg0, __arg1, objectCount, pObjectEntryTypes, __arg4);
            return __ret;
        }
    }

    public static void VkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(global::VkPhysicalDeviceT physicalDevice, global::VkDeviceGeneratedCommandsFeaturesNVX pFeatures, global::VkDeviceGeneratedCommandsLimitsNVX pLimits)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(pFeatures, null) ? global::System.IntPtr.Zero : pFeatures.__Instance;
        var __arg2 = ReferenceEquals(pLimits, null) ? global::System.IntPtr.Zero : pLimits.__Instance;
        __Internal.VkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(__arg0, __arg1, __arg2);
    }

    public static void VkCmdSetViewportWScalingNV(global::VkCommandBufferT commandBuffer, uint firstViewport, uint viewportCount, global::VkViewportWScalingNV pViewportWScalings)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg3 = ReferenceEquals(pViewportWScalings, null) ? global::System.IntPtr.Zero : pViewportWScalings.__Instance;
        __Internal.VkCmdSetViewportWScalingNV(__arg0, firstViewport, viewportCount, __arg3);
    }

    public static global::VkResult VkReleaseDisplayEXT(global::VkPhysicalDeviceT physicalDevice, global::VkDisplayKHR_T display)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(display, null) ? global::System.IntPtr.Zero : display.__Instance;
        var __ret = __Internal.VkReleaseDisplayEXT(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkGetPhysicalDeviceSurfaceCapabilities2EXT(global::VkPhysicalDeviceT physicalDevice, global::VkSurfaceKHR_T surface, global::VkSurfaceCapabilities2EXT pSurfaceCapabilities)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg1 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
        var __arg2 = ReferenceEquals(pSurfaceCapabilities, null) ? global::System.IntPtr.Zero : pSurfaceCapabilities.__Instance;
        var __ret = __Internal.VkGetPhysicalDeviceSurfaceCapabilities2EXT(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static global::VkResult VkDisplayPowerControlEXT(global::VkDeviceT device, global::VkDisplayKHR_T display, global::VkDisplayPowerInfoEXT pDisplayPowerInfo)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(display, null) ? global::System.IntPtr.Zero : display.__Instance;
        var __arg2 = ReferenceEquals(pDisplayPowerInfo, null) ? global::System.IntPtr.Zero : pDisplayPowerInfo.__Instance;
        var __ret = __Internal.VkDisplayPowerControlEXT(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static global::VkResult VkRegisterDeviceEventEXT(global::VkDeviceT device, global::VkDeviceEventInfoEXT pDeviceEventInfo, global::VkAllocationCallbacks pAllocator, global::VkFenceT pFence)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pDeviceEventInfo, null) ? global::System.IntPtr.Zero : pDeviceEventInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pFence, null) ? global::System.IntPtr.Zero : pFence.__Instance;
        var __ret = __Internal.VkRegisterDeviceEventEXT(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static global::VkResult VkRegisterDisplayEventEXT(global::VkDeviceT device, global::VkDisplayKHR_T display, global::VkDisplayEventInfoEXT pDisplayEventInfo, global::VkAllocationCallbacks pAllocator, global::VkFenceT pFence)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(display, null) ? global::System.IntPtr.Zero : display.__Instance;
        var __arg2 = ReferenceEquals(pDisplayEventInfo, null) ? global::System.IntPtr.Zero : pDisplayEventInfo.__Instance;
        var __arg3 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg4 = ReferenceEquals(pFence, null) ? global::System.IntPtr.Zero : pFence.__Instance;
        var __ret = __Internal.VkRegisterDisplayEventEXT(__arg0, __arg1, __arg2, __arg3, __arg4);
        return __ret;
    }

    public static global::VkResult VkGetSwapchainCounterEXT(global::VkDeviceT device, global::VkSwapchainKHR_T swapchain, global::VkSurfaceCounterFlagBitsEXT counter, ref ulong pCounterValue)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(swapchain, null) ? global::System.IntPtr.Zero : swapchain.__Instance;
        fixed (ulong* __refParamPtr3 = &pCounterValue)
        {
            var __arg3 = __refParamPtr3;
            var __ret = __Internal.VkGetSwapchainCounterEXT(__arg0, __arg1, counter, __arg3);
            return __ret;
        }
    }

    public static global::VkResult VkGetRefreshCycleDurationGOOGLE(global::VkDeviceT device, global::VkSwapchainKHR_T swapchain, global::VkRefreshCycleDurationGOOGLE pDisplayTimingProperties)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(swapchain, null) ? global::System.IntPtr.Zero : swapchain.__Instance;
        var __arg2 = ReferenceEquals(pDisplayTimingProperties, null) ? global::System.IntPtr.Zero : pDisplayTimingProperties.__Instance;
        var __ret = __Internal.VkGetRefreshCycleDurationGOOGLE(__arg0, __arg1, __arg2);
        return __ret;
    }

    public static global::VkResult VkGetPastPresentationTimingGOOGLE(global::VkDeviceT device, global::VkSwapchainKHR_T swapchain, ref uint pPresentationTimingCount, global::VkPastPresentationTimingGOOGLE pPresentationTimings)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(swapchain, null) ? global::System.IntPtr.Zero : swapchain.__Instance;
        fixed (uint* __refParamPtr2 = &pPresentationTimingCount)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(pPresentationTimings, null) ? global::System.IntPtr.Zero : pPresentationTimings.__Instance;
            var __ret = __Internal.VkGetPastPresentationTimingGOOGLE(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }
    }

    public static void VkCmdSetDiscardRectangleEXT(global::VkCommandBufferT commandBuffer, uint firstDiscardRectangle, uint discardRectangleCount, global::VkRect2D pDiscardRectangles)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg3 = ReferenceEquals(pDiscardRectangles, null) ? global::System.IntPtr.Zero : pDiscardRectangles.__Instance;
        __Internal.VkCmdSetDiscardRectangleEXT(__arg0, firstDiscardRectangle, discardRectangleCount, __arg3);
    }

    public static void VkSetHdrMetadataEXT(global::VkDeviceT device, uint swapchainCount, global::VkSwapchainKHR_T pSwapchains, global::VkHdrMetadataEXT pMetadata)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg2 = ReferenceEquals(pSwapchains, null) ? global::System.IntPtr.Zero : pSwapchains.__Instance;
        var __arg3 = ReferenceEquals(pMetadata, null) ? global::System.IntPtr.Zero : pMetadata.__Instance;
        __Internal.VkSetHdrMetadataEXT(__arg0, swapchainCount, __arg2, __arg3);
    }

    public static global::VkResult VkSetDebugUtilsObjectNameEXT(global::VkDeviceT device, global::VkDebugUtilsObjectNameInfoEXT pNameInfo)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pNameInfo, null) ? global::System.IntPtr.Zero : pNameInfo.__Instance;
        var __ret = __Internal.VkSetDebugUtilsObjectNameEXT(__arg0, __arg1);
        return __ret;
    }

    public static global::VkResult VkSetDebugUtilsObjectTagEXT(global::VkDeviceT device, global::VkDebugUtilsObjectTagInfoEXT pTagInfo)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pTagInfo, null) ? global::System.IntPtr.Zero : pTagInfo.__Instance;
        var __ret = __Internal.VkSetDebugUtilsObjectTagEXT(__arg0, __arg1);
        return __ret;
    }

    public static void VkQueueBeginDebugUtilsLabelEXT(global::VkQueueT queue, global::VkDebugUtilsLabelEXT pLabelInfo)
    {
        var __arg0 = ReferenceEquals(queue, null) ? global::System.IntPtr.Zero : queue.__Instance;
        var __arg1 = ReferenceEquals(pLabelInfo, null) ? global::System.IntPtr.Zero : pLabelInfo.__Instance;
        __Internal.VkQueueBeginDebugUtilsLabelEXT(__arg0, __arg1);
    }

    public static void VkQueueEndDebugUtilsLabelEXT(global::VkQueueT queue)
    {
        var __arg0 = ReferenceEquals(queue, null) ? global::System.IntPtr.Zero : queue.__Instance;
        __Internal.VkQueueEndDebugUtilsLabelEXT(__arg0);
    }

    public static void VkQueueInsertDebugUtilsLabelEXT(global::VkQueueT queue, global::VkDebugUtilsLabelEXT pLabelInfo)
    {
        var __arg0 = ReferenceEquals(queue, null) ? global::System.IntPtr.Zero : queue.__Instance;
        var __arg1 = ReferenceEquals(pLabelInfo, null) ? global::System.IntPtr.Zero : pLabelInfo.__Instance;
        __Internal.VkQueueInsertDebugUtilsLabelEXT(__arg0, __arg1);
    }

    public static void VkCmdBeginDebugUtilsLabelEXT(global::VkCommandBufferT commandBuffer, global::VkDebugUtilsLabelEXT pLabelInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pLabelInfo, null) ? global::System.IntPtr.Zero : pLabelInfo.__Instance;
        __Internal.VkCmdBeginDebugUtilsLabelEXT(__arg0, __arg1);
    }

    public static void VkCmdEndDebugUtilsLabelEXT(global::VkCommandBufferT commandBuffer)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdEndDebugUtilsLabelEXT(__arg0);
    }

    public static void VkCmdInsertDebugUtilsLabelEXT(global::VkCommandBufferT commandBuffer, global::VkDebugUtilsLabelEXT pLabelInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pLabelInfo, null) ? global::System.IntPtr.Zero : pLabelInfo.__Instance;
        __Internal.VkCmdInsertDebugUtilsLabelEXT(__arg0, __arg1);
    }

    public static global::VkResult VkCreateDebugUtilsMessengerEXT(global::VkInstanceT instance, global::VkDebugUtilsMessengerCreateInfoEXT pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkDebugUtilsMessengerEXT_T pMessenger)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pMessenger, null) ? global::System.IntPtr.Zero : pMessenger.__Instance;
        var __ret = __Internal.VkCreateDebugUtilsMessengerEXT(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyDebugUtilsMessengerEXT(global::VkInstanceT instance, global::VkDebugUtilsMessengerEXT_T messenger, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        var __arg1 = ReferenceEquals(messenger, null) ? global::System.IntPtr.Zero : messenger.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyDebugUtilsMessengerEXT(__arg0, __arg1, __arg2);
    }

    public static void VkSubmitDebugUtilsMessageEXT(global::VkInstanceT instance, global::VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, uint messageTypes, global::VkDebugUtilsMessengerCallbackDataEXT pCallbackData)
    {
        var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
        var __arg3 = ReferenceEquals(pCallbackData, null) ? global::System.IntPtr.Zero : pCallbackData.__Instance;
        __Internal.VkSubmitDebugUtilsMessageEXT(__arg0, messageSeverity, messageTypes, __arg3);
    }

    public static void VkCmdSetSampleLocationsEXT(global::VkCommandBufferT commandBuffer, global::VkSampleLocationsInfoEXT pSampleLocationsInfo)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg1 = ReferenceEquals(pSampleLocationsInfo, null) ? global::System.IntPtr.Zero : pSampleLocationsInfo.__Instance;
        __Internal.VkCmdSetSampleLocationsEXT(__arg0, __arg1);
    }

    public static void VkGetPhysicalDeviceMultisamplePropertiesEXT(global::VkPhysicalDeviceT physicalDevice, global::VkSampleCountFlagBits samples, global::VkMultisamplePropertiesEXT pMultisampleProperties)
    {
        var __arg0 = ReferenceEquals(physicalDevice, null) ? global::System.IntPtr.Zero : physicalDevice.__Instance;
        var __arg2 = ReferenceEquals(pMultisampleProperties, null) ? global::System.IntPtr.Zero : pMultisampleProperties.__Instance;
        __Internal.VkGetPhysicalDeviceMultisamplePropertiesEXT(__arg0, samples, __arg2);
    }

    public static global::VkResult VkCreateValidationCacheEXT(global::VkDeviceT device, global::VkValidationCacheCreateInfoEXT pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkValidationCacheEXT_T pValidationCache)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        var __arg3 = ReferenceEquals(pValidationCache, null) ? global::System.IntPtr.Zero : pValidationCache.__Instance;
        var __ret = __Internal.VkCreateValidationCacheEXT(__arg0, __arg1, __arg2, __arg3);
        return __ret;
    }

    public static void VkDestroyValidationCacheEXT(global::VkDeviceT device, global::VkValidationCacheEXT_T validationCache, global::VkAllocationCallbacks pAllocator)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(validationCache, null) ? global::System.IntPtr.Zero : validationCache.__Instance;
        var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
        __Internal.VkDestroyValidationCacheEXT(__arg0, __arg1, __arg2);
    }

    public static global::VkResult VkMergeValidationCachesEXT(global::VkDeviceT device, global::VkValidationCacheEXT_T dstCache, uint srcCacheCount, global::VkValidationCacheEXT_T pSrcCaches)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(dstCache, null) ? global::System.IntPtr.Zero : dstCache.__Instance;
        var __arg3 = ReferenceEquals(pSrcCaches, null) ? global::System.IntPtr.Zero : pSrcCaches.__Instance;
        var __ret = __Internal.VkMergeValidationCachesEXT(__arg0, __arg1, srcCacheCount, __arg3);
        return __ret;
    }

    public static global::VkResult VkGetValidationCacheDataEXT(global::VkDeviceT device, global::VkValidationCacheEXT_T validationCache, ref ulong pDataSize, global::System.IntPtr pData)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg1 = ReferenceEquals(validationCache, null) ? global::System.IntPtr.Zero : validationCache.__Instance;
        fixed (ulong* __refParamPtr2 = &pDataSize)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.VkGetValidationCacheDataEXT(__arg0, __arg1, __arg2, pData);
            return __ret;
        }
    }

    public static global::VkResult VkGetMemoryHostPointerPropertiesEXT(global::VkDeviceT device, global::VkExternalMemoryHandleTypeFlagBits handleType, global::System.IntPtr pHostPointer, global::VkMemoryHostPointerPropertiesEXT pMemoryHostPointerProperties)
    {
        var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
        var __arg3 = ReferenceEquals(pMemoryHostPointerProperties, null) ? global::System.IntPtr.Zero : pMemoryHostPointerProperties.__Instance;
        var __ret = __Internal.VkGetMemoryHostPointerPropertiesEXT(__arg0, handleType, pHostPointer, __arg3);
        return __ret;
    }

    public static void VkCmdWriteBufferMarkerAMD(global::VkCommandBufferT commandBuffer, global::VkPipelineStageFlagBits pipelineStage, global::VkBufferT dstBuffer, ulong dstOffset, uint marker)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        var __arg2 = ReferenceEquals(dstBuffer, null) ? global::System.IntPtr.Zero : dstBuffer.__Instance;
        __Internal.VkCmdWriteBufferMarkerAMD(__arg0, pipelineStage, __arg2, dstOffset, marker);
    }

    public static void VkCmdSetCheckpointNV(global::VkCommandBufferT commandBuffer, global::System.IntPtr pCheckpointMarker)
    {
        var __arg0 = ReferenceEquals(commandBuffer, null) ? global::System.IntPtr.Zero : commandBuffer.__Instance;
        __Internal.VkCmdSetCheckpointNV(__arg0, pCheckpointMarker);
    }

    public static void VkGetQueueCheckpointDataNV(global::VkQueueT queue, ref uint pCheckpointDataCount, global::VkCheckpointDataNV pCheckpointData)
    {
        var __arg0 = ReferenceEquals(queue, null) ? global::System.IntPtr.Zero : queue.__Instance;
        fixed (uint* __refParamPtr1 = &pCheckpointDataCount)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(pCheckpointData, null) ? global::System.IntPtr.Zero : pCheckpointData.__Instance;
            __Internal.VkGetQueueCheckpointDataNV(__arg0, __arg1, __arg2);
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class CommandBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::VkQueueFlagBits m_queueType;

            [FieldOffset(4)]
            internal global::VkCommandBufferLevel m_bufferLevel;

            [FieldOffset(8)]
            internal global::System.IntPtr m_commandBuffer;

            [FieldOffset(16)]
            internal byte m_running;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CommandBuffer@acid@@QEAA@AEB_NAEBW4VkQueueFlagBits@@AEBW4VkCommandBufferLevel@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool begin, global::VkQueueFlagBits queueType, global::VkCommandBufferLevel bufferLevel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CommandBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1CommandBuffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Begin@CommandBuffer@acid@@QEAAXAEBI@Z")]
            internal static extern void Begin(global::System.IntPtr instance, uint usage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?End@CommandBuffer@acid@@QEAAXXZ")]
            internal static extern void End(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Submit@CommandBuffer@acid@@QEAAXPEAUVkSemaphore_T@@PEAUVkFence_T@@AEB_N@Z")]
            internal static extern void Submit(global::System.IntPtr instance, global::System.IntPtr signalSemaphore, global::System.IntPtr fence, bool createFence);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRunning@CommandBuffer@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsRunning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCommandBuffer@CommandBuffer@acid@@QEBAPEAUVkCommandBuffer_T@@XZ")]
            internal static extern global::System.IntPtr GetCommandBuffer(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.CommandBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.CommandBuffer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.CommandBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.CommandBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.CommandBuffer __CreateInstance(global::AcidSharp.CommandBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.CommandBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.CommandBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.CommandBuffer.__Internal));
            *(global::AcidSharp.CommandBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CommandBuffer(global::AcidSharp.CommandBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CommandBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CommandBuffer(bool begin = true, global::VkQueueFlagBits queueType = global::VkQueueFlagBits.VkQueueGraphicsBit, global::VkCommandBufferLevel bufferLevel = global::VkCommandBufferLevel.VkCommandBufferLevelPrimary)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.CommandBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), begin, queueType, bufferLevel);
        }

        public CommandBuffer(global::AcidSharp.CommandBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.CommandBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.CommandBuffer.__Internal*) __Instance) = *((global::AcidSharp.CommandBuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.CommandBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Begin(uint usage = (uint) global::VkCommandBufferUsageFlagBits.VkCommandBufferUsageOneTimeSubmitBit)
        {
            __Internal.Begin((__Instance + __PointerAdjustment), usage);
        }

        public void End()
        {
            __Internal.End((__Instance + __PointerAdjustment));
        }

        public void Submit(global::VkSemaphoreT signalSemaphore = default(global::VkSemaphoreT), global::VkFenceT fence = default(global::VkFenceT), bool createFence = true)
        {
            var __arg0 = ReferenceEquals(signalSemaphore, null) ? global::System.IntPtr.Zero : signalSemaphore.__Instance;
            var __arg1 = ReferenceEquals(fence, null) ? global::System.IntPtr.Zero : fence.__Instance;
            __Internal.Submit((__Instance + __PointerAdjustment), __arg0, __arg1, createFence);
        }

        public static implicit operator global::AcidSharp.CommandBuffer(bool begin)
        {
            return new global::AcidSharp.CommandBuffer(begin);
        }

        public bool IsRunning
        {
            get
            {
                var __ret = __Internal.IsRunning((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::VkCommandBufferT CommandBuffer
        {
            get
            {
                var __ret = __Internal.GetCommandBuffer((__Instance + __PointerAdjustment));
                global::VkCommandBufferT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkCommandBufferT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkCommandBufferT) global::VkCommandBufferT.NativeToManagedMap[__ret];
                else __result0 = global::VkCommandBufferT.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Represents when a module will update in the game loop.</summary>
    public enum ModuleUpdate
    {
        UpdateAlways = 0,
        UpdatePre = 1,
        UpdateNormal = 2,
        UpdatePost = 3,
        UpdateRender = 4
    }

    /// <summary>A interface used for defining engine modules.</summary>
    public unsafe abstract partial class IModule : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IModule> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IModule>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IModule __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IModuleInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IModule __CreateInstance(global::AcidSharp.IModule.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IModuleInternal(native, skipVTables);
        }

        protected IModule(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IModule(global::AcidSharp.IModule _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IModule");
        }

        protected IModule()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.IModule");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IModule.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the module.</summary>
        public abstract void Update();

        #region Virtual table interop

        // void Update() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IModule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IModuleInternal : global::AcidSharp.IModule, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IModule.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IModule.__Internal));
            *(global::AcidSharp.IModule.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IModuleInternal(global::AcidSharp.IModule.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IModuleInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>The update function for the module.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }
    }
}

namespace AcidSharp
{
    /// <summary>A logging class used in Acid, will write output to a file one the application has closed.</summary>
    public unsafe partial class Log : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Log@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Out@Log@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void Out(global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Error@Log@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void Error(global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateLog@Log@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void CreateLog(global::System.IntPtr filename);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Log> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Log>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Log __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Log(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Log __CreateInstance(global::AcidSharp.Log.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Log(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Log.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Log.__Internal));
            *(global::AcidSharp.Log.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Log(global::AcidSharp.Log.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Log(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Log()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Log.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Log(global::AcidSharp.Log _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Log.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.Log.__Internal*) __Instance) = *((global::AcidSharp.Log.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Log __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Outputs a message into the console.</summary>
        /// <param name="string">The string to output.</param>
        public static void Out(string @string)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(@string, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.Out(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Outputs a error into the console.</summary>
        /// <param name="string">The string to output.</param>
        public static void Error(string @string)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(@string, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.Error(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Outputs all logs into a file.</summary>
        /// <param name="filename">The filename to output into.</param>
        public static void CreateLog(string filename)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.CreateLog(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }
    }
}

namespace AcidSharp
{
    /// <summary>The default updater for the engine.</summary>
    public unsafe partial class ModuleRegister : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Map.__Internalc__N_std_S_map__f___N_std_S_unique_ptr____N_acid_S_IModule___N_std_S_default_delete__S1____N_std_S_less__f___N_std_S_allocator____N_std_S_pair__1f_S0_ m_modules;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModuleRegister@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FillRegister@ModuleRegister@acid@@QEAAXXZ")]
            internal static extern void FillRegister(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ContainsModule@ModuleRegister@acid@@QEBA_NPEAVIModule@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ContainsModule(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RegisterModule@ModuleRegister@acid@@QEAAPEAVIModule@2@PEAV32@AEBW4ModuleUpdate@2@@Z")]
            internal static extern global::System.IntPtr RegisterModule(global::System.IntPtr instance, global::System.IntPtr module, global::AcidSharp.ModuleUpdate update);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@ModuleRegister@acid@@QEAA_NPEAVIModule@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterModule(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RunUpdate@ModuleRegister@acid@@QEBAXAEBW4ModuleUpdate@2@@Z")]
            internal static extern void RunUpdate(global::System.IntPtr instance, global::AcidSharp.ModuleUpdate update);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModuleCount@ModuleRegister@acid@@QEBAIXZ")]
            internal static extern uint GetModuleCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ModuleRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ModuleRegister>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.ModuleRegister __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ModuleRegister(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ModuleRegister __CreateInstance(global::AcidSharp.ModuleRegister.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ModuleRegister(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ModuleRegister.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ModuleRegister.__Internal));
            global::AcidSharp.ModuleRegister.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ModuleRegister(global::AcidSharp.ModuleRegister.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new module register.</summary>
        public ModuleRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ModuleRegister(global::AcidSharp.ModuleRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ModuleRegister __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Fills the module register with default modules.</summary>
        public void FillRegister()
        {
            __Internal.FillRegister((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets if a module is contained in this registry.</summary>
        /// <param name="module">The module to find.</param>
        public bool ContainsModule(global::AcidSharp.IModule module)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.ContainsModule((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Registers a module with the register.</summary>
        /// <param name="module">The modules object.</param>
        /// <param name="update">The modules update type.</param>
        public global::AcidSharp.IModule RegisterModule(global::AcidSharp.IModule module, global::AcidSharp.ModuleUpdate update)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.RegisterModule((__Instance + __PointerAdjustment), __arg0, update);
            global::AcidSharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.IModule) global::AcidSharp.IModule.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="module">The module to deregister.</param>
        public bool DeregisterModule(global::AcidSharp.IModule module)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Runs updates for all module update types.</summary>
        /// <param name="update">The modules update type.</param>
        public void RunUpdate(global::AcidSharp.ModuleUpdate update)
        {
            __Internal.RunUpdate((__Instance + __PointerAdjustment), update);
        }

        public uint ModuleCount
        {
            get
            {
                var __ret = __Internal.GetModuleCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A class for handing and calculating deltas.</summary>
    public unsafe partial class Delta : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_currentFrameTime;

            [FieldOffset(4)]
            internal float m_lastFrameTime;

            [FieldOffset(8)]
            internal float m_change;

            [FieldOffset(12)]
            internal float m_time;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Delta@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Delta@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Delta@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Delta@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChange@Delta@acid@@QEBAMXZ")]
            internal static extern float GetChange(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Delta@acid@@QEBAMXZ")]
            internal static extern float GetTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Delta> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Delta>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Delta __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Delta(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Delta __CreateInstance(global::AcidSharp.Delta.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Delta(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Delta.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Delta.__Internal));
            *(global::AcidSharp.Delta.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Delta(global::AcidSharp.Delta.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Delta(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new change handler.</summary>
        public Delta()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Delta.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Delta(global::AcidSharp.Delta _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Delta.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.Delta.__Internal*) __Instance) = *((global::AcidSharp.Delta.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Delta __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates change and times.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public float Change
        {
            get
            {
                var __ret = __Internal.GetChange((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Time
        {
            get
            {
                var __ret = __Internal.GetTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A timer implementation for events.</summary>
    public unsafe partial class Timer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_startTime;

            [FieldOffset(4)]
            internal float m_interval;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Timer@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Timer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Timer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ResetStartTime@Timer@acid@@QEAAXXZ")]
            internal static extern void ResetStartTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInterval@Timer@acid@@QEBAMXZ")]
            internal static extern float GetInterval(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInterval@Timer@acid@@QEAAXAEBM@Z")]
            internal static extern void SetInterval(global::System.IntPtr instance, float interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsPassedTime@Timer@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPassedTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Timer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Timer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Timer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Timer(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Timer __CreateInstance(global::AcidSharp.Timer.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Timer(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Timer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Timer.__Internal));
            *(global::AcidSharp.Timer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Timer(global::AcidSharp.Timer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Timer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new timer.</summary>
        /// <param name="interval">The time between events (seconds).</param>
        public Timer(float interval)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Timer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), interval);
        }

        public Timer(global::AcidSharp.Timer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Timer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.Timer.__Internal*) __Instance) = *((global::AcidSharp.Timer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Timer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds the intervals value to the start time.</summary>
        public void ResetStartTime()
        {
            __Internal.ResetStartTime((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::AcidSharp.Timer(float interval)
        {
            return new global::AcidSharp.Timer(interval);
        }

        /// <summary>Gets what the interval is. (Seconds).</summary>
        /// <param name="interval">The new timer interval.</param>
        /// <remarks>Gets the timers interval. (Seconds, Resets timer).</remarks>
        public float Interval
        {
            get
            {
                var __ret = __Internal.GetInterval((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetInterval((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets if the interval has been passes for the timer.</summary>
        public bool IsPassedTime
        {
            get
            {
                var __ret = __Internal.IsPassedTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A class used to define how the engine will run updates and timings on modules.</summary>
    public unsafe partial class ModuleUpdater : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Delta.__Internal m_deltaUpdate;

            [FieldOffset(16)]
            internal global::AcidSharp.Delta.__Internal m_deltaRender;

            [FieldOffset(32)]
            internal global::AcidSharp.Timer.__Internal m_timerUpdate;

            [FieldOffset(40)]
            internal global::AcidSharp.Timer.__Internal m_timerRender;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleUpdater@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleUpdater@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModuleUpdater@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@ModuleUpdater@acid@@QEAAXAEBVModuleRegister@2@@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr moduleRegister);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelta@ModuleUpdater@acid@@QEBAMXZ")]
            internal static extern float GetDelta(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaRender@ModuleUpdater@acid@@QEBAMXZ")]
            internal static extern float GetDeltaRender(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ModuleUpdater> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ModuleUpdater>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.ModuleUpdater __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ModuleUpdater(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ModuleUpdater __CreateInstance(global::AcidSharp.ModuleUpdater.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ModuleUpdater(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ModuleUpdater.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ModuleUpdater.__Internal));
            *(global::AcidSharp.ModuleUpdater.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModuleUpdater(global::AcidSharp.ModuleUpdater.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleUpdater(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new updater.</summary>
        public ModuleUpdater()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ModuleUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ModuleUpdater(global::AcidSharp.ModuleUpdater _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ModuleUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.ModuleUpdater.__Internal*) __Instance) = *((global::AcidSharp.ModuleUpdater.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ModuleUpdater __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates all modules in order.</summary>
        public void Update(global::AcidSharp.ModuleRegister moduleRegister)
        {
            if (ReferenceEquals(moduleRegister, null))
                throw new global::System.ArgumentNullException("moduleRegister", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = moduleRegister.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public float Delta
        {
            get
            {
                var __ret = __Internal.GetDelta((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public float DeltaRender
        {
            get
            {
                var __ret = __Internal.GetDeltaRender((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Main class for Acid, manages modules and updates. After creating your Engine object call  to start.</summary>
    public unsafe partial class Engine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Chrono.TimePoint.__Internalc__N_std_N_chrono_S_time_point____N_std_N_chrono_S_steady_clock___N_std_N_chrono_S_duration__K___N_std_S_ratio__VK1_VK1000000000 m_start;

            [FieldOffset(8)]
            internal float m_timeOffset;

            [FieldOffset(16)]
            internal global::AcidSharp.ModuleRegister.__Internal m_moduleRegister;

            [FieldOffset(32)]
            internal global::AcidSharp.ModuleUpdater.__Internal m_moduleUpdater;

            [FieldOffset(80)]
            internal float m_fpsLimit;

            [FieldOffset(84)]
            internal byte m_initialized;

            [FieldOffset(85)]
            internal byte m_running;

            [FieldOffset(86)]
            internal byte m_error;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@acid@@QEAA@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool emptyRegister);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Engine@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Engine@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Run@Engine@acid@@QEAAHXZ")]
            internal static extern int Run(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RegisterModule@Engine@acid@@QEAAPEAVIModule@2@PEAV32@AEBW4ModuleUpdate@2@@Z")]
            internal static extern global::System.IntPtr RegisterModule(global::System.IntPtr instance, global::System.IntPtr module, global::AcidSharp.ModuleUpdate update);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@Engine@acid@@QEAA_NPEAVIModule@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterModule(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInitialized@Engine@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetInitialized(global::System.IntPtr instance, bool initialized);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RequestClose@Engine@acid@@QEAAXAEB_N@Z")]
            internal static extern void RequestClose(global::System.IntPtr instance, bool error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeOffset@Engine@acid@@QEBAMXZ")]
            internal static extern float GetTimeOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTimeOffset@Engine@acid@@QEAAXAEBM@Z")]
            internal static extern void SetTimeOffset(global::System.IntPtr instance, float timeOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFpsLimit@Engine@acid@@QEBAMXZ")]
            internal static extern float GetFpsLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFpsLimit@Engine@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFpsLimit(global::System.IntPtr instance, float fpsLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelta@Engine@acid@@QEBAMXZ")]
            internal static extern float GetDelta(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaRender@Engine@acid@@QEBAMXZ")]
            internal static extern float GetDeltaRender(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeMs@Engine@acid@@QEBAMXZ")]
            internal static extern float GetTimeMs(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Engine@acid@@QEBAMXZ")]
            internal static extern float GetTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInitialized@Engine@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsInitialized(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRunning@Engine@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsRunning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDateTime@Engine@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetDateTime(global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Engine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Engine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Engine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Engine(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Engine __CreateInstance(global::AcidSharp.Engine.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Engine(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Engine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Engine.__Internal));
            global::AcidSharp.Engine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Engine(global::AcidSharp.Engine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Engine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Carries out the setup for basic engine components and the engine. Call  after creating a instance.</summary>
        /// <param name="emptyRegister">If the module register will start empty.</param>
        public Engine(bool emptyRegister = false)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), emptyRegister);
        }

        public Engine(global::AcidSharp.Engine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Engine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the updater.</summary>
        public int Run()
        {
            var __ret = __Internal.Run((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Registers a module with the register.</summary>
        /// <param name="module">The modules object.</param>
        /// <param name="update">The modules update type.</param>
        public global::AcidSharp.IModule RegisterModule(global::AcidSharp.IModule module, global::AcidSharp.ModuleUpdate update)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.RegisterModule((__Instance + __PointerAdjustment), __arg0, update);
            global::AcidSharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.IModule) global::AcidSharp.IModule.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="module">The module to deregister.</param>
        public bool DeregisterModule(global::AcidSharp.IModule module)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Sets if the engine has been initialized.</summary>
        /// <param name="initialized">If the engine has been initialized.</param>
        public void SetInitialized(bool initialized)
        {
            __Internal.SetInitialized((__Instance + __PointerAdjustment), initialized);
        }

        /// <summary>Requests the engine to delete and stop the gameloop.</summary>
        /// <param name="error">If a bad error occured.</param>
        public void RequestClose(bool error)
        {
            __Internal.RequestClose((__Instance + __PointerAdjustment), error);
        }

        public static implicit operator global::AcidSharp.Engine(bool emptyRegister)
        {
            return new global::AcidSharp.Engine(emptyRegister);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::AcidSharp.Engine Get()
        {
            var __ret = __Internal.Get();
            global::AcidSharp.Engine __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Engine.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Engine) global::AcidSharp.Engine.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Engine.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the added/removed time for the engine (seconds).</summary>
        /// <param name="timeOffset">The new time offset.</param>
        /// <remarks>Sets the time offset for the engine (seconds).</remarks>
        public float TimeOffset
        {
            get
            {
                var __ret = __Internal.GetTimeOffset((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetTimeOffset((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the fps limit.</summary>
        /// <param name="fpsLimit">The new fps limit.</param>
        /// <remarks>Sets the fps limit. -1 disables limits.</remarks>
        public float FpsLimit
        {
            get
            {
                var __ret = __Internal.GetFpsLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFpsLimit((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public float Delta
        {
            get
            {
                var __ret = __Internal.GetDelta((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public float DeltaRender
        {
            get
            {
                var __ret = __Internal.GetDeltaRender((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public float TimeMs
        {
            get
            {
                var __ret = __Internal.GetTimeMs((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public float Time
        {
            get
            {
                var __ret = __Internal.GetTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the engine has been initialized.</summary>
        public bool IsInitialized
        {
            get
            {
                var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the engine is running.</summary>
        public bool IsRunning
        {
            get
            {
                var __ret = __Internal.IsRunning((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current date time as a string. &quot;%d-%m-%Y %I:%M:%S&quot;</summary>
        public static string DateTime
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetDateTime(new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A module used for managing files on engine updates.</summary>
    public unsafe partial class Files : global::AcidSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Files@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Files@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Files@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Files@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddSearchPath@Files@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void AddSearchPath(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SearchFile@Files@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void SearchFile(global::System.IntPtr @return, global::System.IntPtr filename);
        }

        internal static new global::AcidSharp.Files __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Files(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Files __CreateInstance(global::AcidSharp.Files.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Files(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Files.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Files.__Internal));
            global::AcidSharp.Files.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Files(global::AcidSharp.Files.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Files(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Files()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Files.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.Files");
        }

        public Files(global::AcidSharp.Files _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Files.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Files");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Files.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::AcidSharp.Files Get()
        {
            var __ret = __Internal.Get();
            global::AcidSharp.Files __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Files.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Files) global::AcidSharp.Files.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Files.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Adds an file search path.</summary>
        /// <param name="path">The task to add.</param>
        public static void AddSearchPath(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.AddSearchPath(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Find a file by partial path in a search path.</summary>
        /// <param name="filename">The filename to find.</param>
        public static string SearchFile(string filename)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.SearchFile(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        #region Virtual table interop

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Files) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public enum PipelineMode
    {
        PipelineModePolygon = 0,
        PipelineModePolygonNoDepth = 1,
        PipelineModeMrt = 2,
        PipelineModeMrtNoDepth = 3,
        PipelineModeCompute = 4
    }

    public unsafe partial class GraphicsStage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_renderpass;

            [FieldOffset(4)]
            internal uint m_subpass;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GraphicsStage@acid@@QEAA@AEBI0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint renderpass, uint subpass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GraphicsStage@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8GraphicsStage@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9GraphicsStage@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRenderpass@GraphicsStage@acid@@QEBAIXZ")]
            internal static extern uint GetRenderpass(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSubpass@GraphicsStage@acid@@QEBAIXZ")]
            internal static extern uint GetSubpass(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.GraphicsStage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.GraphicsStage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.GraphicsStage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.GraphicsStage(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.GraphicsStage __CreateInstance(global::AcidSharp.GraphicsStage.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.GraphicsStage(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.GraphicsStage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.GraphicsStage.__Internal));
            *(global::AcidSharp.GraphicsStage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GraphicsStage(global::AcidSharp.GraphicsStage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GraphicsStage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GraphicsStage(uint renderpass, uint subpass)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.GraphicsStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), renderpass, subpass);
        }

        public GraphicsStage(global::AcidSharp.GraphicsStage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.GraphicsStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.GraphicsStage.__Internal*) __Instance) = *((global::AcidSharp.GraphicsStage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.GraphicsStage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator ==(global::AcidSharp.GraphicsStage __op, global::AcidSharp.GraphicsStage other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.GraphicsStage;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.GraphicsStage.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.GraphicsStage __op, global::AcidSharp.GraphicsStage other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public uint Renderpass
        {
            get
            {
                var __ret = __Internal.GetRenderpass((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Subpass
        {
            get
            {
                var __ret = __Internal.GetSubpass((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class VertexInput : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkVertexInputBindingDescription___N_std_S_allocator__S0_ m_bindingDescriptions;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkVertexInputAttributeDescription___N_std_S_allocator__S0_ m_attributeDescriptions;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexInput@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexInput@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.VertexInput> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.VertexInput>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.VertexInput __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexInput(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.VertexInput __CreateInstance(global::AcidSharp.VertexInput.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexInput(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.VertexInput.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexInput.__Internal));
            global::AcidSharp.VertexInput.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexInput(global::AcidSharp.VertexInput.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexInput(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexInput(global::AcidSharp.VertexInput _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexInput.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.VertexInput __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class DescriptorType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_binding;

            [FieldOffset(4)]
            internal uint m_stage;

            [FieldOffset(8)]
            internal global::VkDescriptorSetLayoutBinding.__Internal m_descriptorSetLayoutBinding;

            [FieldOffset(32)]
            internal global::VkDescriptorPoolSize.__Internal m_descriptorPoolSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorType@acid@@QEAA@AEBI0AEBUVkDescriptorSetLayoutBinding@@AEBUVkDescriptorPoolSize@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint binding, uint stage, global::System.IntPtr descriptorSetLayoutBinding, global::System.IntPtr descriptorPoolSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorType@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@DescriptorType@acid@@QEBAIXZ")]
            internal static extern uint GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStage@DescriptorType@acid@@QEBAIXZ")]
            internal static extern uint GetStage(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLayoutBinding@DescriptorType@acid@@QEBA?AUVkDescriptorSetLayoutBinding@@XZ")]
            internal static extern void GetLayoutBinding(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPoolSize@DescriptorType@acid@@QEBA?AUVkDescriptorPoolSize@@XZ")]
            internal static extern void GetPoolSize(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.DescriptorType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.DescriptorType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.DescriptorType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.DescriptorType(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.DescriptorType __CreateInstance(global::AcidSharp.DescriptorType.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.DescriptorType(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.DescriptorType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DescriptorType.__Internal));
            *(global::AcidSharp.DescriptorType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DescriptorType(global::AcidSharp.DescriptorType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DescriptorType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DescriptorType(uint binding, uint stage, global::VkDescriptorSetLayoutBinding descriptorSetLayoutBinding, global::VkDescriptorPoolSize descriptorPoolSize)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DescriptorType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(descriptorSetLayoutBinding, null))
                throw new global::System.ArgumentNullException("descriptorSetLayoutBinding", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = descriptorSetLayoutBinding.__Instance;
            if (ReferenceEquals(descriptorPoolSize, null))
                throw new global::System.ArgumentNullException("descriptorPoolSize", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = descriptorPoolSize.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), binding, stage, __arg2, __arg3);
        }

        public DescriptorType(global::AcidSharp.DescriptorType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DescriptorType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.DescriptorType.__Internal*) __Instance) = *((global::AcidSharp.DescriptorType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.DescriptorType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Stage
        {
            get
            {
                var __ret = __Internal.GetStage((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::VkDescriptorSetLayoutBinding LayoutBinding
        {
            get
            {
                var __ret = new global::VkDescriptorSetLayoutBinding.__Internal();
                __Internal.GetLayoutBinding((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::VkDescriptorSetLayoutBinding.__CreateInstance(__ret);
            }
        }

        public global::VkDescriptorPoolSize PoolSize
        {
            get
            {
                var __ret = new global::VkDescriptorPoolSize.__Internal();
                __Internal.GetPoolSize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::VkDescriptorPoolSize.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class PipelineDefine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineDefine@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineDefine@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PipelineDefine@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@PipelineDefine@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@PipelineDefine@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetValue(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.PipelineDefine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.PipelineDefine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.PipelineDefine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.PipelineDefine(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.PipelineDefine __CreateInstance(global::AcidSharp.PipelineDefine.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.PipelineDefine(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.PipelineDefine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.PipelineDefine.__Internal));
            global::AcidSharp.PipelineDefine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PipelineDefine(global::AcidSharp.PipelineDefine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PipelineDefine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PipelineDefine(string name, string value)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.PipelineDefine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public PipelineDefine(global::AcidSharp.PipelineDefine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.PipelineDefine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.PipelineDefine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public string Value
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetValue((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }

    public unsafe partial class PipelineCreate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_shaderStages;

            [FieldOffset(24)]
            internal global::AcidSharp.VertexInput.__Internal m_vertexInput;

            [FieldOffset(72)]
            internal global::AcidSharp.PipelineMode m_pipelineMode;

            [FieldOffset(76)]
            internal global::VkPolygonMode m_polygonMode;

            [FieldOffset(80)]
            internal uint m_cullMode;

            [FieldOffset(88)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_PipelineDefine___N_std_S_allocator__S0_ m_defines;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineCreate@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PipelineCreate@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexInput@PipelineCreate@acid@@QEBA?AVVertexInput@2@XZ")]
            internal static extern void GetVertexInput(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMode@PipelineCreate@acid@@QEBA?AW4PipelineMode@2@XZ")]
            internal static extern global::AcidSharp.PipelineMode GetMode(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPolygonMode@PipelineCreate@acid@@QEBA?AW4VkPolygonMode@@XZ")]
            internal static extern global::VkPolygonMode GetPolygonMode(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCullMode@PipelineCreate@acid@@QEBAIXZ")]
            internal static extern uint GetCullMode(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.PipelineCreate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.PipelineCreate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.PipelineCreate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.PipelineCreate(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.PipelineCreate __CreateInstance(global::AcidSharp.PipelineCreate.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.PipelineCreate(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.PipelineCreate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.PipelineCreate.__Internal));
            global::AcidSharp.PipelineCreate.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PipelineCreate(global::AcidSharp.PipelineCreate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PipelineCreate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PipelineCreate(global::AcidSharp.PipelineCreate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.PipelineCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.PipelineCreate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::AcidSharp.VertexInput VertexInput
        {
            get
            {
                var __ret = new global::AcidSharp.VertexInput.__Internal();
                __Internal.GetVertexInput((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.VertexInput.__CreateInstance(__ret);
            }
        }

        public global::AcidSharp.PipelineMode Mode
        {
            get
            {
                var __ret = __Internal.GetMode((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::VkPolygonMode PolygonMode
        {
            get
            {
                var __ret = __Internal.GetPolygonMode((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint CullMode
        {
            get
            {
                var __ret = __Internal.GetCullMode((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class ComputeCreate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_shaderStage;

            [FieldOffset(32)]
            internal uint m_width;

            [FieldOffset(36)]
            internal uint m_height;

            [FieldOffset(40)]
            internal uint m_workgroupSize;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_PipelineDefine___N_std_S_allocator__S0_ m_defines;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComputeCreate@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ComputeCreate@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShaderStage@ComputeCreate@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetShaderStage(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@ComputeCreate@acid@@QEBAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@ComputeCreate@acid@@QEBAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWorkgroupSize@ComputeCreate@acid@@QEBAIXZ")]
            internal static extern uint GetWorkgroupSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ComputeCreate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ComputeCreate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.ComputeCreate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ComputeCreate(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ComputeCreate __CreateInstance(global::AcidSharp.ComputeCreate.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ComputeCreate(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ComputeCreate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ComputeCreate.__Internal));
            global::AcidSharp.ComputeCreate.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ComputeCreate(global::AcidSharp.ComputeCreate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ComputeCreate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ComputeCreate(global::AcidSharp.ComputeCreate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ComputeCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ComputeCreate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string ShaderStage
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetShaderStage((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint WorkgroupSize
        {
            get
            {
                var __ret = __Internal.GetWorkgroupSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Glslang
{
    public unsafe partial class TProgram
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Glslang.TProgram> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Glslang.TProgram>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Glslang.TProgram __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Glslang.TProgram(native.ToPointer(), skipVTables);
        }

        internal static global::Glslang.TProgram __CreateInstance(global::Glslang.TProgram.__Internal native, bool skipVTables = false)
        {
            return new global::Glslang.TProgram(native, skipVTables);
        }

        private static void* __CopyValue(global::Glslang.TProgram.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Glslang.TProgram.__Internal));
            *(global::Glslang.TProgram.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TProgram(global::Glslang.TProgram.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TProgram(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class Uniform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal int m_binding;

            [FieldOffset(36)]
            internal int m_offset;

            [FieldOffset(40)]
            internal int m_size;

            [FieldOffset(44)]
            internal int m_glType;

            [FieldOffset(48)]
            internal uint m_stageFlags;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Uniform@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH111AEBI@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, int binding, int offset, int size, int glType, uint stageFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Uniform@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Uniform@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Uniform@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Uniform@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Uniform@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStageFlags@Uniform@acid@@QEBAIXZ")]
            internal static extern uint GetStageFlags(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStageFlags@Uniform@acid@@QEAAXAEBI@Z")]
            internal static extern void SetStageFlags(global::System.IntPtr instance, uint stageFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Uniform@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@Uniform@acid@@QEBAHXZ")]
            internal static extern int GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOffset@Uniform@acid@@QEBAHXZ")]
            internal static extern int GetOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@Uniform@acid@@QEBAHXZ")]
            internal static extern int GetSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlType@Uniform@acid@@QEBAHXZ")]
            internal static extern int GetGlType(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Uniform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Uniform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Uniform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Uniform(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Uniform __CreateInstance(global::AcidSharp.Uniform.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Uniform(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Uniform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Uniform.__Internal));
            global::AcidSharp.Uniform.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Uniform(global::AcidSharp.Uniform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Uniform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Uniform(string name, int binding, int offset, int size, int glType, uint stageFlags)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Uniform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, binding, offset, size, glType, stageFlags);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public Uniform(global::AcidSharp.Uniform _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Uniform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Uniform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator ==(global::AcidSharp.Uniform __op, global::AcidSharp.Uniform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Uniform;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Uniform.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Uniform __op, global::AcidSharp.Uniform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public uint StageFlags
        {
            get
            {
                var __ret = __Internal.GetStageFlags((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetStageFlags((__Instance + __PointerAdjustment), value);
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public int Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Offset
        {
            get
            {
                var __ret = __Internal.GetOffset((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int GlType
        {
            get
            {
                var __ret = __Internal.GetGlType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class UniformBlock : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal int m_binding;

            [FieldOffset(36)]
            internal int m_size;

            [FieldOffset(40)]
            internal uint m_stageFlags;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_acid_S_Uniform___N_std_S_allocator__S0_ m_uniforms;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformBlock@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH1AEBI@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, int binding, int size, uint stageFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformBlock@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UniformBlock@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@UniformBlock@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStageFlags@UniformBlock@acid@@QEBAIXZ")]
            internal static extern uint GetStageFlags(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStageFlags@UniformBlock@acid@@QEAAXAEBI@Z")]
            internal static extern void SetStageFlags(global::System.IntPtr instance, uint stageFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@UniformBlock@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@UniformBlock@acid@@QEBAHXZ")]
            internal static extern int GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@UniformBlock@acid@@QEBAHXZ")]
            internal static extern int GetSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UniformBlock> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UniformBlock>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.UniformBlock __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.UniformBlock(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.UniformBlock __CreateInstance(global::AcidSharp.UniformBlock.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.UniformBlock(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.UniformBlock.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UniformBlock.__Internal));
            global::AcidSharp.UniformBlock.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UniformBlock(global::AcidSharp.UniformBlock.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UniformBlock(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UniformBlock(string name, int binding, int size, uint stageFlags)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UniformBlock.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, binding, size, stageFlags);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public UniformBlock(global::AcidSharp.UniformBlock _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UniformBlock.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.UniformBlock __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public uint StageFlags
        {
            get
            {
                var __ret = __Internal.GetStageFlags((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetStageFlags((__Instance + __PointerAdjustment), value);
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public int Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class VertexAttribute : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal int m_location;

            [FieldOffset(36)]
            internal int m_size;

            [FieldOffset(40)]
            internal int m_glType;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAttribute@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH11@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, int location, int size, int glType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAttribute@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexAttribute@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@VertexAttribute@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@VertexAttribute@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocation@VertexAttribute@acid@@QEBAHXZ")]
            internal static extern int GetLocation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@VertexAttribute@acid@@QEBAHXZ")]
            internal static extern int GetSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlType@VertexAttribute@acid@@QEBAHXZ")]
            internal static extern int GetGlType(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.VertexAttribute> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.VertexAttribute>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.VertexAttribute __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexAttribute(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.VertexAttribute __CreateInstance(global::AcidSharp.VertexAttribute.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexAttribute(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.VertexAttribute.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexAttribute.__Internal));
            global::AcidSharp.VertexAttribute.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexAttribute(global::AcidSharp.VertexAttribute.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexAttribute(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexAttribute(string name, int location, int size, int glType)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexAttribute.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, location, size, glType);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public VertexAttribute(global::AcidSharp.VertexAttribute _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexAttribute.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.VertexAttribute __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public int Location
        {
            get
            {
                var __ret = __Internal.GetLocation((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int GlType
        {
            get
            {
                var __ret = __Internal.GetGlType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class ShaderProgram : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 176)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_acid_S_Uniform___N_std_S_allocator__S0_ m_uniforms;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_acid_S_UniformBlock___N_std_S_allocator__S0_ m_uniformBlocks;

            [FieldOffset(80)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_acid_S_VertexAttribute___N_std_S_allocator__S0_ m_vertexAttributes;

            [FieldOffset(104)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_DescriptorType___N_std_S_allocator__S0_ m_descriptors;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkVertexInputAttributeDescription___N_std_S_allocator__S0_ m_attributeDescriptions;

            [FieldOffset(152)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_notFoundNames;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShaderProgram@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShaderProgram@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ShaderProgram@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ReportedNotFound@ShaderProgram@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ReportedNotFound(global::System.IntPtr instance, global::System.IntPtr name, bool reportIfFound);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ProcessShader@ShaderProgram@acid@@QEAAXXZ")]
            internal static extern void ProcessShader(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GlTypeToVk@ShaderProgram@acid@@QEAA?AW4VkFormat@@AEBH@Z")]
            internal static extern global::VkFormat GlTypeToVk(global::System.IntPtr instance, int type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDescriptorLocation@ShaderProgram@acid@@QEAAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern int GetDescriptorLocation(global::System.IntPtr instance, global::System.IntPtr descriptor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShaderStage@ShaderProgram@acid@@SA?AW4VkShaderStageFlagBits@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::VkShaderStageFlagBits GetShaderStage(global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InsertDefineBlock@ShaderProgram@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z")]
            internal static extern void InsertDefineBlock(global::System.IntPtr @return, global::System.IntPtr shaderCode, global::System.IntPtr blockCode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ProcessIncludes@ShaderProgram@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void ProcessIncludes(global::System.IntPtr @return, global::System.IntPtr shaderCode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ProcessShader@ShaderProgram@acid@@QEAAPEAUVkShaderModule_T@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBI@Z")]
            internal static extern global::System.IntPtr ProcessShader(global::System.IntPtr instance, global::System.IntPtr shaderCode, uint stageFlag);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@ShaderProgram@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@ShaderProgram@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLastDescriptorBinding@ShaderProgram@acid@@QEBAIXZ")]
            internal static extern uint GetLastDescriptorBinding(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ShaderProgram> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ShaderProgram>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.ShaderProgram __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ShaderProgram(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ShaderProgram __CreateInstance(global::AcidSharp.ShaderProgram.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ShaderProgram(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ShaderProgram.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ShaderProgram.__Internal));
            global::AcidSharp.ShaderProgram.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShaderProgram(global::AcidSharp.ShaderProgram.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShaderProgram(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ShaderProgram(string name)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ShaderProgram.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public ShaderProgram(global::AcidSharp.ShaderProgram _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ShaderProgram.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ShaderProgram __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool ReportedNotFound(string name, bool reportIfFound)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.ReportedNotFound((__Instance + __PointerAdjustment), __arg0, reportIfFound);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public void ProcessShader()
        {
            __Internal.ProcessShader((__Instance + __PointerAdjustment));
        }

        public global::VkFormat GlTypeToVk(int type)
        {
            var __ret = __Internal.GlTypeToVk((__Instance + __PointerAdjustment), type);
            return __ret;
        }

        public int GetDescriptorLocation(string descriptor)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptor, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetDescriptorLocation((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public global::VkShaderModuleT ProcessShader(string shaderCode, uint stageFlag)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(shaderCode, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.ProcessShader((__Instance + __PointerAdjustment), __arg0, stageFlag);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::VkShaderModuleT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VkShaderModuleT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VkShaderModuleT) global::VkShaderModuleT.NativeToManagedMap[__ret];
            else __result0 = global::VkShaderModuleT.__CreateInstance(__ret);
            return __result0;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.ShaderProgram(string name)
        {
            return new global::AcidSharp.ShaderProgram(name);
        }

        public static global::VkShaderStageFlagBits GetShaderStage(string filename)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetShaderStage(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public static string InsertDefineBlock(string shaderCode, string blockCode)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(shaderCode, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(blockCode, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.InsertDefineBlock(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static string ProcessIncludes(string shaderCode)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(shaderCode, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ProcessIncludes(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public uint LastDescriptorBinding
        {
            get
            {
                var __ret = __Internal.GetLastDescriptorBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe abstract partial class IPipeline : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPipeline;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPipeline@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPipeline@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IPipeline@acid@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BindPipeline@IPipeline@acid@@QEBAXAEBVCommandBuffer@2@@Z")]
            internal static extern void BindPipeline(global::System.IntPtr instance, global::System.IntPtr commandBuffer);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IPipeline> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IPipeline>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IPipeline __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IPipelineInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IPipeline __CreateInstance(global::AcidSharp.IPipeline.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IPipelineInternal(native, skipVTables);
        }

        protected IPipeline(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected IPipeline()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.IPipeline");
        }

        protected IPipeline(global::AcidSharp.IPipeline _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IPipeline");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IPipeline __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IPipeline.__Internal*) __Instance)->vfptr_IPipeline = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::AcidSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void BindPipeline(global::AcidSharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.BindPipeline((__Instance + __PointerAdjustment), __arg0);
        }

        public abstract global::VkDescriptorSetLayoutT DescriptorSetLayout
        {
            get;
        }

        public abstract global::VkDescriptorPoolT DescriptorPool
        {
            get;
        }

        public abstract global::VkPipelineT Pipeline
        {
            get;
        }

        public abstract global::VkPipelineLayoutT PipelineLayout
        {
            get;
        }

        public abstract global::VkPipelineBindPoint PipelineBindPoint
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IPipeline() { }
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // VkDescriptorSetLayout GetDescriptorSetLayout() const = 0
        private static global::AcidSharp.Delegates.Func_IntPtr_IntPtr _GetDescriptorSetLayoutDelegateInstance;

        private static global::System.IntPtr _GetDescriptorSetLayoutDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.DescriptorSetLayout;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // VkDescriptorPool GetDescriptorPool() const = 0
        private static global::AcidSharp.Delegates.Func_IntPtr_IntPtr _GetDescriptorPoolDelegateInstance;

        private static global::System.IntPtr _GetDescriptorPoolDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.DescriptorPool;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // VkPipeline GetPipeline() const = 0
        private static global::AcidSharp.Delegates.Func_IntPtr_IntPtr _GetPipelineDelegateInstance;

        private static global::System.IntPtr _GetPipelineDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Pipeline;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // VkPipelineLayout GetPipelineLayout() const = 0
        private static global::AcidSharp.Delegates.Func_IntPtr_IntPtr _GetPipelineLayoutDelegateInstance;

        private static global::System.IntPtr _GetPipelineLayoutDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.PipelineLayout;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // VkPipelineBindPoint GetPipelineBindPoint() const = 0
        private static global::AcidSharp.Delegates.Func_VkPipelineBindPoint_IntPtr _GetPipelineBindPointDelegateInstance;

        private static global::VkPipelineBindPoint _GetPipelineBindPointDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.PipelineBindPoint;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetDescriptorSetLayoutDelegateInstance += _GetDescriptorSetLayoutDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetDescriptorSetLayoutDelegateInstance).ToPointer();
                _GetDescriptorPoolDelegateInstance += _GetDescriptorPoolDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetDescriptorPoolDelegateInstance).ToPointer();
                _GetPipelineDelegateInstance += _GetPipelineDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPipelineDelegateInstance).ToPointer();
                _GetPipelineLayoutDelegateInstance += _GetPipelineLayoutDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetPipelineLayoutDelegateInstance).ToPointer();
                _GetPipelineBindPointDelegateInstance += _GetPipelineBindPointDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetPipelineBindPointDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(8 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(8 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = _Thunks[1];
                    *(void**) (vfptr0 + 32) = _Thunks[2];
                    *(void**) (vfptr0 + 40) = _Thunks[3];
                    *(void**) (vfptr0 + 48) = _Thunks[4];
                    *(void**) (vfptr0 + 56) = _Thunks[5];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IPipelineInternal : global::AcidSharp.IPipeline, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IPipeline.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IPipeline.__Internal));
            *(global::AcidSharp.IPipeline.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IPipelineInternal(global::AcidSharp.IPipeline.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IPipelineInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override global::VkDescriptorSetLayoutT DescriptorSetLayout
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___GetDescriptorSetLayoutDelegate = (global::AcidSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetDescriptorSetLayoutDelegate((__Instance + __PointerAdjustment));
                global::VkDescriptorSetLayoutT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkDescriptorSetLayoutT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkDescriptorSetLayoutT) global::VkDescriptorSetLayoutT.NativeToManagedMap[__ret];
                else __result0 = global::VkDescriptorSetLayoutT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public override global::VkDescriptorPoolT DescriptorPool
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetDescriptorPoolDelegate = (global::AcidSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetDescriptorPoolDelegate((__Instance + __PointerAdjustment));
                global::VkDescriptorPoolT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkDescriptorPoolT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkDescriptorPoolT) global::VkDescriptorPoolT.NativeToManagedMap[__ret];
                else __result0 = global::VkDescriptorPoolT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public override global::VkPipelineT Pipeline
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetPipelineDelegate = (global::AcidSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetPipelineDelegate((__Instance + __PointerAdjustment));
                global::VkPipelineT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkPipelineT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkPipelineT) global::VkPipelineT.NativeToManagedMap[__ret];
                else __result0 = global::VkPipelineT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public override global::VkPipelineLayoutT PipelineLayout
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetPipelineLayoutDelegate = (global::AcidSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetPipelineLayoutDelegate((__Instance + __PointerAdjustment));
                global::VkPipelineLayoutT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkPipelineLayoutT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkPipelineLayoutT) global::VkPipelineLayoutT.NativeToManagedMap[__ret];
                else __result0 = global::VkPipelineLayoutT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public override global::VkPipelineBindPoint PipelineBindPoint
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___GetPipelineBindPointDelegate = (global::AcidSharp.Delegates.Func_VkPipelineBindPoint_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_VkPipelineBindPoint_IntPtr));
                var __ret = ___GetPipelineBindPointDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class IDescriptor
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IDescriptor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IDescriptor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IDescriptor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IDescriptor(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IDescriptor __CreateInstance(global::AcidSharp.IDescriptor.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IDescriptor(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.IDescriptor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IDescriptor.__Internal));
            *(global::AcidSharp.IDescriptor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IDescriptor(global::AcidSharp.IDescriptor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IDescriptor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class DescriptorSet : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.SharedPtr.__Internal m_shaderProgram;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipelineLayout;

            [FieldOffset(24)]
            internal global::VkPipelineBindPoint m_pipelineBindPoint;

            [FieldOffset(32)]
            internal global::System.IntPtr m_descriptorPool;

            [FieldOffset(40)]
            internal global::System.IntPtr m_descriptorSet;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorSet@acid@@QEAA@AEBVIPipeline@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr pipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorSet@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1DescriptorSet@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BindDescriptor@DescriptorSet@acid@@QEAAXAEBVCommandBuffer@2@@Z")]
            internal static extern void BindDescriptor(global::System.IntPtr instance, global::System.IntPtr commandBuffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDescriptorSet@DescriptorSet@acid@@QEBAPEAUVkDescriptorSet_T@@XZ")]
            internal static extern global::System.IntPtr GetDescriptorSet(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.DescriptorSet> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.DescriptorSet>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.DescriptorSet __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.DescriptorSet(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.DescriptorSet __CreateInstance(global::AcidSharp.DescriptorSet.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.DescriptorSet(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.DescriptorSet.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DescriptorSet.__Internal));
            global::AcidSharp.DescriptorSet.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DescriptorSet(global::AcidSharp.DescriptorSet.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DescriptorSet(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DescriptorSet(global::AcidSharp.IPipeline pipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DescriptorSet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pipeline.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public DescriptorSet(global::AcidSharp.DescriptorSet _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DescriptorSet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.DescriptorSet __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void BindDescriptor(global::AcidSharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.BindDescriptor((__Instance + __PointerAdjustment), __arg0);
        }

        public static implicit operator global::AcidSharp.DescriptorSet(global::AcidSharp.IPipeline pipeline)
        {
            return new global::AcidSharp.DescriptorSet(pipeline);
        }

        public global::VkDescriptorSetT DescriptorSet
        {
            get
            {
                var __ret = __Internal.GetDescriptorSet((__Instance + __PointerAdjustment));
                global::VkDescriptorSetT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkDescriptorSetT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkDescriptorSetT) global::VkDescriptorSetT.NativeToManagedMap[__ret];
                else __result0 = global::VkDescriptorSetT.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class Buffer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Buffer;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Buffer@acid@@QEAA@AEB_KAEBI1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong size, uint usage, uint properties);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Buffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindMemoryType@Buffer@acid@@SAIAEBI0@Z")]
            internal static extern uint FindMemoryType(uint typeFilter, uint properties);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CopyBuffer@Buffer@acid@@SAXPEAUVkBuffer_T@@0AEB_K@Z")]
            internal static extern void CopyBuffer(global::System.IntPtr srcBuffer, global::System.IntPtr dstBuffer, ulong size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@Buffer@acid@@QEBA_KXZ")]
            internal static extern ulong GetSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBuffer@Buffer@acid@@QEBAPEAUVkBuffer_T@@XZ")]
            internal static extern global::System.IntPtr GetBuffer(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBufferMemory@Buffer@acid@@QEBAPEAUVkDeviceMemory_T@@XZ")]
            internal static extern global::System.IntPtr GetBufferMemory(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Buffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Buffer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Buffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Buffer(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Buffer __CreateInstance(global::AcidSharp.Buffer.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Buffer(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Buffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Buffer.__Internal));
            global::AcidSharp.Buffer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Buffer(global::AcidSharp.Buffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Buffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public Buffer(ulong size, uint usage, uint properties)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), size, usage, properties);
            SetupVTables(GetType().FullName == "AcidSharp.Buffer");
        }

        public Buffer(global::AcidSharp.Buffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Buffer");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Buffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Buffer.__Internal*) __Instance)->vfptr_Buffer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___dtorDelegate = (global::AcidSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_int));
                ___dtorDelegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static uint FindMemoryType(uint typeFilter, uint properties)
        {
            var __ret = __Internal.FindMemoryType(typeFilter, properties);
            return __ret;
        }

        public static void CopyBuffer(global::VkBufferT srcBuffer, global::VkBufferT dstBuffer, ulong size)
        {
            var __arg0 = ReferenceEquals(srcBuffer, null) ? global::System.IntPtr.Zero : srcBuffer.__Instance;
            var __arg1 = ReferenceEquals(dstBuffer, null) ? global::System.IntPtr.Zero : dstBuffer.__Instance;
            __Internal.CopyBuffer(__arg0, __arg1, size);
        }

        protected ulong MSize
        {
            get
            {
                return ((global::AcidSharp.Buffer.__Internal*) __Instance)->m_size;
            }

            set
            {
                ((global::AcidSharp.Buffer.__Internal*)__Instance)->m_size = value;
            }
        }

        protected global::VkBufferT MBuffer
        {
            get
            {
                global::VkBufferT __result0;
                if (((global::AcidSharp.Buffer.__Internal*) __Instance)->m_buffer == IntPtr.Zero) __result0 = null;
                else if (global::VkBufferT.NativeToManagedMap.ContainsKey(((global::AcidSharp.Buffer.__Internal*) __Instance)->m_buffer))
                    __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[((global::AcidSharp.Buffer.__Internal*) __Instance)->m_buffer];
                else __result0 = global::VkBufferT.__CreateInstance(((global::AcidSharp.Buffer.__Internal*) __Instance)->m_buffer);
                return __result0;
            }

            set
            {
                ((global::AcidSharp.Buffer.__Internal*)__Instance)->m_buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        protected global::VkDeviceMemoryT MBufferMemory
        {
            get
            {
                global::VkDeviceMemoryT __result0;
                if (((global::AcidSharp.Buffer.__Internal*) __Instance)->m_bufferMemory == IntPtr.Zero) __result0 = null;
                else if (global::VkDeviceMemoryT.NativeToManagedMap.ContainsKey(((global::AcidSharp.Buffer.__Internal*) __Instance)->m_bufferMemory))
                    __result0 = (global::VkDeviceMemoryT) global::VkDeviceMemoryT.NativeToManagedMap[((global::AcidSharp.Buffer.__Internal*) __Instance)->m_bufferMemory];
                else __result0 = global::VkDeviceMemoryT.__CreateInstance(((global::AcidSharp.Buffer.__Internal*) __Instance)->m_bufferMemory);
                return __result0;
            }

            set
            {
                ((global::AcidSharp.Buffer.__Internal*)__Instance)->m_bufferMemory = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public ulong Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::VkBufferT Buffer
        {
            get
            {
                var __ret = __Internal.GetBuffer((__Instance + __PointerAdjustment));
                global::VkBufferT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkBufferT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkBufferT) global::VkBufferT.NativeToManagedMap[__ret];
                else __result0 = global::VkBufferT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::VkDeviceMemoryT BufferMemory
        {
            get
            {
                var __ret = __Internal.GetBufferMemory((__Instance + __PointerAdjustment));
                global::VkDeviceMemoryT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkDeviceMemoryT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkDeviceMemoryT) global::VkDeviceMemoryT.NativeToManagedMap[__ret];
                else __result0 = global::VkDeviceMemoryT.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // virtual ~Buffer()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Buffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class IndexBuffer : global::AcidSharp.Buffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Buffer;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(32)]
            internal global::VkIndexType m_indexType;

            [FieldOffset(36)]
            internal uint m_indexCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IndexBuffer@acid@@QEAA@AEBW4VkIndexType@@AEB_K1PEBX@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::VkIndexType indexType, ulong elementSize, ulong indexCount, global::System.IntPtr newData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IndexBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndexType@IndexBuffer@acid@@QEBA?AW4VkIndexType@@XZ")]
            internal static extern global::VkIndexType GetIndexType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndexCount@IndexBuffer@acid@@QEBAIXZ")]
            internal static extern uint GetIndexCount(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.IndexBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IndexBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IndexBuffer __CreateInstance(global::AcidSharp.IndexBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IndexBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.IndexBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IndexBuffer.__Internal));
            global::AcidSharp.IndexBuffer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private IndexBuffer(global::AcidSharp.IndexBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IndexBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public IndexBuffer(global::VkIndexType indexType, ulong elementSize, ulong indexCount, global::System.IntPtr newData)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IndexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), indexType, elementSize, indexCount, newData);
            SetupVTables(GetType().FullName == "AcidSharp.IndexBuffer");
        }

        public IndexBuffer(global::AcidSharp.IndexBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IndexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IndexBuffer");
        }

        public global::VkIndexType IndexType
        {
            get
            {
                var __ret = __Internal.GetIndexType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint IndexCount
        {
            get
            {
                var __ret = __Internal.GetIndexCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~IndexBuffer()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IndexBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class VertexBuffer : global::AcidSharp.Buffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Buffer;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(32)]
            internal uint m_vertexCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexBuffer@acid@@QEAA@AEB_K0PEBX@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong elementSize, ulong vertexCount, global::System.IntPtr newData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexCount@VertexBuffer@acid@@QEBAIXZ")]
            internal static extern uint GetVertexCount(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.VertexBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.VertexBuffer __CreateInstance(global::AcidSharp.VertexBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.VertexBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexBuffer.__Internal));
            global::AcidSharp.VertexBuffer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexBuffer(global::AcidSharp.VertexBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public VertexBuffer(ulong elementSize, ulong vertexCount, global::System.IntPtr newData)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), elementSize, vertexCount, newData);
            SetupVTables(GetType().FullName == "AcidSharp.VertexBuffer");
        }

        public VertexBuffer(global::AcidSharp.VertexBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.VertexBuffer");
        }

        public uint VertexCount
        {
            get
            {
                var __ret = __Internal.GetVertexCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~VertexBuffer()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.VertexBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A managed resource object.</summary>
    public unsafe abstract partial class IResource : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IResource@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IResource@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IResource> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IResource>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IResource __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IResourceInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IResource __CreateInstance(global::AcidSharp.IResource.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IResourceInternal(native, skipVTables);
        }

        protected IResource(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IResource(global::AcidSharp.IResource _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IResource.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IResource");
        }

        protected IResource()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IResource.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.IResource");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IResource.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets a unique name (most likely a filename) associated with this resource object.</summary>
        public abstract string Filename
        {
            get;
        }

        #region Virtual table interop

        // std::string GetFilename() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IResource) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IResourceInternal : global::AcidSharp.IResource, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IResource.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IResource.__Internal));
            *(global::AcidSharp.IResource.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IResourceInternal(global::AcidSharp.IResource.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IResourceInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets a unique name (most likely a filename) associated with this resource object.</summary>
        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe abstract partial class IVertex : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IVertex;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IVertex@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IVertex@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IVertex> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IVertex>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IVertex __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IVertexInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IVertex __CreateInstance(global::AcidSharp.IVertex.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IVertexInternal(native, skipVTables);
        }

        protected IVertex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IVertex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IVertex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.IVertex");
        }

        protected IVertex(global::AcidSharp.IVertex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IVertex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IVertex");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IVertex __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IVertex.__Internal*) __Instance)->vfptr_IVertex = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract global::AcidSharp.Vector3 Position
        {
            get;

            set;
        }

        public abstract ulong Size
        {
            get;
        }

        #region Virtual table interop

        // Vector3 GetPosition() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IVertex) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::AcidSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Vector3.__Internal() : *(global::AcidSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // void SetPosition(const Vector3 &position) = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _SetPositionDelegateInstance;

        private static void _SetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IVertex) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Vector3 __result0;
            if (position == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result0 = (global::AcidSharp.Vector3) global::AcidSharp.Vector3.NativeToManagedMap[position];
            else __result0 = global::AcidSharp.Vector3.__CreateInstance(position);
            __target.Position = __result0;
        }

        // size_t GetSize() const = 0
        private static global::AcidSharp.Delegates.Func_ulong_IntPtr _GetSizeDelegateInstance;

        private static ulong _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IVertex) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _SetPositionDelegateInstance += _SetPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetPositionDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IVertexInternal : global::AcidSharp.IVertex, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IVertex.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IVertex.__Internal));
            *(global::AcidSharp.IVertex.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IVertexInternal(global::AcidSharp.IVertex.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IVertexInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override global::AcidSharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetPositionDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___SetPositionDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                ___SetPositionDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override ulong Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___GetSizeDelegate = (global::AcidSharp.Delegates.Func_ulong_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_ulong_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Class that represents a OBJ model.</summary>
    public unsafe partial class Model : global::AcidSharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::AcidSharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::AcidSharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Model@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Model@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Model@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@Model@acid@@QEAAXAEBVCommandBuffer@2@AEBI@Z")]
            internal static extern void CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, uint instances);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMinExtents@Model@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetMinExtents(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxExtents@Model@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetMaxExtents(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Model@acid@@QEBAMXZ")]
            internal static extern float GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Model@acid@@QEBAMXZ")]
            internal static extern float GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDepth@Model@acid@@QEBAMXZ")]
            internal static extern float GetDepth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@Model@acid@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexBuffer@Model@acid@@QEBAPEAVVertexBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetVertexBuffer(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndexBuffer@Model@acid@@QEBAPEAVIndexBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetIndexBuffer(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.Model __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Model(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Model __CreateInstance(global::AcidSharp.Model.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Model(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Model.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Model.__Internal));
            global::AcidSharp.Model.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Model(global::AcidSharp.Model.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Model(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new empty model.</summary>
        public Model()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Model.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.Model");
        }

        public Model(global::AcidSharp.Model _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Model.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Model");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Model.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void CmdRender(global::AcidSharp.CommandBuffer commandBuffer, uint instances = 1)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, instances);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public global::AcidSharp.Vector3 MinExtents
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetMinExtents((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }

        public global::AcidSharp.Vector3 MaxExtents
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetMaxExtents((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }

        public float Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Depth
        {
            get
            {
                var __ret = __Internal.GetDepth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::AcidSharp.VertexBuffer VertexBuffer
        {
            get
            {
                var __ret = __Internal.GetVertexBuffer((__Instance + __PointerAdjustment));
                global::AcidSharp.VertexBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.VertexBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.VertexBuffer) global::AcidSharp.VertexBuffer.NativeToManagedMap[__ret];
                else global::AcidSharp.VertexBuffer.NativeToManagedMap[__ret] = __result0 = (global::AcidSharp.VertexBuffer) global::AcidSharp.VertexBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::AcidSharp.IndexBuffer IndexBuffer
        {
            get
            {
                var __ret = __Internal.GetIndexBuffer((__Instance + __PointerAdjustment));
                global::AcidSharp.IndexBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.IndexBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.IndexBuffer) global::AcidSharp.IndexBuffer.NativeToManagedMap[__ret];
                else global::AcidSharp.IndexBuffer.NativeToManagedMap[__ret] = __result0 = (global::AcidSharp.IndexBuffer) global::AcidSharp.IndexBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Model) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>Holds a 2-tuple vector.</summary>
    public unsafe partial class Vector2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Vector2._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@AEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Vector2@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector2@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector2@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector2@acid@@QEBA?AV12@AEBMAEBV12@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float angle, global::System.IntPtr rotationAxis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InTriangle@Vector2@acid@@QEBA_NAEBV12@00@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InTriangle(global::System.IntPtr instance, global::System.IntPtr v1, global::System.IntPtr v2, global::System.IntPtr v3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector2@acid@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Vector2@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Vector2@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector2@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector2@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector2@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector2@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBVVector2@0@AEBV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBVVector2@0@AEBV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AVector2@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector2@acid@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector2@acid@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector2@acid@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector2@acid@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector2@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector2@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector2@acid@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector2@acid@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CartesianToPolar@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void CartesianToPolar(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PolarToCartesian@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void PolarToCartesian(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::AcidSharp.Vector2._.__.__Internal __;

                [FieldOffset(0)]
                internal global::AcidSharp.Vector2._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed float m_elements[2];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Vector2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Vector2>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Vector2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Vector2(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Vector2 __CreateInstance(global::AcidSharp.Vector2.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Vector2(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Vector2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector2.__Internal));
            global::AcidSharp.Vector2.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector2(global::AcidSharp.Vector2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector2.</summary>
        public Vector2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        public Vector2(float x, float y)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), x, y);
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector2(global::AcidSharp.Vector2 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector2(global::AcidSharp.Vector3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Vector2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector2 Add(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector2 Subtract(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector2 Multiply(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector2 Divide(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::AcidSharp.Vector2 Scale(float scalar)
        {
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around the origin.</summary>
        /// <param name="angle">The angle to rotate by, in radians.</param>
        public global::AcidSharp.Vector2 Rotate(float angle)
        {
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), angle);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around a rotation axis.</summary>
        /// <param name="angle">The angle to rotate by, in radians.</param>
        /// <param name="rotationAxis">The point to rotate the vector around.</param>
        public global::AcidSharp.Vector2 Rotate(float angle, global::AcidSharp.Vector2 rotationAxis)
        {
            if (ReferenceEquals(rotationAxis, null))
                throw new global::System.ArgumentNullException("rotationAxis", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotationAxis.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), angle, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::AcidSharp.Vector2 Negate()
        {
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::AcidSharp.Vector2 Normalize()
        {
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector2 DistanceVector(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Gets if this vector is in a triangle.</summary>
        /// <param name="v1">The first triangle vertex.</param>
        /// <param name="v2">The second triangle vertex.</param>
        /// <param name="v3">The third triangle vertex.</param>
        public bool InTriangle(global::AcidSharp.Vector2 v1, global::AcidSharp.Vector2 v2, global::AcidSharp.Vector2 v3)
        {
            if (ReferenceEquals(v1, null))
                throw new global::System.ArgumentNullException("v1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = v1.__Instance;
            if (ReferenceEquals(v2, null))
                throw new global::System.ArgumentNullException("v2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = v2.__Instance;
            if (ReferenceEquals(v3, null))
                throw new global::System.ArgumentNullException("v3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = v3.__Instance;
            var __ret = __Internal.InTriangle((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::AcidSharp.Vector2 SmoothDamp(global::AcidSharp.Vector2 target, global::AcidSharp.Vector2 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public void Decode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::AcidSharp.Vector2 __op, global::AcidSharp.Vector2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Vector2;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Vector2.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Vector2 __op, global::AcidSharp.Vector2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::AcidSharp.Vector2 __op, global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::AcidSharp.Vector2 __op, global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::AcidSharp.Vector2 __op, global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::AcidSharp.Vector2 __op, global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::AcidSharp.Vector2 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::AcidSharp.Vector2 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public static global::AcidSharp.Vector2 operator -(global::AcidSharp.Vector2 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.Vector2(global::AcidSharp.Vector3 source)
        {
            return new global::AcidSharp.Vector2(source);
        }

        public static global::AcidSharp.Vector2 operator +(global::AcidSharp.Vector2 left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator -(global::AcidSharp.Vector2 left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator *(global::AcidSharp.Vector2 left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator /(global::AcidSharp.Vector2 left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator +(float left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator -(float left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator *(float left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator /(float left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator +(global::AcidSharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator -(global::AcidSharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator *(global::AcidSharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 operator /(global::AcidSharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator *(global::AcidSharp.Vector2 left, global::AcidSharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator /(global::AcidSharp.Vector2 left, global::AcidSharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Vector2 Zero
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Vector2@acid@@2V12@B");
                return global::AcidSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector2 One
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ONE@Vector2@acid@@2V12@B");
                return global::AcidSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector2 Left
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?LEFT@Vector2@acid@@2V12@B");
                return global::AcidSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector2 Right
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?RIGHT@Vector2@acid@@2V12@B");
                return global::AcidSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector2 Up
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?UP@Vector2@acid@@2V12@B");
                return global::AcidSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector2 Down
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DOWN@Vector2@acid@@2V12@B");
                return global::AcidSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector2 PositiveInfinity
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Vector2@acid@@2V12@B");
                return global::AcidSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Vector2 NegativeInfinity
        {
            get
            {
                var __ptr = (global::AcidSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Vector2@acid@@2V12@B");
                return global::AcidSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), index);
                return *__ret;
            }

            set
            {
                *global::AcidSharp.Vector2.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), index) = value;
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetX((__Instance + __PointerAdjustment), value);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetY((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Converts from rectangular to spherical coordinates, this vector is in cartesian (x, y).</summary>
        public global::AcidSharp.Vector2 CartesianToPolar
        {
            get
            {
                var __ret = new global::AcidSharp.Vector2.__Internal();
                __Internal.CartesianToPolar((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector2.__CreateInstance(__ret);
            }
        }

        /// <summary>Converts from spherical to rectangular coordinates, this vector is in polar (radius, theta).</summary>
        public global::AcidSharp.Vector2 PolarToCartesian
        {
            get
            {
                var __ret = new global::AcidSharp.Vector2.__Internal();
                __Internal.PolarToCartesian((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector2.__CreateInstance(__ret);
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class VertexAnimated : global::AcidSharp.IVertex, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IVertex;

            [FieldOffset(8)]
            internal global::AcidSharp.Vector3.__Internal m_position;

            [FieldOffset(20)]
            internal global::AcidSharp.Vector2.__Internal m_uv;

            [FieldOffset(28)]
            internal global::AcidSharp.Vector3.__Internal m_normal;

            [FieldOffset(40)]
            internal global::AcidSharp.Vector3.__Internal m_tangent;

            [FieldOffset(52)]
            internal global::AcidSharp.Vector3.__Internal m_jointId;

            [FieldOffset(64)]
            internal global::AcidSharp.Vector3.__Internal m_vertexWeight;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimated@acid@@QEAA@AEBVVector3@1@AEBVVector2@1@0000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr uv, global::System.IntPtr normal, global::System.IntPtr tangent, global::System.IntPtr jointId, global::System.IntPtr vertexWeight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimated@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexAnimated@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUv@VertexAnimated@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetUv(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUv@VertexAnimated@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetUv(global::System.IntPtr instance, global::System.IntPtr uv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormal@VertexAnimated@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetNormal(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormal@VertexAnimated@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetNormal(global::System.IntPtr instance, global::System.IntPtr normal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTangent@VertexAnimated@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetTangent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTangent@VertexAnimated@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetTangent(global::System.IntPtr instance, global::System.IntPtr tangent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointId@VertexAnimated@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetJointId(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJointId@VertexAnimated@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetJointId(global::System.IntPtr instance, global::System.IntPtr jointId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexWeight@VertexAnimated@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetVertexWeight(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetVertexWeight@VertexAnimated@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetVertexWeight(global::System.IntPtr instance, global::System.IntPtr vertexWeight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexInput@VertexAnimated@acid@@SA?AVVertexInput@2@XZ")]
            internal static extern void GetVertexInput(global::System.IntPtr @return);
        }

        internal static new global::AcidSharp.VertexAnimated __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexAnimated(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.VertexAnimated __CreateInstance(global::AcidSharp.VertexAnimated.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexAnimated(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.VertexAnimated.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexAnimated.__Internal));
            global::AcidSharp.VertexAnimated.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexAnimated(global::AcidSharp.VertexAnimated.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexAnimated(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public VertexAnimated(global::AcidSharp.Vector3 position, global::AcidSharp.Vector2 uv, global::AcidSharp.Vector3 normal, global::AcidSharp.Vector3 tangent, global::AcidSharp.Vector3 jointId, global::AcidSharp.Vector3 vertexWeight)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uv.__Instance;
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = normal.__Instance;
            if (ReferenceEquals(tangent, null))
                throw new global::System.ArgumentNullException("tangent", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = tangent.__Instance;
            if (ReferenceEquals(jointId, null))
                throw new global::System.ArgumentNullException("jointId", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = jointId.__Instance;
            if (ReferenceEquals(vertexWeight, null))
                throw new global::System.ArgumentNullException("vertexWeight", "Cannot be null because it is a C++ reference (&).");
            var __arg5 = vertexWeight.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
            SetupVTables(GetType().FullName == "AcidSharp.VertexAnimated");
        }

        public VertexAnimated(global::AcidSharp.VertexAnimated source)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.VertexAnimated");
        }

        public VertexAnimated() : this(global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector2.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero)
        {
        }

        public VertexAnimated(global::AcidSharp.Vector3 position) : this(position, global::AcidSharp.Vector2.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero)
        {
        }

        public VertexAnimated(global::AcidSharp.Vector3 position, global::AcidSharp.Vector2 uv) : this(position, uv, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero)
        {
        }

        public VertexAnimated(global::AcidSharp.Vector3 position, global::AcidSharp.Vector2 uv, global::AcidSharp.Vector3 normal) : this(position, uv, normal, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero)
        {
        }

        public VertexAnimated(global::AcidSharp.Vector3 position, global::AcidSharp.Vector2 uv, global::AcidSharp.Vector3 normal, global::AcidSharp.Vector3 tangent) : this(position, uv, normal, tangent, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero)
        {
        }

        public VertexAnimated(global::AcidSharp.Vector3 position, global::AcidSharp.Vector2 uv, global::AcidSharp.Vector3 normal, global::AcidSharp.Vector3 tangent, global::AcidSharp.Vector3 jointId) : this(position, uv, normal, tangent, jointId, global::AcidSharp.Vector3.Zero)
        {
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IVertex __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.VertexAnimated.__Internal*) __Instance)->vfptr_IVertex = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::AcidSharp.VertexAnimated(global::AcidSharp.Vector3 position)
        {
            return new global::AcidSharp.VertexAnimated(position);
        }

        public override global::AcidSharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetPositionDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___SetPositionDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                ___SetPositionDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector2 Uv
        {
            get
            {
                var __ret = new global::AcidSharp.Vector2.__Internal();
                __Internal.GetUv((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetUv((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 Normal
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetNormal((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetNormal((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 Tangent
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetTangent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTangent((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 JointId
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetJointId((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetJointId((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 VertexWeight
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetVertexWeight((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetVertexWeight((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override ulong Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___GetSizeDelegate = (global::AcidSharp.Delegates.Func_ulong_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_ulong_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public static global::AcidSharp.VertexInput VertexInput
        {
            get
            {
                var __ret = new global::AcidSharp.VertexInput.__Internal();
                __Internal.GetVertexInput(new IntPtr(&__ret));
                return global::AcidSharp.VertexInput.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // Vector3 GetPosition() const override { return m_position; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.VertexAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::AcidSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Vector3.__Internal() : *(global::AcidSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // void SetPosition(const Vector3 &position) override { m_position = position; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _SetPositionDelegateInstance;

        private static void _SetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.VertexAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Vector3 __result0;
            if (position == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result0 = (global::AcidSharp.Vector3) global::AcidSharp.Vector3.NativeToManagedMap[position];
            else __result0 = global::AcidSharp.Vector3.__CreateInstance(position);
            __target.Position = __result0;
        }

        // size_t GetSize() const override { return sizeof(VertexAnimated); }
        private static global::AcidSharp.Delegates.Func_ulong_IntPtr _GetSizeDelegateInstance;

        private static ulong _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.VertexAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _SetPositionDelegateInstance += _SetPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetPositionDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class VertexSkinData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_jointIds;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_weights;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexSkinData@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexSkinData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexSkinData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddJointEffect@VertexSkinData@acid@@QEAAXAEBIAEBM@Z")]
            internal static extern void AddJointEffect(global::System.IntPtr instance, uint jointId, float weight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LimitJointNumber@VertexSkinData@acid@@QEAAXAEBI@Z")]
            internal static extern void LimitJointNumber(global::System.IntPtr instance, uint max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FillEmptyWeights@VertexSkinData@acid@@QEAAXAEBI@Z")]
            internal static extern void FillEmptyWeights(global::System.IntPtr instance, uint max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveExcessJointIds@VertexSkinData@acid@@QEAAXAEBI@Z")]
            internal static extern void RemoveExcessJointIds(global::System.IntPtr instance, uint max);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.VertexSkinData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.VertexSkinData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.VertexSkinData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexSkinData(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.VertexSkinData __CreateInstance(global::AcidSharp.VertexSkinData.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexSkinData(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.VertexSkinData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexSkinData.__Internal));
            global::AcidSharp.VertexSkinData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexSkinData(global::AcidSharp.VertexSkinData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexSkinData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexSkinData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexSkinData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public VertexSkinData(global::AcidSharp.VertexSkinData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexSkinData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.VertexSkinData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddJointEffect(uint jointId, float weight)
        {
            __Internal.AddJointEffect((__Instance + __PointerAdjustment), jointId, weight);
        }

        public void LimitJointNumber(uint max)
        {
            __Internal.LimitJointNumber((__Instance + __PointerAdjustment), max);
        }

        public void FillEmptyWeights(uint max)
        {
            __Internal.FillEmptyWeights((__Instance + __PointerAdjustment), max);
        }

        public void RemoveExcessJointIds(uint max)
        {
            __Internal.RemoveExcessJointIds((__Instance + __PointerAdjustment), max);
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class VertexAnimatedData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Vector3.__Internal m_position;

            [FieldOffset(12)]
            internal int m_uvIndex;

            [FieldOffset(16)]
            internal int m_normalIndex;

            [FieldOffset(24)]
            internal global::System.IntPtr m_duplicateVertex;

            [FieldOffset(32)]
            internal int m_index;

            [FieldOffset(40)]
            internal global::AcidSharp.VertexSkinData.__Internal m_skinData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimatedData@acid@@QEAA@AEBHAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int index, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimatedData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexAnimatedData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasSameTextureAndNormal@VertexAnimatedData@acid@@QEBA_NAEBH0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasSameTextureAndNormal(global::System.IntPtr instance, int textureIndexOther, int normalIndexOther);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUvIndex@VertexAnimatedData@acid@@QEBAHXZ")]
            internal static extern int GetUvIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUvIndex@VertexAnimatedData@acid@@QEAAXAEBH@Z")]
            internal static extern void SetUvIndex(global::System.IntPtr instance, int uvIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormalIndex@VertexAnimatedData@acid@@QEBAHXZ")]
            internal static extern int GetNormalIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormalIndex@VertexAnimatedData@acid@@QEAAXAEBH@Z")]
            internal static extern void SetNormalIndex(global::System.IntPtr instance, int normalIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDuplicateVertex@VertexAnimatedData@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetDuplicateVertex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDuplicateVertex@VertexAnimatedData@acid@@QEAAXPEAV12@@Z")]
            internal static extern void SetDuplicateVertex(global::System.IntPtr instance, global::System.IntPtr duplicateVertex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSkinData@VertexAnimatedData@acid@@QEBA?AVVertexSkinData@2@XZ")]
            internal static extern void GetSkinData(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSkinData@VertexAnimatedData@acid@@QEAAXAEBVVertexSkinData@2@@Z")]
            internal static extern void SetSkinData(global::System.IntPtr instance, global::System.IntPtr skinData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@VertexAnimatedData@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@VertexAnimatedData@acid@@QEBAHXZ")]
            internal static extern int GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsSet@VertexAnimatedData@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSet(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.VertexAnimatedData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.VertexAnimatedData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.VertexAnimatedData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexAnimatedData(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.VertexAnimatedData __CreateInstance(global::AcidSharp.VertexAnimatedData.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexAnimatedData(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.VertexAnimatedData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexAnimatedData.__Internal));
            global::AcidSharp.VertexAnimatedData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexAnimatedData(global::AcidSharp.VertexAnimatedData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexAnimatedData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexAnimatedData(int index, global::AcidSharp.Vector3 position)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexAnimatedData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), index, __arg1);
        }

        public VertexAnimatedData(global::AcidSharp.VertexAnimatedData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexAnimatedData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.VertexAnimatedData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool HasSameTextureAndNormal(int textureIndexOther, int normalIndexOther)
        {
            var __ret = __Internal.HasSameTextureAndNormal((__Instance + __PointerAdjustment), textureIndexOther, normalIndexOther);
            return __ret;
        }

        public int UvIndex
        {
            get
            {
                var __ret = __Internal.GetUvIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetUvIndex((__Instance + __PointerAdjustment), value);
            }
        }

        public int NormalIndex
        {
            get
            {
                var __ret = __Internal.GetNormalIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetNormalIndex((__Instance + __PointerAdjustment), value);
            }
        }

        public global::AcidSharp.VertexAnimatedData DuplicateVertex
        {
            get
            {
                var __ret = __Internal.GetDuplicateVertex((__Instance + __PointerAdjustment));
                global::AcidSharp.VertexAnimatedData __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.VertexAnimatedData.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.VertexAnimatedData) global::AcidSharp.VertexAnimatedData.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.VertexAnimatedData.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetDuplicateVertex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.VertexSkinData SkinData
        {
            get
            {
                var __ret = new global::AcidSharp.VertexSkinData.__Internal();
                __Internal.GetSkinData((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.VertexSkinData.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetSkinData((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 Position
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }

        public int Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsSet
        {
            get
            {
                var __ret = __Internal.IsSet((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class GeometryLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 160)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.SharedPtr.__Internal m_meshData;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_VertexSkinData___N_std_S_allocator__S0_ m_vertexWeights;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_VertexAnimatedData___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_positionsList;

            [FieldOffset(64)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Vector2___N_std_S_allocator__S0_ m_uvsList;

            [FieldOffset(88)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Vector3___N_std_S_allocator__S0_ m_normalsList;

            [FieldOffset(112)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_VertexAnimated___N_std_S_allocator__S0_ m_vertices;

            [FieldOffset(136)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_indices;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GeometryLoader@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1GeometryLoader@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.GeometryLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.GeometryLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.GeometryLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.GeometryLoader(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.GeometryLoader __CreateInstance(global::AcidSharp.GeometryLoader.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.GeometryLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.GeometryLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.GeometryLoader.__Internal));
            global::AcidSharp.GeometryLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private GeometryLoader(global::AcidSharp.GeometryLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GeometryLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GeometryLoader(global::AcidSharp.GeometryLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.GeometryLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.GeometryLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class JointData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_index;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_nameId;

            [FieldOffset(40)]
            internal global::AcidSharp.Matrix4.__Internal m_bindLocalTransform;

            [FieldOffset(104)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_acid_S_JointData___N_std_S_allocator__S0_ m_children;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointData@acid@@QEAA@AEBIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint index, global::System.IntPtr nameId, global::System.IntPtr bindLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JointData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@JointData@acid@@QEBAIXZ")]
            internal static extern uint GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNameId@JointData@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetNameId(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBindLocalTransform@JointData@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetBindLocalTransform(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.JointData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.JointData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.JointData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.JointData(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.JointData __CreateInstance(global::AcidSharp.JointData.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.JointData(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.JointData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointData.__Internal));
            global::AcidSharp.JointData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JointData(global::AcidSharp.JointData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public JointData(uint index, string nameId, global::AcidSharp.Matrix4 bindLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(nameId, __allocator1);
            var __arg1 = __basicString1.__Instance;
            if (ReferenceEquals(bindLocalTransform, null))
                throw new global::System.ArgumentNullException("bindLocalTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = bindLocalTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), index, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public JointData(global::AcidSharp.JointData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JointData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.JointData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string NameId
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetNameId((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public global::AcidSharp.Matrix4 BindLocalTransform
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.GetBindLocalTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A class that holds many various math functions.</summary>
    public unsafe partial class Maths : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Maths@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Random@Maths@acid@@SAMAEBM0@Z")]
            internal static extern float Random(float min, float max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomNormal@Maths@acid@@SAMAEBM0@Z")]
            internal static extern float RandomNormal(float standardDeviation, float mean);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomLog@Maths@acid@@SAMAEBM0@Z")]
            internal static extern float RandomLog(float min, float max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Radians@Maths@acid@@SAMAEBM@Z")]
            internal static extern float Radians(float degrees);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Degrees@Maths@acid@@SAMAEBM@Z")]
            internal static extern float Degrees(float radians);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WrapDegrees@Maths@acid@@SAMAEBM@Z")]
            internal static extern float WrapDegrees(float degrees);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WrapRadians@Maths@acid@@SAMAEBM@Z")]
            internal static extern float WrapRadians(float radians);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RoundToPlace@Maths@acid@@SAMAEBMAEBH@Z")]
            internal static extern float RoundToPlace(float value, int place);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Deadband@Maths@acid@@SAMAEBM0@Z")]
            internal static extern float Deadband(float min, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AlmostEqual@Maths@acid@@SA_NAEBM00@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AlmostEqual(float a, float b, float eps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Maths@acid@@SAMAEBM00@Z")]
            internal static extern float SmoothDamp(float current, float target, float rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@Maths@acid@@SAMAEBM00@Z")]
            internal static extern float Interpolate(float a, float b, float blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InterpolateCosine@Maths@acid@@SAMAEBM00@Z")]
            internal static extern float InterpolateCosine(float a, float b, float blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothlyStep@Maths@acid@@SAMAEBM00@Z")]
            internal static extern float SmoothlyStep(float edge0, float edge1, float x);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Maths> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Maths>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Maths __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Maths(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Maths __CreateInstance(global::AcidSharp.Maths.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Maths(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Maths.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Maths.__Internal));
            *(global::AcidSharp.Maths.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Maths(global::AcidSharp.Maths.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Maths(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Maths()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Maths.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Maths(global::AcidSharp.Maths _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Maths.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.Maths.__Internal*) __Instance) = *((global::AcidSharp.Maths.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Maths __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Generates a random value from between a range.</summary>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        public static float Random(float min = 0.0F, float max = 1.0F)
        {
            var __ret = __Internal.Random(min, max);
            return __ret;
        }

        /// <summary>Generates a single value from a normal distribution, using Box-Muller. https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform</summary>
        /// <param name="standardDeviation">The standards deviation of the distribution.</param>
        /// <param name="mean">The mean of the distribution.</param>
        public static float RandomNormal(float standardDeviation, float mean)
        {
            var __ret = __Internal.RandomNormal(standardDeviation, mean);
            return __ret;
        }

        /// <summary>Creates a number between two numbers, logarithmic.</summary>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        public static float RandomLog(float min, float max)
        {
            var __ret = __Internal.RandomLog(min, max);
            return __ret;
        }

        /// <summary>Converts degrees to radians.</summary>
        /// <param name="degrees">The degrees value.</param>
        public static float Radians(float degrees)
        {
            var __ret = __Internal.Radians(degrees);
            return __ret;
        }

        /// <summary>Converts radians to degrees.</summary>
        /// <param name="radians">The radians value.</param>
        public static float Degrees(float radians)
        {
            var __ret = __Internal.Degrees(radians);
            return __ret;
        }

        /// <summary>Normalizes a angle into the range of 0-360.</summary>
        /// <param name="degrees">The source angle.</param>
        public static float WrapDegrees(float degrees)
        {
            var __ret = __Internal.WrapDegrees(degrees);
            return __ret;
        }

        /// <summary>Normalizes a angle into the range of 0-2PI.</summary>
        /// <param name="radians">The source angle.</param>
        public static float WrapRadians(float radians)
        {
            var __ret = __Internal.WrapRadians(radians);
            return __ret;
        }

        /// <summary>Rounds a value to a amount of places after the decimal point.</summary>
        /// <param name="value">The value to round.</param>
        /// <param name="place">How many places after the decimal to round to.</param>
        public static float RoundToPlace(float value, int place)
        {
            var __ret = __Internal.RoundToPlace(value, place);
            return __ret;
        }

        /// <summary>Used to floor the value if less than the min.</summary>
        /// <param name="min">The minimum value.</param>
        /// <param name="value">The value.</param>
        public static float Deadband(float min, float value)
        {
            var __ret = __Internal.Deadband(min, value);
            return __ret;
        }

        /// <summary>Checks if two values are almost equal.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="eps">EPS is the measure of equality.</param>
        public static bool AlmostEqual(float a, float b, float eps)
        {
            var __ret = __Internal.AlmostEqual(a, b, eps);
            return __ret;
        }

        /// <summary>Gradually changes a value to a target.</summary>
        /// <param name="current">The current value.</param>
        /// <param name="target">The target value.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public static float SmoothDamp(float current, float target, float rate)
        {
            var __ret = __Internal.SmoothDamp(current, target, rate);
            return __ret;
        }

        /// <summary>Interpolates two values by a blendFactor using linear interpolation.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="blend">The blend value.</param>
        public static float Interpolate(float a, float b, float blend)
        {
            var __ret = __Internal.Interpolate(a, b, blend);
            return __ret;
        }

        /// <summary>Interpolates two values by a blendFactor using cosine interpolation.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="blend">The blend value.</param>
        public static float InterpolateCosine(float a, float b, float blend)
        {
            var __ret = __Internal.InterpolateCosine(a, b, blend);
            return __ret;
        }

        /// <summary>A calculation that steps smoothly between two edges.</summary>
        /// <param name="edge0">The inner edge.</param>
        /// <param name="edge1">The outer edge.</param>
        /// <param name="x">The sample.</param>
        public static float SmoothlyStep(float edge0, float edge1, float x)
        {
            var __ret = __Internal.SmoothlyStep(edge0, edge1, x);
            return __ret;
        }
    }

    public unsafe partial class Maths
    {
        public partial struct __Internal
        {
        }

        public static float Pi
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?PI@acid@@3MB");
                return *__ptr;
            }
        }

        public static float DegToRad
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DEG_TO_RAD@acid@@3MB");
                return *__ptr;
            }
        }

        public static float RadToDeg
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?RAD_TO_DEG@acid@@3MB");
                return *__ptr;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Holds a RGBA colour.</summary>
    public unsafe partial class Colour : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Colour._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr hex, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBVVector4@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Colour@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Colour@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Colour@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Colour@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Colour@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Colour@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Colour@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@Colour@acid@@QEBA?AV12@AEBV12@M@Z")]
            internal static extern void Interpolate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other, float blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Colour@acid@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Colour@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Colour@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Colour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Colour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MColour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NColour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OColour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PColour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Colour@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Colour@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Colour@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVColour@0@V10@AEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::AcidSharp.Colour.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVColour@0@V10@AEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::AcidSharp.Colour.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVColour@0@V10@AEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::AcidSharp.Colour.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVColour@0@V10@AEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::AcidSharp.Colour.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVColour@0@V10@M@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::AcidSharp.Colour.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVColour@0@V10@M@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::AcidSharp.Colour.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVColour@0@V10@M@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::AcidSharp.Colour.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVColour@0@V10@M@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::AcidSharp.Colour.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVColour@0@MV10@@Z")]
            internal static extern void OperatorPlus_1(global::System.IntPtr @return, float value, global::AcidSharp.Colour.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVColour@0@MV10@@Z")]
            internal static extern void OperatorMinus_1(global::System.IntPtr @return, float value, global::AcidSharp.Colour.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVColour@0@MV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, float value, global::AcidSharp.Colour.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVColour@0@MV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, float value, global::AcidSharp.Colour.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AColour@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetR@Colour@acid@@QEBAMXZ")]
            internal static extern float GetR(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetR@Colour@acid@@QEAAXAEBM@Z")]
            internal static extern void SetR(global::System.IntPtr instance, float r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetG@Colour@acid@@QEBAMXZ")]
            internal static extern float GetG(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetG@Colour@acid@@QEAAXAEBM@Z")]
            internal static extern void SetG(global::System.IntPtr instance, float g);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetB@Colour@acid@@QEBAMXZ")]
            internal static extern float GetB(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetB@Colour@acid@@QEAAXAEBM@Z")]
            internal static extern void SetB(global::System.IntPtr instance, float b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetA@Colour@acid@@QEBAMXZ")]
            internal static extern float GetA(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetA@Colour@acid@@QEAAXAEBM@Z")]
            internal static extern void SetA(global::System.IntPtr instance, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Colour@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Colour@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUnit@Colour@acid@@QEBA?AV12@XZ")]
            internal static extern void GetUnit(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHex@Colour@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetHex(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::AcidSharp.Colour._.__.__Internal __;

                [FieldOffset(0)]
                internal global::AcidSharp.Colour._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed float m_elements[4];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Colour> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Colour>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Colour __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Colour(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Colour __CreateInstance(global::AcidSharp.Colour.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Colour(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Colour.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Colour.__Internal));
            global::AcidSharp.Colour.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Colour(global::AcidSharp.Colour.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Colour(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for colour.</summary>
        public Colour()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="r">The new R value.</param>
        /// <param name="g">The new G value.</param>
        /// <param name="b">The new B value.</param>
        /// <param name="a">The new A value.</param>
        public Colour(float r, float g, float b, float a = 1.0F)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), r, g, b, a);
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="hex">The new values from HEX.</param>
        /// <param name="a">The new A value.</param>
        public Colour(string hex, float a = 1.0F)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(hex, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, a);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="source">Creates this colour out of a existing one.</param>
        public Colour(global::AcidSharp.Colour source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="source">Creates this colour out of a existing vector.</param>
        public Colour(global::AcidSharp.Vector3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="source">Creates this colour out of a existing vector.</param>
        public Colour(global::AcidSharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Colour __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Colour Add(global::AcidSharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Colour Subtract(global::AcidSharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Colour Multiply(global::AcidSharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Colour Divide(global::AcidSharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::AcidSharp.Colour Scale(float scalar)
        {
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::AcidSharp.Colour Normalize()
        {
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Interpolates between this and another colour.</summary>
        /// <param name="other">The other colour.</param>
        /// <param name="blend">The blend factor.</param>
        public global::AcidSharp.Colour Interpolate(global::AcidSharp.Colour other, float blend)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.Interpolate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, blend);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::AcidSharp.Colour SmoothDamp(global::AcidSharp.Colour target, global::AcidSharp.Colour rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public void Decode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::AcidSharp.Colour __op, global::AcidSharp.Colour other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Colour;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Colour.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Colour __op, global::AcidSharp.Colour other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::AcidSharp.Colour __op, global::AcidSharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::AcidSharp.Colour __op, global::AcidSharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::AcidSharp.Colour __op, global::AcidSharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::AcidSharp.Colour __op, global::AcidSharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::AcidSharp.Colour __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::AcidSharp.Colour __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.Colour(string hex)
        {
            return new global::AcidSharp.Colour(hex);
        }

        public static implicit operator global::AcidSharp.Colour(global::AcidSharp.Vector3 source)
        {
            return new global::AcidSharp.Colour(source);
        }

        public static implicit operator global::AcidSharp.Colour(global::AcidSharp.Vector4 source)
        {
            return new global::AcidSharp.Colour(source);
        }

        public static global::AcidSharp.Colour operator +(global::AcidSharp.Colour left, global::AcidSharp.Colour right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator -(global::AcidSharp.Colour left, global::AcidSharp.Colour right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator *(global::AcidSharp.Colour left, global::AcidSharp.Colour right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator /(global::AcidSharp.Colour left, global::AcidSharp.Colour right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator +(global::AcidSharp.Colour left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, value);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator -(global::AcidSharp.Colour left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, value);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator *(global::AcidSharp.Colour left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, value);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator /(global::AcidSharp.Colour left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, value);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator +(float value, global::AcidSharp.Colour left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorPlus_1(new IntPtr(&__ret), value, __arg1);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator -(float value, global::AcidSharp.Colour left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorMinus_1(new IntPtr(&__ret), value, __arg1);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator *(float value, global::AcidSharp.Colour left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), value, __arg1);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour operator /(float value, global::AcidSharp.Colour left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::AcidSharp.Colour.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), value, __arg1);
            return global::AcidSharp.Colour.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Colour Clear
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?CLEAR@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Black
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?BLACK@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Grey
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?GREY@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Silver
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?SILVER@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour White
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?WHITE@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Maroon
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?MAROON@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Red
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?RED@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Olive
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?OLIVE@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Yellow
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?YELLOW@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Green
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?GREEN@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Lime
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?LIME@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Teal
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?TEAL@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Aqua
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?AQUA@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Navy
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NAVY@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Blue
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?BLUE@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Purple
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?PURPLE@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Colour Fuchsia
        {
            get
            {
                var __ptr = (global::AcidSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?FUCHSIA@Colour@acid@@2V12@B");
                return global::AcidSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), index);
                return *__ret;
            }

            set
            {
                *global::AcidSharp.Colour.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), index) = value;
            }
        }

        public float R
        {
            get
            {
                var __ret = __Internal.GetR((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetR((__Instance + __PointerAdjustment), value);
            }
        }

        public float G
        {
            get
            {
                var __ret = __Internal.GetG((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetG((__Instance + __PointerAdjustment), value);
            }
        }

        public float B
        {
            get
            {
                var __ret = __Internal.GetB((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetB((__Instance + __PointerAdjustment), value);
            }
        }

        public float A
        {
            get
            {
                var __ret = __Internal.GetA((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetA((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets a colour representing the unit value of this colour.</summary>
        public global::AcidSharp.Colour Unit
        {
            get
            {
                var __ret = new global::AcidSharp.Colour.__Internal();
                __Internal.GetUnit((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Colour.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the hex code from this colour.</summary>
        public string Hex
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetHex((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class VertexModel : global::AcidSharp.IVertex, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IVertex;

            [FieldOffset(8)]
            internal global::AcidSharp.Vector3.__Internal m_position;

            [FieldOffset(20)]
            internal global::AcidSharp.Vector2.__Internal m_uv;

            [FieldOffset(28)]
            internal global::AcidSharp.Vector3.__Internal m_normal;

            [FieldOffset(40)]
            internal global::AcidSharp.Vector3.__Internal m_tangent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModel@acid@@QEAA@AEBVVector3@1@AEBVVector2@1@00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr uv, global::System.IntPtr normal, global::System.IntPtr tangent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModel@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexModel@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUv@VertexModel@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetUv(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUv@VertexModel@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetUv(global::System.IntPtr instance, global::System.IntPtr uv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormal@VertexModel@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetNormal(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormal@VertexModel@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetNormal(global::System.IntPtr instance, global::System.IntPtr normal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTangent@VertexModel@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetTangent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTangent@VertexModel@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetTangent(global::System.IntPtr instance, global::System.IntPtr tangent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexInput@VertexModel@acid@@SA?AVVertexInput@2@XZ")]
            internal static extern void GetVertexInput(global::System.IntPtr @return);
        }

        internal static new global::AcidSharp.VertexModel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexModel(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.VertexModel __CreateInstance(global::AcidSharp.VertexModel.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.VertexModel(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.VertexModel.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexModel.__Internal));
            global::AcidSharp.VertexModel.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexModel(global::AcidSharp.VertexModel.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexModel(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public VertexModel(global::AcidSharp.Vector3 position, global::AcidSharp.Vector2 uv, global::AcidSharp.Vector3 normal, global::AcidSharp.Vector3 tangent)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexModel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uv.__Instance;
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = normal.__Instance;
            if (ReferenceEquals(tangent, null))
                throw new global::System.ArgumentNullException("tangent", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = tangent.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            SetupVTables(GetType().FullName == "AcidSharp.VertexModel");
        }

        public VertexModel(global::AcidSharp.VertexModel source)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.VertexModel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.VertexModel");
        }

        public VertexModel() : this(global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector2.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero)
        {
        }

        public VertexModel(global::AcidSharp.Vector3 position) : this(position, global::AcidSharp.Vector2.Zero, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero)
        {
        }

        public VertexModel(global::AcidSharp.Vector3 position, global::AcidSharp.Vector2 uv) : this(position, uv, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.Zero)
        {
        }

        public VertexModel(global::AcidSharp.Vector3 position, global::AcidSharp.Vector2 uv, global::AcidSharp.Vector3 normal) : this(position, uv, normal, global::AcidSharp.Vector3.Zero)
        {
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IVertex __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.VertexModel.__Internal*) __Instance)->vfptr_IVertex = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::AcidSharp.VertexModel(global::AcidSharp.Vector3 position)
        {
            return new global::AcidSharp.VertexModel(position);
        }

        public override global::AcidSharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetPositionDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___SetPositionDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                ___SetPositionDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector2 Uv
        {
            get
            {
                var __ret = new global::AcidSharp.Vector2.__Internal();
                __Internal.GetUv((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetUv((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 Normal
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetNormal((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetNormal((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 Tangent
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetTangent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTangent((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override ulong Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___GetSizeDelegate = (global::AcidSharp.Delegates.Func_ulong_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_ulong_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public static global::AcidSharp.VertexInput VertexInput
        {
            get
            {
                var __ret = new global::AcidSharp.VertexInput.__Internal();
                __Internal.GetVertexInput(new IntPtr(&__ret));
                return global::AcidSharp.VertexInput.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // Vector3 GetPosition() const override { return m_position; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.VertexModel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::AcidSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Vector3.__Internal() : *(global::AcidSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // void SetPosition(const Vector3 &position) override { m_position = position; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _SetPositionDelegateInstance;

        private static void _SetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.VertexModel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Vector3 __result0;
            if (position == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result0 = (global::AcidSharp.Vector3) global::AcidSharp.Vector3.NativeToManagedMap[position];
            else __result0 = global::AcidSharp.Vector3.__CreateInstance(position);
            __target.Position = __result0;
        }

        // size_t GetSize() const override { return sizeof(VertexModel); }
        private static global::AcidSharp.Delegates.Func_ulong_IntPtr _GetSizeDelegateInstance;

        private static ulong _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.VertexModel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _SetPositionDelegateInstance += _SetPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetPositionDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class IComponent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IComponent@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IComponent@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStarted@IComponent@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetStarted(global::System.IntPtr instance, bool started);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnabled@IComponent@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetEnabled(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGameObject@IComponent@acid@@QEBAPEAVGameObject@2@XZ")]
            internal static extern global::System.IntPtr GetGameObject(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGameObject@IComponent@acid@@QEAAXPEAVGameObject@2@@Z")]
            internal static extern void SetGameObject(global::System.IntPtr instance, global::System.IntPtr gameObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsStarted@IComponent@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsStarted(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsEnabled@IComponent@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsEnabled(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IComponent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IComponent>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IComponent __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IComponent(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IComponent __CreateInstance(global::AcidSharp.IComponent.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IComponent(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.IComponent.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IComponent.__Internal));
            global::AcidSharp.IComponent.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private IComponent(global::AcidSharp.IComponent.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IComponent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public IComponent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IComponent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.IComponent");
        }

        public IComponent(global::AcidSharp.IComponent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IComponent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IComponent");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IComponent.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public virtual void Start()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___StartDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___StartDelegate((__Instance + __PointerAdjustment));
        }

        public virtual void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public virtual void Decode(global::AcidSharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___DecodeDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public virtual void Encode(global::AcidSharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___EncodeDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetStarted(bool started)
        {
            __Internal.SetStarted((__Instance + __PointerAdjustment), started);
        }

        public void SetEnabled(bool enable)
        {
            __Internal.SetEnabled((__Instance + __PointerAdjustment), enable);
        }

        public global::AcidSharp.GameObject GameObject
        {
            get
            {
                var __ret = __Internal.GetGameObject((__Instance + __PointerAdjustment));
                global::AcidSharp.GameObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.GameObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.GameObject) global::AcidSharp.GameObject.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.GameObject.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetGameObject((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool IsStarted
        {
            get
            {
                var __ret = __Internal.IsStarted((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsEnabled
        {
            get
            {
                var __ret = __Internal.IsEnabled((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Start() { }
        private static global::AcidSharp.Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IComponent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() { }
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IComponent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) { }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IComponent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::AcidSharp.Metadata) global::AcidSharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::AcidSharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const { }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IComponent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::AcidSharp.Metadata) global::AcidSharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::AcidSharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class Mesh : global::AcidSharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Std.SharedPtr.__Internal m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mesh@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Mesh@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.Mesh __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Mesh(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Mesh __CreateInstance(global::AcidSharp.Mesh.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Mesh(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Mesh.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Mesh.__Internal));
            global::AcidSharp.Mesh.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Mesh(global::AcidSharp.Mesh.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Mesh(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Mesh(global::AcidSharp.Mesh _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Mesh.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Mesh");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Mesh.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::AcidSharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::AcidSharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public virtual void TrySetModel(string filename)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
            var ___TrySetModelDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            ___TrySetModelDelegate((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public virtual global::AcidSharp.VertexInput VertexInput
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetVertexInputDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.VertexInput.__Internal();
                ___GetVertexInputDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.VertexInput.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::AcidSharp.Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::AcidSharp.Metadata) global::AcidSharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::AcidSharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::AcidSharp.Metadata) global::AcidSharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::AcidSharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // VertexInput GetVertexInput() const { return VertexModel::GetVertexInput(); }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetVertexInputDelegateInstance;

        private static void _GetVertexInputDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.VertexInput;
            *(global::AcidSharp.VertexInput.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.VertexInput.__Internal() : *(global::AcidSharp.VertexInput.__Internal*) __ret.__Instance;
        }

        // void TrySetModel(const std::string &filename)
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _TrySetModelDelegateInstance;

        private static void _TrySetModelDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.TrySetModel(__stringRet0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetVertexInputDelegateInstance += _GetVertexInputDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetVertexInputDelegateInstance).ToPointer();
                _TrySetModelDelegateInstance += _TrySetModelDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_TrySetModelDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                *(void**) (vfptr0 + 48) = _Thunks[4];
                *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                *(void**) (vfptr0 + 64) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class SkeletonLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.SharedPtr.__Internal m_armatureData;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_boneOrder;

            [FieldOffset(40)]
            internal uint m_jointCount;

            [FieldOffset(48)]
            internal global::Std.SharedPtr.__Internal m_headJoint;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SkeletonLoader@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SkeletonLoader@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointCount@SkeletonLoader@acid@@QEBAIXZ")]
            internal static extern uint GetJointCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.SkeletonLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.SkeletonLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.SkeletonLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.SkeletonLoader(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.SkeletonLoader __CreateInstance(global::AcidSharp.SkeletonLoader.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.SkeletonLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.SkeletonLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SkeletonLoader.__Internal));
            global::AcidSharp.SkeletonLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SkeletonLoader(global::AcidSharp.SkeletonLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SkeletonLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SkeletonLoader(global::AcidSharp.SkeletonLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SkeletonLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.SkeletonLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint JointCount
        {
            get
            {
                var __ret = __Internal.GetJointCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class SkinLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.SharedPtr.__Internal m_skinData;

            [FieldOffset(16)]
            internal uint m_maxWeights;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_jointOrder;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_VertexSkinData___N_std_S_allocator__S0_ m_verticesSkinData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SkinLoader@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SkinLoader@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.SkinLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.SkinLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.SkinLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.SkinLoader(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.SkinLoader __CreateInstance(global::AcidSharp.SkinLoader.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.SkinLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.SkinLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SkinLoader.__Internal));
            global::AcidSharp.SkinLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SkinLoader(global::AcidSharp.SkinLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SkinLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SkinLoader(global::AcidSharp.SkinLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SkinLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.SkinLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace AcidSharp
{
    /// <summary>This class represents an animated armature with a skin mesh.</summary>
    public unsafe partial class MeshAnimated : global::AcidSharp.Mesh, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 144)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(40)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(72)]
            internal global::Std.SharedPtr.__Internal m_model1;

            [FieldOffset(88)]
            internal global::Std.SharedPtr.__Internal m_headJoint;

            [FieldOffset(104)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Animator___N_std_S_default_delete__S0_ m_animator;

            [FieldOffset(112)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Animation___N_std_S_default_delete__S0_ m_animation;

            [FieldOffset(120)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Matrix4___N_std_S_allocator__S0_ m_jointMatrices;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshAnimated@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshAnimated@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1MeshAnimated@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.MeshAnimated __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.MeshAnimated(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.MeshAnimated __CreateInstance(global::AcidSharp.MeshAnimated.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.MeshAnimated(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.MeshAnimated.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.MeshAnimated.__Internal));
            global::AcidSharp.MeshAnimated.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshAnimated(global::AcidSharp.MeshAnimated.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshAnimated(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MeshAnimated(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.MeshAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "AcidSharp.MeshAnimated");
        }

        public MeshAnimated(global::AcidSharp.MeshAnimated _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.MeshAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.MeshAnimated");
        }

        public MeshAnimated() : this("")
        {
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.MeshAnimated.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::AcidSharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::AcidSharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public override void TrySetModel(string filename)
        {
            base.TrySetModel(filename);
        }

        public static implicit operator global::AcidSharp.MeshAnimated(string filename)
        {
            return new global::AcidSharp.MeshAnimated(filename);
        }

        public static global::AcidSharp.Matrix4 Correction
        {
            get
            {
                var __ptr = (global::AcidSharp.Matrix4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?CORRECTION@MeshAnimated@acid@@2VMatrix4@2@B");
                return global::AcidSharp.Matrix4.__CreateInstance(*__ptr);
            }
        }

        public static uint MaxJoints
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?MAX_JOINTS@MeshAnimated@acid@@2IB");
                return *__ptr;
            }
        }

        public static uint MaxWeights
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?MAX_WEIGHTS@MeshAnimated@acid@@2IB");
                return *__ptr;
            }
        }

        public override global::AcidSharp.VertexInput VertexInput
        {
            get
            {
                return base.VertexInput;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::AcidSharp.Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::AcidSharp.Metadata) global::AcidSharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::AcidSharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::AcidSharp.Metadata) global::AcidSharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::AcidSharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // VertexInput GetVertexInput() const { return VertexAnimated::GetVertexInput(); }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetVertexInputDelegateInstance;

        private static void _GetVertexInputDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.VertexInput;
            *(global::AcidSharp.VertexInput.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.VertexInput.__Internal() : *(global::AcidSharp.VertexInput.__Internal*) __ret.__Instance;
        }

        // void TrySetModel(const std::string &filename) override
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _TrySetModelDelegateInstance;

        private static void _TrySetModelDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.TrySetModel(__stringRet0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetVertexInputDelegateInstance += _GetVertexInputDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetVertexInputDelegateInstance).ToPointer();
                _TrySetModelDelegateInstance += _TrySetModelDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_TrySetModelDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                *(void**) (vfptr0 + 48) = _Thunks[4];
                *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                *(void**) (vfptr0 + 64) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class ALCdeviceStruct
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCdeviceStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCdeviceStruct>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::ALCdeviceStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::ALCdeviceStruct(native.ToPointer(), skipVTables);
    }

    internal static global::ALCdeviceStruct __CreateInstance(global::ALCdeviceStruct.__Internal native, bool skipVTables = false)
    {
        return new global::ALCdeviceStruct(native, skipVTables);
    }

    private static void* __CopyValue(global::ALCdeviceStruct.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::ALCdeviceStruct.__Internal));
        *(global::ALCdeviceStruct.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private ALCdeviceStruct(global::ALCdeviceStruct.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected ALCdeviceStruct(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class ALCcontextStruct
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCcontextStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCcontextStruct>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::ALCcontextStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::ALCcontextStruct(native.ToPointer(), skipVTables);
    }

    internal static global::ALCcontextStruct __CreateInstance(global::ALCcontextStruct.__Internal native, bool skipVTables = false)
    {
        return new global::ALCcontextStruct(native, skipVTables);
    }

    private static void* __CopyValue(global::ALCcontextStruct.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::ALCcontextStruct.__Internal));
        *(global::ALCcontextStruct.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private ALCcontextStruct(global::ALCcontextStruct.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected ALCcontextStruct(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace AcidSharp
{
    /// <summary>A module used for loading, managing and playing a variety of different sound types.</summary>
    public unsafe partial class Audio : global::AcidSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_alDevice;

            [FieldOffset(16)]
            internal global::System.IntPtr m_alContext;

            [FieldOffset(24)]
            internal float m_volume;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Audio@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Audio@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Audio@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Audio@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StringifyResultAl@Audio@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH@Z")]
            internal static extern void StringifyResultAl(global::System.IntPtr @return, int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CheckAl@Audio@acid@@SAXAEBH@Z")]
            internal static extern void CheckAl(int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVolume@Audio@acid@@QEBAMXZ")]
            internal static extern float GetVolume(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetVolume@Audio@acid@@QEAAXAEBM@Z")]
            internal static extern void SetVolume(global::System.IntPtr instance, float volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDevice@Audio@acid@@QEBAPEAUALCdevice_struct@@XZ")]
            internal static extern global::System.IntPtr GetDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetContext@Audio@acid@@QEBAPEAUALCcontext_struct@@XZ")]
            internal static extern global::System.IntPtr GetContext(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.Audio __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Audio(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Audio __CreateInstance(global::AcidSharp.Audio.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Audio(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Audio.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Audio.__Internal));
            global::AcidSharp.Audio.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Audio(global::AcidSharp.Audio.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Audio(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Audio()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Audio.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.Audio");
        }

        public Audio(global::AcidSharp.Audio _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Audio.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Audio");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Audio.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::AcidSharp.Audio Get()
        {
            var __ret = __Internal.Get();
            global::AcidSharp.Audio __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Audio.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Audio) global::AcidSharp.Audio.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Audio.__CreateInstance(__ret);
            return __result0;
        }

        public static string StringifyResultAl(int result)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.StringifyResultAl(new IntPtr(&__ret), result);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static void CheckAl(int result)
        {
            __Internal.CheckAl(result);
        }

        public float Volume
        {
            get
            {
                var __ret = __Internal.GetVolume((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetVolume((__Instance + __PointerAdjustment), value);
            }
        }

        public global::ALCdeviceStruct Device
        {
            get
            {
                var __ret = __Internal.GetDevice((__Instance + __PointerAdjustment));
                global::ALCdeviceStruct __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ALCdeviceStruct.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ALCdeviceStruct) global::ALCdeviceStruct.NativeToManagedMap[__ret];
                else __result0 = global::ALCdeviceStruct.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::ALCcontextStruct Context
        {
            get
            {
                var __ret = __Internal.GetContext((__Instance + __PointerAdjustment));
                global::ALCcontextStruct __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ALCcontextStruct.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ALCcontextStruct) global::ALCcontextStruct.NativeToManagedMap[__ret];
                else __result0 = global::ALCcontextStruct.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Audio) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>Class that represents a sound buffer.</summary>
    public unsafe partial class SoundBuffer : global::AcidSharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal uint m_buffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SoundBuffer@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SoundBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SoundBuffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBuffer@SoundBuffer@acid@@QEBAIXZ")]
            internal static extern uint GetBuffer(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.SoundBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.SoundBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.SoundBuffer __CreateInstance(global::AcidSharp.SoundBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.SoundBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.SoundBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SoundBuffer.__Internal));
            global::AcidSharp.SoundBuffer.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SoundBuffer(global::AcidSharp.SoundBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new sound buffer.</summary>
        /// <param name="filename">The file to load the sound buffer from.</param>
        public SoundBuffer(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SoundBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "AcidSharp.SoundBuffer");
        }

        public SoundBuffer(global::AcidSharp.SoundBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SoundBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.SoundBuffer");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.SoundBuffer.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::AcidSharp.SoundBuffer(string filename)
        {
            return new global::AcidSharp.SoundBuffer(filename);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public uint Buffer
        {
            get
            {
                var __ret = __Internal.GetBuffer((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.SoundBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public enum SoundType
    {
        TypeGeneral = 0,
        TypeSound = 1,
        TypeMusic = 2
    }

    /// <summary>Class that represents a loaded sound.</summary>
    public unsafe partial class Sound : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.SharedPtr.__Internal m_soundBuffer;

            [FieldOffset(16)]
            internal uint m_source;

            [FieldOffset(20)]
            internal byte m_playing;

            [FieldOffset(24)]
            internal float m_gain;

            [FieldOffset(28)]
            internal float m_pitch;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Sound@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBM1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, float gain, float pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Sound@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Sound@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Play@Sound@acid@@QEAAXAEB_N@Z")]
            internal static extern void Play(global::System.IntPtr instance, bool loop);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Pause@Sound@acid@@QEAAXXZ")]
            internal static extern void Pause(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resume@Sound@acid@@QEAAXXZ")]
            internal static extern void Resume(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Stop@Sound@acid@@QEAAXXZ")]
            internal static extern void Stop(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Sound@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDirection@Sound@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetDirection(global::System.IntPtr instance, global::System.IntPtr direction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetVelocity@Sound@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetVelocity(global::System.IntPtr instance, global::System.IntPtr velocity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGain@Sound@acid@@QEBAMXZ")]
            internal static extern float GetGain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGain@Sound@acid@@QEAAXAEBM@Z")]
            internal static extern void SetGain(global::System.IntPtr instance, float gain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPitch@Sound@acid@@QEBAMXZ")]
            internal static extern float GetPitch(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPitch@Sound@acid@@QEAAXAEBM@Z")]
            internal static extern void SetPitch(global::System.IntPtr instance, float pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsPlaying@Sound@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPlaying(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Sound> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Sound>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Sound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Sound(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Sound __CreateInstance(global::AcidSharp.Sound.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Sound(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Sound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Sound.__Internal));
            global::AcidSharp.Sound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Sound(global::AcidSharp.Sound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sound(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Sound(string filename, float gain = 1.0F, float pitch = 1.0F)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Sound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, gain, pitch);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public Sound(global::AcidSharp.Sound _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Sound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Sound __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Play(bool loop = false)
        {
            __Internal.Play((__Instance + __PointerAdjustment), loop);
        }

        public void Pause()
        {
            __Internal.Pause((__Instance + __PointerAdjustment));
        }

        public void Resume()
        {
            __Internal.Resume((__Instance + __PointerAdjustment));
        }

        public void Stop()
        {
            __Internal.Stop((__Instance + __PointerAdjustment));
        }

        public void SetPosition(global::AcidSharp.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetDirection(global::AcidSharp.Vector3 direction)
        {
            if (ReferenceEquals(direction, null))
                throw new global::System.ArgumentNullException("direction", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = direction.__Instance;
            __Internal.SetDirection((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetVelocity(global::AcidSharp.Vector3 velocity)
        {
            if (ReferenceEquals(velocity, null))
                throw new global::System.ArgumentNullException("velocity", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = velocity.__Instance;
            __Internal.SetVelocity((__Instance + __PointerAdjustment), __arg0);
        }

        public static implicit operator global::AcidSharp.Sound(string filename)
        {
            return new global::AcidSharp.Sound(filename);
        }

        public float Gain
        {
            get
            {
                var __ret = __Internal.GetGain((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetGain((__Instance + __PointerAdjustment), value);
            }
        }

        public float Pitch
        {
            get
            {
                var __ret = __Internal.GetPitch((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetPitch((__Instance + __PointerAdjustment), value);
            }
        }

        public bool IsPlaying
        {
            get
            {
                var __ret = __Internal.IsPlaying((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}


public enum STBVorbisError
{
    VorbisNoError = 0,
    VorbisNeedMoreData = 1,
    VorbisInvalidApiMixing = 2,
    VorbisOutofmem = 3,
    VorbisFeatureNotSupported = 4,
    VorbisTooManyChannels = 5,
    VorbisFileOpenFailure = 6,
    VorbisSeekWithoutLength = 7,
    VorbisUnexpectedEof = 10,
    VorbisSeekInvalid = 11,
    VorbisInvalidSetup = 20,
    VorbisInvalidStream = 21,
    VorbisMissingCapturePattern = 30,
    VorbisInvalidStreamStructureVersion = 31,
    VorbisContinuedPacketFlagInvalid = 32,
    VorbisIncorrectStreamSerialNumber = 33,
    VorbisInvalidFirstPage = 34,
    VorbisBadPacketType = 35,
    VorbisCantFindLastPage = 36,
    VorbisSeekFailed = 37
}


public unsafe partial class StbVorbisAlloc : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal global::System.IntPtr alloc_buffer;

        [FieldOffset(8)]
        internal int alloc_buffer_length_in_bytes;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0stb_vorbis_alloc@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::StbVorbisAlloc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::StbVorbisAlloc>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::StbVorbisAlloc __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::StbVorbisAlloc(native.ToPointer(), skipVTables);
    }

    internal static global::StbVorbisAlloc __CreateInstance(global::StbVorbisAlloc.__Internal native, bool skipVTables = false)
    {
        return new global::StbVorbisAlloc(native, skipVTables);
    }

    private static void* __CopyValue(global::StbVorbisAlloc.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::StbVorbisAlloc.__Internal));
        *(global::StbVorbisAlloc.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private StbVorbisAlloc(global::StbVorbisAlloc.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected StbVorbisAlloc(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public StbVorbisAlloc()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::StbVorbisAlloc.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public StbVorbisAlloc(global::StbVorbisAlloc _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::StbVorbisAlloc.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::StbVorbisAlloc.__Internal*) __Instance) = *((global::StbVorbisAlloc.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::StbVorbisAlloc __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public char* AllocBuffer
    {
        get
        {
            return (char*) ((global::StbVorbisAlloc.__Internal*) __Instance)->alloc_buffer;
        }

        set
        {
            ((global::StbVorbisAlloc.__Internal*)__Instance)->alloc_buffer = (global::System.IntPtr) (sbyte*) value;
        }
    }

    public int AllocBufferLengthInBytes
    {
        get
        {
            return ((global::StbVorbisAlloc.__Internal*) __Instance)->alloc_buffer_length_in_bytes;
        }

        set
        {
            ((global::StbVorbisAlloc.__Internal*)__Instance)->alloc_buffer_length_in_bytes = value;
        }
    }
}

public unsafe partial class StbVorbis
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::StbVorbis> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::StbVorbis>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::StbVorbis __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::StbVorbis(native.ToPointer(), skipVTables);
    }

    internal static global::StbVorbis __CreateInstance(global::StbVorbis.__Internal native, bool skipVTables = false)
    {
        return new global::StbVorbis(native, skipVTables);
    }

    private static void* __CopyValue(global::StbVorbis.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::StbVorbis.__Internal));
        *(global::StbVorbis.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private StbVorbis(global::StbVorbis.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected StbVorbis(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class StbVorbisInfo : IDisposable
{
    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct __Internal
    {
        [FieldOffset(0)]
        internal uint sample_rate;

        [FieldOffset(4)]
        internal int channels;

        [FieldOffset(8)]
        internal uint setup_memory_required;

        [FieldOffset(12)]
        internal uint setup_temp_memory_required;

        [FieldOffset(16)]
        internal uint temp_memory_required;

        [FieldOffset(20)]
        internal int max_frame_size;

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="??0stb_vorbis_info@@QEAA@AEBU0@@Z")]
        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::StbVorbisInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::StbVorbisInfo>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::StbVorbisInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::StbVorbisInfo(native.ToPointer(), skipVTables);
    }

    internal static global::StbVorbisInfo __CreateInstance(global::StbVorbisInfo.__Internal native, bool skipVTables = false)
    {
        return new global::StbVorbisInfo(native, skipVTables);
    }

    private static void* __CopyValue(global::StbVorbisInfo.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::StbVorbisInfo.__Internal));
        *(global::StbVorbisInfo.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private StbVorbisInfo(global::StbVorbisInfo.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected StbVorbisInfo(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }

    public StbVorbisInfo()
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::StbVorbisInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    public StbVorbisInfo(global::StbVorbisInfo _0)
    {
        __Instance = Marshal.AllocHGlobal(sizeof(global::StbVorbisInfo.__Internal));
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
        *((global::StbVorbisInfo.__Internal*) __Instance) = *((global::StbVorbisInfo.__Internal*) _0.__Instance);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
    }

    public virtual void Dispose(bool disposing)
    {
        if (__Instance == IntPtr.Zero)
            return;
        global::StbVorbisInfo __dummy;
        NativeToManagedMap.TryRemove(__Instance, out __dummy);
        if (__ownsNativeInstance)
            Marshal.FreeHGlobal(__Instance);
        __Instance = IntPtr.Zero;
    }

    public uint SampleRate
    {
        get
        {
            return ((global::StbVorbisInfo.__Internal*) __Instance)->sample_rate;
        }

        set
        {
            ((global::StbVorbisInfo.__Internal*)__Instance)->sample_rate = value;
        }
    }

    public int Channels
    {
        get
        {
            return ((global::StbVorbisInfo.__Internal*) __Instance)->channels;
        }

        set
        {
            ((global::StbVorbisInfo.__Internal*)__Instance)->channels = value;
        }
    }

    public uint SetupMemoryRequired
    {
        get
        {
            return ((global::StbVorbisInfo.__Internal*) __Instance)->setup_memory_required;
        }

        set
        {
            ((global::StbVorbisInfo.__Internal*)__Instance)->setup_memory_required = value;
        }
    }

    public uint SetupTempMemoryRequired
    {
        get
        {
            return ((global::StbVorbisInfo.__Internal*) __Instance)->setup_temp_memory_required;
        }

        set
        {
            ((global::StbVorbisInfo.__Internal*)__Instance)->setup_temp_memory_required = value;
        }
    }

    public uint TempMemoryRequired
    {
        get
        {
            return ((global::StbVorbisInfo.__Internal*) __Instance)->temp_memory_required;
        }

        set
        {
            ((global::StbVorbisInfo.__Internal*)__Instance)->temp_memory_required = value;
        }
    }

    public int MaxFrameSize
    {
        get
        {
            return ((global::StbVorbisInfo.__Internal*) __Instance)->max_frame_size;
        }

        set
        {
            ((global::StbVorbisInfo.__Internal*)__Instance)->max_frame_size = value;
        }
    }
}

public unsafe partial class stb_vorbis
{
    public partial struct __Internal
    {
        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_info")]
        internal static extern global::StbVorbisInfo.__Internal StbVorbisGetInfo(global::System.IntPtr f);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_error")]
        internal static extern int StbVorbisGetError(global::System.IntPtr f);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_close")]
        internal static extern void StbVorbisClose(global::System.IntPtr f);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_sample_offset")]
        internal static extern int StbVorbisGetSampleOffset(global::System.IntPtr f);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_file_offset")]
        internal static extern uint StbVorbisGetFileOffset(global::System.IntPtr f);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_open_pushdata")]
        internal static extern global::System.IntPtr StbVorbisOpenPushdata(byte* datablock, int datablock_length_in_bytes, int* datablock_memory_consumed_in_bytes, int* error, global::System.IntPtr alloc_buffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_decode_frame_pushdata")]
        internal static extern int StbVorbisDecodeFramePushdata(global::System.IntPtr f, byte* datablock, int datablock_length_in_bytes, int* channels, float*** output, int* samples);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_flush_pushdata")]
        internal static extern void StbVorbisFlushPushdata(global::System.IntPtr f);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_decode_filename")]
        internal static extern int StbVorbisDecodeFilename([MarshalAs(UnmanagedType.LPStr)] string filename, int* channels, int* sample_rate, short** output);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_decode_memory")]
        internal static extern int StbVorbisDecodeMemory(byte* mem, int len, int* channels, int* sample_rate, short** output);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_open_memory")]
        internal static extern global::System.IntPtr StbVorbisOpenMemory(byte* data, int len, int* error, global::System.IntPtr alloc_buffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_open_filename")]
        internal static extern global::System.IntPtr StbVorbisOpenFilename([MarshalAs(UnmanagedType.LPStr)] string filename, int* error, global::System.IntPtr alloc_buffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_open_file")]
        internal static extern global::System.IntPtr StbVorbisOpenFile(global::System.IntPtr f, int close_handle_on_close, int* error, global::System.IntPtr alloc_buffer);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_open_file_section")]
        internal static extern global::System.IntPtr StbVorbisOpenFileSection(global::System.IntPtr f, int close_handle_on_close, int* error, global::System.IntPtr alloc_buffer, uint len);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_seek_frame")]
        internal static extern int StbVorbisSeekFrame(global::System.IntPtr f, uint sample_number);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_seek")]
        internal static extern int StbVorbisSeek(global::System.IntPtr f, uint sample_number);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_seek_start")]
        internal static extern int StbVorbisSeekStart(global::System.IntPtr f);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_stream_length_in_samples")]
        internal static extern uint StbVorbisStreamLengthInSamples(global::System.IntPtr f);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_stream_length_in_seconds")]
        internal static extern float StbVorbisStreamLengthInSeconds(global::System.IntPtr f);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_frame_float")]
        internal static extern int StbVorbisGetFrameFloat(global::System.IntPtr f, int* channels, float*** output);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_frame_short_interleaved")]
        internal static extern int StbVorbisGetFrameShortInterleaved(global::System.IntPtr f, int num_c, short* buffer, int num_shorts);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_frame_short")]
        internal static extern int StbVorbisGetFrameShort(global::System.IntPtr f, int num_c, short** buffer, int num_samples);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_samples_float_interleaved")]
        internal static extern int StbVorbisGetSamplesFloatInterleaved(global::System.IntPtr f, int channels, float* buffer, int num_floats);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_samples_float")]
        internal static extern int StbVorbisGetSamplesFloat(global::System.IntPtr f, int channels, float** buffer, int num_samples);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_samples_short_interleaved")]
        internal static extern int StbVorbisGetSamplesShortInterleaved(global::System.IntPtr f, int channels, short* buffer, int num_shorts);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="stb_vorbis_get_samples_short")]
        internal static extern int StbVorbisGetSamplesShort(global::System.IntPtr f, int channels, short** buffer, int num_samples);
    }

    public static global::StbVorbisInfo StbVorbisGetInfo(global::StbVorbis f)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisGetInfo(__arg0);
        return global::StbVorbisInfo.__CreateInstance(__ret);
    }

    public static int StbVorbisGetError(global::StbVorbis f)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisGetError(__arg0);
        return __ret;
    }

    public static void StbVorbisClose(global::StbVorbis f)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        __Internal.StbVorbisClose(__arg0);
    }

    public static int StbVorbisGetSampleOffset(global::StbVorbis f)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisGetSampleOffset(__arg0);
        return __ret;
    }

    public static uint StbVorbisGetFileOffset(global::StbVorbis f)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisGetFileOffset(__arg0);
        return __ret;
    }

    public static global::StbVorbis StbVorbisOpenPushdata(byte* datablock, int datablock_length_in_bytes, ref int datablock_memory_consumed_in_bytes, ref int error, global::StbVorbisAlloc alloc_buffer)
    {
        fixed (int* __refParamPtr2 = &datablock_memory_consumed_in_bytes)
        {
            var __arg2 = __refParamPtr2;
            fixed (int* __refParamPtr3 = &error)
            {
                var __arg3 = __refParamPtr3;
                var __arg4 = ReferenceEquals(alloc_buffer, null) ? global::System.IntPtr.Zero : alloc_buffer.__Instance;
                var __ret = __Internal.StbVorbisOpenPushdata(datablock, datablock_length_in_bytes, __arg2, __arg3, __arg4);
                global::StbVorbis __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::StbVorbis.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::StbVorbis) global::StbVorbis.NativeToManagedMap[__ret];
                else __result0 = global::StbVorbis.__CreateInstance(__ret);
                return __result0;
            }
        }
    }

    public static int StbVorbisDecodeFramePushdata(global::StbVorbis f, byte* datablock, int datablock_length_in_bytes, ref int channels, float*** output, ref int samples)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        fixed (int* __refParamPtr3 = &channels)
        {
            var __arg3 = __refParamPtr3;
            fixed (int* __refParamPtr5 = &samples)
            {
                var __arg5 = __refParamPtr5;
                var __ret = __Internal.StbVorbisDecodeFramePushdata(__arg0, datablock, datablock_length_in_bytes, __arg3, output, __arg5);
                return __ret;
            }
        }
    }

    public static void StbVorbisFlushPushdata(global::StbVorbis f)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        __Internal.StbVorbisFlushPushdata(__arg0);
    }

    public static int StbVorbisDecodeFilename(string filename, ref int channels, ref int sample_rate, short** output)
    {
        fixed (int* __refParamPtr1 = &channels)
        {
            var __arg1 = __refParamPtr1;
            fixed (int* __refParamPtr2 = &sample_rate)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.StbVorbisDecodeFilename(filename, __arg1, __arg2, output);
                return __ret;
            }
        }
    }

    public static int StbVorbisDecodeMemory(byte* mem, int len, ref int channels, ref int sample_rate, short** output)
    {
        fixed (int* __refParamPtr2 = &channels)
        {
            var __arg2 = __refParamPtr2;
            fixed (int* __refParamPtr3 = &sample_rate)
            {
                var __arg3 = __refParamPtr3;
                var __ret = __Internal.StbVorbisDecodeMemory(mem, len, __arg2, __arg3, output);
                return __ret;
            }
        }
    }

    public static global::StbVorbis StbVorbisOpenMemory(byte* data, int len, ref int error, global::StbVorbisAlloc alloc_buffer)
    {
        fixed (int* __refParamPtr2 = &error)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(alloc_buffer, null) ? global::System.IntPtr.Zero : alloc_buffer.__Instance;
            var __ret = __Internal.StbVorbisOpenMemory(data, len, __arg2, __arg3);
            global::StbVorbis __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::StbVorbis.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::StbVorbis) global::StbVorbis.NativeToManagedMap[__ret];
            else __result0 = global::StbVorbis.__CreateInstance(__ret);
            return __result0;
        }
    }

    public static global::StbVorbis StbVorbisOpenFilename(string filename, ref int error, global::StbVorbisAlloc alloc_buffer)
    {
        fixed (int* __refParamPtr1 = &error)
        {
            var __arg1 = __refParamPtr1;
            var __arg2 = ReferenceEquals(alloc_buffer, null) ? global::System.IntPtr.Zero : alloc_buffer.__Instance;
            var __ret = __Internal.StbVorbisOpenFilename(filename, __arg1, __arg2);
            global::StbVorbis __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::StbVorbis.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::StbVorbis) global::StbVorbis.NativeToManagedMap[__ret];
            else __result0 = global::StbVorbis.__CreateInstance(__ret);
            return __result0;
        }
    }

    public static global::StbVorbis StbVorbisOpenFile(global::System.IntPtr f, int close_handle_on_close, ref int error, global::StbVorbisAlloc alloc_buffer)
    {
        fixed (int* __refParamPtr2 = &error)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(alloc_buffer, null) ? global::System.IntPtr.Zero : alloc_buffer.__Instance;
            var __ret = __Internal.StbVorbisOpenFile(f, close_handle_on_close, __arg2, __arg3);
            global::StbVorbis __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::StbVorbis.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::StbVorbis) global::StbVorbis.NativeToManagedMap[__ret];
            else __result0 = global::StbVorbis.__CreateInstance(__ret);
            return __result0;
        }
    }

    public static global::StbVorbis StbVorbisOpenFileSection(global::System.IntPtr f, int close_handle_on_close, ref int error, global::StbVorbisAlloc alloc_buffer, uint len)
    {
        fixed (int* __refParamPtr2 = &error)
        {
            var __arg2 = __refParamPtr2;
            var __arg3 = ReferenceEquals(alloc_buffer, null) ? global::System.IntPtr.Zero : alloc_buffer.__Instance;
            var __ret = __Internal.StbVorbisOpenFileSection(f, close_handle_on_close, __arg2, __arg3, len);
            global::StbVorbis __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::StbVorbis.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::StbVorbis) global::StbVorbis.NativeToManagedMap[__ret];
            else __result0 = global::StbVorbis.__CreateInstance(__ret);
            return __result0;
        }
    }

    public static int StbVorbisSeekFrame(global::StbVorbis f, uint sample_number)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisSeekFrame(__arg0, sample_number);
        return __ret;
    }

    public static int StbVorbisSeek(global::StbVorbis f, uint sample_number)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisSeek(__arg0, sample_number);
        return __ret;
    }

    public static int StbVorbisSeekStart(global::StbVorbis f)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisSeekStart(__arg0);
        return __ret;
    }

    public static uint StbVorbisStreamLengthInSamples(global::StbVorbis f)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisStreamLengthInSamples(__arg0);
        return __ret;
    }

    public static float StbVorbisStreamLengthInSeconds(global::StbVorbis f)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisStreamLengthInSeconds(__arg0);
        return __ret;
    }

    public static int StbVorbisGetFrameFloat(global::StbVorbis f, ref int channels, float*** output)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        fixed (int* __refParamPtr1 = &channels)
        {
            var __arg1 = __refParamPtr1;
            var __ret = __Internal.StbVorbisGetFrameFloat(__arg0, __arg1, output);
            return __ret;
        }
    }

    public static int StbVorbisGetFrameShortInterleaved(global::StbVorbis f, int num_c, ref short buffer, int num_shorts)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        fixed (short* __refParamPtr2 = &buffer)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.StbVorbisGetFrameShortInterleaved(__arg0, num_c, __arg2, num_shorts);
            return __ret;
        }
    }

    public static int StbVorbisGetFrameShort(global::StbVorbis f, int num_c, short** buffer, int num_samples)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisGetFrameShort(__arg0, num_c, buffer, num_samples);
        return __ret;
    }

    public static int StbVorbisGetSamplesFloatInterleaved(global::StbVorbis f, int channels, ref float buffer, int num_floats)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        fixed (float* __refParamPtr2 = &buffer)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.StbVorbisGetSamplesFloatInterleaved(__arg0, channels, __arg2, num_floats);
            return __ret;
        }
    }

    public static int StbVorbisGetSamplesFloat(global::StbVorbis f, int channels, float** buffer, int num_samples)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisGetSamplesFloat(__arg0, channels, buffer, num_samples);
        return __ret;
    }

    public static int StbVorbisGetSamplesShortInterleaved(global::StbVorbis f, int channels, ref short buffer, int num_shorts)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        fixed (short* __refParamPtr2 = &buffer)
        {
            var __arg2 = __refParamPtr2;
            var __ret = __Internal.StbVorbisGetSamplesShortInterleaved(__arg0, channels, __arg2, num_shorts);
            return __ret;
        }
    }

    public static int StbVorbisGetSamplesShort(global::StbVorbis f, int channels, short** buffer, int num_samples)
    {
        var __arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
        var __ret = __Internal.StbVorbisGetSamplesShort(__arg0, channels, buffer, num_samples);
        return __ret;
    }
}

public unsafe partial class GLFWwindow
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::GLFWwindow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native.ToPointer(), skipVTables);
    }

    internal static global::GLFWwindow __CreateInstance(global::GLFWwindow.__Internal native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native, skipVTables);
    }

    private static void* __CopyValue(global::GLFWwindow.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::GLFWwindow.__Internal));
        *(global::GLFWwindow.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private GLFWwindow(global::GLFWwindow.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected GLFWwindow(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace AcidSharp
{
    /// <summary>A module used for the creation, updating and destruction of the display.</summary>
    public unsafe partial class Display : global::AcidSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1928)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal uint m_windowWidth;

            [FieldOffset(12)]
            internal uint m_windowHeight;

            [FieldOffset(16)]
            internal uint m_fullscreenWidth;

            [FieldOffset(20)]
            internal uint m_fullscreenHeight;

            [FieldOffset(24)]
            internal float m_aspectRatio;

            [FieldOffset(28)]
            internal uint m_positionX;

            [FieldOffset(32)]
            internal uint m_positionY;

            [FieldOffset(40)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;

            [FieldOffset(72)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_iconPath;

            [FieldOffset(104)]
            internal byte m_antialiasing;

            [FieldOffset(105)]
            internal byte m_fullscreen;

            [FieldOffset(106)]
            internal byte m_closed;

            [FieldOffset(107)]
            internal byte m_focused;

            [FieldOffset(108)]
            internal byte m_iconified;

            [FieldOffset(109)]
            internal byte m_validationLayers;

            [FieldOffset(112)]
            internal global::System.IntPtr m_window;

            [FieldOffset(120)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceLayerList;

            [FieldOffset(144)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceExtensionList;

            [FieldOffset(168)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_deviceExtensionList;

            [FieldOffset(192)]
            internal global::System.IntPtr m_debugReportCallback;

            [FieldOffset(200)]
            internal global::System.IntPtr m_instance;

            [FieldOffset(208)]
            internal global::System.IntPtr m_surface;

            [FieldOffset(216)]
            internal global::VkSurfaceCapabilitiesKHR.__Internal m_surfaceCapabilities;

            [FieldOffset(268)]
            internal global::VkSurfaceFormatKHR.__Internal m_surfaceFormat;

            [FieldOffset(280)]
            internal global::System.IntPtr m_logicalDevice;

            [FieldOffset(288)]
            internal global::VkSampleCountFlagBits m_msaaSamples;

            [FieldOffset(296)]
            internal global::System.IntPtr m_physicalDevice;

            [FieldOffset(304)]
            internal global::VkPhysicalDeviceProperties.__Internal m_physicalDeviceProperties;

            [FieldOffset(1128)]
            internal global::VkPhysicalDeviceFeatures.__Internal m_physicalDeviceFeatures;

            [FieldOffset(1352)]
            internal global::VkPhysicalDeviceMemoryProperties.__Internal m_physicalDeviceMemoryProperties;

            [FieldOffset(1872)]
            internal uint m_supportedQueues;

            [FieldOffset(1876)]
            internal uint m_graphicsFamily;

            [FieldOffset(1880)]
            internal uint m_presentFamily;

            [FieldOffset(1884)]
            internal uint m_computeFamily;

            [FieldOffset(1888)]
            internal uint m_transferFamily;

            [FieldOffset(1896)]
            internal global::System.IntPtr m_graphicsQueue;

            [FieldOffset(1904)]
            internal global::System.IntPtr m_presentQueue;

            [FieldOffset(1912)]
            internal global::System.IntPtr m_computeQueue;

            [FieldOffset(1920)]
            internal global::System.IntPtr m_transferQueue;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Display@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Display@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindMemoryTypeIndex@Display@acid@@QEAAIPEBUVkPhysicalDeviceMemoryProperties@@PEBUVkMemoryRequirements@@AEBI@Z")]
            internal static extern uint FindMemoryTypeIndex(global::System.IntPtr instance, global::System.IntPtr deviceMemoryProperties, global::System.IntPtr memoryRequirements, uint requiredProperties);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWindowSize@Display@acid@@QEAAXAEBI0@Z")]
            internal static extern void SetWindowSize(global::System.IntPtr instance, uint width, uint height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAntialiasing@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetAntialiasing(global::System.IntPtr instance, bool antialiasing);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFullscreen@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetFullscreen(global::System.IntPtr instance, bool fullscreen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StringifyResultGlfw@Display@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH@Z")]
            internal static extern void StringifyResultGlfw(global::System.IntPtr @return, int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CheckGlfw@Display@acid@@SAXAEBH@Z")]
            internal static extern void CheckGlfw(int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StringifyResultVk@Display@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBW4VkResult@@@Z")]
            internal static extern void StringifyResultVk(global::System.IntPtr @return, global::VkResult result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CheckVk@Display@acid@@SAXAEBW4VkResult@@@Z")]
            internal static extern void CheckVk(global::VkResult result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Display@acid@@QEAAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWidth@Display@acid@@QEAAXAEBI@Z")]
            internal static extern void SetWidth(global::System.IntPtr instance, uint width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Display@acid@@QEAAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeight@Display@acid@@QEAAXAEBI@Z")]
            internal static extern void SetHeight(global::System.IntPtr instance, uint height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTitle@Display@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetTitle(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTitle@Display@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetTitle(global::System.IntPtr instance, global::System.IntPtr title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIcon@Display@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetIcon(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIcon@Display@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetIcon(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowWidth@Display@acid@@QEBAIXZ")]
            internal static extern uint GetWindowWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowHeight@Display@acid@@QEBAIXZ")]
            internal static extern uint GetWindowHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAspectRatio@Display@acid@@QEBAMXZ")]
            internal static extern float GetAspectRatio(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAntialiasing@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAntialiasing(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFullscreen@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFullscreen(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsClosed@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsClosed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFocused@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFocused(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowXPos@Display@acid@@QEBAIXZ")]
            internal static extern uint GetWindowXPos(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowYPos@Display@acid@@QEBAIXZ")]
            internal static extern uint GetWindowYPos(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIconified@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsIconified(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindow@Display@acid@@QEBAPEAUGLFWwindow@@XZ")]
            internal static extern global::System.IntPtr GetWindow(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInstance@Display@acid@@QEBAPEAUVkInstance_T@@XZ")]
            internal static extern global::System.IntPtr GetInstance(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSurface@Display@acid@@QEBAPEAUVkSurfaceKHR_T@@XZ")]
            internal static extern global::System.IntPtr GetSurface(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSurfaceCapabilities@Display@acid@@QEBA?AUVkSurfaceCapabilitiesKHR@@XZ")]
            internal static extern void GetSurfaceCapabilities(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSurfaceFormat@Display@acid@@QEBA?AUVkSurfaceFormatKHR@@XZ")]
            internal static extern void GetSurfaceFormat(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLogicalDevice@Display@acid@@QEBAPEAUVkDevice_T@@XZ")]
            internal static extern global::System.IntPtr GetLogicalDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMsaaSamples@Display@acid@@QEBA?AW4VkSampleCountFlagBits@@XZ")]
            internal static extern global::VkSampleCountFlagBits GetMsaaSamples(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPhysicalDevice@Display@acid@@QEBAPEAUVkPhysicalDevice_T@@XZ")]
            internal static extern global::System.IntPtr GetPhysicalDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPhysicalDeviceProperties@Display@acid@@QEBA?AUVkPhysicalDeviceProperties@@XZ")]
            internal static extern void GetPhysicalDeviceProperties(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPhysicalDeviceFeatures@Display@acid@@QEBA?AUVkPhysicalDeviceFeatures@@XZ")]
            internal static extern void GetPhysicalDeviceFeatures(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPhysicalDeviceMemoryProperties@Display@acid@@QEBA?AUVkPhysicalDeviceMemoryProperties@@XZ")]
            internal static extern void GetPhysicalDeviceMemoryProperties(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGraphicsQueue@Display@acid@@QEBAPEAUVkQueue_T@@XZ")]
            internal static extern global::System.IntPtr GetGraphicsQueue(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPresentQueue@Display@acid@@QEBAPEAUVkQueue_T@@XZ")]
            internal static extern global::System.IntPtr GetPresentQueue(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComputeQueue@Display@acid@@QEBAPEAUVkQueue_T@@XZ")]
            internal static extern global::System.IntPtr GetComputeQueue(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransferQueue@Display@acid@@QEBAPEAUVkQueue_T@@XZ")]
            internal static extern global::System.IntPtr GetTransferQueue(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGraphicsFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetGraphicsFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPresentFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetPresentFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComputeFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetComputeFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransferFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetTransferFamily(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.Display __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Display(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Display __CreateInstance(global::AcidSharp.Display.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Display(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Display.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Display.__Internal));
            global::AcidSharp.Display.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Display(global::AcidSharp.Display.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Display(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Display()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.Display");
        }

        public Display(global::AcidSharp.Display _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Display");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Display.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public uint FindMemoryTypeIndex(global::VkPhysicalDeviceMemoryProperties deviceMemoryProperties, global::VkMemoryRequirements memoryRequirements, uint requiredProperties)
        {
            var __arg0 = ReferenceEquals(deviceMemoryProperties, null) ? global::System.IntPtr.Zero : deviceMemoryProperties.__Instance;
            var __arg1 = ReferenceEquals(memoryRequirements, null) ? global::System.IntPtr.Zero : memoryRequirements.__Instance;
            var __ret = __Internal.FindMemoryTypeIndex((__Instance + __PointerAdjustment), __arg0, __arg1, requiredProperties);
            return __ret;
        }

        /// <summary>Sets window size to a new size.</summary>
        /// <param name="width">The new width in pixels.</param>
        /// <param name="height">The new height in pixels.</param>
        public void SetWindowSize(uint width, uint height)
        {
            __Internal.SetWindowSize((__Instance + __PointerAdjustment), width, height);
        }

        /// <summary>Requests the display to antialias.</summary>
        /// <param name="antialiasing">If the display should antialias.</param>
        public void SetAntialiasing(bool antialiasing)
        {
            __Internal.SetAntialiasing((__Instance + __PointerAdjustment), antialiasing);
        }

        /// <summary>Sets the display to be fullscreen or windowed.</summary>
        /// <param name="fullscreen">Weather or not to be fullscreen.</param>
        public void SetFullscreen(bool fullscreen)
        {
            __Internal.SetFullscreen((__Instance + __PointerAdjustment), fullscreen);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::AcidSharp.Display Get()
        {
            var __ret = __Internal.Get();
            global::AcidSharp.Display __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Display.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Display) global::AcidSharp.Display.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Display.__CreateInstance(__ret);
            return __result0;
        }

        public static string StringifyResultGlfw(int result)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.StringifyResultGlfw(new IntPtr(&__ret), result);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static void CheckGlfw(int result)
        {
            __Internal.CheckGlfw(result);
        }

        public static string StringifyResultVk(global::VkResult result)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.StringifyResultVk(new IntPtr(&__ret), result);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static void CheckVk(global::VkResult result)
        {
            __Internal.CheckVk(result);
        }

        /// <summary>Gets the width of the display in pixels.</summary>
        /// <param name="width">The new width in pixels.</param>
        /// <remarks>Sets the width of the display in pixels.</remarks>
        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetWidth((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the height of the display in pixels.</summary>
        /// <param name="height">The new height in pixels.</param>
        /// <remarks>Sets the height of the display in pixels.</remarks>
        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetHeight((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the window's title.</summary>
        /// <param name="title">The new title.</param>
        /// <remarks>Sets window title</remarks>
        public string Title
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetTitle((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetTitle((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the window's icon file.</summary>
        /// <param name="filename">The new icon file.</param>
        /// <remarks>Sets window icon image.</remarks>
        public string Icon
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetIcon((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetIcon((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the non-fullscreen width of the display in pixels.</summary>
        public uint WindowWidth
        {
            get
            {
                var __ret = __Internal.GetWindowWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the non-fullscreen height of the display in pixels.</summary>
        public uint WindowHeight
        {
            get
            {
                var __ret = __Internal.GetWindowHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the aspect ratio between the displays width and height.</summary>
        public float AspectRatio
        {
            get
            {
                var __ret = __Internal.GetAspectRatio((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the display requests antialiased images.</summary>
        public bool IsAntialiasing
        {
            get
            {
                var __ret = __Internal.IsAntialiasing((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets weather the display is fullscreen or not.</summary>
        public bool IsFullscreen
        {
            get
            {
                var __ret = __Internal.IsFullscreen((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the display is closed.</summary>
        public bool IsClosed
        {
            get
            {
                var __ret = __Internal.IsClosed((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the display is selected.</summary>
        public bool IsFocused
        {
            get
            {
                var __ret = __Internal.IsFocused((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position of the display in pixels.</summary>
        public uint WindowXPos
        {
            get
            {
                var __ret = __Internal.GetWindowXPos((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position of the display in pixels.</summary>
        public uint WindowYPos
        {
            get
            {
                var __ret = __Internal.GetWindowYPos((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows is minimized.</summary>
        public bool IsIconified
        {
            get
            {
                var __ret = __Internal.IsIconified((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::GLFWwindow Window
        {
            get
            {
                var __ret = __Internal.GetWindow((__Instance + __PointerAdjustment));
                global::GLFWwindow __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GLFWwindow) global::GLFWwindow.NativeToManagedMap[__ret];
                else __result0 = global::GLFWwindow.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::VkInstanceT Instance
        {
            get
            {
                var __ret = __Internal.GetInstance((__Instance + __PointerAdjustment));
                global::VkInstanceT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkInstanceT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkInstanceT) global::VkInstanceT.NativeToManagedMap[__ret];
                else __result0 = global::VkInstanceT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::VkSurfaceKHR_T Surface
        {
            get
            {
                var __ret = __Internal.GetSurface((__Instance + __PointerAdjustment));
                global::VkSurfaceKHR_T __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkSurfaceKHR_T.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkSurfaceKHR_T) global::VkSurfaceKHR_T.NativeToManagedMap[__ret];
                else __result0 = global::VkSurfaceKHR_T.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::VkSurfaceCapabilitiesKHR SurfaceCapabilities
        {
            get
            {
                var __ret = new global::VkSurfaceCapabilitiesKHR.__Internal();
                __Internal.GetSurfaceCapabilities((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::VkSurfaceCapabilitiesKHR.__CreateInstance(__ret);
            }
        }

        public global::VkSurfaceFormatKHR SurfaceFormat
        {
            get
            {
                var __ret = new global::VkSurfaceFormatKHR.__Internal();
                __Internal.GetSurfaceFormat((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::VkSurfaceFormatKHR.__CreateInstance(__ret);
            }
        }

        public global::VkDeviceT LogicalDevice
        {
            get
            {
                var __ret = __Internal.GetLogicalDevice((__Instance + __PointerAdjustment));
                global::VkDeviceT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkDeviceT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkDeviceT) global::VkDeviceT.NativeToManagedMap[__ret];
                else __result0 = global::VkDeviceT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::VkSampleCountFlagBits MsaaSamples
        {
            get
            {
                var __ret = __Internal.GetMsaaSamples((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::VkPhysicalDeviceT PhysicalDevice
        {
            get
            {
                var __ret = __Internal.GetPhysicalDevice((__Instance + __PointerAdjustment));
                global::VkPhysicalDeviceT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkPhysicalDeviceT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkPhysicalDeviceT) global::VkPhysicalDeviceT.NativeToManagedMap[__ret];
                else __result0 = global::VkPhysicalDeviceT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::VkPhysicalDeviceProperties PhysicalDeviceProperties
        {
            get
            {
                var __ret = new global::VkPhysicalDeviceProperties.__Internal();
                __Internal.GetPhysicalDeviceProperties((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::VkPhysicalDeviceProperties.__CreateInstance(__ret);
            }
        }

        public global::VkPhysicalDeviceFeatures PhysicalDeviceFeatures
        {
            get
            {
                var __ret = new global::VkPhysicalDeviceFeatures.__Internal();
                __Internal.GetPhysicalDeviceFeatures((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::VkPhysicalDeviceFeatures.__CreateInstance(__ret);
            }
        }

        public global::VkPhysicalDeviceMemoryProperties PhysicalDeviceMemoryProperties
        {
            get
            {
                var __ret = new global::VkPhysicalDeviceMemoryProperties.__Internal();
                __Internal.GetPhysicalDeviceMemoryProperties((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::VkPhysicalDeviceMemoryProperties.__CreateInstance(__ret);
            }
        }

        public global::VkQueueT GraphicsQueue
        {
            get
            {
                var __ret = __Internal.GetGraphicsQueue((__Instance + __PointerAdjustment));
                global::VkQueueT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkQueueT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkQueueT) global::VkQueueT.NativeToManagedMap[__ret];
                else __result0 = global::VkQueueT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::VkQueueT PresentQueue
        {
            get
            {
                var __ret = __Internal.GetPresentQueue((__Instance + __PointerAdjustment));
                global::VkQueueT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkQueueT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkQueueT) global::VkQueueT.NativeToManagedMap[__ret];
                else __result0 = global::VkQueueT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::VkQueueT ComputeQueue
        {
            get
            {
                var __ret = __Internal.GetComputeQueue((__Instance + __PointerAdjustment));
                global::VkQueueT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkQueueT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkQueueT) global::VkQueueT.NativeToManagedMap[__ret];
                else __result0 = global::VkQueueT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::VkQueueT TransferQueue
        {
            get
            {
                var __ret = __Internal.GetTransferQueue((__Instance + __PointerAdjustment));
                global::VkQueueT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VkQueueT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VkQueueT) global::VkQueueT.NativeToManagedMap[__ret];
                else __result0 = global::VkQueueT.__CreateInstance(__ret);
                return __result0;
            }
        }

        public uint GraphicsFamily
        {
            get
            {
                var __ret = __Internal.GetGraphicsFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint PresentFamily
        {
            get
            {
                var __ret = __Internal.GetPresentFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint ComputeFamily
        {
            get
            {
                var __ret = __Internal.GetComputeFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint TransferFamily
        {
            get
            {
                var __ret = __Internal.GetTransferFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Display) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Display
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackError@acid@@YAXHPEBD@Z")]
            internal static extern void CallbackError(int error, [MarshalAs(UnmanagedType.LPStr)] string description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackClose@acid@@YAXPEAUGLFWwindow@@@Z")]
            internal static extern void CallbackClose(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFocus@acid@@YAXPEAUGLFWwindow@@H@Z")]
            internal static extern void CallbackFocus(global::System.IntPtr window, int focused);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackPosition@acid@@YAXPEAUGLFWwindow@@HH@Z")]
            internal static extern void CallbackPosition(global::System.IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackSize@acid@@YAXPEAUGLFWwindow@@HH@Z")]
            internal static extern void CallbackSize(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFrame@acid@@YAXPEAUGLFWwindow@@HH@Z")]
            internal static extern void CallbackFrame(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackIconify@acid@@YAXPEAUGLFWwindow@@H@Z")]
            internal static extern void CallbackIconify(global::System.IntPtr window, int iconified);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackDebug@acid@@YAIIW4VkDebugReportObjectTypeEXT@@_K1HPEBD2PEAX@Z")]
            internal static extern uint CallbackDebug(uint flags, global::VkDebugReportObjectTypeEXT objectType, ulong targetObject, ulong location, int messageCode, [MarshalAs(UnmanagedType.LPStr)] string pLayerPrefix, [MarshalAs(UnmanagedType.LPStr)] string pMessage, global::System.IntPtr pUserData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FvkCreateDebugReportCallbackEXT@acid@@YA?AW4VkResult@@PEAUVkInstance_T@@PEBUVkDebugReportCallbackCreateInfoEXT@@PEBUVkAllocationCallbacks@@PEAPEAUVkDebugReportCallbackEXT_T@@@Z")]
            internal static extern global::VkResult FvkCreateDebugReportCallbackEXT(global::System.IntPtr instance, global::System.IntPtr pCreateInfo, global::System.IntPtr pAllocator, global::System.IntPtr pCallback);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FvkDestroyDebugReportCallbackEXT@acid@@YAXPEAUVkInstance_T@@PEAUVkDebugReportCallbackEXT_T@@PEBUVkAllocationCallbacks@@@Z")]
            internal static extern void FvkDestroyDebugReportCallbackEXT(global::System.IntPtr instance, global::System.IntPtr callback, global::System.IntPtr pAllocator);
        }

        public static void CallbackError(int error, string description)
        {
            __Internal.CallbackError(error, description);
        }

        public static void CallbackClose(global::GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackClose(__arg0);
        }

        public static void CallbackFocus(global::GLFWwindow window, int focused)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFocus(__arg0, focused);
        }

        public static void CallbackPosition(global::GLFWwindow window, int xpos, int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackPosition(__arg0, xpos, ypos);
        }

        public static void CallbackSize(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackSize(__arg0, width, height);
        }

        public static void CallbackFrame(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFrame(__arg0, width, height);
        }

        public static void CallbackIconify(global::GLFWwindow window, int iconified)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackIconify(__arg0, iconified);
        }

        public static uint CallbackDebug(uint flags, global::VkDebugReportObjectTypeEXT objectType, ulong targetObject, ulong location, int messageCode, string pLayerPrefix, string pMessage, global::System.IntPtr pUserData)
        {
            var __ret = __Internal.CallbackDebug(flags, objectType, targetObject, location, messageCode, pLayerPrefix, pMessage, pUserData);
            return __ret;
        }

        public static global::VkResult FvkCreateDebugReportCallbackEXT(global::VkInstanceT instance, global::VkDebugReportCallbackCreateInfoEXT pCreateInfo, global::VkAllocationCallbacks pAllocator, global::VkDebugReportCallbackEXT_T pCallback)
        {
            var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
            var __arg1 = ReferenceEquals(pCreateInfo, null) ? global::System.IntPtr.Zero : pCreateInfo.__Instance;
            var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
            var __arg3 = ReferenceEquals(pCallback, null) ? global::System.IntPtr.Zero : pCallback.__Instance;
            var __ret = __Internal.FvkCreateDebugReportCallbackEXT(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        public static void FvkDestroyDebugReportCallbackEXT(global::VkInstanceT instance, global::VkDebugReportCallbackEXT_T callback, global::VkAllocationCallbacks pAllocator)
        {
            var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
            var __arg1 = ReferenceEquals(callback, null) ? global::System.IntPtr.Zero : callback.__Instance;
            var __arg2 = ReferenceEquals(pAllocator, null) ? global::System.IntPtr.Zero : pAllocator.__Instance;
            __Internal.FvkDestroyDebugReportCallbackEXT(__arg0, __arg1, __arg2);
        }
    }
}

namespace AcidSharp
{
    /// <summary>A simple event listener and runner.</summary>
    public unsafe abstract partial class IEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IEvent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IEvent@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IEvent@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IEvent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IEvent>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IEvent __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IEventInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IEvent __CreateInstance(global::AcidSharp.IEvent.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IEventInternal(native, skipVTables);
        }

        protected IEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IEvent(global::AcidSharp.IEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IEvent");
        }

        protected IEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.IEvent");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IEvent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IEvent.__Internal*) __Instance)->vfptr_IEvent = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Run when a event has occurred.</summary>
        public abstract void OnEvent();

        /// <summary>Gets if the event has occurred.</summary>
        public abstract bool EventTriggered
        {
            get;
        }

        /// <summary>Gets if the event is removed after it has run once.</summary>
        public abstract bool RemoveAfterEvent
        {
            get;
        }

        #region Virtual table interop

        // bool EventTriggered() = 0
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _EventTriggeredDelegateInstance;

        private static bool _EventTriggeredDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.EventTriggered;
            return __ret;
        }

        // void OnEvent() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr _OnEventDelegateInstance;

        private static void _OnEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnEvent();
        }

        // bool RemoveAfterEvent() = 0
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _RemoveAfterEventDelegateInstance;

        private static bool _RemoveAfterEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RemoveAfterEvent;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _EventTriggeredDelegateInstance += _EventTriggeredDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_EventTriggeredDelegateInstance).ToPointer();
                _OnEventDelegateInstance += _OnEventDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnEventDelegateInstance).ToPointer();
                _RemoveAfterEventDelegateInstance += _RemoveAfterEventDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_RemoveAfterEventDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IEventInternal : global::AcidSharp.IEvent, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IEvent.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IEvent.__Internal));
            *(global::AcidSharp.IEvent.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IEventInternal(global::AcidSharp.IEvent.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IEventInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Run when a event has occurred.</summary>
        public override void OnEvent()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___OnEventDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___OnEventDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets if the event has occurred.</summary>
        public override bool EventTriggered
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___EventTriggeredDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___EventTriggeredDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the event is removed after it has run once.</summary>
        public override bool RemoveAfterEvent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___RemoveAfterEventDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___RemoveAfterEventDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
}

namespace AcidSharp
{
    /// <summary>A module used for managing events on engine updates.</summary>
    public unsafe partial class Events : global::AcidSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IEvent___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_events;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Events@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Events@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Events@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Events@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddEvent@Events@acid@@QEAAPEAVIEvent@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr AddEvent(global::System.IntPtr instance, global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveEvent@Events@acid@@QEAA_NPEAVIEvent@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveEvent(global::System.IntPtr instance, global::System.IntPtr @event);
        }

        internal static new global::AcidSharp.Events __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Events(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Events __CreateInstance(global::AcidSharp.Events.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Events(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Events.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Events.__Internal));
            global::AcidSharp.Events.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Events(global::AcidSharp.Events.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Events(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Events()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Events.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.Events");
        }

        public Events(global::AcidSharp.Events _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Events.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Events");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Events.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Adds an event to the listening list.</summary>
        /// <param name="event">The event to add.</param>
        public global::AcidSharp.IEvent AddEvent(global::AcidSharp.IEvent @event)
        {
            var __arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            var __ret = __Internal.AddEvent((__Instance + __PointerAdjustment), __arg0);
            global::AcidSharp.IEvent __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.IEvent.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.IEvent) global::AcidSharp.IEvent.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.IEvent.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Removes a event to the listening list.</summary>
        /// <param name="event">The event to remove.</param>
        public bool RemoveEvent(global::AcidSharp.IEvent @event)
        {
            var __arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            var __ret = __Internal.RemoveEvent((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::AcidSharp.Events Get()
        {
            var __ret = __Internal.Get();
            global::AcidSharp.Events __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Events.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Events) global::AcidSharp.Events.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Events.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Events) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A class that is the most basic implementation of the event interface.</summary>
    public unsafe partial class EventStandard : global::AcidSharp.IEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 144)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IEvent;

            [FieldOffset(8)]
            internal global::Std.Function.__Internal m_triggered;

            [FieldOffset(72)]
            internal global::Std.Function.__Internal m_onEvent;

            [FieldOffset(136)]
            internal byte m_repeat;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0EventStandard@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1EventStandard@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.EventStandard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.EventStandard(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.EventStandard __CreateInstance(global::AcidSharp.EventStandard.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.EventStandard(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.EventStandard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.EventStandard.__Internal));
            global::AcidSharp.EventStandard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private EventStandard(global::AcidSharp.EventStandard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventStandard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public EventStandard(global::AcidSharp.EventStandard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.EventStandard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.EventStandard");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IEvent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.EventStandard.__Internal*) __Instance)->vfptr_IEvent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void OnEvent()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___OnEventDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___OnEventDelegate((__Instance + __PointerAdjustment));
        }

        public override bool EventTriggered
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___EventTriggeredDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___EventTriggeredDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public override bool RemoveAfterEvent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___RemoveAfterEventDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___RemoveAfterEventDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool EventTriggered() override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _EventTriggeredDelegateInstance;

        private static bool _EventTriggeredDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.EventTriggered;
            return __ret;
        }

        // void OnEvent() override
        private static global::AcidSharp.Delegates.Action_IntPtr _OnEventDelegateInstance;

        private static void _OnEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnEvent();
        }

        // bool RemoveAfterEvent() override { return !m_repeat; }
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _RemoveAfterEventDelegateInstance;

        private static bool _RemoveAfterEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RemoveAfterEvent;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _EventTriggeredDelegateInstance += _EventTriggeredDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_EventTriggeredDelegateInstance).ToPointer();
                _OnEventDelegateInstance += _OnEventDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnEventDelegateInstance).ToPointer();
                _RemoveAfterEventDelegateInstance += _RemoveAfterEventDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_RemoveAfterEventDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A class that runs a event after a time has passed.</summary>
    public unsafe partial class EventTime : global::AcidSharp.IEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IEvent;

            [FieldOffset(8)]
            internal global::AcidSharp.Timer.__Internal m_timer;

            [FieldOffset(16)]
            internal global::Std.Function.__Internal m_onEvent;

            [FieldOffset(80)]
            internal byte m_repeat;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0EventTime@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1EventTime@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.EventTime __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.EventTime(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.EventTime __CreateInstance(global::AcidSharp.EventTime.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.EventTime(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.EventTime.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.EventTime.__Internal));
            global::AcidSharp.EventTime.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private EventTime(global::AcidSharp.EventTime.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventTime(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public EventTime(global::AcidSharp.EventTime _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.EventTime.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.EventTime");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IEvent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.EventTime.__Internal*) __Instance)->vfptr_IEvent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void OnEvent()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___OnEventDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___OnEventDelegate((__Instance + __PointerAdjustment));
        }

        public override bool EventTriggered
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___EventTriggeredDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___EventTriggeredDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public override bool RemoveAfterEvent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___RemoveAfterEventDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___RemoveAfterEventDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool EventTriggered() override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _EventTriggeredDelegateInstance;

        private static bool _EventTriggeredDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.EventTriggered;
            return __ret;
        }

        // void OnEvent() override
        private static global::AcidSharp.Delegates.Action_IntPtr _OnEventDelegateInstance;

        private static void _OnEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnEvent();
        }

        // bool RemoveAfterEvent() override { return !m_repeat; }
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _RemoveAfterEventDelegateInstance;

        private static bool _RemoveAfterEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RemoveAfterEvent;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _EventTriggeredDelegateInstance += _EventTriggeredDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_EventTriggeredDelegateInstance).ToPointer();
                _OnEventDelegateInstance += _OnEventDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnEventDelegateInstance).ToPointer();
                _RemoveAfterEventDelegateInstance += _RemoveAfterEventDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_RemoveAfterEventDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe abstract partial class IFile : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IFile@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IFile@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IFile> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IFile>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IFile __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IFileInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IFile __CreateInstance(global::AcidSharp.IFile.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IFileInternal(native, skipVTables);
        }

        protected IFile(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IFile(global::AcidSharp.IFile _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IFile");
        }

        protected IFile()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.IFile");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IFile.__Internal*) __Instance)->vfptr_IFile = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Load();

        public abstract void Save();

        public abstract void Clear();

        public abstract string Filename
        {
            get;

            set;
        }

        #region Virtual table interop

        // void Load() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // std::string GetFilename() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void SetFilename(const std::string &filename) = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _SetFilenameDelegateInstance;

        private static void _SetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.Filename = __stringRet0;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _SetFilenameDelegateInstance += _SetFilenameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IFileInternal : global::AcidSharp.IFile, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IFile.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IFile.__Internal));
            *(global::AcidSharp.IFile.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IFileInternal(global::AcidSharp.IFile.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IFileInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___LoadDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___SaveDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___SetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                ___SetFilenameDelegate((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class RowCsv : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_elements;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RowCsv@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RowCsv@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.RowCsv> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.RowCsv>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.RowCsv __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.RowCsv(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.RowCsv __CreateInstance(global::AcidSharp.RowCsv.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.RowCsv(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.RowCsv.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.RowCsv.__Internal));
            global::AcidSharp.RowCsv.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RowCsv(global::AcidSharp.RowCsv.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RowCsv(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RowCsv(global::AcidSharp.RowCsv _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.RowCsv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.RowCsv __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class FileCsv : global::AcidSharp.IFile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal sbyte m_delimiter;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_RowCsv___N_std_S_allocator__S0_ m_rows;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileCsv@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBD@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, sbyte delimiter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileCsv@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FileCsv@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRow@FileCsv@acid@@QEAA?AVRowCsv@2@AEBI@Z")]
            internal static extern void GetRow(global::System.IntPtr instance, global::System.IntPtr @return, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PushRow@FileCsv@acid@@QEAAXAEBVRowCsv@2@@Z")]
            internal static extern void PushRow(global::System.IntPtr instance, global::System.IntPtr row);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRow@FileCsv@acid@@QEAAXAEBVRowCsv@2@AEBI@Z")]
            internal static extern void SetRow(global::System.IntPtr instance, global::System.IntPtr row, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelimiter@FileCsv@acid@@QEBADXZ")]
            internal static extern sbyte GetDelimiter(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDelimiter@FileCsv@acid@@QEAAXAEBD@Z")]
            internal static extern void SetDelimiter(global::System.IntPtr instance, sbyte delimiter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRowCount@FileCsv@acid@@QEBA_KXZ")]
            internal static extern ulong GetRowCount(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.FileCsv __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.FileCsv(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.FileCsv __CreateInstance(global::AcidSharp.FileCsv.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.FileCsv(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.FileCsv.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileCsv.__Internal));
            global::AcidSharp.FileCsv.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FileCsv(global::AcidSharp.FileCsv.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileCsv(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FileCsv(string filename, char delimiter = ',')
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileCsv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = global::System.Convert.ToSByte(delimiter);
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "AcidSharp.FileCsv");
        }

        public FileCsv(global::AcidSharp.FileCsv _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileCsv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.FileCsv");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.FileCsv.__Internal*) __Instance)->vfptr_IFile = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___LoadDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___SaveDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public global::AcidSharp.RowCsv GetRow(uint index)
        {
            var __ret = new global::AcidSharp.RowCsv.__Internal();
            __Internal.GetRow((__Instance + __PointerAdjustment), new IntPtr(&__ret), index);
            return global::AcidSharp.RowCsv.__CreateInstance(__ret);
        }

        public void PushRow(global::AcidSharp.RowCsv row)
        {
            if (ReferenceEquals(row, null))
                throw new global::System.ArgumentNullException("row", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = row.__Instance;
            __Internal.PushRow((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetRow(global::AcidSharp.RowCsv row, uint index)
        {
            if (ReferenceEquals(row, null))
                throw new global::System.ArgumentNullException("row", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = row.__Instance;
            __Internal.SetRow((__Instance + __PointerAdjustment), __arg0, index);
        }

        public static implicit operator global::AcidSharp.FileCsv(string filename)
        {
            return new global::AcidSharp.FileCsv(filename);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___SetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                ___SetFilenameDelegate((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public char Delimiter
        {
            get
            {
                var __ret = __Internal.GetDelimiter((__Instance + __PointerAdjustment));
                return global::System.Convert.ToChar(__ret);
            }

            set
            {
                var __arg0 = global::System.Convert.ToSByte(value);
                __Internal.SetDelimiter((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public ulong RowCount
        {
            get
            {
                var __ret = __Internal.GetRowCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Load() override
        private static global::AcidSharp.Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() override
        private static global::AcidSharp.Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() override
        private static global::AcidSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // std::string GetFilename() const override { return m_filename; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void SetFilename(const std::string &filename) override { m_filename = filename; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _SetFilenameDelegateInstance;

        private static void _SetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.Filename = __stringRet0;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _SetFilenameDelegateInstance += _SetFilenameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class JsonSection : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_JsonSection___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(64)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_content;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JsonSection@acid@@QEAA@PEAV01@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr name, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JsonSection@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JsonSection@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@JsonSection@acid@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@JsonSection@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@JsonSection@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetContent@JsonSection@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetContent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetContent@JsonSection@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetContent(global::System.IntPtr instance, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@JsonSection@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.JsonSection> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.JsonSection>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.JsonSection __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.JsonSection(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.JsonSection __CreateInstance(global::AcidSharp.JsonSection.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.JsonSection(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.JsonSection.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JsonSection.__Internal));
            global::AcidSharp.JsonSection.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JsonSection(global::AcidSharp.JsonSection.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JsonSection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public JsonSection(global::AcidSharp.JsonSection parent, string name, string content)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JsonSection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(name, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(content, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        public JsonSection(global::AcidSharp.JsonSection _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.JsonSection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.JsonSection __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddChild(global::AcidSharp.JsonSection child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Content
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetContent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetContent((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::AcidSharp.JsonSection Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::AcidSharp.JsonSection __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.JsonSection.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.JsonSection) global::AcidSharp.JsonSection.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.JsonSection.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class FileJson : global::AcidSharp.IFile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.SharedPtr.__Internal m_parent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileJson@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileJson@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FileJson@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.FileJson __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.FileJson(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.FileJson __CreateInstance(global::AcidSharp.FileJson.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.FileJson(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.FileJson.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileJson.__Internal));
            global::AcidSharp.FileJson.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FileJson(global::AcidSharp.FileJson.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileJson(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FileJson(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileJson.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "AcidSharp.FileJson");
        }

        public FileJson(global::AcidSharp.FileJson _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileJson.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.FileJson");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.FileJson.__Internal*) __Instance)->vfptr_IFile = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___LoadDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___SaveDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::AcidSharp.FileJson(string filename)
        {
            return new global::AcidSharp.FileJson(filename);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___SetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                ___SetFilenameDelegate((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // void Load() override
        private static global::AcidSharp.Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() override
        private static global::AcidSharp.Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() override
        private static global::AcidSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // std::string GetFilename() const override { return m_filename; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void SetFilename(const std::string &filename) override { m_filename = filename; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _SetFilenameDelegateInstance;

        private static void _SetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.Filename = __stringRet0;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _SetFilenameDelegateInstance += _SetFilenameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class FileXml : global::AcidSharp.IFile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.SharedPtr.__Internal m_parent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileXml@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileXml@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FileXml@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.FileXml __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.FileXml(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.FileXml __CreateInstance(global::AcidSharp.FileXml.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.FileXml(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.FileXml.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileXml.__Internal));
            global::AcidSharp.FileXml.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FileXml(global::AcidSharp.FileXml.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileXml(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FileXml(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileXml.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "AcidSharp.FileXml");
        }

        public FileXml(global::AcidSharp.FileXml _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileXml.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.FileXml");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.FileXml.__Internal*) __Instance)->vfptr_IFile = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___LoadDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___SaveDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::AcidSharp.FileXml(string filename)
        {
            return new global::AcidSharp.FileXml(filename);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___SetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                ___SetFilenameDelegate((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // void Load() override
        private static global::AcidSharp.Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() override
        private static global::AcidSharp.Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() override
        private static global::AcidSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // std::string GetFilename() const override { return m_filename; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void SetFilename(const std::string &filename) override { m_filename = filename; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _SetFilenameDelegateInstance;

        private static void _SetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.Filename = __stringRet0;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _SetFilenameDelegateInstance += _SetFilenameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class XmlNode : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_XmlNode___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_attributes;

            [FieldOffset(64)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_content;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0XmlNode@acid@@QEAA@PEAV01@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr attributes, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0XmlNode@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1XmlNode@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@XmlNode@acid@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttributes@XmlNode@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetAttributes(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAttributes@XmlNode@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetAttributes(global::System.IntPtr instance, global::System.IntPtr attributes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetContent@XmlNode@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetContent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetContent@XmlNode@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetContent(global::System.IntPtr instance, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@XmlNode@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.XmlNode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.XmlNode>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.XmlNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.XmlNode(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.XmlNode __CreateInstance(global::AcidSharp.XmlNode.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.XmlNode(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.XmlNode.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.XmlNode.__Internal));
            global::AcidSharp.XmlNode.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private XmlNode(global::AcidSharp.XmlNode.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected XmlNode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public XmlNode(global::AcidSharp.XmlNode parent, string attributes, string content)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.XmlNode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(attributes, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(content, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        public XmlNode(global::AcidSharp.XmlNode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.XmlNode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.XmlNode __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddChild(global::AcidSharp.XmlNode child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public string Attributes
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetAttributes((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetAttributes((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Content
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetContent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetContent((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::AcidSharp.XmlNode Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::AcidSharp.XmlNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.XmlNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.XmlNode) global::AcidSharp.XmlNode.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.XmlNode.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A helper for C++ files.</summary>
    public unsafe partial class FileSystem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileSystem@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FileExists@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool FileExists(global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeleteFile@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeleteFile(global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateFile@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateFile(global::System.IntPtr filepath, bool createFolders);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ClearFile@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ClearFile(global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateFolder@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateFolder(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WriteTextFile@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool WriteTextFile(global::System.IntPtr filepath, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FixPaths@FileSystem@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void FixPaths(global::System.IntPtr @return, global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindName@FileSystem@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void FindName(global::System.IntPtr @return, global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindExt@FileSystem@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void FindExt(global::System.IntPtr @return, global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWorkingDirectory@FileSystem@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetWorkingDirectory(global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.FileSystem> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.FileSystem>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.FileSystem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.FileSystem(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.FileSystem __CreateInstance(global::AcidSharp.FileSystem.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.FileSystem(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.FileSystem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileSystem.__Internal));
            *(global::AcidSharp.FileSystem.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FileSystem(global::AcidSharp.FileSystem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileSystem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FileSystem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileSystem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FileSystem(global::AcidSharp.FileSystem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.FileSystem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.FileSystem.__Internal*) __Instance) = *((global::AcidSharp.FileSystem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.FileSystem __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if a file exists.</summary>
        /// <param name="filepath">The filepath.</param>
        public static bool FileExists(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.FileExists(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Deletes a file.</summary>
        /// <param name="filepath">The filepath.</param>
        public static bool DeleteFile(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.DeleteFile(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Creates a file, and the folder path.</summary>
        /// <param name="filepath">The filepath.</param>
        /// <param name="createFolders">If folders should also be created.</param>
        public static bool CreateFile(string filepath, bool createFolders = true)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateFile(__arg0, createFolders);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Clears the contents from a file.</summary>
        /// <param name="filepath">The filepath.</param>
        public static bool ClearFile(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.ClearFile(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Creates a directory.</summary>
        /// <param name="path">The directory to create.</param>
        public static bool CreateFolder(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateFolder(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Writes to a text file from a string.</summary>
        /// <param name="filepath">The filepath.</param>
        /// <param name="data">The text data.</param>
        public static bool WriteTextFile(string filepath, string data)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(data, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.WriteTextFile(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>Removes backslashes from directories.</summary>
        public static string FixPaths(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.FixPaths(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Gets the file name from the full path.</summary>
        public static string FindName(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.FindName(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Gets the file extension from the full path.</summary>
        public static string FindExt(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.FindExt(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Gets the current working directory.</summary>
        public static string WorkingDirectory
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetWorkingDirectory(new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Interface for an axis based input device.</summary>
    public unsafe abstract partial class IAxis : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IAxis@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IAxis@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IAxis> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IAxis>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IAxis __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IAxisInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IAxis __CreateInstance(global::AcidSharp.IAxis.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IAxisInternal(native, skipVTables);
        }

        protected IAxis(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IAxis(global::AcidSharp.IAxis _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IAxis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IAxis");
        }

        protected IAxis()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IAxis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.IAxis");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IAxis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IAxis.__Internal*) __Instance)->vfptr_IAxis = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets the current value along the axis. -1 is smallest input, 1 is largest input.</summary>
        public abstract float Amount
        {
            get;
        }

        #region Virtual table interop

        // float GetAmount() const = 0
        private static global::AcidSharp.Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IAxis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IAxisInternal : global::AcidSharp.IAxis, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IAxis.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IAxis.__Internal));
            *(global::AcidSharp.IAxis.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IAxisInternal(global::AcidSharp.IAxis.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IAxisInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets the current value along the axis. -1 is smallest input, 1 is largest input.</summary>
        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetAmountDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Interface for a binary input device.</summary>
    public unsafe abstract partial class IButton : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IButton@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IButton@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IButton> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IButton>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IButton __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IButtonInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IButton __CreateInstance(global::AcidSharp.IButton.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IButtonInternal(native, skipVTables);
        }

        protected IButton(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IButton(global::AcidSharp.IButton _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IButton");
        }

        protected IButton()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.IButton");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IButton.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if the key is down and was not down before. Key press recognized as one click.</summary>
        public abstract bool WasDown();

        /// <summary>Returns whether this button is currently pressed.</summary>
        public abstract bool IsDown
        {
            get;
        }

        #region Virtual table interop

        // bool IsDown() const = 0
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() = 0
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IButtonInternal : global::AcidSharp.IButton, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IButton.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IButton.__Internal));
            *(global::AcidSharp.IButton.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IButtonInternal(global::AcidSharp.IButton.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IButtonInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets if the key is down and was not down before. Key press recognized as one click.</summary>
        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Returns whether this button is currently pressed.</summary>
        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___IsDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Axis composed of two buttons.</summary>
    public unsafe partial class AxisButton : global::AcidSharp.IAxis, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IButton___N_std_S_default_delete__S0_ m_negative;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IButton___N_std_S_default_delete__S0_ m_positive;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisButton@acid@@QEAA@PEAVIButton@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr negative, global::System.IntPtr positive);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisButton@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1AxisButton@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.AxisButton __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.AxisButton(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.AxisButton __CreateInstance(global::AcidSharp.AxisButton.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.AxisButton(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.AxisButton.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.AxisButton.__Internal));
            global::AcidSharp.AxisButton.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AxisButton(global::AcidSharp.AxisButton.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AxisButton(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new axis button.</summary>
        /// <param name="negative">When this button is down, the axis is negative.</param>
        /// <param name="positive">When this button is down, the axis is positive.</param>
        public AxisButton(global::AcidSharp.IButton negative, global::AcidSharp.IButton positive)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.AxisButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(negative, null) ? global::System.IntPtr.Zero : negative.__Instance;
            var __arg1 = ReferenceEquals(positive, null) ? global::System.IntPtr.Zero : positive.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "AcidSharp.AxisButton");
        }

        public AxisButton(global::AcidSharp.AxisButton _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.AxisButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.AxisButton");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IAxis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.AxisButton.__Internal*) __Instance)->vfptr_IAxis = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetAmountDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // float GetAmount() const override
        private static global::AcidSharp.Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.AxisButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>Axis composed of multiple other axes.</summary>
    public unsafe partial class AxisCompound : global::AcidSharp.IAxis, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IAxis___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_axes;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisCompound@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1AxisCompound@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.AxisCompound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.AxisCompound(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.AxisCompound __CreateInstance(global::AcidSharp.AxisCompound.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.AxisCompound(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.AxisCompound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.AxisCompound.__Internal));
            global::AcidSharp.AxisCompound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AxisCompound(global::AcidSharp.AxisCompound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AxisCompound(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public AxisCompound(global::AcidSharp.AxisCompound _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.AxisCompound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.AxisCompound");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IAxis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.AxisCompound.__Internal*) __Instance)->vfptr_IAxis = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetAmountDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // float GetAmount() const override
        private static global::AcidSharp.Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.AxisCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public enum JoystickPort
    {
        Joystick1 = 0,
        Joystick2 = 1,
        Joystick3 = 2,
        Joystick4 = 3,
        Joystick5 = 4,
        Joystick6 = 5,
        Joystick7 = 6,
        Joystick8 = 7,
        Joystick9 = 8,
        Joystick10 = 9,
        Joystick11 = 10,
        Joystick12 = 11,
        Joystick13 = 12,
        Joystick14 = 13,
        Joystick15 = 14,
        Joystick16 = 15,
        JoystickBeginRange = 0,
        JoystickEndRange = 15,
        JoystickRangeSize = 16,
        JoystickMaxEnum = 2147483647
    }

    /// <summary>A definition for a managed joystick.</summary>
    public unsafe partial class Joystick : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.JoystickPort m_port;

            [FieldOffset(4)]
            internal byte m_connected;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_axes;

            [FieldOffset(48)]
            internal global::System.IntPtr m_buttons;

            [FieldOffset(56)]
            internal uint m_axeCount;

            [FieldOffset(60)]
            internal uint m_buttonCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joystick@acid@@QEAA@AEBU01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joystick@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Joystick@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Joystick> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Joystick>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Joystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Joystick(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Joystick __CreateInstance(global::AcidSharp.Joystick.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Joystick(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Joystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Joystick.__Internal));
            global::AcidSharp.Joystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Joystick(global::AcidSharp.Joystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joystick(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Joystick(global::AcidSharp.Joystick _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Joystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Joystick()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Joystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Joystick __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::AcidSharp.JoystickPort MPort
        {
            get
            {
                return ((global::AcidSharp.Joystick.__Internal*) __Instance)->m_port;
            }

            set
            {
                ((global::AcidSharp.Joystick.__Internal*)__Instance)->m_port = value;
            }
        }

        public bool MConnected
        {
            get
            {
                return ((global::AcidSharp.Joystick.__Internal*) __Instance)->m_connected != 0;
            }

            set
            {
                ((global::AcidSharp.Joystick.__Internal*)__Instance)->m_connected = (byte) (value ? 1 : 0);
            }
        }

        public string MName
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new global::System.IntPtr(&((global::AcidSharp.Joystick.__Internal*) __Instance)->m_name));
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                ((global::AcidSharp.Joystick.__Internal*)__Instance)->m_name = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }
        }

        public float* MAxes
        {
            get
            {
                return (float*) ((global::AcidSharp.Joystick.__Internal*) __Instance)->m_axes;
            }

            set
            {
                ((global::AcidSharp.Joystick.__Internal*)__Instance)->m_axes = (global::System.IntPtr) value;
            }
        }

        public byte* MButtons
        {
            get
            {
                return (byte*) ((global::AcidSharp.Joystick.__Internal*) __Instance)->m_buttons;
            }

            set
            {
                ((global::AcidSharp.Joystick.__Internal*)__Instance)->m_buttons = (global::System.IntPtr) value;
            }
        }

        public uint MAxeCount
        {
            get
            {
                return ((global::AcidSharp.Joystick.__Internal*) __Instance)->m_axeCount;
            }

            set
            {
                ((global::AcidSharp.Joystick.__Internal*)__Instance)->m_axeCount = value;
            }
        }

        public uint MButtonCount
        {
            get
            {
                return ((global::AcidSharp.Joystick.__Internal*) __Instance)->m_buttonCount;
            }

            set
            {
                ((global::AcidSharp.Joystick.__Internal*)__Instance)->m_buttonCount = value;
            }
        }
    }

    /// <summary>A module used for the creation, updating and destruction of the joysticks.</summary>
    public unsafe partial class Joysticks : global::AcidSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 968)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Array.__Internalc__N_std_S_array____N_acid_S_Joystick_Vk15 m_connected;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joysticks@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joysticks@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Joysticks@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Joysticks@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsConnected@Joysticks@acid@@QEBA_NAEBW4JoystickPort@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsConnected(global::System.IntPtr instance, global::AcidSharp.JoystickPort port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Joysticks@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBW4JoystickPort@2@@Z")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return, global::AcidSharp.JoystickPort port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetButton@Joysticks@acid@@QEBA_NAEBW4JoystickPort@2@AEBI@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetButton(global::System.IntPtr instance, global::AcidSharp.JoystickPort port, uint button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAxis@Joysticks@acid@@QEBAMAEBW4JoystickPort@2@AEBI@Z")]
            internal static extern float GetAxis(global::System.IntPtr instance, global::AcidSharp.JoystickPort port, uint axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCountButtons@Joysticks@acid@@QEBAIAEBW4JoystickPort@2@@Z")]
            internal static extern uint GetCountButtons(global::System.IntPtr instance, global::AcidSharp.JoystickPort port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCountAxes@Joysticks@acid@@QEBAIAEBW4JoystickPort@2@@Z")]
            internal static extern uint GetCountAxes(global::System.IntPtr instance, global::AcidSharp.JoystickPort port);
        }

        internal static new global::AcidSharp.Joysticks __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Joysticks(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Joysticks __CreateInstance(global::AcidSharp.Joysticks.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Joysticks(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Joysticks.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Joysticks.__Internal));
            global::AcidSharp.Joysticks.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Joysticks(global::AcidSharp.Joysticks.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joysticks(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Joysticks()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Joysticks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.Joysticks");
        }

        public Joysticks(global::AcidSharp.Joysticks _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Joysticks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Joysticks");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Joysticks.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Determines if the joystick is connected</summary>
        /// <param name="port">The joystick to check connection with.</param>
        public bool IsConnected(global::AcidSharp.JoystickPort port)
        {
            var __ret = __Internal.IsConnected((__Instance + __PointerAdjustment), port);
            return __ret;
        }

        /// <summary>Gets the name of the joystick.</summary>
        /// <param name="port">The joystick to get the name of.</param>
        public string GetName(global::AcidSharp.JoystickPort port)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret), port);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Gets the whether a button on a joystick is pressed.</summary>
        /// <param name="port">The joystick to get the button from.</param>
        /// <param name="button">The button of interest.</param>
        public bool GetButton(global::AcidSharp.JoystickPort port, uint button)
        {
            var __ret = __Internal.GetButton((__Instance + __PointerAdjustment), port, button);
            return __ret;
        }

        /// <summary>Gets the value of a joysticks axis.</summary>
        /// <param name="port">The joystick to get the axis from.</param>
        /// <param name="axis">The axis of interest.</param>
        public float GetAxis(global::AcidSharp.JoystickPort port, uint axis)
        {
            var __ret = __Internal.GetAxis((__Instance + __PointerAdjustment), port, axis);
            return __ret;
        }

        /// <summary>Gets the number of buttons the joystick offers.</summary>
        /// <param name="port">The joystick to the the button count from.</param>
        public uint GetCountButtons(global::AcidSharp.JoystickPort port)
        {
            var __ret = __Internal.GetCountButtons((__Instance + __PointerAdjustment), port);
            return __ret;
        }

        /// <summary>Gets the number of axes the joystick offers.</summary>
        /// <param name="port">The joystick to the the axis count from.</param>
        public uint GetCountAxes(global::AcidSharp.JoystickPort port)
        {
            var __ret = __Internal.GetCountAxes((__Instance + __PointerAdjustment), port);
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::AcidSharp.Joysticks Get()
        {
            var __ret = __Internal.Get();
            global::AcidSharp.Joysticks __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Joysticks.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Joysticks) global::AcidSharp.Joysticks.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Joysticks.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Joysticks) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>Axis from a joystick.</summary>
    public unsafe partial class AxisJoystick : global::AcidSharp.IAxis, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [FieldOffset(8)]
            internal global::AcidSharp.JoystickPort m_joystick;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_axes;

            [FieldOffset(40)]
            internal byte m_reverse;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisJoystick@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1AxisJoystick@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJoystick@AxisJoystick@acid@@QEBA?AW4JoystickPort@2@XZ")]
            internal static extern global::AcidSharp.JoystickPort GetJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJoystick@AxisJoystick@acid@@QEAAXAEBW4JoystickPort@2@@Z")]
            internal static extern void SetJoystick(global::System.IntPtr instance, global::AcidSharp.JoystickPort joystickPort);
        }

        internal static new global::AcidSharp.AxisJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.AxisJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.AxisJoystick __CreateInstance(global::AcidSharp.AxisJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.AxisJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.AxisJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.AxisJoystick.__Internal));
            global::AcidSharp.AxisJoystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AxisJoystick(global::AcidSharp.AxisJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AxisJoystick(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public AxisJoystick(global::AcidSharp.AxisJoystick _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.AxisJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.AxisJoystick");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IAxis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.AxisJoystick.__Internal*) __Instance)->vfptr_IAxis = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::AcidSharp.JoystickPort Joystick
        {
            get
            {
                var __ret = __Internal.GetJoystick((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetJoystick((__Instance + __PointerAdjustment), value);
            }
        }

        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetAmountDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // float GetAmount() const override
        private static global::AcidSharp.Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.AxisJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>Handles multiple buttons at once.</summary>
    public unsafe partial class ButtonCompound : global::AcidSharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IButton___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_buttons;

            [FieldOffset(32)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonCompound@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ButtonCompound@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.ButtonCompound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ButtonCompound(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ButtonCompound __CreateInstance(global::AcidSharp.ButtonCompound.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ButtonCompound(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ButtonCompound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ButtonCompound.__Internal));
            global::AcidSharp.ButtonCompound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonCompound(global::AcidSharp.ButtonCompound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonCompound(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ButtonCompound(global::AcidSharp.ButtonCompound _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ButtonCompound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.ButtonCompound");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.ButtonCompound.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___IsDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool IsDown() const override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ButtonCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ButtonCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>Button from a joystick.</summary>
    public unsafe partial class ButtonJoystick : global::AcidSharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::AcidSharp.JoystickPort m_joystick;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_buttons;

            [FieldOffset(40)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonJoystick@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ButtonJoystick@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJoystick@ButtonJoystick@acid@@QEBA?AW4JoystickPort@2@XZ")]
            internal static extern global::AcidSharp.JoystickPort GetJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJoystick@ButtonJoystick@acid@@QEAAXAEBW4JoystickPort@2@@Z")]
            internal static extern void SetJoystick(global::System.IntPtr instance, global::AcidSharp.JoystickPort joystickPort);
        }

        internal static new global::AcidSharp.ButtonJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ButtonJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ButtonJoystick __CreateInstance(global::AcidSharp.ButtonJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ButtonJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ButtonJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ButtonJoystick.__Internal));
            global::AcidSharp.ButtonJoystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonJoystick(global::AcidSharp.ButtonJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonJoystick(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ButtonJoystick(global::AcidSharp.ButtonJoystick _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ButtonJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.ButtonJoystick");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.ButtonJoystick.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public global::AcidSharp.JoystickPort Joystick
        {
            get
            {
                var __ret = __Internal.GetJoystick((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetJoystick((__Instance + __PointerAdjustment), value);
            }
        }

        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___IsDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool IsDown() const override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ButtonJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ButtonJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public enum Key
    {
        KeyUnknown = -1,
        KeySpace = 32,
        KeyApostrophe = 39,
        KeyComma = 44,
        KeyMinus = 45,
        KeyPeriod = 46,
        KeySlash = 47,
        Key0 = 48,
        Key1 = 49,
        Key2 = 50,
        Key3 = 51,
        Key4 = 52,
        Key5 = 53,
        Key6 = 54,
        Key7 = 55,
        Key8 = 56,
        Key9 = 57,
        KeySemicolon = 59,
        KeyEqual = 61,
        KeyA = 65,
        KeyB = 66,
        KeyC = 67,
        KeyD = 68,
        KeyE = 69,
        KeyF = 70,
        KeyG = 71,
        KeyH = 72,
        KeyI = 73,
        KeyJ = 74,
        KeyK = 75,
        KeyL = 76,
        KeyM = 77,
        KeyN = 78,
        KeyO = 79,
        KeyP = 80,
        KeyQ = 81,
        KeyR = 82,
        KeyS = 83,
        KeyT = 84,
        KeyU = 85,
        KeyV = 86,
        KeyW = 87,
        KeyX = 88,
        KeyY = 89,
        KeyZ = 90,
        KeyLeftBracket = 91,
        KeyBackslash = 92,
        KeyRightBracket = 93,
        KeyGraveAccent = 96,
        KeyWorld1 = 161,
        KeyWorld2 = 162,
        KeyEscape = 256,
        KeyEnter = 257,
        KeyTab = 258,
        KeyBackspace = 259,
        KeyInsert = 260,
        KeyDelete = 261,
        KeyRight = 262,
        KeyLeft = 263,
        KeyDown = 264,
        KeyUp = 265,
        KeyPageUp = 266,
        KeyPageDown = 267,
        KeyHome = 268,
        KeyEnd = 269,
        KeyCapsLock = 280,
        KeyScrollLock = 281,
        KeyNumLock = 282,
        KeyPrintScreen = 283,
        KeyPause = 284,
        KeyF1 = 290,
        KeyF2 = 291,
        KeyF3 = 292,
        KeyF4 = 293,
        KeyF5 = 294,
        KeyF6 = 295,
        KeyF7 = 296,
        KeyF8 = 297,
        KeyF9 = 298,
        KeyF10 = 299,
        KeyF11 = 300,
        KeyF12 = 301,
        KeyF13 = 302,
        KeyF14 = 303,
        KeyF15 = 304,
        KeyF16 = 305,
        KeyF17 = 306,
        KeyF18 = 307,
        KeyF19 = 308,
        KeyF20 = 309,
        KeyF21 = 310,
        KeyF22 = 311,
        KeyF23 = 312,
        KeyF24 = 313,
        KeyF25 = 314,
        KeyPad0 = 320,
        KeyPad1 = 321,
        KeyPad2 = 322,
        KeyPad3 = 323,
        KeyPad4 = 324,
        KeyPad5 = 325,
        KeyPad6 = 326,
        KeyPad7 = 327,
        KeyPad8 = 328,
        KeyPad9 = 329,
        KeyPadDecimal = 330,
        KeyPadDivide = 331,
        KeyPadMultiply = 332,
        KeyPadSubtract = 333,
        KeyPadAdd = 334,
        KeyPadEnter = 335,
        KeyPadEqual = 336,
        KeyLeftShift = 340,
        KeyLeftControl = 341,
        KeyLeftAlt = 342,
        KeyLeftSuper = 343,
        KeyRightShift = 344,
        KeyRightControl = 345,
        KeyRightAlt = 346,
        KeyRightSuper = 347,
        KeyMenu = 348,
        KeyBeginRange = -1,
        KeyEndRange = 348,
        KeyRangeSize = 350,
        KeyMaxEnum = 2147483647
    }

    /// <summary>A module used for the creation, updating and destruction of the keyboard keys.</summary>
    public unsafe partial class Keyboard : global::AcidSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 360)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Array.__Internalc__N_std_S_array__b_Vk348 m_keyboardKeys;

            [FieldOffset(356)]
            internal sbyte m_char;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyboard@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyboard@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Keyboard@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Keyboard@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetKey@Keyboard@acid@@QEBA_NAEBW4Key@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetKey(global::System.IntPtr instance, global::AcidSharp.Key key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChar@Keyboard@acid@@QEBADXZ")]
            internal static extern sbyte GetChar(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.Keyboard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Keyboard(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Keyboard __CreateInstance(global::AcidSharp.Keyboard.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Keyboard(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Keyboard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Keyboard.__Internal));
            global::AcidSharp.Keyboard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Keyboard(global::AcidSharp.Keyboard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Keyboard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Keyboard()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Keyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.Keyboard");
        }

        public Keyboard(global::AcidSharp.Keyboard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Keyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Keyboard");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Keyboard.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets whether or not a particular key is currently pressed. Actions: WSI_ACTION_PRESS, WSI_ACTION_RELEASE, WSI_ACTION_REPEAT</summary>
        /// <param name="key">The key to test.</param>
        public bool GetKey(global::AcidSharp.Key key)
        {
            var __ret = __Internal.GetKey((__Instance + __PointerAdjustment), key);
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::AcidSharp.Keyboard Get()
        {
            var __ret = __Internal.Get();
            global::AcidSharp.Keyboard __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Keyboard.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Keyboard) global::AcidSharp.Keyboard.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Keyboard.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the current user input, ASCII Dec value.</summary>
        public char Char
        {
            get
            {
                var __ret = __Internal.GetChar((__Instance + __PointerAdjustment));
                return global::System.Convert.ToChar(__ret);
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Keyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Keyboard
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackKey@acid@@YAXPEAUGLFWwindow@@HHHH@Z")]
            internal static extern void CallbackKey(global::System.IntPtr window, int key, int scancode, int action, int mods);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackChar@acid@@YAXPEAUGLFWwindow@@I@Z")]
            internal static extern void CallbackChar(global::System.IntPtr window, uint codepoint);
        }

        public static void CallbackKey(global::GLFWwindow window, int key, int scancode, int action, int mods)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackKey(__arg0, key, scancode, action, mods);
        }

        public static void CallbackChar(global::GLFWwindow window, uint codepoint)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackChar(__arg0, codepoint);
        }
    }
}

namespace AcidSharp
{
    /// <summary>Keys from a keyboard.</summary>
    public unsafe partial class ButtonKeyboard : global::AcidSharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_E_Key___N_std_S_allocator__S0_ m_keys;

            [FieldOffset(32)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonKeyboard@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ButtonKeyboard@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.ButtonKeyboard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ButtonKeyboard(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ButtonKeyboard __CreateInstance(global::AcidSharp.ButtonKeyboard.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ButtonKeyboard(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ButtonKeyboard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ButtonKeyboard.__Internal));
            global::AcidSharp.ButtonKeyboard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonKeyboard(global::AcidSharp.ButtonKeyboard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonKeyboard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ButtonKeyboard(global::AcidSharp.ButtonKeyboard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ButtonKeyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.ButtonKeyboard");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.ButtonKeyboard.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___IsDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool IsDown() const override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ButtonKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ButtonKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public enum MouseButton
    {
        MouseButton1 = 0,
        MouseButton2 = 1,
        MouseButton3 = 2,
        MouseButton4 = 3,
        MouseButton5 = 4,
        MouseButton6 = 5,
        MouseButton7 = 6,
        MouseButton8 = 7,
        MouseButtonLeft = 0,
        MouseButtonRight = 1,
        MouseButtonMiddle = 2,
        MouseButtonBeginRange = 0,
        MouseButtonEndRange = 7,
        MouseButtonRangeSize = 8,
        MouseButtonMaxEnum = 2147483647
    }

    /// <summary>A module used for the creation, updating and destruction of the mouse.</summary>
    public unsafe partial class Mouse : global::AcidSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Array.__Internalc__N_std_S_array__b_Vk7 m_mouseButtons;

            [FieldOffset(16)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_mousePath;

            [FieldOffset(48)]
            internal float m_lastMousePositionX;

            [FieldOffset(52)]
            internal float m_lastMousePositionY;

            [FieldOffset(56)]
            internal float m_mousePositionX;

            [FieldOffset(60)]
            internal float m_mousePositionY;

            [FieldOffset(64)]
            internal float m_mouseDeltaX;

            [FieldOffset(68)]
            internal float m_mouseDeltaY;

            [FieldOffset(72)]
            internal float m_mouseDeltaWheel;

            [FieldOffset(76)]
            internal byte m_displaySelected;

            [FieldOffset(77)]
            internal byte m_lastCursorDisabled;

            [FieldOffset(78)]
            internal byte m_cursorDisabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mouse@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mouse@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Mouse@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Mouse@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCursorHidden@Mouse@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetCursorHidden(global::System.IntPtr instance, bool disabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetButton@Mouse@acid@@QEBA_NAEBW4MouseButton@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetButton(global::System.IntPtr instance, global::AcidSharp.MouseButton mouseButton);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Mouse@acid@@QEAAXAEBM0@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, float cursorX, float cursorY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCustomMouse@Mouse@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetCustomMouse(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCustomMouse@Mouse@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetCustomMouse(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionX@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetPositionX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionY@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetPositionY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaX@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetDeltaX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaY@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetDeltaY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaWheel@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetDeltaWheel(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsDisplaySelected@Mouse@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsDisplaySelected(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsCursorDisabled@Mouse@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsCursorDisabled(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.Mouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Mouse(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Mouse __CreateInstance(global::AcidSharp.Mouse.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Mouse(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Mouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Mouse.__Internal));
            global::AcidSharp.Mouse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Mouse(global::AcidSharp.Mouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Mouse(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Mouse()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Mouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.Mouse");
        }

        public Mouse(global::AcidSharp.Mouse _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Mouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Mouse");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Mouse.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Sets if the operating systems cursor is hidden whilst in the display.</summary>
        /// <param name="disabled">If the system cursor should be disabled or hidden when not shown.</param>
        public void SetCursorHidden(bool disabled)
        {
            __Internal.SetCursorHidden((__Instance + __PointerAdjustment), disabled);
        }

        /// <summary>Gets whether or not a particular mouse button is currently pressed. Actions: WSI_ACTION_PRESS, WSI_ACTION_RELEASE, WSI_ACTION_REPEAT</summary>
        /// <param name="mouseButton">The mouse button to test.</param>
        public bool GetButton(global::AcidSharp.MouseButton mouseButton)
        {
            var __ret = __Internal.GetButton((__Instance + __PointerAdjustment), mouseButton);
            return __ret;
        }

        /// <summary>Sets the mouse position.</summary>
        /// <param name="cursorX">The x position in screenspace.</param>
        /// <param name="cursorY">The y position in screenspace.</param>
        public void SetPosition(float cursorX, float cursorY)
        {
            __Internal.SetPosition((__Instance + __PointerAdjustment), cursorX, cursorY);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::AcidSharp.Mouse Get()
        {
            var __ret = __Internal.Get();
            global::AcidSharp.Mouse __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Mouse.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Mouse) global::AcidSharp.Mouse.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Mouse.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the mouses custom mouse file.</summary>
        /// <param name="filename">The new custom mouse file.</param>
        /// <remarks>Sets the custom mouse file.</remarks>
        public string CustomMouse
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetCustomMouse((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetCustomMouse((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the mouses screen x position.</summary>
        public float PositionX
        {
            get
            {
                var __ret = __Internal.GetPositionX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses screen y position.</summary>
        public float PositionY
        {
            get
            {
                var __ret = __Internal.GetPositionY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses delta x.</summary>
        public float DeltaX
        {
            get
            {
                var __ret = __Internal.GetDeltaX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses delta y.</summary>
        public float DeltaY
        {
            get
            {
                var __ret = __Internal.GetDeltaY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses wheel delta.</summary>
        public float DeltaWheel
        {
            get
            {
                var __ret = __Internal.GetDeltaWheel((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the display is selected.</summary>
        public bool IsDisplaySelected
        {
            get
            {
                var __ret = __Internal.IsDisplaySelected((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>If the cursor is hidden, the mouse is the display locked if true.</summary>
        public bool IsCursorDisabled
        {
            get
            {
                var __ret = __Internal.IsCursorDisabled((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Mouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Mouse
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackScroll@acid@@YAXPEAUGLFWwindow@@NN@Z")]
            internal static extern void CallbackScroll(global::System.IntPtr window, double xoffset, double yoffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackMouseButton@acid@@YAXPEAUGLFWwindow@@HHH@Z")]
            internal static extern void CallbackMouseButton(global::System.IntPtr window, int button, int action, int mods);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackCursorPos@acid@@YAXPEAUGLFWwindow@@NN@Z")]
            internal static extern void CallbackCursorPos(global::System.IntPtr window, double xpos, double ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackCursorEnter@acid@@YAXPEAUGLFWwindow@@H@Z")]
            internal static extern void CallbackCursorEnter(global::System.IntPtr window, int entered);
        }

        public static void CallbackScroll(global::GLFWwindow window, double xoffset, double yoffset)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackScroll(__arg0, xoffset, yoffset);
        }

        public static void CallbackMouseButton(global::GLFWwindow window, int button, int action, int mods)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackMouseButton(__arg0, button, action, mods);
        }

        public static void CallbackCursorPos(global::GLFWwindow window, double xpos, double ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackCursorPos(__arg0, xpos, ypos);
        }

        public static void CallbackCursorEnter(global::GLFWwindow window, int entered)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackCursorEnter(__arg0, entered);
        }
    }
}

namespace AcidSharp
{
    /// <summary>Button from a mouse.</summary>
    public unsafe partial class ButtonMouse : global::AcidSharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_E_MouseButton___N_std_S_allocator__S0_ m_buttons;

            [FieldOffset(32)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonMouse@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ButtonMouse@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.ButtonMouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ButtonMouse(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ButtonMouse __CreateInstance(global::AcidSharp.ButtonMouse.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ButtonMouse(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ButtonMouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ButtonMouse.__Internal));
            global::AcidSharp.ButtonMouse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonMouse(global::AcidSharp.ButtonMouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonMouse(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ButtonMouse(global::AcidSharp.ButtonMouse _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ButtonMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.ButtonMouse");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.ButtonMouse.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___IsDownDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool IsDown() const override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ButtonMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ButtonMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A class that smoothly increases its value.</summary>
    public unsafe partial class SmoothFloat : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_agility;

            [FieldOffset(4)]
            internal float m_target;

            [FieldOffset(8)]
            internal float m_actual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SmoothFloat@acid@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float initialValue, float agility);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SmoothFloat@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SmoothFloat@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@SmoothFloat@acid@@QEAAXAEBM@Z")]
            internal static extern void Update(global::System.IntPtr instance, float delta);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IncreaseTarget@SmoothFloat@acid@@QEAAXAEBM@Z")]
            internal static extern void IncreaseTarget(global::System.IntPtr instance, float increase);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@SmoothFloat@acid@@QEBAMXZ")]
            internal static extern float Get(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTarget@SmoothFloat@acid@@QEBAMXZ")]
            internal static extern float GetTarget(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTarget@SmoothFloat@acid@@QEAAXAEBM@Z")]
            internal static extern void SetTarget(global::System.IntPtr instance, float target);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.SmoothFloat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.SmoothFloat>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.SmoothFloat __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.SmoothFloat(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.SmoothFloat __CreateInstance(global::AcidSharp.SmoothFloat.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.SmoothFloat(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.SmoothFloat.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SmoothFloat.__Internal));
            *(global::AcidSharp.SmoothFloat.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SmoothFloat(global::AcidSharp.SmoothFloat.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SmoothFloat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new smooth float.</summary>
        /// <param name="initialValue">The initial value.</param>
        /// <param name="agility">The agility for increasing actual.</param>
        public SmoothFloat(float initialValue, float agility)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SmoothFloat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), initialValue, agility);
        }

        public SmoothFloat(global::AcidSharp.SmoothFloat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SmoothFloat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.SmoothFloat.__Internal*) __Instance) = *((global::AcidSharp.SmoothFloat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.SmoothFloat __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the driver with the passed time.</summary>
        /// <param name="delta">The time between the last update.</param>
        public void Update(float delta)
        {
            __Internal.Update((__Instance + __PointerAdjustment), delta);
        }

        /// <summary>Increases the smooth floats target.</summary>
        /// <param name="increase">How much to increase the target by.</param>
        public void IncreaseTarget(float increase)
        {
            __Internal.IncreaseTarget((__Instance + __PointerAdjustment), increase);
        }

        /// <summary>Gets the currently calculated value.</summary>
        public float Get()
        {
            var __ret = __Internal.Get((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Gets the smooth floats current target.</summary>
        /// <param name="target">The new target.</param>
        /// <remarks>Sets the target for the smooth float.</remarks>
        public float Target
        {
            get
            {
                var __ret = __Internal.GetTarget((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetTarget((__Instance + __PointerAdjustment), value);
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Holds a row major 2x2 matrix.</summary>
    public unsafe partial class Matrix2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Matrix2._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float diagonal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@acid@@QEAA@QEBM@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, float[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@acid@@QEAA@QEBVVector2@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::AcidSharp.Vector2.__Internal[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Matrix2@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Matrix2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Matrix2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Matrix2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transform@Matrix2@acid@@QEBA?AVVector2@2@AEBV32@@Z")]
            internal static extern void Transform(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix2@acid@@QEBA?AV12@AEBVVector2@2@@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Matrix2@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSubmatrix@Matrix2@acid@@QEBAMAEBH0@Z")]
            internal static extern float GetSubmatrix(global::System.IntPtr instance, int row, int col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Matrix2@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Matrix2@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Matrix2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Matrix2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GMatrix2@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Matrix2@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVMatrix2@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVMatrix2@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBV10@AEBVVector2@0@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBV10@AEBVVector2@0@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AMatrix2@acid@@QEAAAEAVVector2@1@AEBI@Z")]
            internal static extern global::System.IntPtr OperatorSubscript(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Invert@Matrix2@acid@@QEBA?AV12@XZ")]
            internal static extern void Invert(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transpose@Matrix2@acid@@QEBA?AV12@XZ")]
            internal static extern void Transpose(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Determinant@Matrix2@acid@@QEBAMXZ")]
            internal static extern float Determinant(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::AcidSharp.Matrix2._.__.__Internal __;

                [FieldOffset(0)]
                internal global::AcidSharp.Matrix2._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed byte m_rows[16];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Matrix2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Matrix2>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Matrix2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Matrix2(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Matrix2 __CreateInstance(global::AcidSharp.Matrix2.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Matrix2(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Matrix2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix2.__Internal));
            global::AcidSharp.Matrix2.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Matrix2(global::AcidSharp.Matrix2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Matrix2. The matrix is initialised to the identity.</summary>
        /// <param name="diagonal">The value set to the diagonals.</param>
        public Matrix2(float diagonal = 1.0F)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), diagonal);
        }

        /// <summary>Constructor for Matrix2.</summary>
        /// <param name="source">Creates this matrix out of a existing one.</param>
        public Matrix2(global::AcidSharp.Matrix2 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix2.</summary>
        /// <param name="source">Creates this matrix out of a 4 element array.</param>
        public Matrix2(float[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 4)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            __Internal.ctor_1((__Instance + __PointerAdjustment), source);
        }

        /// <summary>Constructor for Matrix2.</summary>
        /// <param name="source">Creates this matrix out of a 2 vector array.</param>
        public Matrix2(global::AcidSharp.Vector2[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 2)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            global::AcidSharp.Vector2.__Internal[] __source;
            if (ReferenceEquals(source, null))
                __source = null;
            else
            {
                __source = new global::AcidSharp.Vector2.__Internal[source.Length];
                for (int i = 0; i < __source.Length; i++)
                {
                    var __element = source[i];
                    __source[i] = ReferenceEquals(__element, null) ? new global::AcidSharp.Vector2.__Internal() : *(global::AcidSharp.Vector2.__Internal*) __element.__Instance;
                }
            }
            var __arg0 = __source;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Matrix2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix2 Add(global::AcidSharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix2 Subtract(global::AcidSharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix2 Multiply(global::AcidSharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Divides this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix2 Divide(global::AcidSharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Transforms this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector2 Transform(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.Transform((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Matrix2 Scale(global::AcidSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Inverts this matrix.</summary>
        public global::AcidSharp.Matrix2 Negate()
        {
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Gets the submatrix of this matrix.</summary>
        public float GetSubmatrix(int row, int col)
        {
            var __ret = __Internal.GetSubmatrix((__Instance + __PointerAdjustment), row, col);
            return __ret;
        }

        public void Decode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::AcidSharp.Matrix2 __op, global::AcidSharp.Matrix2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Matrix2;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Matrix2.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Matrix2 __op, global::AcidSharp.Matrix2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::AcidSharp.Matrix2 operator -(global::AcidSharp.Matrix2 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.Matrix2(float diagonal)
        {
            return new global::AcidSharp.Matrix2(diagonal);
        }

        public static implicit operator global::AcidSharp.Matrix2(float[] source)
        {
            return new global::AcidSharp.Matrix2(source);
        }

        public static implicit operator global::AcidSharp.Matrix2(global::AcidSharp.Vector2[] source)
        {
            return new global::AcidSharp.Matrix2(source);
        }

        public static global::AcidSharp.Matrix2 operator +(global::AcidSharp.Matrix2 left, global::AcidSharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator -(global::AcidSharp.Matrix2 left, global::AcidSharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator *(global::AcidSharp.Matrix2 left, global::AcidSharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator /(global::AcidSharp.Matrix2 left, global::AcidSharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator *(global::AcidSharp.Matrix2 left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator /(global::AcidSharp.Matrix2 left, global::AcidSharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator *(float left, global::AcidSharp.Matrix2 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator /(float left, global::AcidSharp.Matrix2 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator *(global::AcidSharp.Matrix2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 operator /(global::AcidSharp.Matrix2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix2 Identity
        {
            get
            {
                var __ptr = (global::AcidSharp.Matrix2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?IDENTITY@Matrix2@acid@@2V12@B");
                return global::AcidSharp.Matrix2.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Matrix2 Zero
        {
            get
            {
                var __ptr = (global::AcidSharp.Matrix2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Matrix2@acid@@2V12@B");
                return global::AcidSharp.Matrix2.__CreateInstance(*__ptr);
            }
        }

        public global::AcidSharp.Vector2 this[uint index]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), index);
                return global::AcidSharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                *(global::AcidSharp.Vector2.__Internal*) global::AcidSharp.Matrix2.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), index) = ReferenceEquals(value, null) ? new global::AcidSharp.Vector2.__Internal() : *(global::AcidSharp.Vector2.__Internal*) value.__Instance;
            }
        }

        /// <summary>Negates this matrix.</summary>
        public global::AcidSharp.Matrix2 Invert
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix2.__Internal();
                __Internal.Invert((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix2.__CreateInstance(__ret);
            }
        }

        /// <summary>Transposes this matrix.</summary>
        public global::AcidSharp.Matrix2 Transpose
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix2.__Internal();
                __Internal.Transpose((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix2.__CreateInstance(__ret);
            }
        }

        /// <summary>Takes the determinant of this matrix.</summary>
        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Holds a row major 3x3 matrix.</summary>
    public unsafe partial class Matrix3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Matrix3._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float diagonal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@acid@@QEAA@QEBM@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, float[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@acid@@QEAA@QEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::AcidSharp.Vector3.__Internal[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Matrix3@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Matrix3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Matrix3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix3@acid@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void Multiply_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Matrix3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transform@Matrix3@acid@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void Transform(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix3@acid@@QEBA?AV12@AEBVVector3@2@@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Matrix3@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSubmatrix@Matrix3@acid@@QEBA?AVMatrix2@2@AEBH0@Z")]
            internal static extern void GetSubmatrix(global::System.IntPtr instance, global::System.IntPtr @return, int row, int col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Matrix3@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Matrix3@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Matrix3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Matrix3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GMatrix3@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Matrix3@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVMatrix3@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVMatrix3@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBV10@AEBVVector3@0@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBV10@AEBVVector3@0@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AMatrix3@acid@@QEAAAEAVVector3@1@AEBI@Z")]
            internal static extern global::System.IntPtr OperatorSubscript(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Invert@Matrix3@acid@@QEBA?AV12@XZ")]
            internal static extern void Invert(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transpose@Matrix3@acid@@QEBA?AV12@XZ")]
            internal static extern void Transpose(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Determinant@Matrix3@acid@@QEBAMXZ")]
            internal static extern float Determinant(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 36)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::AcidSharp.Matrix3._.__.__Internal __;

                [FieldOffset(0)]
                internal global::AcidSharp.Matrix3._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 36)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed byte m_rows[36];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Matrix3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Matrix3>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Matrix3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Matrix3(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Matrix3 __CreateInstance(global::AcidSharp.Matrix3.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Matrix3(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Matrix3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix3.__Internal));
            global::AcidSharp.Matrix3.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Matrix3(global::AcidSharp.Matrix3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Matrix3. The matrix is initialised to the identity.</summary>
        /// <param name="diagonal">The value set to the diagonals.</param>
        public Matrix3(float diagonal = 1.0F)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), diagonal);
        }

        /// <summary>Constructor for Matrix3.</summary>
        /// <param name="source">Creates this matrix out of a existing one.</param>
        public Matrix3(global::AcidSharp.Matrix3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix3.</summary>
        /// <param name="source">Creates this matrix out of a 9 element array.</param>
        public Matrix3(float[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 9)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            __Internal.ctor_1((__Instance + __PointerAdjustment), source);
        }

        /// <summary>Constructor for Matrix3.</summary>
        /// <param name="source">Creates this matrix out of a 3 vector array.</param>
        public Matrix3(global::AcidSharp.Vector3[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 3)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            global::AcidSharp.Vector3.__Internal[] __source;
            if (ReferenceEquals(source, null))
                __source = null;
            else
            {
                __source = new global::AcidSharp.Vector3.__Internal[source.Length];
                for (int i = 0; i < __source.Length; i++)
                {
                    var __element = source[i];
                    __source[i] = ReferenceEquals(__element, null) ? new global::AcidSharp.Vector3.__Internal() : *(global::AcidSharp.Vector3.__Internal*) __element.__Instance;
                }
            }
            var __arg0 = __source;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Matrix3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix3 Add(global::AcidSharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix3 Subtract(global::AcidSharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix3 Multiply(global::AcidSharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by a vector.</summary>
        /// <param name="other">The vector.</param>
        public global::AcidSharp.Vector3 Multiply(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Multiply_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Divides this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::AcidSharp.Matrix3 Divide(global::AcidSharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Transforms this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Vector3 Transform(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.Transform((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::AcidSharp.Matrix3 Scale(global::AcidSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Inverts this matrix.</summary>
        public global::AcidSharp.Matrix3 Negate()
        {
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Gets the submatrix of this matrix.</summary>
        public global::AcidSharp.Matrix2 GetSubmatrix(int row, int col)
        {
            var __ret = new global::AcidSharp.Matrix2.__Internal();
            __Internal.GetSubmatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret), row, col);
            return global::AcidSharp.Matrix2.__CreateInstance(__ret);
        }

        public void Decode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::AcidSharp.Matrix3 __op, global::AcidSharp.Matrix3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Matrix3;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Matrix3.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Matrix3 __op, global::AcidSharp.Matrix3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::AcidSharp.Matrix3 operator -(global::AcidSharp.Matrix3 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.Matrix3(float diagonal)
        {
            return new global::AcidSharp.Matrix3(diagonal);
        }

        public static implicit operator global::AcidSharp.Matrix3(float[] source)
        {
            return new global::AcidSharp.Matrix3(source);
        }

        public static implicit operator global::AcidSharp.Matrix3(global::AcidSharp.Vector3[] source)
        {
            return new global::AcidSharp.Matrix3(source);
        }

        public static global::AcidSharp.Matrix3 operator +(global::AcidSharp.Matrix3 left, global::AcidSharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator -(global::AcidSharp.Matrix3 left, global::AcidSharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator *(global::AcidSharp.Matrix3 left, global::AcidSharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator /(global::AcidSharp.Matrix3 left, global::AcidSharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator *(global::AcidSharp.Matrix3 left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator /(global::AcidSharp.Matrix3 left, global::AcidSharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator *(float left, global::AcidSharp.Matrix3 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator /(float left, global::AcidSharp.Matrix3 right)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), left, __arg1);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator *(global::AcidSharp.Matrix3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 operator /(global::AcidSharp.Matrix3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __ret = new global::AcidSharp.Matrix3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, right);
            return global::AcidSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::AcidSharp.Matrix3 Identity
        {
            get
            {
                var __ptr = (global::AcidSharp.Matrix3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?IDENTITY@Matrix3@acid@@2V12@B");
                return global::AcidSharp.Matrix3.__CreateInstance(*__ptr);
            }
        }

        public static global::AcidSharp.Matrix3 Zero
        {
            get
            {
                var __ptr = (global::AcidSharp.Matrix3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Matrix3@acid@@2V12@B");
                return global::AcidSharp.Matrix3.__CreateInstance(*__ptr);
            }
        }

        public global::AcidSharp.Vector3 this[uint index]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), index);
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                *(global::AcidSharp.Vector3.__Internal*) global::AcidSharp.Matrix3.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), index) = ReferenceEquals(value, null) ? new global::AcidSharp.Vector3.__Internal() : *(global::AcidSharp.Vector3.__Internal*) value.__Instance;
            }
        }

        /// <summary>Negates this matrix.</summary>
        public global::AcidSharp.Matrix3 Invert
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix3.__Internal();
                __Internal.Invert((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix3.__CreateInstance(__ret);
            }
        }

        /// <summary>Transposes this matrix.</summary>
        public global::AcidSharp.Matrix3 Transpose
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix3.__Internal();
                __Internal.Transpose((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix3.__CreateInstance(__ret);
            }
        }

        /// <summary>Takes the determinant of this matrix.</summary>
        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Holds position, rotation, and scale components.</summary>
    public unsafe partial class Transform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Vector3.__Internal m_position;

            [FieldOffset(12)]
            internal global::AcidSharp.Vector3.__Internal m_rotation;

            [FieldOffset(24)]
            internal global::AcidSharp.Vector3.__Internal m_scaling;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@acid@@QEAA@AEBVVector3@1@00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation, global::System.IntPtr scaling);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@acid@@QEAA@AEBVVector3@1@0AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation, float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Transform@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Transform@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Transform@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Transform@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Transform@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Transform@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Transform@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Transform@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRotation@Transform@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetRotation(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRotation@Transform@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetRotation(global::System.IntPtr instance, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScaling@Transform@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetScaling(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScaling@Transform@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetScaling(global::System.IntPtr instance, global::System.IntPtr scaling);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWorldMatrix@Transform@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetWorldMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModelMatrix@Transform@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetModelMatrix(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Transform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Transform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Transform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Transform(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Transform __CreateInstance(global::AcidSharp.Transform.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Transform(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Transform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Transform.__Internal));
            global::AcidSharp.Transform.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Transform(global::AcidSharp.Transform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Transform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Transform.</summary>
        public Transform()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="source">Creates this vector out of a transform.</param>
        public Transform(global::AcidSharp.Transform source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="position">The position.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="scaling">The scaling.</param>
        public Transform(global::AcidSharp.Vector3 position, global::AcidSharp.Vector3 rotation, global::AcidSharp.Vector3 scaling)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            if (ReferenceEquals(scaling, null))
                throw new global::System.ArgumentNullException("scaling", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = scaling.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="position">The position.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="scale">The scale.</param>
        public Transform(global::AcidSharp.Vector3 position, global::AcidSharp.Vector3 rotation, float scale)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, scale);
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="position">The position.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="scaling">The scaling.</param>
        public Transform(global::AcidSharp.Vector3 position) : this(position, global::AcidSharp.Vector3.Zero, global::AcidSharp.Vector3.One)
        {
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="position">The position.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="scaling">The scaling.</param>
        public Transform(global::AcidSharp.Vector3 position, global::AcidSharp.Vector3 rotation) : this(position, rotation, global::AcidSharp.Vector3.One)
        {
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Transform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Decode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::AcidSharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::AcidSharp.Transform __op, global::AcidSharp.Transform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.Transform;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.Transform.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.Transform __op, global::AcidSharp.Transform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::AcidSharp.Transform(global::AcidSharp.Vector3 position)
        {
            return new global::AcidSharp.Transform(position);
        }

        public global::AcidSharp.Vector3 Position
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 Rotation
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetRotation((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 Scaling
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetScaling((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetScaling((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Matrix4 WorldMatrix
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.GetWorldMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }
        }

        public global::AcidSharp.Matrix4 ModelMatrix
        {
            get
            {
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                __Internal.GetModelMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Represents a driver that changes over time.</summary>
    public unsafe abstract partial class IDriver : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDriver@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDriver@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IDriver@acid@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@IDriver@acid@@QEAAMAEBN@Z")]
            internal static extern float Update(global::System.IntPtr instance, double delta);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetActualTime@IDriver@acid@@IEBAMXZ")]
            internal static extern float GetActualTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IDriver> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IDriver>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IDriver __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.IDriverInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IDriver __CreateInstance(global::AcidSharp.IDriver.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.IDriverInternal(native, skipVTables);
        }

        protected IDriver(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new driver with a length.</summary>
        /// <param name="length">The drivers length.</param>
        protected IDriver(float length)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IDriver.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), length);
            SetupVTables(GetType().FullName == "AcidSharp.IDriver");
        }

        protected IDriver(global::AcidSharp.IDriver _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IDriver.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IDriver");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IDriver __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IDriver.__Internal*) __Instance)->vfptr_IDriver = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::AcidSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the driver with the passed time.</summary>
        /// <param name="delta">The time between the last update.</param>
        public float Update(double delta)
        {
            var __ret = __Internal.Update((__Instance + __PointerAdjustment), delta);
            return __ret;
        }

        /// <summary>Calculates the new value.</summary>
        /// <param name="time">The time into the drivers life.</param>
        protected abstract float Calculate(float time);

        protected float ActualTime
        {
            get
            {
                var __ret = __Internal.GetActualTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~IDriver() { }
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IDriver) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) = 0
        private static global::AcidSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IDriver) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IDriverInternal : global::AcidSharp.IDriver, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IDriver.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IDriver.__Internal));
            *(global::AcidSharp.IDriver.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IDriverInternal(global::AcidSharp.IDriver.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IDriverInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Calculates the new value.</summary>
        /// <param name="time">The time into the drivers life.</param>
        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }
    }
}

namespace AcidSharp
{
    /// <summary>A bounce driver that uses a sine wave.</summary>
    public unsafe partial class DriverBounce : global::AcidSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_start;

            [FieldOffset(28)]
            internal float m_amplitude;

            [FieldOffset(32)]
            internal float m_length1;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverBounce@acid@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float start, float end, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverBounce@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::AcidSharp.DriverBounce __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverBounce(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.DriverBounce __CreateInstance(global::AcidSharp.DriverBounce.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverBounce(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.DriverBounce.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverBounce.__Internal));
            global::AcidSharp.DriverBounce.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverBounce(global::AcidSharp.DriverBounce.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverBounce(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new sine wave driver.</summary>
        /// <param name="start">The start value.</param>
        /// <param name="end">The end value.</param>
        /// <param name="length">The length between two waves.</param>
        public DriverBounce(float start, float end, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverBounce.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), start, end, length);
            SetupVTables(GetType().FullName == "AcidSharp.DriverBounce");
        }

        public DriverBounce(global::AcidSharp.DriverBounce _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverBounce.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.DriverBounce");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        #region Virtual table interop

        // ~DriverBounce()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverBounce) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::AcidSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverBounce) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A driver that has a constant value.</summary>
    public unsafe partial class DriverConstant : global::AcidSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverConstant@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float constant);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverConstant@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::AcidSharp.DriverConstant __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverConstant(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.DriverConstant __CreateInstance(global::AcidSharp.DriverConstant.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverConstant(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.DriverConstant.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverConstant.__Internal));
            global::AcidSharp.DriverConstant.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverConstant(global::AcidSharp.DriverConstant.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverConstant(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new constant driver.</summary>
        /// <param name="constant">The constant value.</param>
        public DriverConstant(float constant)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverConstant.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), constant);
            SetupVTables(GetType().FullName == "AcidSharp.DriverConstant");
        }

        public DriverConstant(global::AcidSharp.DriverConstant _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverConstant.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.DriverConstant");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        public static implicit operator global::AcidSharp.DriverConstant(float constant)
        {
            return new global::AcidSharp.DriverConstant(constant);
        }

        #region Virtual table interop

        // ~DriverConstant()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverConstant) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::AcidSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverConstant) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A driver that fades from start to end.</summary>
    public unsafe partial class DriverFade : global::AcidSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_start;

            [FieldOffset(28)]
            internal float m_end;

            [FieldOffset(32)]
            internal float m_peak;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverFade@acid@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float start, float end, float peak, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverFade@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStart@DriverFade@acid@@QEBAMXZ")]
            internal static extern float GetStart(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStart@DriverFade@acid@@QEAAXAEBM@Z")]
            internal static extern void SetStart(global::System.IntPtr instance, float start);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetEnd@DriverFade@acid@@QEBAMXZ")]
            internal static extern float GetEnd(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnd@DriverFade@acid@@QEAAXAEBM@Z")]
            internal static extern void SetEnd(global::System.IntPtr instance, float end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPeak@DriverFade@acid@@QEBAMXZ")]
            internal static extern float GetPeak(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPeak@DriverFade@acid@@QEAAXAEBM@Z")]
            internal static extern void SetPeak(global::System.IntPtr instance, float peak);
        }

        internal static new global::AcidSharp.DriverFade __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverFade(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.DriverFade __CreateInstance(global::AcidSharp.DriverFade.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverFade(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.DriverFade.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverFade.__Internal));
            global::AcidSharp.DriverFade.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverFade(global::AcidSharp.DriverFade.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverFade(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new fade driver.</summary>
        /// <param name="start">The start time.</param>
        /// <param name="end">The end time.</param>
        /// <param name="peak">The peak value.</param>
        /// <param name="length">The time taken to get to the end.</param>
        public DriverFade(float start, float end, float peak, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverFade.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), start, end, peak, length);
            SetupVTables(GetType().FullName == "AcidSharp.DriverFade");
        }

        public DriverFade(global::AcidSharp.DriverFade _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverFade.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.DriverFade");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        /// <summary>Gets the start time.</summary>
        /// <param name="start">The new start time.</param>
        /// <remarks>Sets the start time.</remarks>
        public float Start
        {
            get
            {
                var __ret = __Internal.GetStart((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetStart((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the end time.</summary>
        /// <param name="end">The new end time.</param>
        /// <remarks>Sets the end time.</remarks>
        public float End
        {
            get
            {
                var __ret = __Internal.GetEnd((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetEnd((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the peak value.</summary>
        /// <param name="peak">The new peak value.</param>
        /// <remarks>Sets the peak value.</remarks>
        public float Peak
        {
            get
            {
                var __ret = __Internal.GetPeak((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetPeak((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~DriverFade()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverFade) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::AcidSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverFade) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A driver that linearly increases its value.</summary>
    public unsafe partial class DriverLinear : global::AcidSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_startValue;

            [FieldOffset(28)]
            internal float m_difference;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverLinear@acid@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float startValue, float endValue, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverLinear@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::AcidSharp.DriverLinear __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverLinear(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.DriverLinear __CreateInstance(global::AcidSharp.DriverLinear.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverLinear(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.DriverLinear.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverLinear.__Internal));
            global::AcidSharp.DriverLinear.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverLinear(global::AcidSharp.DriverLinear.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverLinear(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new linear driver.</summary>
        /// <param name="startValue">The start value.</param>
        /// <param name="endValue">The end value.</param>
        /// <param name="length">The time to go between values.</param>
        public DriverLinear(float startValue, float endValue, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverLinear.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), startValue, endValue, length);
            SetupVTables(GetType().FullName == "AcidSharp.DriverLinear");
        }

        public DriverLinear(global::AcidSharp.DriverLinear _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverLinear.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.DriverLinear");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        #region Virtual table interop

        // ~DriverLinear()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverLinear) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::AcidSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverLinear) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A driver that uses a sine wave.</summary>
    public unsafe partial class DriverSinwave : global::AcidSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_min;

            [FieldOffset(28)]
            internal float m_amplitude;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSinwave@acid@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float min, float max, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSinwave@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::AcidSharp.DriverSinwave __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverSinwave(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.DriverSinwave __CreateInstance(global::AcidSharp.DriverSinwave.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverSinwave(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.DriverSinwave.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverSinwave.__Internal));
            global::AcidSharp.DriverSinwave.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverSinwave(global::AcidSharp.DriverSinwave.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverSinwave(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new sine wave driver.</summary>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <param name="length">The length between two waves.</param>
        public DriverSinwave(float min, float max, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverSinwave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), min, max, length);
            SetupVTables(GetType().FullName == "AcidSharp.DriverSinwave");
        }

        public DriverSinwave(global::AcidSharp.DriverSinwave _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverSinwave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.DriverSinwave");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        #region Virtual table interop

        // ~DriverSinwave()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverSinwave) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::AcidSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverSinwave) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A driver that slides to its destination using cosine interpolation.</summary>
    public unsafe partial class DriverSlide : global::AcidSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_start;

            [FieldOffset(28)]
            internal float m_end;

            [FieldOffset(32)]
            internal float m_max;

            [FieldOffset(36)]
            internal byte m_reachedTarget;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSlide@acid@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float start, float end, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSlide@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::AcidSharp.DriverSlide __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverSlide(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.DriverSlide __CreateInstance(global::AcidSharp.DriverSlide.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.DriverSlide(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.DriverSlide.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverSlide.__Internal));
            global::AcidSharp.DriverSlide.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverSlide(global::AcidSharp.DriverSlide.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverSlide(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new slide driver.</summary>
        /// <param name="start">The start value.</param>
        /// <param name="end">The end value.</param>
        /// <param name="length">The time to get to the end value.</param>
        public DriverSlide(float start, float end, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverSlide.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), start, end, length);
            SetupVTables(GetType().FullName == "AcidSharp.DriverSlide");
        }

        public DriverSlide(global::AcidSharp.DriverSlide _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.DriverSlide.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.DriverSlide");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        #region Virtual table interop

        // ~DriverSlide()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverSlide) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::AcidSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.DriverSlide) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    public enum NoiseType
    {
        TypeValue = 0,
        TypeValuefractal = 1,
        TypePerlin = 2,
        TypePerlinfractal = 3,
        TypeSimplex = 4,
        TypeSimplexfractal = 5,
        TypeCellular = 6,
        TypeWhitenoise = 7,
        TypeCubic = 8,
        TypeCubicfractal = 9
    }

    public enum NoiseInterp
    {
        InterpLinear = 0,
        InterpHermite = 1,
        InterpQuintic = 2
    }

    public enum NoiseFractal
    {
        FractalFbm = 0,
        FractalBillow = 1,
        FractalRigidmulti = 2
    }

    public enum NoiseCellularFunc
    {
        CellularEuclidean = 0,
        CellularManhattan = 1,
        CellularNatural = 2
    }

    public enum NoiseCellularReturn
    {
        CellularCellvalue = 0,
        CellularNoiselookup = 1,
        CellularDistance = 2,
        CellularDistance2 = 3,
        CellularDistance2add = 4,
        CellularDistance2sub = 5,
        CellularDistance2mul = 6,
        CellularDistance2div = 7
    }

    public unsafe partial class Noise : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int m_seed;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr___nc___N_std_S_default_delete__S0_ m_perm;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr___nc___N_std_S_default_delete__S0_ m_perm12;

            [FieldOffset(24)]
            internal float m_frequency;

            [FieldOffset(28)]
            internal global::AcidSharp.NoiseInterp m_interp;

            [FieldOffset(32)]
            internal global::AcidSharp.NoiseType m_noiseType;

            [FieldOffset(36)]
            internal int m_octaves;

            [FieldOffset(40)]
            internal float m_lacunarity;

            [FieldOffset(44)]
            internal float m_gain;

            [FieldOffset(48)]
            internal global::AcidSharp.NoiseFractal m_fractalType;

            [FieldOffset(52)]
            internal float m_fractalBounding;

            [FieldOffset(56)]
            internal global::AcidSharp.NoiseCellularFunc m_cellularDistanceFunction;

            [FieldOffset(60)]
            internal global::AcidSharp.NoiseCellularReturn m_cellularReturnType;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Noise___N_std_S_default_delete__S0_ m_cellularNoiseLookup;

            [FieldOffset(72)]
            internal int m_cellularDistanceIndex0;

            [FieldOffset(76)]
            internal int m_cellularDistanceIndex1;

            [FieldOffset(80)]
            internal float m_cellularJitter;

            [FieldOffset(84)]
            internal float m_gradientPerturbAmp;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Noise@acid@@QEAA@AEBH@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int seed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Noise@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Noise@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularNoiseLookup@Noise@acid@@QEAAXPEAV12@@Z")]
            internal static extern void SetCellularNoiseLookup(global::System.IntPtr instance, global::System.IntPtr noise);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularDistance2Indices@Noise@acid@@QEBAXAEAH0@Z")]
            internal static extern void GetCellularDistance2Indices(global::System.IntPtr instance, int* cellularDistanceIndex0, int* cellularDistanceIndex1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularDistance2Indices@Noise@acid@@QEAAXAEBH0@Z")]
            internal static extern void SetCellularDistance2Indices(global::System.IntPtr instance, int cellularDistanceIndex0, int cellularDistanceIndex1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetValue(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValueFractal@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetValueFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlin@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetPerlin(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlinFractal@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetPerlinFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplex@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetSimplex(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplexFractal@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetSimplexFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellular@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetCellular(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoise@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetWhiteNoise(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoiseInt@Noise@acid@@QEBAMHH@Z")]
            internal static extern float GetWhiteNoiseInt(global::System.IntPtr instance, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubic@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetCubic(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubicFractal@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetCubicFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoise@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetNoise(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturb@Noise@acid@@QEBAXAEAM0@Z")]
            internal static extern void GradientPerturb(global::System.IntPtr instance, float* x, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturbFractal@Noise@acid@@QEBAXAEAM0@Z")]
            internal static extern void GradientPerturbFractal(global::System.IntPtr instance, float* x, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetValue(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValueFractal@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetValueFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlin@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetPerlin(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlinFractal@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetPerlinFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplex@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetSimplex(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplexFractal@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetSimplexFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellular@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetCellular(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoise@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetWhiteNoise(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoiseInt@Noise@acid@@QEBAMHHH@Z")]
            internal static extern float GetWhiteNoiseInt(global::System.IntPtr instance, int x, int y, int z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubic@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetCubic(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubicFractal@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetCubicFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoise@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetNoise(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturb@Noise@acid@@QEBAXAEAM00@Z")]
            internal static extern void GradientPerturb(global::System.IntPtr instance, float* x, float* y, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturbFractal@Noise@acid@@QEBAXAEAM00@Z")]
            internal static extern void GradientPerturbFractal(global::System.IntPtr instance, float* x, float* y, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplex@Noise@acid@@QEBAMMMMM@Z")]
            internal static extern float GetSimplex(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoise@Noise@acid@@QEBAMMMMM@Z")]
            internal static extern float GetWhiteNoise(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoiseInt@Noise@acid@@QEBAMHHHH@Z")]
            internal static extern float GetWhiteNoiseInt(global::System.IntPtr instance, int x, int y, int z, int w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSeed@Noise@acid@@QEBAHXZ")]
            internal static extern int GetSeed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSeed@Noise@acid@@QEAAXAEBH@Z")]
            internal static extern void SetSeed(global::System.IntPtr instance, int seed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFrequency@Noise@acid@@QEBAMXZ")]
            internal static extern float GetFrequency(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFrequency@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFrequency(global::System.IntPtr instance, float frequency);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInterp@Noise@acid@@QEBA?AW4NoiseInterp@2@XZ")]
            internal static extern global::AcidSharp.NoiseInterp GetInterp(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInterp@Noise@acid@@QEAAXAEBW4NoiseInterp@2@@Z")]
            internal static extern void SetInterp(global::System.IntPtr instance, global::AcidSharp.NoiseInterp interp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoiseType@Noise@acid@@QEBA?AW4NoiseType@2@XZ")]
            internal static extern global::AcidSharp.NoiseType GetNoiseType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNoiseType@Noise@acid@@QEAAXAEBW4NoiseType@2@@Z")]
            internal static extern void SetNoiseType(global::System.IntPtr instance, global::AcidSharp.NoiseType noiseType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalOctaves@Noise@acid@@QEBAHXZ")]
            internal static extern int GetFractalOctaves(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalOctaves@Noise@acid@@QEAAXAEBH@Z")]
            internal static extern void SetFractalOctaves(global::System.IntPtr instance, int octaves);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalLacunarity@Noise@acid@@QEBAMXZ")]
            internal static extern float GetFractalLacunarity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalLacunarity@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFractalLacunarity(global::System.IntPtr instance, float lacunarity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalGain@Noise@acid@@QEBAMXZ")]
            internal static extern float GetFractalGain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalGain@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFractalGain(global::System.IntPtr instance, float gain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalType@Noise@acid@@QEBA?AW4NoiseFractal@2@XZ")]
            internal static extern global::AcidSharp.NoiseFractal GetFractalType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalType@Noise@acid@@QEAAXAEBW4NoiseFractal@2@@Z")]
            internal static extern void SetFractalType(global::System.IntPtr instance, global::AcidSharp.NoiseFractal fractalType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularDistanceFunction@Noise@acid@@QEBA?AW4NoiseCellularFunc@2@XZ")]
            internal static extern global::AcidSharp.NoiseCellularFunc GetCellularDistanceFunction(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularDistanceFunction@Noise@acid@@QEAAXAEBW4NoiseCellularFunc@2@@Z")]
            internal static extern void SetCellularDistanceFunction(global::System.IntPtr instance, global::AcidSharp.NoiseCellularFunc cellularDistanceFunction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularReturnType@Noise@acid@@QEBA?AW4NoiseCellularReturn@2@XZ")]
            internal static extern global::AcidSharp.NoiseCellularReturn GetCellularReturnType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularReturnType@Noise@acid@@QEAAXAEBW4NoiseCellularReturn@2@@Z")]
            internal static extern void SetCellularReturnType(global::System.IntPtr instance, global::AcidSharp.NoiseCellularReturn cellularReturnType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularJitter@Noise@acid@@QEBAMXZ")]
            internal static extern float GetCellularJitter(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularJitter@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetCellularJitter(global::System.IntPtr instance, float cellularJitter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGradientPerturbAmp@Noise@acid@@QEBAMXZ")]
            internal static extern float GetGradientPerturbAmp(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGradientPerturbAmp@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetGradientPerturbAmp(global::System.IntPtr instance, float gradientPerturbAmp);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Noise> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Noise>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Noise __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Noise(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Noise __CreateInstance(global::AcidSharp.Noise.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Noise(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Noise.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Noise.__Internal));
            *(global::AcidSharp.Noise.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Noise(global::AcidSharp.Noise.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Noise(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Noise(int seed)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Noise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), seed);
        }

        public Noise(global::AcidSharp.Noise _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Noise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.Noise.__Internal*) __Instance) = *((global::AcidSharp.Noise.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Noise __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void SetCellularNoiseLookup(global::AcidSharp.Noise noise)
        {
            var __arg0 = ReferenceEquals(noise, null) ? global::System.IntPtr.Zero : noise.__Instance;
            __Internal.SetCellularNoiseLookup((__Instance + __PointerAdjustment), __arg0);
        }

        public void GetCellularDistance2Indices(ref int cellularDistanceIndex0, ref int cellularDistanceIndex1)
        {
            fixed (int* __refParamPtr0 = &cellularDistanceIndex0)
            {
                var __arg0 = __refParamPtr0;
                fixed (int* __refParamPtr1 = &cellularDistanceIndex1)
                {
                    var __arg1 = __refParamPtr1;
                    __Internal.GetCellularDistance2Indices((__Instance + __PointerAdjustment), __arg0, __arg1);
                }
            }
        }

        public void SetCellularDistance2Indices(int cellularDistanceIndex0, int cellularDistanceIndex1)
        {
            __Internal.SetCellularDistance2Indices((__Instance + __PointerAdjustment), cellularDistanceIndex0, cellularDistanceIndex1);
        }

        public float GetValue(float x, float y)
        {
            var __ret = __Internal.GetValue((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetValueFractal(float x, float y)
        {
            var __ret = __Internal.GetValueFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetPerlin(float x, float y)
        {
            var __ret = __Internal.GetPerlin((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetPerlinFractal(float x, float y)
        {
            var __ret = __Internal.GetPerlinFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetSimplex(float x, float y)
        {
            var __ret = __Internal.GetSimplex((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetSimplexFractal(float x, float y)
        {
            var __ret = __Internal.GetSimplexFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetCellular(float x, float y)
        {
            var __ret = __Internal.GetCellular((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetWhiteNoise(float x, float y)
        {
            var __ret = __Internal.GetWhiteNoise((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetWhiteNoiseInt(int x, int y)
        {
            var __ret = __Internal.GetWhiteNoiseInt((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetCubic(float x, float y)
        {
            var __ret = __Internal.GetCubic((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetCubicFractal(float x, float y)
        {
            var __ret = __Internal.GetCubicFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetNoise(float x, float y)
        {
            var __ret = __Internal.GetNoise((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public void GradientPerturb(ref float x, ref float y)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    __Internal.GradientPerturb((__Instance + __PointerAdjustment), __arg0, __arg1);
                }
            }
        }

        public void GradientPerturbFractal(ref float x, ref float y)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    __Internal.GradientPerturbFractal((__Instance + __PointerAdjustment), __arg0, __arg1);
                }
            }
        }

        public float GetValue(float x, float y, float z)
        {
            var __ret = __Internal.GetValue((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetValueFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetValueFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetPerlin(float x, float y, float z)
        {
            var __ret = __Internal.GetPerlin((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetPerlinFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetPerlinFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetSimplex(float x, float y, float z)
        {
            var __ret = __Internal.GetSimplex((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetSimplexFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetSimplexFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetCellular(float x, float y, float z)
        {
            var __ret = __Internal.GetCellular((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetWhiteNoise(float x, float y, float z)
        {
            var __ret = __Internal.GetWhiteNoise((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetWhiteNoiseInt(int x, int y, int z)
        {
            var __ret = __Internal.GetWhiteNoiseInt((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetCubic(float x, float y, float z)
        {
            var __ret = __Internal.GetCubic((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetCubicFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetCubicFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetNoise(float x, float y, float z)
        {
            var __ret = __Internal.GetNoise((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public void GradientPerturb(ref float x, ref float y, ref float z)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (float* __refParamPtr2 = &z)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GradientPerturb((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
                    }
                }
            }
        }

        public void GradientPerturbFractal(ref float x, ref float y, ref float z)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (float* __refParamPtr2 = &z)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GradientPerturbFractal((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
                    }
                }
            }
        }

        public float GetSimplex(float x, float y, float z, float w)
        {
            var __ret = __Internal.GetSimplex((__Instance + __PointerAdjustment), x, y, z, w);
            return __ret;
        }

        public float GetWhiteNoise(float x, float y, float z, float w)
        {
            var __ret = __Internal.GetWhiteNoise((__Instance + __PointerAdjustment), x, y, z, w);
            return __ret;
        }

        public float GetWhiteNoiseInt(int x, int y, int z, int w)
        {
            var __ret = __Internal.GetWhiteNoiseInt((__Instance + __PointerAdjustment), x, y, z, w);
            return __ret;
        }

        public static implicit operator global::AcidSharp.Noise(int seed)
        {
            return new global::AcidSharp.Noise(seed);
        }

        public int Seed
        {
            get
            {
                var __ret = __Internal.GetSeed((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetSeed((__Instance + __PointerAdjustment), value);
            }
        }

        public float Frequency
        {
            get
            {
                var __ret = __Internal.GetFrequency((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFrequency((__Instance + __PointerAdjustment), value);
            }
        }

        public global::AcidSharp.NoiseInterp Interp
        {
            get
            {
                var __ret = __Internal.GetInterp((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetInterp((__Instance + __PointerAdjustment), value);
            }
        }

        public global::AcidSharp.NoiseType NoiseType
        {
            get
            {
                var __ret = __Internal.GetNoiseType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetNoiseType((__Instance + __PointerAdjustment), value);
            }
        }

        public int FractalOctaves
        {
            get
            {
                var __ret = __Internal.GetFractalOctaves((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFractalOctaves((__Instance + __PointerAdjustment), value);
            }
        }

        public float FractalLacunarity
        {
            get
            {
                var __ret = __Internal.GetFractalLacunarity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFractalLacunarity((__Instance + __PointerAdjustment), value);
            }
        }

        public float FractalGain
        {
            get
            {
                var __ret = __Internal.GetFractalGain((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFractalGain((__Instance + __PointerAdjustment), value);
            }
        }

        public global::AcidSharp.NoiseFractal FractalType
        {
            get
            {
                var __ret = __Internal.GetFractalType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFractalType((__Instance + __PointerAdjustment), value);
            }
        }

        public global::AcidSharp.NoiseCellularFunc CellularDistanceFunction
        {
            get
            {
                var __ret = __Internal.GetCellularDistanceFunction((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCellularDistanceFunction((__Instance + __PointerAdjustment), value);
            }
        }

        public global::AcidSharp.NoiseCellularReturn CellularReturnType
        {
            get
            {
                var __ret = __Internal.GetCellularReturnType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCellularReturnType((__Instance + __PointerAdjustment), value);
            }
        }

        public float CellularJitter
        {
            get
            {
                var __ret = __Internal.GetCellularJitter((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCellularJitter((__Instance + __PointerAdjustment), value);
            }
        }

        public float GradientPerturbAmp
        {
            get
            {
                var __ret = __Internal.GetGradientPerturbAmp((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetGradientPerturbAmp((__Instance + __PointerAdjustment), value);
            }
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class ComponentCreate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Function.__Internal m_create;

            [FieldOffset(64)]
            internal global::Std.Function.__Internal m_isSame;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentCreate@acid@@QEAA@AEBU01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentCreate@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ComponentCreate@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ComponentCreate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ComponentCreate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.ComponentCreate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ComponentCreate(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ComponentCreate __CreateInstance(global::AcidSharp.ComponentCreate.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ComponentCreate(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ComponentCreate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ComponentCreate.__Internal));
            global::AcidSharp.ComponentCreate.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ComponentCreate(global::AcidSharp.ComponentCreate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ComponentCreate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ComponentCreate(global::AcidSharp.ComponentCreate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ComponentCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public ComponentCreate()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ComponentCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ComponentCreate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    /// <summary>A class that holds registerd components.</summary>
    public unsafe partial class ComponentRegister : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_acid_S_ComponentCreate___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_components;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentRegister@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentRegister@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ComponentRegister@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterComponent@ComponentRegister@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterComponent(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateComponent@ComponentRegister@acid@@QEAAPEAVIComponent@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr CreateComponent(global::System.IntPtr instance, global::System.IntPtr name);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ComponentRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ComponentRegister>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.ComponentRegister __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ComponentRegister(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ComponentRegister __CreateInstance(global::AcidSharp.ComponentRegister.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ComponentRegister(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ComponentRegister.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ComponentRegister.__Internal));
            global::AcidSharp.ComponentRegister.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ComponentRegister(global::AcidSharp.ComponentRegister.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ComponentRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new component register.</summary>
        public ComponentRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ComponentRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ComponentRegister(global::AcidSharp.ComponentRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ComponentRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ComponentRegister __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Deregisters a component.</summary>
        /// <param name="name">The components name.</param>
        public bool DeregisterComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.DeregisterComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Creates a new component from the register.</summary>
        /// <param name="name">The component name to create.</param>
        public global::AcidSharp.IComponent CreateComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::AcidSharp.IComponent __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.IComponent.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.IComponent) global::AcidSharp.IComponent.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.IComponent.__CreateInstance(__ret);
            return __result0;
        }
    }
}

namespace AcidSharp
{
    /// <summary>Represents the region of space in the modeled world that may appear on the screen.</summary>
    public unsafe partial class Frustum : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Array.__Internalc__N_std_S_array____N_std_S_array__f_Vk4_Vk6 m_frustum;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Frustum@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Frustum@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Frustum@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Frustum@acid@@QEAAXAEBVMatrix4@2@0@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr view, global::System.IntPtr projection);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PointInFrustum@Frustum@acid@@QEBA_NAEBVVector3@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PointInFrustum(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SphereInFrustum@Frustum@acid@@QEBA_NAEBVVector3@2@AEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SphereInFrustum(global::System.IntPtr instance, global::System.IntPtr position, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CubeInFrustum@Frustum@acid@@QEBA_NAEBVVector3@2@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CubeInFrustum(global::System.IntPtr instance, global::System.IntPtr min, global::System.IntPtr max);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Frustum> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Frustum>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Frustum __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Frustum(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Frustum __CreateInstance(global::AcidSharp.Frustum.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Frustum(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Frustum.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Frustum.__Internal));
            *(global::AcidSharp.Frustum.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Frustum(global::AcidSharp.Frustum.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Frustum(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new frustum.</summary>
        public Frustum()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Frustum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Frustum(global::AcidSharp.Frustum _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Frustum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.Frustum.__Internal*) __Instance) = *((global::AcidSharp.Frustum.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Frustum __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates a frustum from the view and projection matrix.</summary>
        /// <param name="view">The view matrix.</param>
        /// <param name="projection">The projection matrix.</param>
        public void Update(global::AcidSharp.Matrix4 view, global::AcidSharp.Matrix4 projection)
        {
            if (ReferenceEquals(view, null))
                throw new global::System.ArgumentNullException("view", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = view.__Instance;
            if (ReferenceEquals(projection, null))
                throw new global::System.ArgumentNullException("projection", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = projection.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Is the point contained in the frustum?</summary>
        /// <param name="position">The points position.</param>
        public bool PointInFrustum(global::AcidSharp.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = __Internal.PointInFrustum((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Is the sphere contained in the frustum?</summary>
        /// <param name="position">The points position.</param>
        /// <param name="radius">The spheres radius.</param>
        public bool SphereInFrustum(global::AcidSharp.Vector3 position, float radius)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = __Internal.SphereInFrustum((__Instance + __PointerAdjustment), __arg0, radius);
            return __ret;
        }

        /// <summary>Is the cube contained partially in the frustum?</summary>
        /// <param name="min">The point 1st position.</param>
        /// <param name="max">The point 2nd position.</param>
        public bool CubeInFrustum(global::AcidSharp.Vector3 min, global::AcidSharp.Vector3 max)
        {
            if (ReferenceEquals(min, null))
                throw new global::System.ArgumentNullException("min", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = min.__Instance;
            if (ReferenceEquals(max, null))
                throw new global::System.ArgumentNullException("max", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = max.__Instance;
            var __ret = __Internal.CubeInFrustum((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }
    }
}

namespace AcidSharp
{
    public unsafe partial class Collider
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Collider> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Collider>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Collider __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Collider(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Collider __CreateInstance(global::AcidSharp.Collider.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Collider(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Collider.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Collider.__Internal));
            *(global::AcidSharp.Collider.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Collider(global::AcidSharp.Collider.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Collider(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>A data structure that stores objects with a notion of space.</summary>
    public unsafe abstract partial class ISpatialStructure : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpatialStructure;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpatialStructure@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpatialStructure@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ISpatialStructure> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ISpatialStructure>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.ISpatialStructure __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ISpatialStructureInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ISpatialStructure __CreateInstance(global::AcidSharp.ISpatialStructure.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ISpatialStructureInternal(native, skipVTables);
        }

        protected ISpatialStructure(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected ISpatialStructure(global::AcidSharp.ISpatialStructure _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ISpatialStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.ISpatialStructure");
        }

        protected ISpatialStructure()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ISpatialStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.ISpatialStructure");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ISpatialStructure __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.ISpatialStructure.__Internal*) __Instance)->vfptr_ISpatialStructure = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds a new object to the spatial structure.</summary>
        /// <param name="object">The object to add.</param>
        public abstract void Add(global::AcidSharp.GameObject targetObject);

        /// <summary>Removes an object from the spatial structure.</summary>
        /// <param name="object">The object to remove.</param>
        public abstract bool Remove(global::AcidSharp.GameObject targetObject);

        /// <summary>Removes all objects from the spatial structure..</summary>
        public abstract void Clear();

        /// <summary>If the structure contains the object.</summary>
        /// <param name="object">The object to check for.</param>
        public abstract bool Contains(global::AcidSharp.GameObject targetObject);

        /// <summary>Gets the size of this structure.</summary>
        public abstract uint Size
        {
            get;
        }

        #region Virtual table interop

        // void Add(GameObject *object) = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _AddDelegateInstance;

        private static void _AddDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::AcidSharp.GameObject) global::AcidSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = global::AcidSharp.GameObject.__CreateInstance(targetObject);
            __target.Add(__result0);
        }

        // bool Remove(GameObject *object) = 0
        private static global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr _RemoveDelegateInstance;

        private static bool _RemoveDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::AcidSharp.GameObject) global::AcidSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = global::AcidSharp.GameObject.__CreateInstance(targetObject);
            var __ret = __target.Remove(__result0);
            return __ret;
        }

        // void Clear() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // uint32_t GetSize() = 0
        private static global::AcidSharp.Delegates.Func_uint_IntPtr _GetSizeDelegateInstance;

        private static uint _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        // bool Contains(GameObject *object) = 0
        private static global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr _ContainsDelegateInstance;

        private static bool _ContainsDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::AcidSharp.GameObject) global::AcidSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = global::AcidSharp.GameObject.__CreateInstance(targetObject);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _AddDelegateInstance += _AddDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AddDelegateInstance).ToPointer();
                _RemoveDelegateInstance += _RemoveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RemoveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
                _ContainsDelegateInstance += _ContainsDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ContainsDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                *(void**) (vfptr0 + 64) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ISpatialStructureInternal : global::AcidSharp.ISpatialStructure, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.ISpatialStructure.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ISpatialStructure.__Internal));
            *(global::AcidSharp.ISpatialStructure.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ISpatialStructureInternal(global::AcidSharp.ISpatialStructure.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ISpatialStructureInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Adds a new object to the spatial structure.</summary>
        /// <param name="object">The object to add.</param>
        public override void Add(global::AcidSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___AddDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            ___AddDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Removes an object from the spatial structure.</summary>
        /// <param name="object">The object to remove.</param>
        public override bool Remove(global::AcidSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RemoveDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___RemoveDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Removes all objects from the spatial structure..</summary>
        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>If the structure contains the object.</summary>
        /// <param name="object">The object to check for.</param>
        public override bool Contains(global::AcidSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
            var ___ContainsDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___ContainsDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the size of this structure.</summary>
        public override uint Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetSizeDelegate = (global::AcidSharp.Delegates.Func_uint_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_uint_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A class that represents a structured game object.</summary>
    public unsafe partial class GameObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::AcidSharp.Transform.__Internal m_transform;

            [FieldOffset(72)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IComponent___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_components;

            [FieldOffset(96)]
            internal global::System.IntPtr m_structure;

            [FieldOffset(104)]
            internal global::System.IntPtr m_parent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GameObject@acid@@QEAA@AEBVTransform@1@PEAVISpatialStructure@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr transform, global::System.IntPtr structure);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GameObject@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVTransform@1@PEAVISpatialStructure@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filepath, global::System.IntPtr transform, global::System.IntPtr structure);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GameObject@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1GameObject@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@GameObject@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddComponent@GameObject@acid@@QEAAPEAVIComponent@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr AddComponent(global::System.IntPtr instance, global::System.IntPtr component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveComponent@GameObject@acid@@QEAA_NPEAVIComponent@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveComponent(global::System.IntPtr instance, global::System.IntPtr component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveComponent@GameObject@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveComponent_1(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StructureRemove@GameObject@acid@@QEAAXXZ")]
            internal static extern void StructureRemove(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@GameObject@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@GameObject@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStructure@GameObject@acid@@QEBAPEAVISpatialStructure@2@XZ")]
            internal static extern global::System.IntPtr GetStructure(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStructure@GameObject@acid@@QEAAXPEAVISpatialStructure@2@@Z")]
            internal static extern void SetStructure(global::System.IntPtr instance, global::System.IntPtr structure);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@GameObject@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetParent@GameObject@acid@@QEAAXPEAV12@@Z")]
            internal static extern void SetParent(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComponentCount@GameObject@acid@@QEBAIXZ")]
            internal static extern uint GetComponentCount(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransform@GameObject@acid@@QEAAAEAVTransform@2@XZ")]
            internal static extern global::System.IntPtr GetTransform(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.GameObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.GameObject>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.GameObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.GameObject(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.GameObject __CreateInstance(global::AcidSharp.GameObject.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.GameObject(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.GameObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.GameObject.__Internal));
            global::AcidSharp.GameObject.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private GameObject(global::AcidSharp.GameObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GameObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new Game Object and store it into a structure.</summary>
        /// <param name="transform">The objects initial world position, rotation, and scale.</param>
        /// <param name="structure">The structure to store the object into, if null it will be stored in the scenes structure.</param>
        public GameObject(global::AcidSharp.Transform transform, global::AcidSharp.ISpatialStructure structure = null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            var __arg1 = ReferenceEquals(structure, null) ? global::System.IntPtr.Zero : structure.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Creates a new Game Object and store it into a structure.</summary>
        /// <param name="filepath">The file to load the component data from.</param>
        /// <param name="transform">The objects initial world position, rotation, and scale.</param>
        /// <param name="structure">The structure to store the object into, if null it will be stored in the scenes structure.</param>
        public GameObject(string filepath, global::AcidSharp.Transform transform, global::AcidSharp.ISpatialStructure structure = null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = transform.__Instance;
            var __arg2 = ReferenceEquals(structure, null) ? global::System.IntPtr.Zero : structure.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public GameObject(global::AcidSharp.GameObject _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.GameObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        /// <summary>Adds a component to this game object.</summary>
        /// <param name="component">The component to add.</param>
        public global::AcidSharp.IComponent AddComponent(global::AcidSharp.IComponent component)
        {
            var __arg0 = ReferenceEquals(component, null) ? global::System.IntPtr.Zero : component.__Instance;
            var __ret = __Internal.AddComponent((__Instance + __PointerAdjustment), __arg0);
            global::AcidSharp.IComponent __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.IComponent.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.IComponent) global::AcidSharp.IComponent.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.IComponent.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Removes a component from this game object.</summary>
        /// <param name="component">The component to remove.</param>
        public bool RemoveComponent(global::AcidSharp.IComponent component)
        {
            var __arg0 = ReferenceEquals(component, null) ? global::System.IntPtr.Zero : component.__Instance;
            var __ret = __Internal.RemoveComponent((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Removes a component from this game object.</summary>
        /// <param name="name">The name of the component to remove.</param>
        public bool RemoveComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.RemoveComponent_1((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public void StructureRemove()
        {
            __Internal.StructureRemove((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::AcidSharp.GameObject(global::AcidSharp.Transform transform)
        {
            return new global::AcidSharp.GameObject(transform);
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::AcidSharp.ISpatialStructure Structure
        {
            get
            {
                var __ret = __Internal.GetStructure((__Instance + __PointerAdjustment));
                global::AcidSharp.ISpatialStructure __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.ISpatialStructure.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.ISpatialStructure) global::AcidSharp.ISpatialStructure.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.ISpatialStructure.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetStructure((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.GameObject Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::AcidSharp.GameObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.GameObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.GameObject) global::AcidSharp.GameObject.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.GameObject.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetParent((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the count of components attached to this Game Object.</summary>
        public uint ComponentCount
        {
            get
            {
                var __ret = __Internal.GetComponentCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::AcidSharp.Transform Transform
        {
            get
            {
                var __ret = __Internal.GetTransform((__Instance + __PointerAdjustment));
                global::AcidSharp.Transform __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.Transform.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.Transform) global::AcidSharp.Transform.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.Transform.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Class that represents a entity prefab.</summary>
    public unsafe partial class PrefabObject : global::AcidSharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IFile___N_std_S_default_delete__S0_ m_file;

            [FieldOffset(48)]
            internal global::Std.SharedPtr.__Internal m_parent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PrefabObject@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PrefabObject@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PrefabObject@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@PrefabObject@acid@@QEAAXAEBVGameObject@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr gameObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Save@PrefabObject@acid@@QEAAXXZ")]
            internal static extern void Save(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.PrefabObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.PrefabObject(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.PrefabObject __CreateInstance(global::AcidSharp.PrefabObject.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.PrefabObject(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.PrefabObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.PrefabObject.__Internal));
            global::AcidSharp.PrefabObject.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PrefabObject(global::AcidSharp.PrefabObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PrefabObject(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new entity prefab.</summary>
        /// <param name="filename">The file name.</param>
        public PrefabObject(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.PrefabObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "AcidSharp.PrefabObject");
        }

        public PrefabObject(global::AcidSharp.PrefabObject _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.PrefabObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.PrefabObject");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.PrefabObject.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Write(global::AcidSharp.GameObject gameObject)
        {
            if (ReferenceEquals(gameObject, null))
                throw new global::System.ArgumentNullException("gameObject", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = gameObject.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public void Save()
        {
            __Internal.Save((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::AcidSharp.PrefabObject(string filename)
        {
            return new global::AcidSharp.PrefabObject(filename);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.PrefabObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class Force : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Vector3.__Internal m_force;

            [FieldOffset(12)]
            internal byte m_neverExpires;

            [FieldOffset(16)]
            internal float m_timeLeft;

            [FieldOffset(20)]
            internal global::AcidSharp.Vector3.__Internal m_position;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Force@acid@@QEAA@AEBVVector3@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr force, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Force@acid@@QEAA@AEBVVector3@1@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr force, float time, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Force@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Force@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Force@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetForce@Force@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetForce(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetForce@Force@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetForce(global::System.IntPtr instance, global::System.IntPtr force);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeLeft@Force@acid@@QEBAMXZ")]
            internal static extern float GetTimeLeft(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTimeLeft@Force@acid@@QEAAXM@Z")]
            internal static extern void SetTimeLeft(global::System.IntPtr instance, float timeLeft);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Force@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Force@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsExpired@Force@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsExpired(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Force> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Force>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Force __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Force(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Force __CreateInstance(global::AcidSharp.Force.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Force(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Force.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Force.__Internal));
            global::AcidSharp.Force.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Force(global::AcidSharp.Force.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Force(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Force(global::AcidSharp.Vector3 force, global::AcidSharp.Vector3 position)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Force.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(force, null))
                throw new global::System.ArgumentNullException("force", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = force.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public Force(global::AcidSharp.Vector3 force, float time, global::AcidSharp.Vector3 position)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Force.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(force, null))
                throw new global::System.ArgumentNullException("force", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = force.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, time, __arg2);
        }

        public Force(global::AcidSharp.Force _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Force.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Force(global::AcidSharp.Vector3 force) : this(force, global::AcidSharp.Vector3.Zero)
        {
        }

        public Force(global::AcidSharp.Vector3 force, float time) : this(force, time, global::AcidSharp.Vector3.Zero)
        {
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Force __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::AcidSharp.Force(global::AcidSharp.Vector3 force)
        {
            return new global::AcidSharp.Force(force);
        }

        public global::AcidSharp.Vector3 Force
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetForce((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetForce((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float TimeLeft
        {
            get
            {
                var __ret = __Internal.GetTimeLeft((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetTimeLeft((__Instance + __PointerAdjustment), value);
            }
        }

        public global::AcidSharp.Vector3 Position
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool IsExpired
        {
            get
            {
                var __ret = __Internal.IsExpired((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>Holds a 3 dimensional ray.</summary>
    public unsafe partial class Ray : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 348)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_useMouse;

            [FieldOffset(4)]
            internal global::AcidSharp.Vector2.__Internal m_screenStart;

            [FieldOffset(12)]
            internal global::AcidSharp.Matrix4.__Internal m_viewMatrix;

            [FieldOffset(76)]
            internal global::AcidSharp.Matrix4.__Internal m_projectionMatrix;

            [FieldOffset(140)]
            internal global::AcidSharp.Vector2.__Internal m_normalizedCoords;

            [FieldOffset(148)]
            internal global::AcidSharp.Vector4.__Internal m_clipCoords;

            [FieldOffset(164)]
            internal global::AcidSharp.Vector4.__Internal m_eyeCoords;

            [FieldOffset(180)]
            internal global::AcidSharp.Matrix4.__Internal m_invertedProjection;

            [FieldOffset(244)]
            internal global::AcidSharp.Matrix4.__Internal m_invertedView;

            [FieldOffset(308)]
            internal global::AcidSharp.Vector4.__Internal m_rayWorld;

            [FieldOffset(324)]
            internal global::AcidSharp.Vector3.__Internal m_origin;

            [FieldOffset(336)]
            internal global::AcidSharp.Vector3.__Internal m_currentRay;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Ray@acid@@QEAA@AEB_NAEBVVector2@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool useMouse, global::System.IntPtr screenStart);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Ray@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Ray@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Ray@acid@@QEAAXAEBVVector3@2@AEBVVector2@2@AEBVMatrix4@2@2@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr currentPosition, global::System.IntPtr mousePosition, global::System.IntPtr viewMatrix, global::System.IntPtr projectionMatrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPointOnRay@Ray@acid@@QEBA?AVVector3@2@AEBM@Z")]
            internal static extern void GetPointOnRay(global::System.IntPtr instance, global::System.IntPtr @return, float distance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ConvertToScreenSpace@Ray@acid@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void ConvertToScreenSpace(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOrigin@Ray@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetOrigin(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentRay@Ray@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetCurrentRay(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Ray> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.Ray>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.Ray __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Ray(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Ray __CreateInstance(global::AcidSharp.Ray.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Ray(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Ray.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Ray.__Internal));
            global::AcidSharp.Ray.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Ray(global::AcidSharp.Ray.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Ray(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new 3D ray.</summary>
        /// <param name="useMouse">If the ray will use the mouse coords or to start from screenStart.</param>
        /// <param name="screenStart">If useMouse is false then this will be used as the rays start.</param>
        public Ray(bool useMouse, global::AcidSharp.Vector2 screenStart)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Ray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(screenStart, null))
                throw new global::System.ArgumentNullException("screenStart", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = screenStart.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), useMouse, __arg1);
        }

        public Ray(global::AcidSharp.Ray _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Ray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.Ray __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the ray to a new position.</summary>
        /// <param name="currentPosition">The new position.</param>
        /// <param name="currentPosition">The mouses xy screen space position.</param>
        /// <param name="viewMatrix">The cameras view matrix.</param>
        /// <param name="projectionMatrix">The projection view matrix.</param>
        public void Update(global::AcidSharp.Vector3 currentPosition, global::AcidSharp.Vector2 mousePosition, global::AcidSharp.Matrix4 viewMatrix, global::AcidSharp.Matrix4 projectionMatrix)
        {
            if (ReferenceEquals(currentPosition, null))
                throw new global::System.ArgumentNullException("currentPosition", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = currentPosition.__Instance;
            if (ReferenceEquals(mousePosition, null))
                throw new global::System.ArgumentNullException("mousePosition", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = mousePosition.__Instance;
            if (ReferenceEquals(viewMatrix, null))
                throw new global::System.ArgumentNullException("viewMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = viewMatrix.__Instance;
            if (ReferenceEquals(projectionMatrix, null))
                throw new global::System.ArgumentNullException("projectionMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = projectionMatrix.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Gets a point on the ray.</summary>
        /// <param name="distance">Distance down the ray to sample.</param>
        public global::AcidSharp.Vector3 GetPointOnRay(float distance)
        {
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.GetPointOnRay((__Instance + __PointerAdjustment), new IntPtr(&__ret), distance);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Converts a position from world space to screen space.</summary>
        /// <param name="position">The position to convert.</param>
        public global::AcidSharp.Vector3 ConvertToScreenSpace(global::AcidSharp.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = new global::AcidSharp.Vector3.__Internal();
            __Internal.ConvertToScreenSpace((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::AcidSharp.Vector3.__CreateInstance(__ret);
        }

        public global::AcidSharp.Vector3 Origin
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetOrigin((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }

        public global::AcidSharp.Vector3 CurrentRay
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetCurrentRay((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>This class is used throughout the engine wherever the camera is involved, so that the engine doesn't rely at all on the camera's implementation.</summary>
    public unsafe abstract partial class ICamera : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ICamera;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ICamera@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ICamera@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ICamera> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ICamera>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.ICamera __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ICameraInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ICamera __CreateInstance(global::AcidSharp.ICamera.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ICameraInternal(native, skipVTables);
        }

        protected ICamera(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected ICamera()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ICamera.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.ICamera");
        }

        protected ICamera(global::AcidSharp.ICamera _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ICamera.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.ICamera");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ICamera __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.ICamera.__Internal*) __Instance)->vfptr_ICamera = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Checks inputs and carries out smooth camera movement. Called before every frame.</summary>
        public abstract void Update();

        /// <summary>Prepares the camera for the reflection render pass.</summary>
        /// <param name="height">The height of the horizontal plane to be reflected over.</param>
        public abstract void ReflectView(float height);

        /// <summary>Gets the distance of the near pane of the view frustum.</summary>
        public abstract float NearPlane
        {
            get;
        }

        /// <summary>Gets the distance of the view frustum's far plane.</summary>
        public abstract float FarPlane
        {
            get;
        }

        /// <summary>Gets the field of view angle for the view frustum.</summary>
        public abstract float Fov
        {
            get;
        }

        /// <summary>Gets the view frustum created by the current camera position and rotation.</summary>
        public abstract global::AcidSharp.Frustum ViewFrustum
        {
            get;
        }

        /// <summary>Gets the ray that extends from the cameras position though the screen.</summary>
        public abstract global::AcidSharp.Ray ViewRay
        {
            get;
        }

        /// <summary>Gets the view matrix created by the current camera position and rotation.</summary>
        public abstract global::AcidSharp.Matrix4 ViewMatrix
        {
            get;
        }

        /// <summary>Gets the projection matrix used in the current scene render.</summary>
        public abstract global::AcidSharp.Matrix4 ProjectionMatrix
        {
            get;
        }

        /// <summary>Gets the cameras 3D position in the world.</summary>
        public abstract global::AcidSharp.Vector3 Position
        {
            get;
        }

        /// <summary>Gets the cameras 3D velocity in the world.</summary>
        public abstract global::AcidSharp.Vector3 Velocity
        {
            get;
        }

        /// <summary>Gets the cameras 3D rotation in the world, where x=pitch, y=yaw, z=roll.</summary>
        public abstract global::AcidSharp.Vector3 Rotation
        {
            get;
        }

        #region Virtual table interop

        // void Update() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void ReflectView(const float &height) = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_float _ReflectViewDelegateInstance;

        private static void _ReflectViewDelegateHook(global::System.IntPtr instance, float height)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ReflectView(height);
        }

        // float GetNearPlane() const = 0
        private static global::AcidSharp.Delegates.Func_float_IntPtr _GetNearPlaneDelegateInstance;

        private static float _GetNearPlaneDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.NearPlane;
            return __ret;
        }

        // float GetFarPlane() const = 0
        private static global::AcidSharp.Delegates.Func_float_IntPtr _GetFarPlaneDelegateInstance;

        private static float _GetFarPlaneDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.FarPlane;
            return __ret;
        }

        // float GetFov() const = 0
        private static global::AcidSharp.Delegates.Func_float_IntPtr _GetFovDelegateInstance;

        private static float _GetFovDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Fov;
            return __ret;
        }

        // Frustum GetViewFrustum() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetViewFrustumDelegateInstance;

        private static void _GetViewFrustumDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ViewFrustum;
            *(global::AcidSharp.Frustum.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Frustum.__Internal() : *(global::AcidSharp.Frustum.__Internal*) __ret.__Instance;
        }

        // Ray GetViewRay() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetViewRayDelegateInstance;

        private static void _GetViewRayDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ViewRay;
            *(global::AcidSharp.Ray.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Ray.__Internal() : *(global::AcidSharp.Ray.__Internal*) __ret.__Instance;
        }

        // Matrix4 GetViewMatrix() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetViewMatrixDelegateInstance;

        private static void _GetViewMatrixDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ViewMatrix;
            *(global::AcidSharp.Matrix4.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Matrix4.__Internal() : *(global::AcidSharp.Matrix4.__Internal*) __ret.__Instance;
        }

        // Matrix4 GetProjectionMatrix() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetProjectionMatrixDelegateInstance;

        private static void _GetProjectionMatrixDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ProjectionMatrix;
            *(global::AcidSharp.Matrix4.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Matrix4.__Internal() : *(global::AcidSharp.Matrix4.__Internal*) __ret.__Instance;
        }

        // Vector3 GetPosition() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::AcidSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Vector3.__Internal() : *(global::AcidSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetVelocity() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetVelocityDelegateInstance;

        private static void _GetVelocityDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Velocity;
            *(global::AcidSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Vector3.__Internal() : *(global::AcidSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetRotation() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetRotationDelegateInstance;

        private static void _GetRotationDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Rotation;
            *(global::AcidSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Vector3.__Internal() : *(global::AcidSharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[12];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _ReflectViewDelegateInstance += _ReflectViewDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_ReflectViewDelegateInstance).ToPointer();
                _GetNearPlaneDelegateInstance += _GetNearPlaneDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetNearPlaneDelegateInstance).ToPointer();
                _GetFarPlaneDelegateInstance += _GetFarPlaneDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFarPlaneDelegateInstance).ToPointer();
                _GetFovDelegateInstance += _GetFovDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetFovDelegateInstance).ToPointer();
                _GetViewFrustumDelegateInstance += _GetViewFrustumDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetViewFrustumDelegateInstance).ToPointer();
                _GetViewRayDelegateInstance += _GetViewRayDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetViewRayDelegateInstance).ToPointer();
                _GetViewMatrixDelegateInstance += _GetViewMatrixDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetViewMatrixDelegateInstance).ToPointer();
                _GetProjectionMatrixDelegateInstance += _GetProjectionMatrixDelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetProjectionMatrixDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _GetVelocityDelegateInstance += _GetVelocityDelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetVelocityDelegateInstance).ToPointer();
                _GetRotationDelegateInstance += _GetRotationDelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetRotationDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(13 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
                *(void**) (vfptr0 + 56) = _Thunks[6];
                *(void**) (vfptr0 + 64) = _Thunks[7];
                *(void**) (vfptr0 + 72) = _Thunks[8];
                *(void**) (vfptr0 + 80) = _Thunks[9];
                *(void**) (vfptr0 + 88) = _Thunks[10];
                *(void**) (vfptr0 + 96) = _Thunks[11];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ICameraInternal : global::AcidSharp.ICamera, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.ICamera.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ICamera.__Internal));
            *(global::AcidSharp.ICamera.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ICameraInternal(global::AcidSharp.ICamera.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ICameraInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Checks inputs and carries out smooth camera movement. Called before every frame.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Prepares the camera for the reflection render pass.</summary>
        /// <param name="height">The height of the horizontal plane to be reflected over.</param>
        public override void ReflectView(float height)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___ReflectViewDelegate = (global::AcidSharp.Delegates.Action_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_float));
            ___ReflectViewDelegate((__Instance + __PointerAdjustment), height);
        }

        /// <summary>Gets the distance of the near pane of the view frustum.</summary>
        public override float NearPlane
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___GetNearPlaneDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetNearPlaneDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the distance of the view frustum's far plane.</summary>
        public override float FarPlane
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFarPlaneDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetFarPlaneDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the field of view angle for the view frustum.</summary>
        public override float Fov
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetFovDelegate = (global::AcidSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetFovDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the view frustum created by the current camera position and rotation.</summary>
        public override global::AcidSharp.Frustum ViewFrustum
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetViewFrustumDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Frustum.__Internal();
                ___GetViewFrustumDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Frustum.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the ray that extends from the cameras position though the screen.</summary>
        public override global::AcidSharp.Ray ViewRay
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___GetViewRayDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Ray.__Internal();
                ___GetViewRayDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Ray.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the view matrix created by the current camera position and rotation.</summary>
        public override global::AcidSharp.Matrix4 ViewMatrix
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___GetViewMatrixDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                ___GetViewMatrixDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the projection matrix used in the current scene render.</summary>
        public override global::AcidSharp.Matrix4 ProjectionMatrix
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
                var ___GetProjectionMatrixDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Matrix4.__Internal();
                ___GetProjectionMatrixDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the cameras 3D position in the world.</summary>
        public override global::AcidSharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
                var ___GetPositionDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the cameras 3D velocity in the world.</summary>
        public override global::AcidSharp.Vector3 Velocity
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
                var ___GetVelocityDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Vector3.__Internal();
                ___GetVelocityDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the cameras 3D rotation in the world, where x=pitch, y=yaw, z=roll.</summary>
        public override global::AcidSharp.Vector3 Rotation
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
                var ___GetRotationDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Vector3.__Internal();
                ___GetRotationDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A rectangle made of a position and dimension.</summary>
    public unsafe partial class UiBound : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.Vector2.__Internal m_position;

            [FieldOffset(8)]
            internal global::AcidSharp.Vector2.__Internal m_reference;

            [FieldOffset(16)]
            internal byte m_aspectPosition;

            [FieldOffset(17)]
            internal byte m_aspectSize;

            [FieldOffset(20)]
            internal global::AcidSharp.Vector2.__Internal m_dimensions;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiBound@acid@@QEAA@AEBVVector2@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N20@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr reference, bool aspectPosition, bool aspectSize, global::System.IntPtr dimensions);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiBound@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiBound@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindPivot@UiBound@acid@@SA?AVVector2@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void FindPivot(global::System.IntPtr @return, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAspectPosition@UiBound@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetAspectPosition(global::System.IntPtr instance, bool aspectPosition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAspectSize@UiBound@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetAspectSize(global::System.IntPtr instance, bool aspectSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8UiBound@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9UiBound@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@UiBound@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@UiBound@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetReference@UiBound@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetReference(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetReference@UiBound@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetReference(global::System.IntPtr instance, global::System.IntPtr reference);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDimensions@UiBound@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetDimensions(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDimensions@UiBound@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetDimensions(global::System.IntPtr instance, global::System.IntPtr dimensions);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAspectPosition@UiBound@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAspectPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAspectSize@UiBound@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAspectSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UiBound> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UiBound>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.UiBound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.UiBound(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.UiBound __CreateInstance(global::AcidSharp.UiBound.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.UiBound(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.UiBound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiBound.__Internal));
            global::AcidSharp.UiBound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiBound(global::AcidSharp.UiBound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiBound(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for rectangle.</summary>
        /// <param name="position">The object screen position.</param>
        /// <param name="reference">The reference pivot vertex (TopLeft, TopCentre, TopRight, CentreLeft, Centre, CentreRight, BottomLeft, BottomCentre, BottomRight).</param>
        /// <param name="aspectPosition">The if the x position will change with display width.</param>
        /// <param name="aspectSize">The if the width will scale with display width.</param>
        /// <param name="dimensions">The object dimensions.</param>
        public UiBound(global::AcidSharp.Vector2 position, string reference, bool aspectPosition, bool aspectSize, global::AcidSharp.Vector2 dimensions)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiBound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(reference, __allocator1);
            var __arg1 = __basicString1.__Instance;
            if (ReferenceEquals(dimensions, null))
                throw new global::System.ArgumentNullException("dimensions", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = dimensions.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, aspectPosition, aspectSize, __arg4);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        /// <summary>Creates a new rectangle.</summary>
        /// <param name="source">Creates this rectangle out of a existing one.</param>
        public UiBound(global::AcidSharp.UiBound source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiBound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for rectangle.</summary>
        /// <param name="position">The object screen position.</param>
        /// <param name="reference">The reference pivot vertex (TopLeft, TopCentre, TopRight, CentreLeft, Centre, CentreRight, BottomLeft, BottomCentre, BottomRight).</param>
        /// <param name="aspectPosition">The if the x position will change with display width.</param>
        /// <param name="aspectSize">The if the width will scale with display width.</param>
        /// <param name="dimensions">The object dimensions.</param>
        public UiBound(global::AcidSharp.Vector2 position) : this(position, "TopLeft", true, true, new global::AcidSharp.Vector2(1.0F, 1.0F))
        {
        }

        /// <summary>Constructor for rectangle.</summary>
        /// <param name="position">The object screen position.</param>
        /// <param name="reference">The reference pivot vertex (TopLeft, TopCentre, TopRight, CentreLeft, Centre, CentreRight, BottomLeft, BottomCentre, BottomRight).</param>
        /// <param name="aspectPosition">The if the x position will change with display width.</param>
        /// <param name="aspectSize">The if the width will scale with display width.</param>
        /// <param name="dimensions">The object dimensions.</param>
        public UiBound(global::AcidSharp.Vector2 position, string reference, bool aspectPosition = true, bool aspectSize = true) : this(position, reference, aspectPosition, aspectSize, new global::AcidSharp.Vector2(1.0F, 1.0F))
        {
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.UiBound __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void SetAspectPosition(bool aspectPosition)
        {
            __Internal.SetAspectPosition((__Instance + __PointerAdjustment), aspectPosition);
        }

        public void SetAspectSize(bool aspectSize)
        {
            __Internal.SetAspectSize((__Instance + __PointerAdjustment), aspectSize);
        }

        public static bool operator ==(global::AcidSharp.UiBound __op, global::AcidSharp.UiBound other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::AcidSharp.UiBound;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::AcidSharp.UiBound.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::AcidSharp.UiBound __op, global::AcidSharp.UiBound other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static implicit operator global::AcidSharp.UiBound(global::AcidSharp.Vector2 position)
        {
            return new global::AcidSharp.UiBound(position);
        }

        public static global::AcidSharp.Vector2 FindPivot(string key)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::AcidSharp.Vector2.__Internal();
            __Internal.FindPivot(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::AcidSharp.Vector2.__CreateInstance(__ret);
        }

        public global::AcidSharp.Vector2 MPosition
        {
            get
            {
                return global::AcidSharp.Vector2.__CreateInstance(new global::System.IntPtr(&((global::AcidSharp.UiBound.__Internal*) __Instance)->m_position));
            }

            set
            {
                ((global::AcidSharp.UiBound.__Internal*)__Instance)->m_position = ReferenceEquals(value, null) ? new global::AcidSharp.Vector2.__Internal() : *(global::AcidSharp.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::AcidSharp.Vector2 MReference
        {
            get
            {
                return global::AcidSharp.Vector2.__CreateInstance(new global::System.IntPtr(&((global::AcidSharp.UiBound.__Internal*) __Instance)->m_reference));
            }

            set
            {
                ((global::AcidSharp.UiBound.__Internal*)__Instance)->m_reference = ReferenceEquals(value, null) ? new global::AcidSharp.Vector2.__Internal() : *(global::AcidSharp.Vector2.__Internal*) value.__Instance;
            }
        }

        public bool MAspectPosition
        {
            get
            {
                return ((global::AcidSharp.UiBound.__Internal*) __Instance)->m_aspectPosition != 0;
            }

            set
            {
                ((global::AcidSharp.UiBound.__Internal*)__Instance)->m_aspectPosition = (byte) (value ? 1 : 0);
            }
        }

        public bool MAspectSize
        {
            get
            {
                return ((global::AcidSharp.UiBound.__Internal*) __Instance)->m_aspectSize != 0;
            }

            set
            {
                ((global::AcidSharp.UiBound.__Internal*)__Instance)->m_aspectSize = (byte) (value ? 1 : 0);
            }
        }

        public global::AcidSharp.Vector2 MDimensions
        {
            get
            {
                return global::AcidSharp.Vector2.__CreateInstance(new global::System.IntPtr(&((global::AcidSharp.UiBound.__Internal*) __Instance)->m_dimensions));
            }

            set
            {
                ((global::AcidSharp.UiBound.__Internal*)__Instance)->m_dimensions = ReferenceEquals(value, null) ? new global::AcidSharp.Vector2.__Internal() : *(global::AcidSharp.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::AcidSharp.Vector2 Position
        {
            get
            {
                var __ret = new global::AcidSharp.Vector2.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector2 Reference
        {
            get
            {
                var __ret = new global::AcidSharp.Vector2.__Internal();
                __Internal.GetReference((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetReference((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector2 Dimensions
        {
            get
            {
                var __ret = new global::AcidSharp.Vector2.__Internal();
                __Internal.GetDimensions((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetDimensions((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool IsAspectPosition
        {
            get
            {
                var __ret = __Internal.IsAspectPosition((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsAspectSize
        {
            get
            {
                var __ret = __Internal.IsAspectSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A representation of a object this is rendered to a screen. This object is contained in a parent and has children. The screen object has a few values that allow for it to be positioned and scaled, along with other variables that are used when rendering. This class can be extended to create a representation for GUI textures, fonts, etc.</summary>
    public unsafe partial class UiObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 208)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(40)]
            internal byte m_visible;

            [FieldOffset(44)]
            internal global::AcidSharp.UiBound.__Internal m_rectangle;

            [FieldOffset(72)]
            internal global::AcidSharp.Vector4.__Internal m_scissor;

            [FieldOffset(88)]
            internal global::AcidSharp.Vector2.__Internal m_positionOffset;

            [FieldOffset(96)]
            internal global::AcidSharp.Vector4.__Internal m_screenTransform;

            [FieldOffset(112)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_alphaDriver;

            [FieldOffset(120)]
            internal float m_alpha;

            [FieldOffset(128)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_scaleDriver;

            [FieldOffset(136)]
            internal float m_scale;

            [FieldOffset(144)]
            internal global::Std.Function.__Internal m_actionClick;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiObject@acid@@QEAA@PEAV01@AEBVUiBound@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr rectangle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiObject@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@UiObject@acid@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveChild@UiObject@acid@@QEAA_NPEAV12@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetVisible@UiObject@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetVisible(global::System.IntPtr instance, bool visible);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAlphaDriver@UiObject@acid@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetAlphaDriver(global::System.IntPtr instance, global::System.IntPtr alphaDriver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScaleDriver@UiObject@acid@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetScaleDriver(global::System.IntPtr instance, global::System.IntPtr scaleDriver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@UiObject@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetParent@UiObject@acid@@QEAAXPEAV12@@Z")]
            internal static extern void SetParent(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRectangle@UiObject@acid@@QEAAAEAVUiBound@2@XZ")]
            internal static extern global::System.IntPtr GetRectangle(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRectangle@UiObject@acid@@QEAAXAEBVUiBound@2@@Z")]
            internal static extern void SetRectangle(global::System.IntPtr instance, global::System.IntPtr rectangle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScissor@UiObject@acid@@QEBA?AVVector4@2@XZ")]
            internal static extern void GetScissor(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScissor@UiObject@acid@@QEAAXAEBVVector4@2@@Z")]
            internal static extern void SetScissor(global::System.IntPtr instance, global::System.IntPtr scissor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionOffset@UiObject@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetPositionOffset(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPositionOffset@UiObject@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetPositionOffset(global::System.IntPtr instance, global::System.IntPtr positionOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsVisible@UiObject@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsVisible(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScreenTransform@UiObject@acid@@QEBA?AVVector4@2@XZ")]
            internal static extern void GetScreenTransform(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAlpha@UiObject@acid@@QEBAMXZ")]
            internal static extern float GetAlpha(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScale@UiObject@acid@@QEBAMXZ")]
            internal static extern float GetScale(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UiObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UiObject>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.UiObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.UiObject(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.UiObject __CreateInstance(global::AcidSharp.UiObject.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.UiObject(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.UiObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiObject.__Internal));
            global::AcidSharp.UiObject.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiObject(global::AcidSharp.UiObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new screen object.</summary>
        /// <param name="parent">The parent screen object.</param>
        /// <param name="rectangle">The rectangle that will represent the bounds of the ui object.</param>
        public UiObject(global::AcidSharp.UiObject parent, global::AcidSharp.UiBound rectangle)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(rectangle, null))
                throw new global::System.ArgumentNullException("rectangle", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rectangle.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "AcidSharp.UiObject");
        }

        public UiObject(global::AcidSharp.UiObject _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.UiObject");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.UiObject.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___dtorDelegate = (global::AcidSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_int));
                ___dtorDelegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the implementation.</summary>
        public virtual void UpdateObject()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateObjectDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateObjectDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Called on mouse click along with 'm_actionClick'.</summary>
        /// <param name="button">The mouse button clicked.</param>
        public virtual bool OnActionMouse(global::AcidSharp.MouseButton button)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___OnActionMouseDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr_AcidSharp_MouseButton) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr_AcidSharp_MouseButton));
            var __ret = ___OnActionMouseDelegate((__Instance + __PointerAdjustment), button);
            return __ret;
        }

        /// <summary>Adds a child to this objects children.</summary>
        /// <param name="child">The child to add.</param>
        public void AddChild(global::AcidSharp.UiObject child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Disowns a child from this objects children.</summary>
        /// <param name="child">The child to disown.</param>
        public bool RemoveChild(global::AcidSharp.UiObject child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            var __ret = __Internal.RemoveChild((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public void SetVisible(bool visible)
        {
            __Internal.SetVisible((__Instance + __PointerAdjustment), visible);
        }

        /// <summary>Sets the alpha driver.</summary>
        /// <param name="alphaDriver">The new alpha driver.</param>
        public void SetAlphaDriver(global::AcidSharp.IDriver alphaDriver)
        {
            var __arg0 = ReferenceEquals(alphaDriver, null) ? global::System.IntPtr.Zero : alphaDriver.__Instance;
            __Internal.SetAlphaDriver((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Sets the scale driver.</summary>
        /// <param name="scaleDriver">The new scale driver.</param>
        public void SetScaleDriver(global::AcidSharp.IDriver scaleDriver)
        {
            var __arg0 = ReferenceEquals(scaleDriver, null) ? global::System.IntPtr.Zero : scaleDriver.__Instance;
            __Internal.SetScaleDriver((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the parent object.</summary>
        /// <param name="parent">The new parent object.</param>
        /// <remarks>Removes this object from the previous parent and attaches it to another parent.</remarks>
        public global::AcidSharp.UiObject Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::AcidSharp.UiObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.UiObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.UiObject) global::AcidSharp.UiObject.NativeToManagedMap[__ret];
                else global::AcidSharp.UiObject.NativeToManagedMap[__ret] = __result0 = (global::AcidSharp.UiObject) global::AcidSharp.UiObject.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetParent((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.UiBound Rectangle
        {
            get
            {
                var __ret = __Internal.GetRectangle((__Instance + __PointerAdjustment));
                global::AcidSharp.UiBound __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.UiBound.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.UiBound) global::AcidSharp.UiBound.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.UiBound.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRectangle((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector4 Scissor
        {
            get
            {
                var __ret = new global::AcidSharp.Vector4.__Internal();
                __Internal.GetScissor((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector4.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetScissor((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector2 PositionOffset
        {
            get
            {
                var __ret = new global::AcidSharp.Vector2.__Internal();
                __Internal.GetPositionOffset((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPositionOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool IsVisible
        {
            get
            {
                var __ret = __Internal.IsVisible((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the ui object screen space transform.</summary>
        public global::AcidSharp.Vector4 ScreenTransform
        {
            get
            {
                var __ret = new global::AcidSharp.Vector4.__Internal();
                __Internal.GetScreenTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector4.__CreateInstance(__ret);
            }
        }

        public float Alpha
        {
            get
            {
                var __ret = __Internal.GetAlpha((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Scale
        {
            get
            {
                var __ret = __Internal.GetScale((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~UiObject()
        private static global::AcidSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.UiObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void UpdateObject()
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.UiObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        // bool OnActionMouse(const MouseButton &button)
        private static global::AcidSharp.Delegates.Func_bool_IntPtr_AcidSharp_MouseButton _OnActionMouseDelegateInstance;

        private static bool _OnActionMouseDelegateHook(global::System.IntPtr instance, global::AcidSharp.MouseButton button)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.UiObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.OnActionMouse(button);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
                _OnActionMouseDelegateInstance += _OnActionMouseDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnActionMouseDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace AcidSharp
{
    public unsafe partial class SelectorJoystick : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 496)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.JoystickPort m_joystick;

            [FieldOffset(8)]
            internal global::AcidSharp.AxisJoystick.__Internal m_axisX;

            [FieldOffset(56)]
            internal global::AcidSharp.AxisJoystick.__Internal m_axisY;

            [FieldOffset(104)]
            internal global::Std.Array.__Internalc__N_std_S_array____N_std_S_optional____N_acid_S_ButtonJoystick_Vk7 m_inputButtons;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SelectorJoystick@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SelectorJoystick@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInputButton@SelectorJoystick@acid@@QEAAXAEBW4MouseButton@2@AEBVButtonJoystick@2@@Z")]
            internal static extern void SetInputButton(global::System.IntPtr instance, global::AcidSharp.MouseButton button, global::System.IntPtr inputButton);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJoystick@SelectorJoystick@acid@@QEBA?AW4JoystickPort@2@XZ")]
            internal static extern global::AcidSharp.JoystickPort GetJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJoystick@SelectorJoystick@acid@@QEAAXAEBW4JoystickPort@2@@Z")]
            internal static extern void SetJoystick(global::System.IntPtr instance, global::AcidSharp.JoystickPort joystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAxisX@SelectorJoystick@acid@@QEBA?AVAxisJoystick@2@XZ")]
            internal static extern void GetAxisX(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAxisX@SelectorJoystick@acid@@QEAAXAEBVAxisJoystick@2@@Z")]
            internal static extern void SetAxisX(global::System.IntPtr instance, global::System.IntPtr axisX);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAxisY@SelectorJoystick@acid@@QEBA?AVAxisJoystick@2@XZ")]
            internal static extern void GetAxisY(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAxisY@SelectorJoystick@acid@@QEAAXAEBVAxisJoystick@2@@Z")]
            internal static extern void SetAxisY(global::System.IntPtr instance, global::System.IntPtr axisY);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.SelectorJoystick> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.SelectorJoystick>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.SelectorJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.SelectorJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.SelectorJoystick __CreateInstance(global::AcidSharp.SelectorJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.SelectorJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.SelectorJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SelectorJoystick.__Internal));
            global::AcidSharp.SelectorJoystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SelectorJoystick(global::AcidSharp.SelectorJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SelectorJoystick(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SelectorJoystick(global::AcidSharp.SelectorJoystick _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SelectorJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.SelectorJoystick __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void SetInputButton(global::AcidSharp.MouseButton button, global::AcidSharp.ButtonJoystick inputButton)
        {
            if (ReferenceEquals(inputButton, null))
                throw new global::System.ArgumentNullException("inputButton", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = inputButton.__Instance;
            __Internal.SetInputButton((__Instance + __PointerAdjustment), button, __arg1);
        }

        public global::AcidSharp.JoystickPort Joystick
        {
            get
            {
                var __ret = __Internal.GetJoystick((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetJoystick((__Instance + __PointerAdjustment), value);
            }
        }

        public global::AcidSharp.AxisJoystick AxisX
        {
            get
            {
                var __ret = new global::AcidSharp.AxisJoystick.__Internal();
                __Internal.GetAxisX((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.AxisJoystick.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAxisX((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.AxisJoystick AxisY
        {
            get
            {
                var __ret = new global::AcidSharp.AxisJoystick.__Internal();
                __Internal.GetAxisY((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.AxisJoystick.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAxisY((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }

    public unsafe partial class UiSelectorMouse : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AcidSharp.MouseButton m_mouseButton;

            [FieldOffset(4)]
            internal byte m_isDown;

            [FieldOffset(5)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiSelectorMouse@acid@@QEAA@AEBU01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UiSelectorMouse> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UiSelectorMouse>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.UiSelectorMouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.UiSelectorMouse(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.UiSelectorMouse __CreateInstance(global::AcidSharp.UiSelectorMouse.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.UiSelectorMouse(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.UiSelectorMouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiSelectorMouse.__Internal));
            *(global::AcidSharp.UiSelectorMouse.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UiSelectorMouse(global::AcidSharp.UiSelectorMouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiSelectorMouse(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UiSelectorMouse()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiSelectorMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public UiSelectorMouse(global::AcidSharp.UiSelectorMouse _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiSelectorMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.UiSelectorMouse.__Internal*) __Instance) = *((global::AcidSharp.UiSelectorMouse.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.UiSelectorMouse __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::AcidSharp.MouseButton MMouseButton
        {
            get
            {
                return ((global::AcidSharp.UiSelectorMouse.__Internal*) __Instance)->m_mouseButton;
            }

            set
            {
                ((global::AcidSharp.UiSelectorMouse.__Internal*)__Instance)->m_mouseButton = value;
            }
        }

        public bool MIsDown
        {
            get
            {
                return ((global::AcidSharp.UiSelectorMouse.__Internal*) __Instance)->m_isDown != 0;
            }

            set
            {
                ((global::AcidSharp.UiSelectorMouse.__Internal*)__Instance)->m_isDown = (byte) (value ? 1 : 0);
            }
        }

        public bool MWasDown
        {
            get
            {
                return ((global::AcidSharp.UiSelectorMouse.__Internal*) __Instance)->m_wasDown != 0;
            }

            set
            {
                ((global::AcidSharp.UiSelectorMouse.__Internal*)__Instance)->m_wasDown = (byte) (value ? 1 : 0);
            }
        }
    }

    /// <summary>Represents a virtual cursor that will be used to determine if a ui action was preformed by a device.</summary>
    public unsafe partial class UiSelector : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_cursorX;

            [FieldOffset(4)]
            internal float m_cursorY;

            [FieldOffset(8)]
            internal global::Std.Array.__Internalc__N_std_S_array____N_acid_S_UiSelectorMouse_Vk7 m_selectorMice;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiSelector@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiSelector@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiSelector@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UiSelector@acid@@QEAAXAEB_NAEBVSelectorJoystick@2@@Z")]
            internal static extern void Update(global::System.IntPtr instance, bool paused, global::System.IntPtr selectorJoystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsSelected@UiSelector@acid@@QEBA_NAEBVUiObject@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSelected(global::System.IntPtr instance, global::System.IntPtr targetObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CancelWasEvent@UiSelector@acid@@QEAAXXZ")]
            internal static extern void CancelWasEvent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsDown@UiSelector@acid@@QEBA_NAEBW4MouseButton@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsDown(global::System.IntPtr instance, global::AcidSharp.MouseButton button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WasDown@UiSelector@acid@@QEBA_NAEBW4MouseButton@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool WasDown(global::System.IntPtr instance, global::AcidSharp.MouseButton button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCursorX@UiSelector@acid@@QEBAMXZ")]
            internal static extern float GetCursorX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCursorY@UiSelector@acid@@QEBAMXZ")]
            internal static extern float GetCursorY(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UiSelector> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.UiSelector>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.UiSelector __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.UiSelector(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.UiSelector __CreateInstance(global::AcidSharp.UiSelector.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.UiSelector(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.UiSelector.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiSelector.__Internal));
            *(global::AcidSharp.UiSelector.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UiSelector(global::AcidSharp.UiSelector.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiSelector(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UiSelector()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiSelector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public UiSelector(global::AcidSharp.UiSelector _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.UiSelector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.UiSelector.__Internal*) __Instance) = *((global::AcidSharp.UiSelector.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.UiSelector __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update(bool paused, global::AcidSharp.SelectorJoystick selectorJoystick)
        {
            if (ReferenceEquals(selectorJoystick, null))
                throw new global::System.ArgumentNullException("selectorJoystick", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = selectorJoystick.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), paused, __arg1);
        }

        /// <summary>Gets if the object provided has the cursor hovered above it.</summary>
        /// <param name="object">The object to check with.</param>
        public bool IsSelected(global::AcidSharp.UiObject targetObject)
        {
            if (ReferenceEquals(targetObject, null))
                throw new global::System.ArgumentNullException("targetObject", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = targetObject.__Instance;
            var __ret = __Internal.IsSelected((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public void CancelWasEvent()
        {
            __Internal.CancelWasEvent((__Instance + __PointerAdjustment));
        }

        public bool IsDown(global::AcidSharp.MouseButton button)
        {
            var __ret = __Internal.IsDown((__Instance + __PointerAdjustment), button);
            return __ret;
        }

        public bool WasDown(global::AcidSharp.MouseButton button)
        {
            var __ret = __Internal.WasDown((__Instance + __PointerAdjustment), button);
            return __ret;
        }

        public float CursorX
        {
            get
            {
                var __ret = __Internal.GetCursorX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float CursorY
        {
            get
            {
                var __ret = __Internal.GetCursorY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

public unsafe partial class BtCollisionConfiguration
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionConfiguration> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionConfiguration>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtCollisionConfiguration __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtCollisionConfiguration(native.ToPointer(), skipVTables);
    }

    internal static global::BtCollisionConfiguration __CreateInstance(global::BtCollisionConfiguration.__Internal native, bool skipVTables = false)
    {
        return new global::BtCollisionConfiguration(native, skipVTables);
    }

    private static void* __CopyValue(global::BtCollisionConfiguration.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtCollisionConfiguration.__Internal));
        *(global::BtCollisionConfiguration.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtCollisionConfiguration(global::BtCollisionConfiguration.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtCollisionConfiguration(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtBroadphaseInterface
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtBroadphaseInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtBroadphaseInterface>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtBroadphaseInterface __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtBroadphaseInterface(native.ToPointer(), skipVTables);
    }

    internal static global::BtBroadphaseInterface __CreateInstance(global::BtBroadphaseInterface.__Internal native, bool skipVTables = false)
    {
        return new global::BtBroadphaseInterface(native, skipVTables);
    }

    private static void* __CopyValue(global::BtBroadphaseInterface.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtBroadphaseInterface.__Internal));
        *(global::BtBroadphaseInterface.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtBroadphaseInterface(global::BtBroadphaseInterface.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtBroadphaseInterface(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtCollisionDispatcher
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionDispatcher> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionDispatcher>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtCollisionDispatcher __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtCollisionDispatcher(native.ToPointer(), skipVTables);
    }

    internal static global::BtCollisionDispatcher __CreateInstance(global::BtCollisionDispatcher.__Internal native, bool skipVTables = false)
    {
        return new global::BtCollisionDispatcher(native, skipVTables);
    }

    private static void* __CopyValue(global::BtCollisionDispatcher.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtCollisionDispatcher.__Internal));
        *(global::BtCollisionDispatcher.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtCollisionDispatcher(global::BtCollisionDispatcher.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtCollisionDispatcher(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtSequentialImpulseConstraintSolver
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtSequentialImpulseConstraintSolver> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtSequentialImpulseConstraintSolver>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtSequentialImpulseConstraintSolver __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtSequentialImpulseConstraintSolver(native.ToPointer(), skipVTables);
    }

    internal static global::BtSequentialImpulseConstraintSolver __CreateInstance(global::BtSequentialImpulseConstraintSolver.__Internal native, bool skipVTables = false)
    {
        return new global::BtSequentialImpulseConstraintSolver(native, skipVTables);
    }

    private static void* __CopyValue(global::BtSequentialImpulseConstraintSolver.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtSequentialImpulseConstraintSolver.__Internal));
        *(global::BtSequentialImpulseConstraintSolver.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtSequentialImpulseConstraintSolver(global::BtSequentialImpulseConstraintSolver.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtSequentialImpulseConstraintSolver(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtDiscreteDynamicsWorld
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtDiscreteDynamicsWorld> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtDiscreteDynamicsWorld>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtDiscreteDynamicsWorld __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtDiscreteDynamicsWorld(native.ToPointer(), skipVTables);
    }

    internal static global::BtDiscreteDynamicsWorld __CreateInstance(global::BtDiscreteDynamicsWorld.__Internal native, bool skipVTables = false)
    {
        return new global::BtDiscreteDynamicsWorld(native, skipVTables);
    }

    private static void* __CopyValue(global::BtDiscreteDynamicsWorld.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtDiscreteDynamicsWorld.__Internal));
        *(global::BtDiscreteDynamicsWorld.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtDiscreteDynamicsWorld(global::BtDiscreteDynamicsWorld.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtDiscreteDynamicsWorld(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace AcidSharp
{
    public unsafe partial class ScenePhysics : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCollisionConfiguration___N_std_S_default_delete__S0_ m_collisionConfiguration;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btBroadphaseInterface___N_std_S_default_delete__S0_ m_broadphase;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCollisionDispatcher___N_std_S_default_delete__S0_ m_dispatcher;

            [FieldOffset(24)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btSequentialImpulseConstraintSolver___N_std_S_default_delete__S0_ m_solver;

            [FieldOffset(32)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btDiscreteDynamicsWorld___N_std_S_default_delete__S0_ m_dynamicsWorld;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ScenePhysics@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ScenePhysics@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ScenePhysics@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@ScenePhysics@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGravity@ScenePhysics@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetGravity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGravity@ScenePhysics@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetGravity(global::System.IntPtr instance, global::System.IntPtr gravity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAirDensity@ScenePhysics@acid@@QEBAMXZ")]
            internal static extern float GetAirDensity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAirDensity@ScenePhysics@acid@@QEAAXAEBM@Z")]
            internal static extern void SetAirDensity(global::System.IntPtr instance, float airDensity);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ScenePhysics> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.ScenePhysics>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.ScenePhysics __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ScenePhysics(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.ScenePhysics __CreateInstance(global::AcidSharp.ScenePhysics.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ScenePhysics(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.ScenePhysics.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ScenePhysics.__Internal));
            *(global::AcidSharp.ScenePhysics.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ScenePhysics(global::AcidSharp.ScenePhysics.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ScenePhysics(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ScenePhysics()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ScenePhysics.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ScenePhysics(global::AcidSharp.ScenePhysics _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.ScenePhysics.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AcidSharp.ScenePhysics.__Internal*) __Instance) = *((global::AcidSharp.ScenePhysics.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ScenePhysics __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public global::AcidSharp.Vector3 Gravity
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetGravity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetGravity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float AirDensity
        {
            get
            {
                var __ret = __Internal.GetAirDensity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetAirDensity((__Instance + __PointerAdjustment), value);
            }
        }
    }
}

public unsafe partial class BtTransform
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtTransform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtTransform>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtTransform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtTransform(native.ToPointer(), skipVTables);
    }

    internal static global::BtTransform __CreateInstance(global::BtTransform.__Internal native, bool skipVTables = false)
    {
        return new global::BtTransform(native, skipVTables);
    }

    private static void* __CopyValue(global::BtTransform.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtTransform.__Internal));
        *(global::BtTransform.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtTransform(global::BtTransform.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtTransform(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtCollisionShape
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionShape>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtCollisionShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtCollisionShape(native.ToPointer(), skipVTables);
    }

    internal static global::BtCollisionShape __CreateInstance(global::BtCollisionShape.__Internal native, bool skipVTables = false)
    {
        return new global::BtCollisionShape(native, skipVTables);
    }

    private static void* __CopyValue(global::BtCollisionShape.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtCollisionShape.__Internal));
        *(global::BtCollisionShape.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtCollisionShape(global::BtCollisionShape.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtCollisionShape(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtRigidBody
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtRigidBody> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtRigidBody>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtRigidBody __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtRigidBody(native.ToPointer(), skipVTables);
    }

    internal static global::BtRigidBody __CreateInstance(global::BtRigidBody.__Internal native, bool skipVTables = false)
    {
        return new global::BtRigidBody(native, skipVTables);
    }

    private static void* __CopyValue(global::BtRigidBody.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtRigidBody.__Internal));
        *(global::BtRigidBody.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtRigidBody(global::BtRigidBody.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtRigidBody(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace AcidSharp
{
    public unsafe partial class Rigidbody : global::AcidSharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 120)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal float m_mass;

            [FieldOffset(28)]
            internal float m_friction;

            [FieldOffset(32)]
            internal global::AcidSharp.Vector3.__Internal m_linearFactor;

            [FieldOffset(44)]
            internal global::AcidSharp.Vector3.__Internal m_angularFactor;

            [FieldOffset(56)]
            internal global::System.IntPtr m_shape;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btRigidBody___N_std_S_default_delete__S0_ m_body;

            [FieldOffset(72)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_Force___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_forces;

            [FieldOffset(96)]
            internal global::AcidSharp.Vector3.__Internal m_linearVelocity;

            [FieldOffset(108)]
            internal global::AcidSharp.Vector3.__Internal m_angularVelocity;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Rigidbody@acid@@QEAA@AEBM0AEBVVector3@1@1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float mass, float friction, global::System.IntPtr linearFactor, global::System.IntPtr angularFactor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Rigidbody@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Rigidbody@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGravity@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetGravity(global::System.IntPtr instance, global::System.IntPtr gravity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddForce@Rigidbody@acid@@QEAAPEAVForce@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr AddForce(global::System.IntPtr instance, global::System.IntPtr force);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ClearForces@Rigidbody@acid@@QEAAXXZ")]
            internal static extern void ClearForces(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMass@Rigidbody@acid@@QEBAMXZ")]
            internal static extern float GetMass(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMass@Rigidbody@acid@@QEAAXAEBM@Z")]
            internal static extern void SetMass(global::System.IntPtr instance, float mass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFriction@Rigidbody@acid@@QEBAMXZ")]
            internal static extern float GetFriction(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFriction@Rigidbody@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFriction(global::System.IntPtr instance, float friction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLinearFactor@Rigidbody@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetLinearFactor(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLinearFactor@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetLinearFactor(global::System.IntPtr instance, global::System.IntPtr linearFactor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAngularFactor@Rigidbody@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetAngularFactor(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAngularFactor@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetAngularFactor(global::System.IntPtr instance, global::System.IntPtr angularFactor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLinearVelocity@Rigidbody@acid@@QEBA?BVVector3@2@XZ")]
            internal static extern void GetLinearVelocity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLinearVelocity@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetLinearVelocity(global::System.IntPtr instance, global::System.IntPtr linearVelocity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAngularVelocity@Rigidbody@acid@@QEBA?BVVector3@2@XZ")]
            internal static extern void GetAngularVelocity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAngularVelocity@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetAngularVelocity(global::System.IntPtr instance, global::System.IntPtr angularVelocity);
        }

        internal static new global::AcidSharp.Rigidbody __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Rigidbody(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Rigidbody __CreateInstance(global::AcidSharp.Rigidbody.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Rigidbody(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Rigidbody.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Rigidbody.__Internal));
            global::AcidSharp.Rigidbody.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Rigidbody(global::AcidSharp.Rigidbody.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Rigidbody(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Rigidbody(float mass, float friction, global::AcidSharp.Vector3 linearFactor, global::AcidSharp.Vector3 angularFactor)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Rigidbody.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(linearFactor, null))
                throw new global::System.ArgumentNullException("linearFactor", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = linearFactor.__Instance;
            if (ReferenceEquals(angularFactor, null))
                throw new global::System.ArgumentNullException("angularFactor", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = angularFactor.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), mass, friction, __arg2, __arg3);
            SetupVTables(GetType().FullName == "AcidSharp.Rigidbody");
        }

        public Rigidbody(global::AcidSharp.Rigidbody _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Rigidbody.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Rigidbody");
        }

        public Rigidbody(float mass = 1.0F, float friction = 0.200000003F) : this(mass, friction, global::AcidSharp.Vector3.One, global::AcidSharp.Vector3.One)
        {
        }

        public Rigidbody(float mass, float friction, global::AcidSharp.Vector3 linearFactor) : this(mass, friction, linearFactor, global::AcidSharp.Vector3.One)
        {
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Rigidbody.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::AcidSharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::AcidSharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public void SetGravity(global::AcidSharp.Vector3 gravity)
        {
            if (ReferenceEquals(gravity, null))
                throw new global::System.ArgumentNullException("gravity", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = gravity.__Instance;
            __Internal.SetGravity((__Instance + __PointerAdjustment), __arg0);
        }

        public global::AcidSharp.Force AddForce(global::AcidSharp.Force force)
        {
            var __arg0 = ReferenceEquals(force, null) ? global::System.IntPtr.Zero : force.__Instance;
            var __ret = __Internal.AddForce((__Instance + __PointerAdjustment), __arg0);
            global::AcidSharp.Force __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Force.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Force) global::AcidSharp.Force.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Force.__CreateInstance(__ret);
            return __result0;
        }

        public void ClearForces()
        {
            __Internal.ClearForces((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::AcidSharp.Rigidbody(float mass)
        {
            return new global::AcidSharp.Rigidbody(mass);
        }

        public float Mass
        {
            get
            {
                var __ret = __Internal.GetMass((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetMass((__Instance + __PointerAdjustment), value);
            }
        }

        public float Friction
        {
            get
            {
                var __ret = __Internal.GetFriction((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFriction((__Instance + __PointerAdjustment), value);
            }
        }

        public global::AcidSharp.Vector3 LinearFactor
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetLinearFactor((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLinearFactor((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 AngularFactor
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetAngularFactor((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAngularFactor((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 LinearVelocity
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetLinearVelocity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLinearVelocity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::AcidSharp.Vector3 AngularVelocity
        {
            get
            {
                var __ret = new global::AcidSharp.Vector3.__Internal();
                __Internal.GetAngularVelocity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAngularVelocity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::AcidSharp.Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::AcidSharp.Metadata) global::AcidSharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::AcidSharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::AcidSharp.Metadata) global::AcidSharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::AcidSharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A structure of spatial objects for a 3D space.</summary>
    public unsafe partial class SceneStructure : global::AcidSharp.ISpatialStructure, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpatialStructure;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_GameObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_objects;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SceneStructure@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SceneStructure@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SceneStructure@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::AcidSharp.SceneStructure __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.SceneStructure(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.SceneStructure __CreateInstance(global::AcidSharp.SceneStructure.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.SceneStructure(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.SceneStructure.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SceneStructure.__Internal));
            global::AcidSharp.SceneStructure.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SceneStructure(global::AcidSharp.SceneStructure.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SceneStructure(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new basic structure.</summary>
        public SceneStructure()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SceneStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.SceneStructure");
        }

        public SceneStructure(global::AcidSharp.SceneStructure _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.SceneStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.SceneStructure");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.ISpatialStructure __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.SceneStructure.__Internal*) __Instance)->vfptr_ISpatialStructure = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Add(global::AcidSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___AddDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            ___AddDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override bool Remove(global::AcidSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RemoveDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___RemoveDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public override bool Contains(global::AcidSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
            var ___ContainsDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___ContainsDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override uint Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetSizeDelegate = (global::AcidSharp.Delegates.Func_uint_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_uint_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Add(GameObject *object) override
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _AddDelegateInstance;

        private static void _AddDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::AcidSharp.GameObject) global::AcidSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = global::AcidSharp.GameObject.__CreateInstance(targetObject);
            __target.Add(__result0);
        }

        // bool Remove(GameObject *object) override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr _RemoveDelegateInstance;

        private static bool _RemoveDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::AcidSharp.GameObject) global::AcidSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = global::AcidSharp.GameObject.__CreateInstance(targetObject);
            var __ret = __target.Remove(__result0);
            return __ret;
        }

        // void Clear() override
        private static global::AcidSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // uint32_t GetSize() override { return static_cast<uint32_t>(m_objects.size()); }
        private static global::AcidSharp.Delegates.Func_uint_IntPtr _GetSizeDelegateInstance;

        private static uint _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        // bool Contains(GameObject *object) override
        private static global::AcidSharp.Delegates.Func_bool_IntPtr_IntPtr _ContainsDelegateInstance;

        private static bool _ContainsDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::AcidSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::AcidSharp.GameObject) global::AcidSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = global::AcidSharp.GameObject.__CreateInstance(targetObject);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _AddDelegateInstance += _AddDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AddDelegateInstance).ToPointer();
                _RemoveDelegateInstance += _RemoveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RemoveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
                _ContainsDelegateInstance += _ContainsDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ContainsDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                *(void**) (vfptr0 + 64) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace AcidSharp
{
    /// <summary>A object used to represent a scene.</summary>
    public unsafe abstract partial class IScene : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IScene;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_ICamera___N_std_S_default_delete__S0_ m_camera;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_ScenePhysics___N_std_S_default_delete__S0_ m_physics;

            [FieldOffset(24)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_SceneStructure___N_std_S_default_delete__S0_ m_structure;

            [FieldOffset(32)]
            internal byte m_started;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IScene@acid@@QEAA@PEAVICamera@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IScene@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IScene@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStarted@IScene@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetStarted(global::System.IntPtr instance, bool started);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCamera@IScene@acid@@QEBAPEAVICamera@2@XZ")]
            internal static extern global::System.IntPtr GetCamera(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCamera@IScene@acid@@QEAAXPEAVICamera@2@@Z")]
            internal static extern void SetCamera(global::System.IntPtr instance, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPhysics@IScene@acid@@QEBAPEAVScenePhysics@2@XZ")]
            internal static extern global::System.IntPtr GetPhysics(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStructure@IScene@acid@@QEAAPEAVSceneStructure@2@XZ")]
            internal static extern global::System.IntPtr GetStructure(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsStarted@IScene@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsStarted(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IScene> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AcidSharp.IScene>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AcidSharp.IScene __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.ISceneInternal(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.IScene __CreateInstance(global::AcidSharp.IScene.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.ISceneInternal(native, skipVTables);
        }

        protected IScene(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new scene.</summary>
        /// <param name="camera">The scenes camera.</param>
        protected IScene(global::AcidSharp.ICamera camera)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IScene.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(camera, null) ? global::System.IntPtr.Zero : camera.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IScene");
        }

        protected IScene(global::AcidSharp.IScene _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IScene.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.IScene");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IScene __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.IScene.__Internal*) __Instance)->vfptr_IScene = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Start();

        /// <summary>Run when updating the scene.</summary>
        public abstract void Update();

        /// <summary>Sets if this scene has started.</summary>
        /// <param name="started">If the scene has started.</param>
        public void SetStarted(bool started)
        {
            __Internal.SetStarted((__Instance + __PointerAdjustment), started);
        }

        /// <summary>Gets the current camera object.</summary>
        /// <param name="camera">The new camera.</param>
        /// <remarks>Sets the current camera to a new camera.</remarks>
        public global::AcidSharp.ICamera Camera
        {
            get
            {
                var __ret = __Internal.GetCamera((__Instance + __PointerAdjustment));
                global::AcidSharp.ICamera __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.ICamera.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.ICamera) global::AcidSharp.ICamera.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.ICamera.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetCamera((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the scene physics system.</summary>
        public global::AcidSharp.ScenePhysics Physics
        {
            get
            {
                var __ret = __Internal.GetPhysics((__Instance + __PointerAdjustment));
                global::AcidSharp.ScenePhysics __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.ScenePhysics.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.ScenePhysics) global::AcidSharp.ScenePhysics.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.ScenePhysics.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the scene object structure.</summary>
        public global::AcidSharp.SceneStructure Structure
        {
            get
            {
                var __ret = __Internal.GetStructure((__Instance + __PointerAdjustment));
                global::AcidSharp.SceneStructure __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.SceneStructure.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.SceneStructure) global::AcidSharp.SceneStructure.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.SceneStructure.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets if this scene has started.</summary>
        public bool IsStarted
        {
            get
            {
                var __ret = __Internal.IsStarted((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the main menu is open.</summary>
        public abstract bool IsGamePaused
        {
            get;
        }

        /// <summary>The primary colour to be used in UI elements.</summary>
        public abstract global::AcidSharp.Colour UiColour
        {
            get;
        }

        /// <summary>The UI selector for a joystick.</summary>
        public abstract global::AcidSharp.SelectorJoystick SelectorJoystick
        {
            get;
        }

        #region Virtual table interop

        // void Start() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IScene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() = 0
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IScene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // bool IsGamePaused() const = 0
        private static global::AcidSharp.Delegates.Func_bool_IntPtr _IsGamePausedDelegateInstance;

        private static bool _IsGamePausedDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IScene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsGamePaused;
            return __ret;
        }

        // Colour GetUiColour() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetUiColourDelegateInstance;

        private static void _GetUiColourDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IScene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.UiColour;
            *(global::AcidSharp.Colour.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.Colour.__Internal() : *(global::AcidSharp.Colour.__Internal*) __ret.__Instance;
        }

        // SelectorJoystick GetSelectorJoystick() const = 0
        private static global::AcidSharp.Delegates.Action_IntPtr_IntPtr _GetSelectorJoystickDelegateInstance;

        private static void _GetSelectorJoystickDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.IScene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.SelectorJoystick;
            *(global::AcidSharp.SelectorJoystick.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::AcidSharp.SelectorJoystick.__Internal() : *(global::AcidSharp.SelectorJoystick.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _IsGamePausedDelegateInstance += _IsGamePausedDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_IsGamePausedDelegateInstance).ToPointer();
                _GetUiColourDelegateInstance += _GetUiColourDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetUiColourDelegateInstance).ToPointer();
                _GetSelectorJoystickDelegateInstance += _GetSelectorJoystickDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetSelectorJoystickDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ISceneInternal : global::AcidSharp.IScene, IDisposable
    {
        private static void* __CopyValue(global::AcidSharp.IScene.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.IScene.__Internal));
            *(global::AcidSharp.IScene.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ISceneInternal(global::AcidSharp.IScene.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ISceneInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Start()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___StartDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___StartDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Run when updating the scene.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets if the main menu is open.</summary>
        public override bool IsGamePaused
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___IsGamePausedDelegate = (global::AcidSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsGamePausedDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>The primary colour to be used in UI elements.</summary>
        public override global::AcidSharp.Colour UiColour
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetUiColourDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.Colour.__Internal();
                ___GetUiColourDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.Colour.__CreateInstance(__ret);
            }
        }

        /// <summary>The UI selector for a joystick.</summary>
        public override global::AcidSharp.SelectorJoystick SelectorJoystick
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetSelectorJoystickDelegate = (global::AcidSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::AcidSharp.SelectorJoystick.__Internal();
                ___GetSelectorJoystickDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::AcidSharp.SelectorJoystick.__CreateInstance(__ret);
            }
        }
    }
}

namespace AcidSharp
{
    /// <summary>A module used for managing game scenes on engine updates.</summary>
    public unsafe partial class Scenes : global::AcidSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IScene___N_std_S_default_delete__S0_ m_scene;

            [FieldOffset(16)]
            internal global::AcidSharp.ComponentRegister.__Internal m_componentRegister;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Scenes@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Scenes@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Scenes@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Scenes@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterComponent@Scenes@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterComponent(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateComponent@Scenes@acid@@QEAAPEAVIComponent@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr CreateComponent(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScene@Scenes@acid@@QEBAPEAVIScene@2@XZ")]
            internal static extern global::System.IntPtr GetScene(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScene@Scenes@acid@@QEAAXPEAVIScene@2@@Z")]
            internal static extern void SetScene(global::System.IntPtr instance, global::System.IntPtr scene);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCamera@Scenes@acid@@QEBAPEAVICamera@2@XZ")]
            internal static extern global::System.IntPtr GetCamera(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPhysics@Scenes@acid@@QEBAPEAVScenePhysics@2@XZ")]
            internal static extern global::System.IntPtr GetPhysics(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStructure@Scenes@acid@@QEBAPEAVSceneStructure@2@XZ")]
            internal static extern global::System.IntPtr GetStructure(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsGamePaused@Scenes@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGamePaused(global::System.IntPtr instance);
        }

        internal static new global::AcidSharp.Scenes __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AcidSharp.Scenes(native.ToPointer(), skipVTables);
        }

        internal static global::AcidSharp.Scenes __CreateInstance(global::AcidSharp.Scenes.__Internal native, bool skipVTables = false)
        {
            return new global::AcidSharp.Scenes(native, skipVTables);
        }

        private static void* __CopyValue(global::AcidSharp.Scenes.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Scenes.__Internal));
            global::AcidSharp.Scenes.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Scenes(global::AcidSharp.Scenes.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Scenes(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new Scenes module.</summary>
        public Scenes()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Scenes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "AcidSharp.Scenes");
        }

        public Scenes(global::AcidSharp.Scenes _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AcidSharp.Scenes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "AcidSharp.Scenes");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AcidSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::AcidSharp.Scenes.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::AcidSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AcidSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Deregisters a component.</summary>
        /// <param name="name">The components name.</param>
        public bool DeregisterComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.DeregisterComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Creates a new component from the register.</summary>
        /// <param name="name">The component name to create.</param>
        public global::AcidSharp.IComponent CreateComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::AcidSharp.IComponent __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.IComponent.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.IComponent) global::AcidSharp.IComponent.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.IComponent.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::AcidSharp.Scenes Get()
        {
            var __ret = __Internal.Get();
            global::AcidSharp.Scenes __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AcidSharp.Scenes.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AcidSharp.Scenes) global::AcidSharp.Scenes.NativeToManagedMap[__ret];
            else __result0 = global::AcidSharp.Scenes.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the current scene.</summary>
        /// <param name="scene">The new scene.</param>
        /// <remarks>Sets the current scene to a new scene.</remarks>
        public global::AcidSharp.IScene Scene
        {
            get
            {
                var __ret = __Internal.GetScene((__Instance + __PointerAdjustment));
                global::AcidSharp.IScene __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.IScene.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.IScene) global::AcidSharp.IScene.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.IScene.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetScene((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the current camera object.</summary>
        public global::AcidSharp.ICamera Camera
        {
            get
            {
                var __ret = __Internal.GetCamera((__Instance + __PointerAdjustment));
                global::AcidSharp.ICamera __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.ICamera.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.ICamera) global::AcidSharp.ICamera.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.ICamera.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the scene physics system.</summary>
        public global::AcidSharp.ScenePhysics Physics
        {
            get
            {
                var __ret = __Internal.GetPhysics((__Instance + __PointerAdjustment));
                global::AcidSharp.ScenePhysics __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.ScenePhysics.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.ScenePhysics) global::AcidSharp.ScenePhysics.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.ScenePhysics.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the scene object structure.</summary>
        public global::AcidSharp.SceneStructure Structure
        {
            get
            {
                var __ret = __Internal.GetStructure((__Instance + __PointerAdjustment));
                global::AcidSharp.SceneStructure __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::AcidSharp.SceneStructure.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::AcidSharp.SceneStructure) global::AcidSharp.SceneStructure.NativeToManagedMap[__ret];
                else __result0 = global::AcidSharp.SceneStructure.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets if the scene is paused.</summary>
        public bool IsGamePaused
        {
            get
            {
                var __ret = __Internal.IsGamePaused((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::AcidSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::AcidSharp.Scenes) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 160)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_acid_S_ComponentCreate
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::AcidSharp.ComponentCreate.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_acid_S_JointTransform
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::AcidSharp.JointTransform.__Internal second;
        }
    }

}
namespace Std
{
    namespace CompressedPair
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IScene__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_SceneStructure__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_ScenePhysics__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_ICamera__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Force__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btRigidBody__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btDiscreteDynamicsWorld__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btSequentialImpulseConstraintSolver__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btCollisionDispatcher__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btBroadphaseInterface__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btCollisionConfiguration__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IDriver__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_UiObject__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IFile__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Noise__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IAxis__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IButton__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_XmlNode__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_JsonSection__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IEvent__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Animation__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Animator__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_GameObject__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IComponent__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_VertexAnimatedData__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IndexBuffer__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_VertexBuffer__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IModule__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }
    }
}
